# Ultimate Production Code Audit Prompt
**Version:** 1.0 | **Date:** 2026-02-24

Copy this prompt, change the project-specific sections, and run once per project.
This is designed to catch everything in a single pass — no re-scans needed.

---

## HOW TO USE

1. Replace `[PROJECT_NAME]`, `[ARCHITECTURE_RULES]`, and `[ACCEPTED_PATTERNS]` with your project specifics
2. Split your codebase into chunks of **10-15 files max** per agent (context window limit)
3. For each chunk, use this prompt as the agent instruction
4. Merge results at the end
5. As the first step, use the most cheapest agent to create the full folder-subfolder-file tree of the project
6. Use Opus to orchesterate the in-depth scan by using the below prompt exactly as it is, filling in the project name, splitting the file list from step 5. into chunks of 10-15 files and calling a Sonnet sub agent with this prompt.
7. Use Sonnet to do the actual scan based on the prompts generated by Opus in step 6.
8. Once results are back, write them to the Metadata/AUDIT-FINDINGS-REVIEW.md file including the exact issues, the exact file and line number the issue was found on, with a separate section for each project.
---

## THE PROMPT

```
PRODUCTION CODE AUDIT — [PROJECT_NAME]

You are performing a FINAL production readiness audit. Read EVERY file listed
below LINE BY LINE. Do not skim, summarize, or skip files. For each file,
check ALL 15 categories below. Report ALL issues found.

═══════════════════════════════════════════════════════════════
CATEGORY 1: RULE 13 — Stubs, Placeholders, Simulations
═══════════════════════════════════════════════════════════════
Flag:
- Methods that return hardcoded values instead of computing them
- Comments containing: TODO, FIXME, HACK, "placeholder", "simulation",
  "simplified", "for demo", "in production would", "when available"
- Methods with empty bodies or bodies that only log/return defaults
- Implementations that use ConcurrentDictionary when they should use
  an external system (database, cache, message queue)
- Any class whose name implies an external system (Redis*, Mongo*, S3*,
  Kafka*, etc.) but doesn't actually connect to that system

Do NOT flag:
- PlatformNotSupportedException for hardware that genuinely may not exist
- IsProductionReady => false guards (these are intentional)
- NotSupportedException with descriptive messages for genuinely unsupported operations

═══════════════════════════════════════════════════════════════
CATEGORY 2: THREAD SAFETY
═══════════════════════════════════════════════════════════════
Flag:
- Double-checked locking on non-volatile boolean fields
  Pattern: `if (!_flag) { lock(x) { if (!_flag) { ... _flag = true; } } }`
  where `_flag` is not `volatile`
- Non-atomic read-modify-write on shared fields:
  `_counter++`, `_total += value`, `_field = _field + x`
  (must use Interlocked.Increment, Interlocked.Add, or lock)
- TOCTOU (Time-of-Check-Time-of-Use) races:
  Pattern: `if (dict.ContainsKey(k)) { dict[k] = ... }` without holding
  a lock across both operations
- Shared mutable collections (List<T>, Dictionary<K,V>, HashSet<T>)
  accessed from multiple threads without synchronization
- `new Random()` used in concurrent code (not thread-safe before .NET 6;
  use Random.Shared in .NET 6+)
- Fields written in one thread, read in another without volatile/Interlocked:
  especially `_disposed`, `_initialized`, `_isRunning`, `_isAvailable`
- ReaderWriterLockSlim used but class doesn't implement IDisposable
- Lock ordering violations (nested locks in inconsistent order)

Do NOT flag:
- SemaphoreSlim.Wait() in synchronous methods (this is the correct sync API)
- Volatile.Read/Volatile.Write usage (these are correct)
- Interlocked.* usage (these are correct)
- ConcurrentDictionary operations (thread-safe by design)
- BoundedDictionary operations (if documented as ConcurrentDictionary wrapper)

═══════════════════════════════════════════════════════════════
CATEGORY 3: SYNC-OVER-ASYNC
═══════════════════════════════════════════════════════════════
Flag:
- `.GetAwaiter().GetResult()` — blocks thread, deadlock risk
- `.Result` on a Task that may not be completed
- `.Wait()` on a Task (not SemaphoreSlim.Wait())
- `Task.Run(() => ...).GetAwaiter().GetResult()` — sync-over-async wrapper
- Synchronous file I/O (File.ReadAllText, File.WriteAllText, File.AppendAllText)
  called from async methods — should use Async variants
- `FileStream` opened with `FileOptions.Asynchronous` but used with
  synchronous Read/Write/Seek calls (causes thread pool starvation on Windows)

Do NOT flag:
- `.Result` on a task after checking `IsCompletedSuccessfully` (safe)
- SemaphoreSlim.Wait() in sync methods (correct API)
- Task.Wait() or .Result in Dispose() methods (common .NET pattern)
- Task.FromResult / Task.CompletedTask (not async at all)
- .Result on a value that is not a Task (e.g., a struct field named Result)

═══════════════════════════════════════════════════════════════
CATEGORY 4: SECURITY
═══════════════════════════════════════════════════════════════
Flag:
- Hardcoded secrets, API keys, passwords, connection strings
- MD5 or SHA1 used for any purpose (use SHA-256+ or xxHash)
- AES-CBC without authentication (use AES-GCM)
- String equality for secret/token comparison (timing side-channel)
  Must use CryptographicOperations.FixedTimeEquals
- Guid.NewGuid() used for security tokens (not guaranteed CSPRNG)
  Must use RandomNumberGenerator.GetBytes()
- Security checks that fail OPEN (exception → allow) instead of
  fail CLOSED (exception → deny)
- TLS certificate validation disabled without logging
- User input passed directly to SQL, file paths, process arguments,
  or format strings without sanitization
- Console.WriteLine for security-sensitive information
- Regex without timeout or RegexOptions.NonBacktracking (ReDoS risk)
- PIN/password stored as `string` instead of SecureString/ReadOnlySpan<byte>
- P/Invoke struct layouts that don't match the native ABI
  (missing fields in [StructLayout(Sequential)] causes offset corruption)

Do NOT flag:
- [Obsolete(error:true)] on deprecated crypto (correct deprecation)
- Debug.WriteLine (compiled out in Release)
- Hash randomization from GetHashCode() (covered in Category 12)

═══════════════════════════════════════════════════════════════
CATEGORY 5: SILENT CATCH BLOCKS
═══════════════════════════════════════════════════════════════
Flag:
- `catch { }` — empty catch with no logging, no metric, no rethrow
- `catch (Exception) { /* comment only */ }` — comment but no code
- `catch (Exception ex) { return defaultValue; }` — swallow and return default
  without any logging

The swallowing itself may be correct (best-effort operations), but the
SILENCE is the bug. Every catch block must have at minimum ONE of:
- A log statement (Debug.WriteLine, _logger.Log*, Console.Error)
- A metric increment (Interlocked.Increment on an error counter)
- A rethrow (throw; or ExceptionDispatchInfo.Capture)

Do NOT flag:
- catch blocks inside Dispose() methods (standard pattern)
- catch blocks that DO have Debug.WriteLine or _logger calls
- catch blocks that set a status/result variable with error info

═══════════════════════════════════════════════════════════════
CATEGORY 6: FIRE-AND-FORGET TASKS
═══════════════════════════════════════════════════════════════
Flag:
- `_ = SomeAsync()` — discarded Task with no error handling
- `_ = Task.Run(() => ...)` — background task with no fault observation
- `Task.Run(() => ...).ContinueWith(...)` where ContinueWith doesn't
  check `.IsFaulted`
- Timer callbacks that call async methods without try/catch:
  `_timer = new Timer(_ => SomeAsync(), ...)` — exceptions silently lost
- Dispose() that doesn't cancel CancellationTokenSource before disposing it
  (running tasks get ObjectDisposedException)

Do NOT flag:
- _ = Task.Run inside a try/catch that handles the exception
- Fire-and-forget that explicitly logs "this is best-effort" AND has a log
  in the catch block of the called method

═══════════════════════════════════════════════════════════════
CATEGORY 7: RESOURCE LEAKS
═══════════════════════════════════════════════════════════════
Flag:
- IDisposable objects created but never disposed (no `using`, no Dispose call)
- HttpClient created per-request instead of shared/injected
  (socket exhaustion)
- static HttpClient without explicit Timeout set
- SemaphoreSlim, ReaderWriterLockSlim, Timer created as fields but
  class doesn't implement IDisposable
- Stream objects created in pipeline but not tracked for disposal
- CancellationTokenSource created but never disposed

Do NOT flag:
- IDisposable in using statements (correct)
- HttpClient injected via IHttpClientFactory (correct)
- Objects disposed in Dispose(bool) pattern (correct)

═══════════════════════════════════════════════════════════════
CATEGORY 8: CONSOLE.WRITELINE
═══════════════════════════════════════════════════════════════
Flag:
- Any `Console.WriteLine` or `Console.Write` in library/SDK/plugin code
  (should use Debug.WriteLine, ILogger, or structured logging)

Do NOT flag:
- Console.WriteLine in CLI entry points or test code
- Debug.WriteLine (compiled out in Release, accepted)

═══════════════════════════════════════════════════════════════
CATEGORY 9: ERROR HANDLING GAPS
═══════════════════════════════════════════════════════════════
Flag:
- Async methods that never throw — they catch everything and return
  a default, making callers unable to distinguish success from failure
- Methods that return null on error without any out-of-band signal
  (should throw, return Result<T>, or set an error property)
- Unbounded recursion without a depth/retry limit
- float.Parse / int.Parse without TryParse fallback on user-configurable values

Do NOT flag:
- Try* pattern methods that return bool (TryGet, TryParse — these are correct)
- Methods documented to return null for "not found"

═══════════════════════════════════════════════════════════════
CATEGORY 10: DATA INTEGRITY
═══════════════════════════════════════════════════════════════
Flag:
- `string.GetHashCode()` used for ANY persistent purpose:
  routing, sharding, bloom filters, consistent hashing, caching keys
  (.NET randomizes GetHashCode per process — values change on restart)
- `object.GetHashCode()` for same reasons
- Double/float accumulation without atomic operations in concurrent code
  (Interlocked doesn't support double; must use lock or CAS loop)
- CAS (compare-and-swap) patterns where the compare and swap are not
  in the same atomic operation

Do NOT flag:
- GetHashCode() used only for in-memory HashSet/Dictionary (transient, OK)
- GetHashCode() used only within a single method scope (transient, OK)

═══════════════════════════════════════════════════════════════
CATEGORY 11: ARCHITECTURAL VIOLATIONS
═══════════════════════════════════════════════════════════════
[PROJECT-SPECIFIC — Replace with your architecture rules]

For DataWarehouse:
- AD-05: Strategies must be WORKERS, not orchestrators.
  Flag strategies that: hold IMessageBus, instantiate other strategies,
  contain routing/coordination logic, act as registries
- Plugin isolation: plugins must reference ONLY the SDK.
  Flag: direct references to other plugins or to Kernel
- Base class mandatory: never implement SDK interfaces directly.
  Flag: classes implementing IPlugin, IDataTransformation etc. without
  extending PluginBase, StrategyBase etc.

═══════════════════════════════════════════════════════════════
CATEGORY 12: OPERATOR PRECEDENCE / LOGIC BUGS
═══════════════════════════════════════════════════════════════
Flag:
- `&&` chains broken by `||` without parentheses
  Pattern: `a && b && c || d` (d applies regardless of a,b,c)
- Ternary operator precedence confusion
- LINQ .Where() with complex boolean expressions that may short-circuit wrong
- Integer division where floating-point was intended
  Pattern: `int / int` producing 0 when both are small

═══════════════════════════════════════════════════════════════
CATEGORY 13: PERFORMANCE ANTI-PATTERNS (LOW PRIORITY)
═══════════════════════════════════════════════════════════════
Flag (but mark as LOW/P2):
- Allocation inside hot loops (new HashSet per call, new List per iteration)
- O(n) operations where O(1) or O(log n) data structures exist
  (LinkedList.Find for LRU, List.RemoveAll for dedup)
- O(n²) nested loops over unbounded collections
- Static fields holding mutable state without thread safety
  (singleton registries, global caches)

═══════════════════════════════════════════════════════════════
CATEGORY 14: MISSING VALIDATION AT BOUNDARIES
═══════════════════════════════════════════════════════════════
Flag:
- Public API methods that don't validate null arguments
- Deserialized data used without validation (JSON, XML, binary)
- Configuration values used without range/format checks
- Network-received data used in format strings, file paths, or SQL

═══════════════════════════════════════════════════════════════
CATEGORY 15: NAMING / CONTRACT LIES
═══════════════════════════════════════════════════════════════
Flag:
- Methods named *Async that do no async work (sync disguised as async)
- Properties like IsAvailable that return true when the feature doesn't work
- Classes named after external systems (RedisStore, MongoBackend) that
  don't actually connect to those systems
- Interfaces with "production" in the name whose implementations are stubs

═══════════════════════════════════════════════════════════════

[ACCEPTED_PATTERNS — Project-specific patterns to NOT flag]

For DataWarehouse:
- SemaphoreSlim.Wait() in sync contexts
- catch in Dispose paths
- Debug.WriteLine for SDK logging
- Task.FromResult for sync interface implementations
- PlatformNotSupportedException for hardware (genuine platform limitation)
- IsProductionReady => false guard
- Volatile/Interlocked usage (previous fixes verified correct)
- [Obsolete(error:true)] on deprecated code

═══════════════════════════════════════════════════════════════

FILES TO SCAN:
[List files here — max 10-15 per agent]

═══════════════════════════════════════════════════════════════

OUTPUT FORMAT:
For each finding, provide:
1. Category number (1-15)
2. Severity: P0 (broken/data-loss), P1 (production-risk), P2 (quality)
3. File:Line
4. One-paragraph description of what's wrong and why
5. Impact statement

At the end, provide:
- Summary table: Category | P0 | P1 | P2
- Files confirmed clean (no findings)
- Accepted patterns encountered and correctly skipped
```

---

## SPLITTING STRATEGY

To avoid the "context window overflow → missed files" problem:

1. **Count files first:** `find . -name "*.cs" | wc -l`
2. **Group by directory:** Each directory gets its own agent
3. **Max 10-15 files per agent** — never more
4. **If a single directory has 50+ files:** Split alphabetically or by subdirectory
5. **Every file must appear in exactly one agent's list** — no gaps, no overlaps

### Splitting formula:
```
Total files ÷ 10 (target per agent) = Number of agents needed
```

Example: 970 SDK files ÷ 10 = ~97 agents

### Track coverage:
After all agents complete, verify:
```
Sum of (files scanned per agent) == Total .cs files in project
```

If the numbers don't match, you missed files.

---

## WHY THIS CATCHES EVERYTHING IN ONE PASS

Previous scans missed issues because:
1. **Narrow focus** — checked 3-5 categories, not 15
2. **Implicit accepted patterns** — agents guessed what to skip
3. **Overloaded agents** — 200+ files per agent → context overflow → skimming
4. **No coverage tracking** — no verification that every file was actually read

This prompt fixes all four:
1. **15 explicit categories** with specific patterns to match
2. **Explicit accepted patterns** section — no guessing
3. **30-50 file limit** — agents read every line
4. **Coverage verification** at the end

---

## TEMPLATE FOR LAUNCHING AGENTS

```
Task(
  subagent_type="oh-my-claudecode:code-reviewer",
  model="sonnet",
  prompt="""[PASTE THE PROMPT ABOVE WITH YOUR PROJECT SPECIFICS]

  FILES TO SCAN:
  - path/to/file1.cs
  - path/to/file2.cs
  ... (30-50 files)
  """
)
```

Launch agents in parallel groups of 2-3 to avoid rate limits.
As each agent completes, add their findings to Metadata/AUDIT-FINDINGS-REVIEW.md file, commit and push.
