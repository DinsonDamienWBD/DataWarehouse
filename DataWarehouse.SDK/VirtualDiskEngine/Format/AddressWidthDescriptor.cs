using DataWarehouse.SDK.Contracts;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace DataWarehouse.SDK.VirtualDiskEngine.Format;

/// <summary>
/// Superblock address width declaration. Stored in the superblock to indicate
/// the on-disk pointer width used throughout the VDE.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: Address width superblock descriptor (CE-07)")]
public sealed record AddressWidthDescriptor
{
    /// <summary>The current on-disk address width for all pointers.</summary>
    public AddressWidth CurrentWidth { get; init; }

    /// <summary>
    /// Minimum address width a reader must support to open this VDE.
    /// May be less than <see cref="CurrentWidth"/> during backward-compatible promotion.
    /// </summary>
    public AddressWidth MinReaderVersion { get; init; }

    /// <summary>Whether an online width promotion is currently in progress.</summary>
    public bool PromotionInProgress { get; init; }

    /// <summary>
    /// Target width during an active promotion, or null if no promotion is active.
    /// </summary>
    public AddressWidth? TargetWidth { get; init; }

    /// <summary>
    /// Creates a default descriptor for 64-bit addressing (most common).
    /// </summary>
    public static AddressWidthDescriptor CreateDefault() => new()
    {
        CurrentWidth = AddressWidth.Width64,
        MinReaderVersion = AddressWidth.Width64,
        PromotionInProgress = false,
        TargetWidth = null
    };
}

/// <summary>
/// Plan for online address width promotion, generated by <see cref="AddressWidthPromotionEngine"/>.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: Address width promotion plan (CE-07)")]
public sealed record PromotionPlan
{
    /// <summary>Source address width.</summary>
    public AddressWidth From { get; init; }

    /// <summary>Target address width.</summary>
    public AddressWidth To { get; init; }

    /// <summary>
    /// Estimated number of metadata blocks that contain pointers and must be rewritten.
    /// Data blocks are not affected (only metadata pointers change width).
    /// </summary>
    public long EstimatedBlocksToRewrite { get; init; }

    /// <summary>Estimated duration based on block count and typical I/O throughput.</summary>
    public TimeSpan EstimatedDuration { get; init; }

    /// <summary>
    /// Whether the promotion requires bumping <see cref="AddressWidthDescriptor.MinReaderVersion"/>
    /// (true if target width is wider than current min reader version).
    /// </summary>
    public bool RequiresMinReaderVersionBump { get; init; }
}

/// <summary>
/// Engine for determining when address width promotion is needed and generating
/// promotion plans. Width promotion is background-safe: old-width readers can still
/// read data blocks while only metadata pointers are being rewritten.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: Address width promotion engine (CE-07)")]
public sealed class AddressWidthPromotionEngine
{
    private readonly AddressWidthDescriptor _current;
    private readonly ILogger _logger;

    /// <summary>Threshold ratio of block count to max capacity that triggers promotion recommendation.</summary>
    private const double PromotionThreshold = 0.75;

    /// <summary>Headroom multiplier for width recommendation (4x current usage).</summary>
    private const long HeadroomMultiplier = 4;

    /// <summary>Estimated metadata block rewrite throughput in blocks per second.</summary>
    private const long EstimatedBlocksPerSecond = 100_000;

    /// <summary>
    /// Creates a new promotion engine for the given descriptor.
    /// </summary>
    /// <param name="current">Current address width descriptor.</param>
    /// <param name="logger">Optional logger.</param>
    public AddressWidthPromotionEngine(AddressWidthDescriptor current, ILogger? logger = null)
    {
        _current = current ?? throw new ArgumentNullException(nameof(current));
        _logger = logger ?? NullLogger.Instance;
    }

    /// <summary>
    /// Returns true if the current block count exceeds 75% of the maximum
    /// addressable blocks for the given width, indicating promotion should
    /// be started before running out of address space.
    /// </summary>
    /// <param name="currentBlockCount">Current number of allocated blocks.</param>
    /// <param name="currentWidth">Current address width.</param>
    public bool ShouldPromote(long currentBlockCount, AddressWidth currentWidth)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(currentBlockCount);

        long maxBlocks = WideBlockAddress.MaxBlockCount(currentWidth);

        // For widths where MaxBlockCount returns long.MaxValue, only promote if we're very close
        if (maxBlocks == long.MaxValue)
        {
            if (currentWidth == AddressWidth.Width128)
                return false; // 128-bit can never need promotion

            // For 64-bit, check if we're above 75% of actual addressable range
            return currentBlockCount > (long)(maxBlocks * PromotionThreshold);
        }

        double ratio = (double)currentBlockCount / maxBlocks;
        bool shouldPromote = ratio >= PromotionThreshold;

        if (shouldPromote)
        {
            _logger.LogWarning(
                "Block count {BlockCount} is at {Ratio:P1} of max {MaxBlocks} for {Width}. Promotion recommended.",
                currentBlockCount, ratio, maxBlocks, currentWidth);
        }

        return shouldPromote;
    }

    /// <summary>
    /// Returns the smallest address width that fits the current block count
    /// with at least 4x headroom.
    /// </summary>
    /// <param name="currentBlockCount">Current number of allocated blocks.</param>
    public AddressWidth RecommendWidth(long currentBlockCount)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(currentBlockCount);

        long needed = currentBlockCount;
        // Apply headroom if it won't overflow
        if (currentBlockCount <= long.MaxValue / HeadroomMultiplier)
            needed = currentBlockCount * HeadroomMultiplier;

        // Check widths in order from narrowest to widest
        if (needed <= WideBlockAddress.MaxBlockCount(AddressWidth.Width32))
            return AddressWidth.Width32;

        if (needed <= WideBlockAddress.MaxBlockCount(AddressWidth.Width48))
            return AddressWidth.Width48;

        if (needed <= WideBlockAddress.MaxBlockCount(AddressWidth.Width64))
            return AddressWidth.Width64;

        return AddressWidth.Width128;
    }

    /// <summary>
    /// Generates a plan for online width promotion to the target width.
    /// </summary>
    /// <param name="targetWidth">The desired target width.</param>
    /// <returns>A promotion plan with estimated cost and duration.</returns>
    public PromotionPlan CreatePromotionPlan(AddressWidth targetWidth)
    {
        if ((byte)targetWidth <= (byte)_current.CurrentWidth)
            throw new ArgumentException(
                $"Target width {targetWidth} must be wider than current {_current.CurrentWidth}.",
                nameof(targetWidth));

        // Estimate: metadata blocks are roughly 1-5% of total volume
        // Use a conservative 5% estimate for planning purposes
        const double metadataBlockRatio = 0.05;
        long estimatedMetadataBlocks = (long)(WideBlockAddress.MaxBlockCount(_current.CurrentWidth) * metadataBlockRatio);

        // Cap the estimate to something reasonable
        estimatedMetadataBlocks = Math.Min(estimatedMetadataBlocks, 100_000_000);

        var estimatedDuration = TimeSpan.FromSeconds(
            (double)estimatedMetadataBlocks / EstimatedBlocksPerSecond);

        bool requiresBump = (byte)targetWidth > (byte)_current.MinReaderVersion;

        var plan = new PromotionPlan
        {
            From = _current.CurrentWidth,
            To = targetWidth,
            EstimatedBlocksToRewrite = estimatedMetadataBlocks,
            EstimatedDuration = estimatedDuration,
            RequiresMinReaderVersionBump = requiresBump
        };

        _logger.LogInformation(
            "Promotion plan: {From} -> {To}, ~{Blocks} metadata blocks, ~{Duration}",
            plan.From, plan.To, plan.EstimatedBlocksToRewrite, plan.EstimatedDuration);

        return plan;
    }

    /// <summary>
    /// Returns the number of bytes per on-disk pointer for the given address width.
    /// Simply returns the byte count encoded in the enum value.
    /// </summary>
    /// <param name="width">The address width.</param>
    public static int BytesPerPointer(AddressWidth width) => (int)width;
}
