using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using DataWarehouse.SDK.Contracts;

namespace DataWarehouse.SDK.VirtualDiskEngine.FormalVerification;

/// <summary>
/// Configuration for TLC model checker execution.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: TLA+ formal verification framework (COMP-03)")]
public sealed record ModelConfig
{
    /// <summary>Maximum number of states TLC will explore before stopping.</summary>
    public int MaxStates { get; init; } = 1_000_000;

    /// <summary>Number of parallel worker threads for TLC.</summary>
    public int Workers { get; init; } = 4;

    /// <summary>Model constants (name to integer value) passed to TLC.</summary>
    public Dictionary<string, int> Constants { get; init; } = new();
}

/// <summary>
/// A complete TLA+ specification ready for model checking.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: TLA+ formal verification framework (COMP-03)")]
public sealed record TlaPlusSpec
{
    /// <summary>TLA+ module name (also used as filename stem).</summary>
    public required string ModuleName { get; init; }

    /// <summary>Complete TLA+ specification text.</summary>
    public required string SpecText { get; init; }

    /// <summary>Names of invariant predicates to check.</summary>
    public required string[] Invariants { get; init; }

    /// <summary>Names of temporal properties to check (liveness, fairness).</summary>
    public string[] TemporalProperties { get; init; } = Array.Empty<string>();

    /// <summary>Configuration for the model checker run.</summary>
    public ModelConfig Config { get; init; } = new();
}

/// <summary>
/// Result of running TLC model checker on a specification.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: TLA+ formal verification framework (COMP-03)")]
public sealed record ModelCheckResult
{
    /// <summary>Whether all invariants and temporal properties held.</summary>
    public required bool Passed { get; init; }

    /// <summary>If failed, the counterexample trace showing the invariant violation.</summary>
    public string? CounterExample { get; init; }

    /// <summary>Total number of distinct states explored by TLC.</summary>
    public long StatesExplored { get; init; }

    /// <summary>Wall-clock duration of the model checking run.</summary>
    public TimeSpan Duration { get; init; }

    /// <summary>Names of invariants that were violated (empty if passed).</summary>
    public string[] ViolatedInvariants { get; init; } = Array.Empty<string>();
}

/// <summary>
/// Interface for TLA+ formal verification models that generate specification text.
/// Each model encodes the state machine and safety invariants for a critical VDE subsystem.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: TLA+ formal verification framework (COMP-03)")]
public interface ITlaPlusModel
{
    /// <summary>
    /// Generates the complete TLA+ specification for this model.
    /// </summary>
    /// <param name="config">Optional model configuration overrides.</param>
    /// <returns>A fully-formed TLA+ specification ready for TLC.</returns>
    TlaPlusSpec GenerateSpec(ModelConfig? config = null);
}

/// <summary>
/// Static utility class for generating TLC configuration files, CI scripts,
/// and parsing TLC output. Provides the CI integration entry point for
/// running formal verification as part of the build pipeline.
/// </summary>
[SdkCompatibility("6.0.0", Notes = "Phase 85: TLA+ formal verification framework (COMP-03)")]
public static class TlaPlusModelGenerator
{
    /// <summary>
    /// Generates a TLC .cfg configuration file for the given specification.
    /// </summary>
    /// <param name="spec">The TLA+ specification to generate config for.</param>
    /// <returns>Content of the .cfg file.</returns>
    public static string GenerateTlcConfig(TlaPlusSpec spec)
    {
        ArgumentNullException.ThrowIfNull(spec);

        var sb = new StringBuilder();
        sb.AppendLine("\\* TLC configuration for " + spec.ModuleName);
        sb.AppendLine("\\* Auto-generated by DataWarehouse TLA+ Formal Verification Framework");
        sb.AppendLine();

        // Specification
        sb.AppendLine("SPECIFICATION Spec");
        sb.AppendLine();

        // Constants
        if (spec.Config.Constants.Count > 0)
        {
            foreach (var (name, value) in spec.Config.Constants.OrderBy(kvp => kvp.Key, StringComparer.Ordinal))
            {
                sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "CONSTANT {0} = {1}", name, value));
            }
            sb.AppendLine();
        }

        // Invariants
        foreach (var invariant in spec.Invariants)
        {
            sb.AppendLine("INVARIANT " + invariant);
        }

        if (spec.Invariants.Length > 0 && spec.TemporalProperties.Length > 0)
        {
            sb.AppendLine();
        }

        // Temporal properties
        foreach (var property in spec.TemporalProperties)
        {
            sb.AppendLine("PROPERTY " + property);
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generates a shell script that downloads TLC (if missing) and runs it on all specifications.
    /// Suitable for CI pipeline integration (GitHub Actions, Azure DevOps, Jenkins).
    /// </summary>
    /// <param name="specs">All specifications to verify.</param>
    /// <returns>A bash shell script that runs TLC on each spec.</returns>
    public static string GenerateCiScript(IReadOnlyList<TlaPlusSpec> specs)
    {
        ArgumentNullException.ThrowIfNull(specs);

        var sb = new StringBuilder();
        sb.AppendLine("#!/usr/bin/env bash");
        sb.AppendLine("set -euo pipefail");
        sb.AppendLine();
        sb.AppendLine("# TLA+ Formal Verification CI Script");
        sb.AppendLine("# Auto-generated by DataWarehouse TLA+ Formal Verification Framework");
        sb.AppendLine("# Requires: Java 11+ runtime");
        sb.AppendLine();

        // TLC download
        sb.AppendLine("TLC_VERSION=\"1.8.0\"");
        sb.AppendLine("TLC_JAR=\"tla2tools.jar\"");
        sb.AppendLine("TLC_URL=\"https://github.com/tlaplus/tlaplus/releases/download/v${TLC_VERSION}/${TLC_JAR}\"");
        sb.AppendLine();
        sb.AppendLine("if [ ! -f \"${TLC_JAR}\" ]; then");
        sb.AppendLine("  echo \"Downloading TLC model checker v${TLC_VERSION}...\"");
        sb.AppendLine("  curl -sSL -o \"${TLC_JAR}\" \"${TLC_URL}\"");
        sb.AppendLine("fi");
        sb.AppendLine();

        sb.AppendLine("FAILED=0");
        sb.AppendLine("TOTAL=0");
        sb.AppendLine();

        foreach (var spec in specs)
        {
            var moduleName = spec.ModuleName;
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                "echo \"=== Verifying {0} ===\"", moduleName));
            sb.AppendLine("TOTAL=$((TOTAL + 1))");

            // P2-799: Inline spec and config content directly into the heredoc rather than
            // referencing bash variables that were never populated, which produced empty files.
            // Write spec file
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                "cat > \"{0}.tla\" << 'SPEC_EOF'", moduleName));
            sb.AppendLine(spec.SpecText);
            sb.AppendLine("SPEC_EOF");

            // Write config file
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                "cat > \"{0}.cfg\" << 'CFG_EOF'", moduleName));
            sb.AppendLine(GenerateTlcConfig(spec));
            sb.AppendLine("CFG_EOF");

            // Run TLC
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                "if java -jar \"${{TLC_JAR}}\" -config \"{0}.cfg\" -workers {1} \"{0}.tla\" 2>&1; then",
                moduleName, spec.Config.Workers));
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                "  echo \"PASS: {0}\"", moduleName));
            sb.AppendLine("else");
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                "  echo \"FAIL: {0}\"", moduleName));
            sb.AppendLine("  FAILED=$((FAILED + 1))");
            sb.AppendLine("fi");
            sb.AppendLine();
        }

        sb.AppendLine("echo \"\"");
        sb.AppendLine("echo \"Results: $((TOTAL - FAILED))/${TOTAL} passed\"");
        sb.AppendLine("if [ ${FAILED} -ne 0 ]; then");
        sb.AppendLine("  echo \"FORMAL VERIFICATION FAILED\"");
        sb.AppendLine("  exit 1");
        sb.AppendLine("fi");
        sb.AppendLine("echo \"FORMAL VERIFICATION PASSED\"");

        return sb.ToString();
    }

    /// <summary>
    /// Parses TLC standard output to extract the model checking result.
    /// </summary>
    /// <param name="tlcStdout">Standard output from a TLC run.</param>
    /// <returns>Parsed result with pass/fail, state count, and any counterexample.</returns>
    public static ModelCheckResult ParseTlcOutput(string tlcStdout)
    {
        ArgumentNullException.ThrowIfNull(tlcStdout);

        // Cat 13 (finding 802): string.Split allocates proportional to TLC output size.
        // TLC output is bounded (≤ few MB) and ParseTlcOutput is called once per model-check
        // run — not in a hot path. For large outputs, prefer MemoryExtensions.Split or
        // StreamReader line-by-line enumeration to avoid the intermediate array allocation.
        var lines = tlcStdout.Split('\n');
        var passed = true;
        long statesExplored = 0;
        string? counterExample = null;
        var violatedInvariants = new List<string>();
        var duration = TimeSpan.Zero;

        var inCounterExample = false;
        var counterExampleBuilder = new StringBuilder();

        foreach (var line in lines)
        {
            var trimmed = line.Trim();

            // Check for invariant violation
            if (trimmed.StartsWith("Error: Invariant", StringComparison.Ordinal))
            {
                passed = false;
                var invariantName = ExtractInvariantName(trimmed);
                if (invariantName != null)
                {
                    violatedInvariants.Add(invariantName);
                }
                inCounterExample = true;
                continue;
            }

            // Check for general error
            if (trimmed.StartsWith("Error:", StringComparison.Ordinal))
            {
                passed = false;
            }

            // Collect counterexample trace
            if (inCounterExample)
            {
                if (trimmed.StartsWith("State ", StringComparison.Ordinal) ||
                    trimmed.StartsWith("/\\", StringComparison.Ordinal) ||
                    trimmed.Length == 0)
                {
                    counterExampleBuilder.AppendLine(trimmed);
                }
                else if (trimmed.StartsWith("Finished", StringComparison.Ordinal))
                {
                    inCounterExample = false;
                }
            }

            // Parse state count
            if (trimmed.Contains("distinct states found", StringComparison.Ordinal))
            {
                statesExplored = ExtractStateCount(trimmed);
            }

            // Parse duration
            if (trimmed.StartsWith("Finished in", StringComparison.Ordinal))
            {
                duration = ExtractDuration(trimmed);
            }

            // Check for explicit pass
            if (trimmed.Contains("Model checking completed. No error has been found.", StringComparison.Ordinal))
            {
                passed = true;
            }
        }

        if (counterExampleBuilder.Length > 0)
        {
            counterExample = counterExampleBuilder.ToString().TrimEnd();
        }

        return new ModelCheckResult
        {
            Passed = passed,
            CounterExample = counterExample,
            StatesExplored = statesExplored,
            Duration = duration,
            ViolatedInvariants = violatedInvariants.ToArray()
        };
    }

    /// <summary>
    /// Returns all four formal verification models for batch CI execution.
    /// </summary>
    /// <returns>All registered TLA+ models.</returns>
    public static IReadOnlyList<ITlaPlusModel> GetAllModels()
    {
        return new ITlaPlusModel[]
        {
            new WalRecoveryModel(),
            new RaftConsensusModel(),
            new BTreeInvariantsModel(),
            new SuperblockUpdateModel()
        };
    }

    private static string? ExtractInvariantName(string line)
    {
        // Format: "Error: Invariant InvariantName is violated."
        const string prefix = "Error: Invariant ";
        if (!line.StartsWith(prefix, StringComparison.Ordinal))
            return null;

        var rest = line.Substring(prefix.Length);
        var spaceIdx = rest.IndexOf(' ');
        return spaceIdx > 0 ? rest.Substring(0, spaceIdx) : rest.TrimEnd('.');
    }

    private static long ExtractStateCount(string line)
    {
        // Format: "123456 distinct states found"
        var parts = line.Split(' ');
        foreach (var part in parts)
        {
            if (long.TryParse(part, NumberStyles.Integer, CultureInfo.InvariantCulture, out var count) && count > 0)
            {
                return count;
            }
        }
        return 0;
    }

    private static TimeSpan ExtractDuration(string line)
    {
        // Format: "Finished in 01:23 at (2024-01-01)" or "Finished in 5s at ..."
        const string prefix = "Finished in ";
        if (!line.StartsWith(prefix, StringComparison.Ordinal))
            return TimeSpan.Zero;

        var rest = line.Substring(prefix.Length);
        var atIdx = rest.IndexOf(" at", StringComparison.Ordinal);
        if (atIdx > 0)
        {
            rest = rest.Substring(0, atIdx);
        }

        if (TimeSpan.TryParse(rest, CultureInfo.InvariantCulture, out var ts))
        {
            return ts;
        }

        // Try seconds format
        if (rest.EndsWith('s') &&
            double.TryParse(rest.TrimEnd('s'), NumberStyles.Float, CultureInfo.InvariantCulture, out var seconds))
        {
            return TimeSpan.FromSeconds(seconds);
        }

        return TimeSpan.Zero;
    }
}
