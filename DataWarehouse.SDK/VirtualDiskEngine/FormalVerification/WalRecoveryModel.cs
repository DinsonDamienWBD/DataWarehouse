using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using DataWarehouse.SDK.Contracts;

namespace DataWarehouse.SDK.VirtualDiskEngine.FormalVerification;

/// <summary>
/// TLA+ formal verification model for Write-Ahead Log (WAL) crash recovery.
/// Proves that the WAL mechanism guarantees data consistency, completeness,
/// recovery idempotence, and absence of partial writes across arbitrary crash points.
/// </summary>
/// <remarks>
/// <para>
/// State variables model the WAL entry sequence, data block state, and crash/recovery flags.
/// Actions model the full write-flush-crash-recover lifecycle.
/// </para>
/// <para>
/// Invariants verified:
/// <list type="bullet">
///   <item>DataConsistency: after recovery, data blocks match committed WAL entries</item>
///   <item>WalCompleteness: every committed write has a corresponding WAL entry</item>
///   <item>RecoveryIdempotence: running recovery twice produces the same state</item>
///   <item>NoPartialWrites: crash during flush leaves data in pre-flush or post-flush state</item>
/// </list>
/// </para>
/// </remarks>
[SdkCompatibility("6.0.0", Notes = "Phase 85: WAL crash recovery TLA+ model (COMP-03)")]
public sealed class WalRecoveryModel : ITlaPlusModel
{
    /// <summary>Default maximum number of WAL entries for tractable state space.</summary>
    public const int DefaultMaxEntries = 5;

    /// <summary>Default maximum number of data blocks.</summary>
    public const int DefaultMaxBlocks = 3;

    /// <inheritdoc />
    public TlaPlusSpec GenerateSpec(ModelConfig? config = null)
    {
        config ??= new ModelConfig();

        var maxEntries = config.Constants.GetValueOrDefault("MaxEntries", DefaultMaxEntries);
        var maxBlocks = config.Constants.GetValueOrDefault("MaxBlocks", DefaultMaxBlocks);

        var constants = new Dictionary<string, int>
        {
            ["MaxEntries"] = maxEntries,
            ["MaxBlocks"] = maxBlocks
        };

        var specText = GenerateSpecText(maxEntries, maxBlocks);
        var invariants = new[]
        {
            "DataConsistency",
            "WalCompleteness",
            "RecoveryIdempotence",
            "NoPartialWrites"
        };

        return new TlaPlusSpec
        {
            ModuleName = "WalRecovery",
            SpecText = specText,
            Invariants = invariants,
            TemporalProperties = new[] { "RecoveryTerminates" },
            Config = new ModelConfig
            {
                MaxStates = config.MaxStates,
                Workers = config.Workers,
                Constants = constants
            }
        };
    }

    private static string GenerateSpecText(int maxEntries, int maxBlocks)
    {
        var sb = new StringBuilder();

        sb.AppendLine("--------------------------- MODULE WalRecovery ---------------------------");
        sb.AppendLine("(**************************************************************************)");
        sb.AppendLine("(* TLA+ specification for Write-Ahead Log crash recovery correctness.     *)");
        sb.AppendLine("(* Proves data consistency, WAL completeness, recovery idempotence,       *)");
        sb.AppendLine("(* and absence of partial writes across arbitrary crash points.            *)");
        sb.AppendLine("(* Auto-generated by DataWarehouse TLA+ Formal Verification Framework.    *)");
        sb.AppendLine("(**************************************************************************)");
        sb.AppendLine();
        sb.AppendLine("EXTENDS Integers, Sequences, FiniteSets, TLC");
        sb.AppendLine();

        // Constants
        sb.AppendLine("CONSTANTS");
        sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
            "    MaxEntries,     \\* Maximum WAL entries (default {0})", maxEntries));
        sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
            "    MaxBlocks       \\* Maximum data blocks (default {0})", maxBlocks));
        sb.AppendLine();

        // Variables
        sb.AppendLine("VARIABLES");
        sb.AppendLine("    walEntries,     \\* Sequence of WAL entries: [block |-> BlockId, data |-> Value, committed |-> BOOLEAN]");
        sb.AppendLine("    dataBlocks,     \\* Function: BlockId -> Value (current data block state)");
        sb.AppendLine("    flushedBlocks,  \\* Function: BlockId -> Value (last durable data block state)");
        sb.AppendLine("    crashed,        \\* Boolean: system has crashed");
        sb.AppendLine("    recovering,     \\* Boolean: recovery is in progress");
        sb.AppendLine("    recoveryCount   \\* Nat: number of recovery runs completed");
        sb.AppendLine();
        sb.AppendLine("vars == <<walEntries, dataBlocks, flushedBlocks, crashed, recovering, recoveryCount>>");
        sb.AppendLine();

        // Type invariant
        sb.AppendLine("Blocks == 1..MaxBlocks");
        sb.AppendLine("Values == 0..MaxEntries");
        sb.AppendLine();
        sb.AppendLine("TypeOK ==");
        sb.AppendLine("    /\\ walEntries \\in Seq([block: Blocks, data: Values, committed: BOOLEAN])");
        sb.AppendLine("    /\\ Len(walEntries) <= MaxEntries");
        sb.AppendLine("    /\\ dataBlocks \\in [Blocks -> Values]");
        sb.AppendLine("    /\\ flushedBlocks \\in [Blocks -> Values]");
        sb.AppendLine("    /\\ crashed \\in BOOLEAN");
        sb.AppendLine("    /\\ recovering \\in BOOLEAN");
        sb.AppendLine("    /\\ recoveryCount \\in 0..MaxEntries");
        sb.AppendLine();

        // Init
        sb.AppendLine("Init ==");
        sb.AppendLine("    /\\ walEntries = << >>");
        sb.AppendLine("    /\\ dataBlocks = [b \\in Blocks |-> 0]");
        sb.AppendLine("    /\\ flushedBlocks = [b \\in Blocks |-> 0]");
        sb.AppendLine("    /\\ crashed = FALSE");
        sb.AppendLine("    /\\ recovering = FALSE");
        sb.AppendLine("    /\\ recoveryCount = 0");
        sb.AppendLine();

        // Actions
        sb.AppendLine("(* --- Write a new WAL entry (before modifying data blocks) --- *)");
        sb.AppendLine("WriteWalEntry(block, data) ==");
        sb.AppendLine("    /\\ ~crashed");
        sb.AppendLine("    /\\ ~recovering");
        sb.AppendLine("    /\\ Len(walEntries) < MaxEntries");
        sb.AppendLine("    /\\ block \\in Blocks");
        sb.AppendLine("    /\\ data \\in Values \\ {0}");
        sb.AppendLine("    /\\ walEntries' = Append(walEntries, [block |-> block, data |-> data, committed |-> FALSE])");
        sb.AppendLine("    /\\ UNCHANGED <<dataBlocks, flushedBlocks, crashed, recovering, recoveryCount>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Commit a pending WAL entry (makes it durable in WAL) --- *)");
        sb.AppendLine("CommitWalEntry ==");
        sb.AppendLine("    /\\ ~crashed");
        sb.AppendLine("    /\\ ~recovering");
        sb.AppendLine("    /\\ Len(walEntries) > 0");
        sb.AppendLine("    /\\ \\E i \\in 1..Len(walEntries):");
        sb.AppendLine("        /\\ ~walEntries[i].committed");
        sb.AppendLine("        /\\ walEntries' = [walEntries EXCEPT ![i].committed = TRUE]");
        sb.AppendLine("    /\\ UNCHANGED <<dataBlocks, flushedBlocks, crashed, recovering, recoveryCount>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Flush committed WAL entries to data blocks --- *)");
        sb.AppendLine("FlushToData ==");
        sb.AppendLine("    /\\ ~crashed");
        sb.AppendLine("    /\\ ~recovering");
        sb.AppendLine("    /\\ \\E i \\in 1..Len(walEntries):");
        sb.AppendLine("        /\\ walEntries[i].committed");
        sb.AppendLine("        /\\ LET entry == walEntries[i]");
        sb.AppendLine("           IN");
        sb.AppendLine("            /\\ dataBlocks' = [dataBlocks EXCEPT ![entry.block] = entry.data]");
        sb.AppendLine("            /\\ flushedBlocks' = [flushedBlocks EXCEPT ![entry.block] = entry.data]");
        sb.AppendLine("    /\\ UNCHANGED <<walEntries, crashed, recovering, recoveryCount>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Crash at any point --- *)");
        sb.AppendLine("Crash ==");
        sb.AppendLine("    /\\ ~crashed");
        sb.AppendLine("    /\\ crashed' = TRUE");
        sb.AppendLine("    /\\ dataBlocks' = flushedBlocks    \\* Unflushed in-memory changes lost");
        sb.AppendLine("    /\\ UNCHANGED <<walEntries, flushedBlocks, recovering, recoveryCount>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Recover by replaying committed WAL entries --- *)");
        sb.AppendLine("Recover ==");
        sb.AppendLine("    /\\ crashed");
        sb.AppendLine("    /\\ ~recovering");
        sb.AppendLine("    /\\ recovering' = TRUE");
        sb.AppendLine("    /\\ LET committedEntries == {i \\in 1..Len(walEntries): walEntries[i].committed}");
        sb.AppendLine("       IN");
        sb.AppendLine("        /\\ dataBlocks' = [b \\in Blocks |->");
        sb.AppendLine("            IF \\E i \\in committedEntries: walEntries[i].block = b");
        sb.AppendLine("            THEN LET maxIdx == CHOOSE i \\in committedEntries:");
        sb.AppendLine("                    /\\ walEntries[i].block = b");
        sb.AppendLine("                    /\\ \\A j \\in committedEntries:");
        sb.AppendLine("                        walEntries[j].block = b => j <= i");
        sb.AppendLine("                 IN walEntries[maxIdx].data");
        sb.AppendLine("            ELSE flushedBlocks[b]]");
        sb.AppendLine("        /\\ flushedBlocks' = dataBlocks'");
        sb.AppendLine("    /\\ UNCHANGED <<walEntries, recoveryCount>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Complete recovery --- *)");
        sb.AppendLine("CompleteRecovery ==");
        sb.AppendLine("    /\\ crashed");
        sb.AppendLine("    /\\ recovering");
        sb.AppendLine("    /\\ crashed' = FALSE");
        sb.AppendLine("    /\\ recovering' = FALSE");
        sb.AppendLine("    /\\ recoveryCount' = recoveryCount + 1");
        sb.AppendLine("    /\\ UNCHANGED <<walEntries, dataBlocks, flushedBlocks>>");
        sb.AppendLine();

        // Next state relation
        sb.AppendLine("Next ==");
        sb.AppendLine("    \\/ \\E block \\in Blocks, data \\in Values \\ {0}: WriteWalEntry(block, data)");
        sb.AppendLine("    \\/ CommitWalEntry");
        sb.AppendLine("    \\/ FlushToData");
        sb.AppendLine("    \\/ Crash");
        sb.AppendLine("    \\/ Recover");
        sb.AppendLine("    \\/ CompleteRecovery");
        sb.AppendLine();

        sb.AppendLine("Spec == Init /\\ [][Next]_vars /\\ WF_vars(Next)");
        sb.AppendLine();

        // Invariants
        sb.AppendLine("(* ===== SAFETY INVARIANTS ===== *)");
        sb.AppendLine();

        sb.AppendLine("(* After recovery completes, data blocks match all committed WAL entries *)");
        sb.AppendLine("DataConsistency ==");
        sb.AppendLine("    (~crashed /\\ recoveryCount > 0) =>");
        sb.AppendLine("        \\A i \\in 1..Len(walEntries):");
        sb.AppendLine("            walEntries[i].committed =>");
        sb.AppendLine("                \\/ dataBlocks[walEntries[i].block] = walEntries[i].data");
        sb.AppendLine("                \\/ \\E j \\in (i+1)..Len(walEntries):");
        sb.AppendLine("                    /\\ walEntries[j].block = walEntries[i].block");
        sb.AppendLine("                    /\\ walEntries[j].committed");
        sb.AppendLine();

        sb.AppendLine("(* Every committed write has a corresponding WAL entry *)");
        sb.AppendLine("WalCompleteness ==");
        sb.AppendLine("    \\A b \\in Blocks:");
        sb.AppendLine("        dataBlocks[b] # 0 =>");
        sb.AppendLine("            \\E i \\in 1..Len(walEntries):");
        sb.AppendLine("                /\\ walEntries[i].block = b");
        sb.AppendLine("                /\\ walEntries[i].committed");
        sb.AppendLine();

        sb.AppendLine("(* Running recovery twice produces the same state *)");
        sb.AppendLine("RecoveryIdempotence ==");
        sb.AppendLine("    (~crashed /\\ recoveryCount > 0) =>");
        sb.AppendLine("        dataBlocks = flushedBlocks");
        sb.AppendLine();

        sb.AppendLine("(* Crash during flush leaves data in pre-flush or post-flush state *)");
        sb.AppendLine("NoPartialWrites ==");
        sb.AppendLine("    crashed =>");
        sb.AppendLine("        \\A b \\in Blocks:");
        sb.AppendLine("            \\/ dataBlocks[b] = flushedBlocks[b]    \\* Pre-flush state");
        sb.AppendLine("            \\/ \\E i \\in 1..Len(walEntries):       \\* Post-flush state");
        sb.AppendLine("                /\\ walEntries[i].block = b");
        sb.AppendLine("                /\\ walEntries[i].committed");
        sb.AppendLine("                /\\ dataBlocks[b] = walEntries[i].data");
        sb.AppendLine();

        // Temporal property
        sb.AppendLine("(* Recovery eventually terminates *)");
        sb.AppendLine("RecoveryTerminates == crashed ~> ~crashed");
        sb.AppendLine();

        sb.AppendLine("==========================================================================");

        return sb.ToString();
    }
}
