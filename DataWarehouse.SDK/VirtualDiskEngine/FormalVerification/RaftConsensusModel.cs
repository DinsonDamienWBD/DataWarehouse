using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using DataWarehouse.SDK.Contracts;

namespace DataWarehouse.SDK.VirtualDiskEngine.FormalVerification;

/// <summary>
/// TLA+ formal verification model for Raft consensus protocol.
/// Proves leader election safety, log matching, leader completeness,
/// and state machine safety invariants across node crashes and restarts.
/// </summary>
/// <remarks>
/// <para>
/// Models the core Raft protocol: RequestVote, AppendEntries, commit advancement,
/// timeout-driven elections, and node crash/restart cycles.
/// </para>
/// <para>
/// Invariants verified:
/// <list type="bullet">
///   <item>ElectionSafety: at most one leader per term</item>
///   <item>LogMatching: matching index+term implies all preceding entries match</item>
///   <item>LeaderCompleteness: committed entries present in all future leaders' logs</item>
///   <item>StateMachineSafety: all nodes applying entry N apply the same command</item>
/// </list>
/// </para>
/// </remarks>
[SdkCompatibility("6.0.0", Notes = "Phase 85: Raft consensus TLA+ model (COMP-03)")]
public sealed class RaftConsensusModel : ITlaPlusModel
{
    /// <summary>Default number of nodes in the Raft cluster.</summary>
    public const int DefaultNumNodes = 3;

    /// <summary>Default maximum term number for tractable state space.</summary>
    public const int DefaultMaxTerm = 3;

    /// <summary>Default maximum log length per node.</summary>
    public const int DefaultMaxLogLen = 4;

    /// <inheritdoc />
    public TlaPlusSpec GenerateSpec(ModelConfig? config = null)
    {
        config ??= new ModelConfig();

        var numNodes = config.Constants.GetValueOrDefault("NumNodes", DefaultNumNodes);
        var maxTerm = config.Constants.GetValueOrDefault("MaxTerm", DefaultMaxTerm);
        var maxLogLen = config.Constants.GetValueOrDefault("MaxLogLen", DefaultMaxLogLen);

        var constants = new Dictionary<string, int>
        {
            ["NumNodes"] = numNodes,
            ["MaxTerm"] = maxTerm,
            ["MaxLogLen"] = maxLogLen
        };

        var specText = GenerateSpecText(numNodes, maxTerm, maxLogLen);
        var invariants = new[]
        {
            "ElectionSafety",
            "LogMatching",
            "LeaderCompleteness",
            "StateMachineSafety"
        };

        return new TlaPlusSpec
        {
            ModuleName = "RaftConsensus",
            SpecText = specText,
            Invariants = invariants,
            TemporalProperties = new[] { "LeaderEventuallyElected" },
            Config = new ModelConfig
            {
                MaxStates = config.MaxStates,
                Workers = config.Workers,
                Constants = constants
            }
        };
    }

    private static string GenerateSpecText(int numNodes, int maxTerm, int maxLogLen)
    {
        var sb = new StringBuilder();

        sb.AppendLine("--------------------------- MODULE RaftConsensus -------------------------");
        sb.AppendLine("(**************************************************************************)");
        sb.AppendLine("(* TLA+ specification for the Raft consensus protocol.                    *)");
        sb.AppendLine("(* Proves election safety, log matching, leader completeness, and         *)");
        sb.AppendLine("(* state machine safety across node crashes and network partitions.        *)");
        sb.AppendLine("(* Auto-generated by DataWarehouse TLA+ Formal Verification Framework.    *)");
        sb.AppendLine("(**************************************************************************)");
        sb.AppendLine();
        sb.AppendLine("EXTENDS Integers, Sequences, FiniteSets, TLC");
        sb.AppendLine();

        // Constants
        sb.AppendLine("CONSTANTS");
        sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
            "    NumNodes,       \\* Number of nodes in the cluster (default {0})", numNodes));
        sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
            "    MaxTerm,        \\* Maximum term number (default {0})", maxTerm));
        sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
            "    MaxLogLen       \\* Maximum log length per node (default {0})", maxLogLen));
        sb.AppendLine();

        // Variables
        sb.AppendLine("VARIABLES");
        sb.AppendLine("    currentTerm,    \\* Function: Node -> Nat (current election term)");
        sb.AppendLine("    votedFor,       \\* Function: Node -> Node \\cup {Nil} (candidate voted for in current term)");
        sb.AppendLine("    log,            \\* Function: Node -> Sequence of [term: Nat, cmd: Nat]");
        sb.AppendLine("    commitIndex,    \\* Function: Node -> Nat (highest committed log index)");
        sb.AppendLine("    nodeState,      \\* Function: Node -> {\"Follower\", \"Candidate\", \"Leader\"}");
        sb.AppendLine("    votesGranted,   \\* Function: Node -> Set of Node (votes received in current election)");
        sb.AppendLine("    alive           \\* Function: Node -> Boolean (node is running)");
        sb.AppendLine();
        sb.AppendLine("vars == <<currentTerm, votedFor, log, commitIndex, nodeState, votesGranted, alive>>");
        sb.AppendLine();

        sb.AppendLine("Nodes == 1..NumNodes");
        sb.AppendLine("Terms == 0..MaxTerm");
        sb.AppendLine("Nil == 0");
        sb.AppendLine("States == {\"Follower\", \"Candidate\", \"Leader\"}");
        sb.AppendLine("Commands == 1..MaxLogLen");
        sb.AppendLine();

        sb.AppendLine("Quorum == {Q \\in SUBSET Nodes: Cardinality(Q) * 2 > NumNodes}");
        sb.AppendLine();

        // Type invariant
        sb.AppendLine("TypeOK ==");
        sb.AppendLine("    /\\ currentTerm \\in [Nodes -> Terms]");
        sb.AppendLine("    /\\ votedFor \\in [Nodes -> Nodes \\cup {Nil}]");
        sb.AppendLine("    /\\ \\A n \\in Nodes: Len(log[n]) <= MaxLogLen");
        sb.AppendLine("    /\\ commitIndex \\in [Nodes -> 0..MaxLogLen]");
        sb.AppendLine("    /\\ nodeState \\in [Nodes -> States]");
        sb.AppendLine("    /\\ votesGranted \\in [Nodes -> SUBSET Nodes]");
        sb.AppendLine("    /\\ alive \\in [Nodes -> BOOLEAN]");
        sb.AppendLine();

        // Init
        sb.AppendLine("Init ==");
        sb.AppendLine("    /\\ currentTerm = [n \\in Nodes |-> 0]");
        sb.AppendLine("    /\\ votedFor = [n \\in Nodes |-> Nil]");
        sb.AppendLine("    /\\ log = [n \\in Nodes |-> << >>]");
        sb.AppendLine("    /\\ commitIndex = [n \\in Nodes |-> 0]");
        sb.AppendLine("    /\\ nodeState = [n \\in Nodes |-> \"Follower\"]");
        sb.AppendLine("    /\\ votesGranted = [n \\in Nodes |-> {}]");
        sb.AppendLine("    /\\ alive = [n \\in Nodes |-> TRUE]");
        sb.AppendLine();

        // Actions
        sb.AppendLine("(* --- Node times out and starts election --- *)");
        sb.AppendLine("HandleTimeout(n) ==");
        sb.AppendLine("    /\\ alive[n]");
        sb.AppendLine("    /\\ nodeState[n] # \"Leader\"");
        sb.AppendLine("    /\\ currentTerm[n] < MaxTerm");
        sb.AppendLine("    /\\ currentTerm' = [currentTerm EXCEPT ![n] = currentTerm[n] + 1]");
        sb.AppendLine("    /\\ nodeState' = [nodeState EXCEPT ![n] = \"Candidate\"]");
        sb.AppendLine("    /\\ votedFor' = [votedFor EXCEPT ![n] = n]");
        sb.AppendLine("    /\\ votesGranted' = [votesGranted EXCEPT ![n] = {n}]");
        sb.AppendLine("    /\\ UNCHANGED <<log, commitIndex, alive>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Follower grants vote to candidate --- *)");
        sb.AppendLine("GrantVote(voter, candidate) ==");
        sb.AppendLine("    /\\ alive[voter]");
        sb.AppendLine("    /\\ alive[candidate]");
        sb.AppendLine("    /\\ voter # candidate");
        sb.AppendLine("    /\\ nodeState[candidate] = \"Candidate\"");
        sb.AppendLine("    /\\ currentTerm[candidate] >= currentTerm[voter]");
        sb.AppendLine("    /\\ \\/ votedFor[voter] = Nil");
        sb.AppendLine("       \\/ votedFor[voter] = candidate");
        sb.AppendLine("    \\* Log up-to-date check");
        sb.AppendLine("    /\\ \\/ Len(log[candidate]) > Len(log[voter])");
        sb.AppendLine("       \\/ /\\ Len(log[candidate]) = Len(log[voter])");
        sb.AppendLine("          /\\ \\/ Len(log[candidate]) = 0");
        sb.AppendLine("             \\/ log[candidate][Len(log[candidate])].term >= log[voter][Len(log[voter])].term");
        sb.AppendLine("    /\\ currentTerm' = [currentTerm EXCEPT ![voter] = currentTerm[candidate]]");
        sb.AppendLine("    /\\ votedFor' = [votedFor EXCEPT ![voter] = candidate]");
        sb.AppendLine("    /\\ votesGranted' = [votesGranted EXCEPT ![candidate] = votesGranted[candidate] \\cup {voter}]");
        sb.AppendLine("    /\\ nodeState' = [nodeState EXCEPT ![voter] = \"Follower\"]");
        sb.AppendLine("    /\\ UNCHANGED <<log, commitIndex, alive>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Candidate becomes leader upon receiving quorum votes --- *)");
        sb.AppendLine("BecomeLeader(n) ==");
        sb.AppendLine("    /\\ alive[n]");
        sb.AppendLine("    /\\ nodeState[n] = \"Candidate\"");
        sb.AppendLine("    /\\ votesGranted[n] \\in Quorum");
        sb.AppendLine("    /\\ nodeState' = [nodeState EXCEPT ![n] = \"Leader\"]");
        sb.AppendLine("    /\\ UNCHANGED <<currentTerm, votedFor, log, commitIndex, votesGranted, alive>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Leader appends entry to its log --- *)");
        sb.AppendLine("AppendEntries(leader, cmd) ==");
        sb.AppendLine("    /\\ alive[leader]");
        sb.AppendLine("    /\\ nodeState[leader] = \"Leader\"");
        sb.AppendLine("    /\\ Len(log[leader]) < MaxLogLen");
        sb.AppendLine("    /\\ cmd \\in Commands");
        sb.AppendLine("    /\\ log' = [log EXCEPT ![leader] = Append(log[leader], [term |-> currentTerm[leader], cmd |-> cmd])]");
        sb.AppendLine("    /\\ UNCHANGED <<currentTerm, votedFor, commitIndex, nodeState, votesGranted, alive>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Leader replicates log entry to follower --- *)");
        sb.AppendLine("ReplicateEntry(leader, follower) ==");
        sb.AppendLine("    /\\ alive[leader]");
        sb.AppendLine("    /\\ alive[follower]");
        sb.AppendLine("    /\\ leader # follower");
        sb.AppendLine("    /\\ nodeState[leader] = \"Leader\"");
        sb.AppendLine("    /\\ Len(log[leader]) > Len(log[follower])");
        sb.AppendLine("    /\\ currentTerm[leader] >= currentTerm[follower]");
        sb.AppendLine("    /\\ LET nextIdx == Len(log[follower]) + 1");
        sb.AppendLine("           entry == log[leader][nextIdx]");
        sb.AppendLine("       IN");
        sb.AppendLine("        /\\ log' = [log EXCEPT ![follower] = Append(log[follower], entry)]");
        sb.AppendLine("        /\\ currentTerm' = [currentTerm EXCEPT ![follower] = currentTerm[leader]]");
        sb.AppendLine("        /\\ nodeState' = [nodeState EXCEPT ![follower] = \"Follower\"]");
        sb.AppendLine("        /\\ votedFor' = [votedFor EXCEPT ![follower] = Nil]");
        sb.AppendLine("    /\\ UNCHANGED <<commitIndex, votesGranted, alive>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Leader commits entry replicated on a quorum --- *)");
        sb.AppendLine("CommitEntry(leader, idx) ==");
        sb.AppendLine("    /\\ alive[leader]");
        sb.AppendLine("    /\\ nodeState[leader] = \"Leader\"");
        sb.AppendLine("    /\\ idx > commitIndex[leader]");
        sb.AppendLine("    /\\ idx <= Len(log[leader])");
        sb.AppendLine("    /\\ log[leader][idx].term = currentTerm[leader]");
        sb.AppendLine("    /\\ {n \\in Nodes: alive[n] /\\ Len(log[n]) >= idx /\\ log[n][idx] = log[leader][idx]} \\in Quorum");
        sb.AppendLine("    /\\ commitIndex' = [commitIndex EXCEPT ![leader] = idx]");
        sb.AppendLine("    /\\ UNCHANGED <<currentTerm, votedFor, log, nodeState, votesGranted, alive>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Follower advances commit index --- *)");
        sb.AppendLine("AdvanceCommitIndex(follower, leader) ==");
        sb.AppendLine("    /\\ alive[follower]");
        sb.AppendLine("    /\\ alive[leader]");
        sb.AppendLine("    /\\ nodeState[leader] = \"Leader\"");
        sb.AppendLine("    /\\ commitIndex[leader] > commitIndex[follower]");
        sb.AppendLine("    /\\ commitIndex[leader] <= Len(log[follower])");
        sb.AppendLine("    /\\ commitIndex' = [commitIndex EXCEPT ![follower] = commitIndex[leader]]");
        sb.AppendLine("    /\\ UNCHANGED <<currentTerm, votedFor, log, nodeState, votesGranted, alive>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Node crashes --- *)");
        sb.AppendLine("NodeCrash(n) ==");
        sb.AppendLine("    /\\ alive[n]");
        sb.AppendLine("    /\\ alive' = [alive EXCEPT ![n] = FALSE]");
        sb.AppendLine("    /\\ UNCHANGED <<currentTerm, votedFor, log, commitIndex, nodeState, votesGranted>>");
        sb.AppendLine();

        sb.AppendLine("(* --- Node restarts as follower --- *)");
        sb.AppendLine("NodeRestart(n) ==");
        sb.AppendLine("    /\\ ~alive[n]");
        sb.AppendLine("    /\\ alive' = [alive EXCEPT ![n] = TRUE]");
        sb.AppendLine("    /\\ nodeState' = [nodeState EXCEPT ![n] = \"Follower\"]");
        sb.AppendLine("    /\\ votedFor' = [votedFor EXCEPT ![n] = Nil]");
        sb.AppendLine("    /\\ votesGranted' = [votesGranted EXCEPT ![n] = {}]");
        sb.AppendLine("    /\\ UNCHANGED <<currentTerm, log, commitIndex>>");
        sb.AppendLine();

        // Next state
        sb.AppendLine("Next ==");
        sb.AppendLine("    \\/ \\E n \\in Nodes: HandleTimeout(n)");
        sb.AppendLine("    \\/ \\E voter, candidate \\in Nodes: GrantVote(voter, candidate)");
        sb.AppendLine("    \\/ \\E n \\in Nodes: BecomeLeader(n)");
        sb.AppendLine("    \\/ \\E leader \\in Nodes, cmd \\in Commands: AppendEntries(leader, cmd)");
        sb.AppendLine("    \\/ \\E leader, follower \\in Nodes: ReplicateEntry(leader, follower)");
        sb.AppendLine("    \\/ \\E leader \\in Nodes, idx \\in 1..MaxLogLen: CommitEntry(leader, idx)");
        sb.AppendLine("    \\/ \\E follower, leader \\in Nodes: AdvanceCommitIndex(follower, leader)");
        sb.AppendLine("    \\/ \\E n \\in Nodes: NodeCrash(n)");
        sb.AppendLine("    \\/ \\E n \\in Nodes: NodeRestart(n)");
        sb.AppendLine();

        sb.AppendLine("Spec == Init /\\ [][Next]_vars /\\ WF_vars(Next)");
        sb.AppendLine();

        // Invariants
        sb.AppendLine("(* ===== SAFETY INVARIANTS ===== *)");
        sb.AppendLine();

        sb.AppendLine("(* At most one leader per term *)");
        sb.AppendLine("ElectionSafety ==");
        sb.AppendLine("    \\A n1, n2 \\in Nodes:");
        sb.AppendLine("        /\\ nodeState[n1] = \"Leader\"");
        sb.AppendLine("        /\\ nodeState[n2] = \"Leader\"");
        sb.AppendLine("        /\\ currentTerm[n1] = currentTerm[n2]");
        sb.AppendLine("        => n1 = n2");
        sb.AppendLine();

        sb.AppendLine("(* If two logs have an entry with the same index and term, all preceding entries match *)");
        sb.AppendLine("LogMatching ==");
        sb.AppendLine("    \\A n1, n2 \\in Nodes:");
        sb.AppendLine("        \\A idx \\in 1..MaxLogLen:");
        sb.AppendLine("            (/\\ idx <= Len(log[n1])");
        sb.AppendLine("             /\\ idx <= Len(log[n2])");
        sb.AppendLine("             /\\ log[n1][idx].term = log[n2][idx].term)");
        sb.AppendLine("            =>");
        sb.AppendLine("            \\A prevIdx \\in 1..idx:");
        sb.AppendLine("                log[n1][prevIdx] = log[n2][prevIdx]");
        sb.AppendLine();

        sb.AppendLine("(* A committed entry is present in all future leaders' logs *)");
        sb.AppendLine("LeaderCompleteness ==");
        sb.AppendLine("    \\A leader \\in Nodes:");
        sb.AppendLine("        nodeState[leader] = \"Leader\" =>");
        sb.AppendLine("            \\A n \\in Nodes:");
        sb.AppendLine("                \\A idx \\in 1..commitIndex[n]:");
        sb.AppendLine("                    idx <= Len(log[n]) =>");
        sb.AppendLine("                        /\\ idx <= Len(log[leader])");
        sb.AppendLine("                        /\\ log[leader][idx] = log[n][idx]");
        sb.AppendLine();

        sb.AppendLine("(* All nodes that have applied entry N applied the same command *)");
        sb.AppendLine("StateMachineSafety ==");
        sb.AppendLine("    \\A n1, n2 \\in Nodes:");
        sb.AppendLine("        \\A idx \\in 1..MaxLogLen:");
        sb.AppendLine("            (/\\ idx <= commitIndex[n1]");
        sb.AppendLine("             /\\ idx <= commitIndex[n2]");
        sb.AppendLine("             /\\ idx <= Len(log[n1])");
        sb.AppendLine("             /\\ idx <= Len(log[n2]))");
        sb.AppendLine("            => log[n1][idx].cmd = log[n2][idx].cmd");
        sb.AppendLine();

        // Temporal property
        sb.AppendLine("(* A leader is eventually elected if a majority of nodes are alive *)");
        sb.AppendLine("LeaderEventuallyElected ==");
        sb.AppendLine("    (\\E Q \\in Quorum: \\A n \\in Q: alive[n]) ~> (\\E n \\in Nodes: nodeState[n] = \"Leader\")");
        sb.AppendLine();

        sb.AppendLine("==========================================================================");

        return sb.ToString();
    }
}
