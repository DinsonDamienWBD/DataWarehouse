# v6.0 Intelligent Policy Engine — Design Discussion

**Date:** 2026-02-20
**Status:** Pre-milestone discussion (requirements not yet formalized)

---

## 1. Core Concept

Transform every applicable feature (94 identified across 8 categories) into a multi-level, cascade-aware, AI-tunable policy with performance optimization. Not a dumb policy enforcer — an intelligent engine that auto-tunes, predicts, and optimizes.

## 2. Multi-Level Hierarchy

```
VDE Instance          <- drive-level (BitLocker analogy)
  +-- Container       <- partition/volume-level
       +-- Object/File <- file-level
            +-- Chunk  <- extent-level
                 +-- Block <- sector-level
```

### VDE Architecture Context

Each DW instance runs a VDE — a single flat binary container file (.dwvd format, DWVD magic). The container has a fixed block layout:
Superblock -> Bitmap -> Inode Table -> WAL -> Checksum Table -> B-Tree Index -> Data Region

### Index/Metadata Separation Across VDEs

Currently, the B-Tree index and inode table (metadata) live inside the same VDE container as the data. The IMetadataIndex (semantic search) lives outside the VDE as a separate plugin.

**Proposal:** Make index/metadata location user-configurable:
- Default: all in same VDE (traditional)
- Separation options: data+index on VDE1, metadata on VDE2 / data on VDE1, index on VDE2, metadata on VDE3 / any combination

**Pros:** Performance (NVMe index + spinning data), scaling (index replicated independently), DR (faster recovery)
**Cons:** Cross-VDE consistency (2PC/saga needed), latency (network hops), atomicity (multi-VDE transactions)

### VDE-Level Governance

All features (tags, ACLs, metadata, encryption, etc.) can be applied to the VDE itself, not just its contents. A VDE tagged `region:eu-only` physically cannot operate outside EU. This enables:
- Sovereignty at infrastructure level
- Simplified compliance auditing
- Zero-trust at container level
- Portable governance

---

## 3. Feature Inventory (94 Features, 8 Categories)

### Summary Matrix

| Feature | Block | Chunk | Object | Container | VDE | Multi-Level Value |
|---------|:-----:|:-----:|:------:|:---------:|:---:|:-----------------:|
| **A. SECURITY** | | | | | | |
| A1. Encryption algorithm | YES | - | YES | YES | YES | HIGH |
| A2. Key management | - | - | YES | YES | YES | HIGH |
| A3. Access control (ACL) | - | - | YES | YES | YES | HIGH |
| A4. Audit trail config | - | - | YES | YES | YES | HIGH |
| A5. Auth requirements | - | - | - | YES | YES | MEDIUM |
| A6. Transit encryption | - | - | - | YES | YES | MEDIUM |
| A7. Data integrity (hash) | YES | YES | YES | YES | YES | HIGH |
| A8. WORM / Immutability | - | - | YES | YES | YES | HIGH |
| A9. Zero Trust policy | - | - | - | YES | YES | LOW |
| **B. DATA PROTECTION** | | | | | | |
| B1. Compression | YES | YES | YES | YES | YES | HIGH |
| B2. Deduplication | YES | - | YES | YES | YES | HIGH |
| B3. Checksums | YES | YES | YES | YES | YES | HIGH |
| B4. RAID / Erasure coding | YES | YES | YES | YES | YES | HIGH |
| B5. Error correction | YES | YES | YES | - | - | MEDIUM |
| B6. Secure delete | YES | - | YES | YES | YES | HIGH |
| **C. GOVERNANCE** | | | | | | |
| C1. Tags | - | - | YES | YES | YES | HIGH |
| C2. Tag policies | - | - | YES | YES | YES | HIGH |
| C3. Data classification | - | - | YES | YES | YES | HIGH |
| C4. Compliance framework | - | - | YES | YES | YES | HIGH |
| C5. Data sovereignty | - | - | YES | YES | YES | HIGH |
| C6. Retention policy | - | - | YES | YES | YES | HIGH |
| C7. Legal hold | - | - | YES | YES | YES | HIGH |
| C8. Data masking | - | - | YES | YES | YES | MEDIUM |
| C9. Consent tracking | - | - | YES | YES | YES | LOW |
| C10. Data lineage | - | - | YES | YES | YES | MEDIUM |
| **D. PERFORMANCE** | | | | | | |
| D1. Storage tiering | - | - | YES | YES | YES | HIGH |
| D2. Caching policy | - | - | YES | YES | YES | HIGH |
| D3. Prefetch | YES | - | YES | YES | YES | MEDIUM |
| D4. QoS / Throttling | - | - | YES | YES | YES | HIGH |
| D5. I/O priority | - | - | YES | YES | YES | MEDIUM |
| D6. Block size | - | - | - | YES | YES | LOW |
| **E. REPLICATION** | | | | | | |
| E1. Replication mode | - | - | YES | YES | YES | HIGH |
| E2. Replication factor | - | - | YES | YES | YES | HIGH |
| E3. Geo-placement | - | - | YES | YES | YES | HIGH |
| E4. Sharding | - | - | - | YES | YES | MEDIUM |
| E5. Federation | - | - | YES | YES | YES | MEDIUM |
| E6. Conflict resolution | - | - | YES | YES | YES | MEDIUM |
| **F. LIFECYCLE** | | | | | | |
| F1. Versioning | - | - | YES | YES | YES | HIGH |
| F2. Snapshots | - | - | YES | YES | YES | HIGH |
| F3. Archival | - | - | YES | YES | YES | HIGH |
| F4. Deletion policy | - | - | YES | YES | YES | HIGH |
| F5. Time-lock | - | - | YES | YES | YES | HIGH |
| F6. TTL / Expiration | - | - | YES | YES | YES | HIGH |
| **G. INTELLIGENCE** | | | | | | |
| G1. AI classification | - | - | YES | YES | YES | MEDIUM |
| G2. Anomaly detection | - | - | - | YES | YES | MEDIUM |
| G3. Heat map scoring | - | - | YES | YES | YES | MEDIUM |
| G4. Content processing | - | - | YES | YES | YES | MEDIUM |
| G5. Predictive replication | - | - | - | YES | YES | LOW |
| **H. OTHER** | | | | | | |
| H1. Quotas | - | - | YES | YES | YES | HIGH |
| H2. Cost allocation | - | - | YES | YES | YES | MEDIUM |
| H3. Notifications | - | - | YES | YES | YES | MEDIUM |
| H4. Storage backend | - | - | - | YES | YES | HIGH |
| H5. Pipeline config | - | - | YES | YES | YES | MEDIUM |

**Features at ALL 5 levels (Block through VDE):** Encryption, Compression, Checksums, RAID/Erasure, Deduplication
**Features at Object/Container/VDE (3 levels):** 38 features (majority)
**Features at Container/VDE only (2 levels):** Auth, TLS, Sharding, Backend, Block size, Anomaly detection

---

## 4. Cascade Resolution Model

### Resolution Strategies by Category

| Category | Default Strategy | Rationale |
|----------|-----------------|-----------|
| Security | MostRestrictive | Child tightens, never loosens |
| Data Protection | MostRestrictive | Integrity guarantees cascade down |
| Governance | Merge + Inherit | Child inherits parent tags AND adds own |
| Compliance | Enforce | Parent retention/legal-hold cannot be shortened |
| Performance | Override | Child picks its own settings (hot data != cold data) |
| Replication | Inherit + Override | VDE default, containers can specialize |
| Lifecycle | MostRestrictive | Longest retention wins, legal hold absolute |

### Cascade Strategy Enum

```
MostRestrictive — Take highest intensity from all levels
Enforce         — Parent value is absolute, children CANNOT override
Inherit         — Child uses parent unless explicitly set
Override        — Closest to data wins
Merge           — Union of all levels (governance/tags)
```

All cascade strategies are themselves user-configurable per feature.

### Edge Cases Addressed

1. **Enforce vs Override conflict:** Enforce at higher level ALWAYS wins over Override at lower level
2. **Empty intermediate levels:** Skipped in resolution (Object inherits from VDE, skipping empty Container)
3. **Merge conflicts (governance):** Per-tag-key conflict resolver (configurable: MostRestrictive, Closest, Union)
4. **Policy change during active operation:** In-flight operations use policy snapshot from start time. New policy applies to next operation. Double-buffered versioned cache.
5. **Circular references:** Detected during policy store validation, rejected

---

## 5. Operational Profiles (The "Slider")

### Named Presets

```
MaxPerformance <------------------------------> MaxSecurity
    |         |         |         |         |
  "Speed"  "Balanced" "Standard" "Strict" "Paranoid"
```

### Profile Settings by Feature

| Feature | Speed | Balanced | Standard | Strict | Paranoid |
|---------|-------|----------|----------|--------|----------|
| Encryption | None | AES-128-CTR | AES-256-GCM | AES-256-GCM+HMAC | PQ-Hybrid+AES-256 |
| Compression | LZ4 (fast) | Snappy | Zstd-3 | Zstd-9 | Zstd-19+integrity |
| Checksum | CRC32 | XXHash64 | SHA-256 | SHA-3-256 | BLAKE3+dual-verify |
| Dedup | None | Block async | Chunk sync | Chunk+content | Full+verified |
| ACL check | VDE-level only | Container+Object | Full cascade | Full+audit | Full+audit+alert |
| Tag eval | Skip | VDE-level only | VDE+Container | Full cascade | Full+policy-engine |
| Replication | Async 1x | Async 2x | Sync 2x | Sync 3x | Sync 3x+verify |
| Versioning | None | Last-5 | All+30d | All+1yr | All+immutable |

### Per-Feature Intensity Configuration

Each feature has a spectrum of intensity levels with associated cost and protection scores:

```
FeaturePolicy {
  featureId: "Encryption"
  intensityLevels: [
    { level: 0, name: "None",        perfCost: 0.0,  protectionScore: 0 },
    { level: 1, name: "AES-128-CTR", perfCost: 0.05, protectionScore: 60 },
    { level: 2, name: "AES-256-GCM", perfCost: 0.12, protectionScore: 85 },
    { level: 3, name: "ChaCha20+HMAC", perfCost: 0.15, protectionScore: 90 },
    { level: 4, name: "PQ-Hybrid",   perfCost: 0.35, protectionScore: 100 }
  ]
}
```

### Per-Level Profile Override

Different levels can run different profiles:

```
VDE: profile=Strict (compliance VDE)
  +-- Container "hot-cache": profile=Speed (perf override)
  +-- Container "audit-trail": profile=Paranoid (untouchable)
  +-- Container "general": profile=inherit (uses VDE's Strict)
```

---

## 6. Performance Optimization Engine

### Check Classification

| Timing | Features | Frequency |
|--------|----------|-----------|
| CONNECT_TIME | VDE ACL, auth/MFA, sovereignty, VDE tags | Once per connection |
| SESSION_CACHED | Container ACL, profile resolution, intensity levels | Once per session |
| PER_OPERATION | Object ACL (if exists), encrypt/decrypt, compress/decompress, checksum | Every I/O |
| DEFERRED | Audit log, AI classification, dedup, tag policy, anomaly detection, async replication | Background |
| PERIODIC | Checksum scrub, compliance re-eval, heat-map recalc, retention enforcement | Scheduled |

### Three-Tier Fast Path

**Tier 1: VDE_ONLY (compiled constant)**
- When: No container or object overrides exist (70-80% of deployments)
- Cost: 0ns (JIT-inlined constant return)
- Implementation: Generated sealed class with direct method calls

**Tier 2: CONTAINER_STOP (cached lookup)**
- When: Containers have overrides but objects don't (15-25%)
- Cost: ~20ns (dictionary lookup)
- Implementation: Pre-computed per-container compiled policies

**Tier 3: FULL_CASCADE (bloom + resolve)**
- When: Objects have overrides (5-10%)
- Cost: ~5ns bloom filter + ~200ns full cascade (1% of ops hit full path)
- Implementation: Bloom filter per VDE for "has override?" + full resolution

### Materialized Policy Cache

Pre-computed effective policies stored in memory at VDE open time. Versioned for in-flight operation safety. Double-buffered swap on policy changes (no operations blocked during recompilation).

### Bloom Filter Skip Index

Maintains per-VDE bloom filter tracking which containers/objects have custom overrides:
- On write with custom policy: add to bloom filter
- On read: if bloom says "no override", skip cascade (guaranteed correct)
- False positives (~1%) cause unnecessary but correct cascade walk
- False negatives: impossible

### Compiled Policy Delegates

For hot-path features (encryption, compression, checksum), policy resolution is JIT-compiled into direct delegates at VDE open time. Recompiled only on policy changes (rare admin operation).

### Performance Benchmarks (Expected)

| Scenario | Per-Op Overhead | Total Hot-Path |
|----------|----------------|----------------|
| Stock Ticker (Speed) | ~12us/KB | LZ4 + CRC32 + cached ACL |
| Standard Enterprise | ~50us/KB | Zstd-3 + AES-256 + SHA-256 + cascade ACL |
| Military (Paranoid) | ~590us/KB | Zstd-19 + PQ-Hybrid + BLAKE3 + sync 3x + full audit |

---

## 7. AI Policy Intelligence

### AI Governance Autonomy Model

#### Autonomy Level Enum (per-feature, per-level)

```
ManualOnly     — AI has no involvement
Suggest        — AI produces recommendations, shown in dashboard
SuggestExplain — AI suggests with full rationale chain
AutoNotify     — AI applies changes, admin notified immediately
AutoSilent     — AI applies changes, logged but no notification
```

### AI Awareness Inputs

1. **Hardware awareness** — CPU capabilities (AES-NI, AVX-512), RAM, storage speed, thermal throttling. Example: "PQ-Hybrid needs X FLOPS, your hardware delivers 0.7X, recommending AES-256-GCM+HMAC"
2. **Data sensitivity awareness** — Observes actual data patterns. Example: "VDE-2 receives 98% non-PII office docs, Paranoid profile costs 340us/op, recommending Standard (45us/op)"
3. **Infrastructure change detection** — Hardware upgrade/network change. Example: "New NVMe tier detected, recommending block-level dedup (previously disabled)"
4. **Workload pattern awareness** — Time-of-day, seasonal, burst. Example: "Trading hours 12x writes, switching LZ4 during peak, Zstd-9 overnight"
5. **Threat awareness** — Anomaly feeds into policy tightening. Example: "4,000 sequential reads in 30s, escalating ACL to per-operation check"
6. **Cost awareness** — Cloud billing. Example: "PQ-Hybrid costs $0.012/GB, AES-256 costs $0.002/GB, switching non-classified saves $14K/mo"

### AI Observation Pipeline (Zero Hot-Path Impact)

```
Data Path (hot - zero AI overhead):
  Write -> Compress -> Encrypt -> Checksum -> Store
                                     |
                                     v (async, non-blocking)
                               MetricsBuffer (lock-free ring buffer)
                                     |
                                     v (background thread, every N seconds)
                               ObservationAggregator
                                     |
                    +----------------+----------------+
                    v                v                v
             HardwareProbe    WorkloadAnalyzer  ThreatDetector
                    |                |                |
                    +----------------+----------------+
                                     v
                               PolicyAdvisor (AI)
                                     |
                                     v
                          PolicyRecommendation
                                     |
                           +---------+---------+
                           v         v         v
                       AutoApply  Suggest   Log Only
```

Performance budget: configurable maxCpuOverhead (default 1%), auto-throttle if exceeded.

### Hybrid Configuration Model

```
Global AI Policy:
  autonomyLevel: Suggest          <- default for everything

  overrides:
    security.*:
      autonomyLevel: Manual        <- never touch security
      aiCanObserve: true           <- but CAN monitor and alert
      aiCanSuggest: false          <- don't even suggest changes

    performance.*:
      autonomyLevel: AutoNotify    <- optimize freely, just tell me
      adjustmentBounds:
        maxDegradation: 10%        <- never reduce protection >10%
        maxCostIncrease: 20%       <- never increase compute >20%

    compression.*:
      autonomyLevel: AutoSilent    <- full auto, don't bother me

    lifecycle.retention:
      autonomyLevel: Manual        <- compliance, don't touch

    replication:
      autonomyLevel: Suggest       <- suggest but I decide
      aiCanEscalate: true          <- except during detected failures
```

---

## 8. Authority Chain and Override Hierarchy

### Three-Level Authority

```
Level 1: Admin Policy (normal administrator configuration)
Level 2: AI Policy (auto-tune/emergency, subject to autonomy permissions)
Level 3: Super Admin Quorum (overrides EVERYTHING, AI CANNOT reverse)
```

### Emergency Escalation Protocol

1. ThreatDetector raises ALERT
2. Check: Does feature allow aiEmergencyEscalation?
3. If yes: AI applies EscalationPolicy (time-bounded, default 15 minutes)
4. Notify ALL admins immediately
5. Countdown timer:
   - Admin confirms -> escalation becomes permanent
   - Admin reverts -> original policy restored
   - Timer expires -> auto-reverts, incident logged

Each escalation generates an immutable EscalationRecord with tamper-proof hash.

### Super Admin Quorum (Multi-Key Authorization)

Like nuclear launch keys — multiple super admins must unanimously agree:

```
QuorumPolicy:
  requiredApprovals: 3     (e.g., 3-of-5 must agree)
  totalSuperAdmins: 5
  approvalWindow: 1 hour   (time to collect approvals)

  Actions requiring quorum:
    - Override AI escalation
    - Change security policies
    - Disable AI entirely
    - Modify quorum rules themselves
    - Grant/revoke super admin role
    - Delete VDE
    - Export encryption keys
    - Disable audit trail
```

### Defense Against Compromised Super Admins

1. **Quorum itself** — Compromising one isn't enough
2. **Hardware tokens** — MFA required (YubiKey, smart card)
3. **Geographic distribution** — Approvals from different network segments
4. **Time-lock on destructive actions** — 24hr cooling-off, ANY super admin can veto
5. **Dead man's switch** — No super admin activity for N days -> auto-lock to max security
6. **Immutable audit trail** — TamperProof pipeline, cryptographically chained
7. **Hardware root of trust (HSM)** — Physical presence for catastrophic changes ("break glass")

### Complete Authority Resolution Order

```
1. Super Admin quorum override? -> Use it. Done. (AI cannot override)
2. Active AI emergency escalation? -> Use it. (Unless Admin/SuperAdmin reverts)
3. Admin policy? -> Use it. (Subject to AI autonomy level)
4. System defaults. (Always present)
```

---

## 9. SDK Architecture

### DECISION: Policy Lives at Plugin Level, Not Strategy Level (Corrected)

The **policy** says WHAT to achieve. The **plugin** decides HOW (selects best strategy). The **strategy** executes.

| Layer | Responsibility | Example |
|-------|---------------|---------|
| **Policy** | What must be achieved | "Encryption: intensity >= 4, protectionScore >= 90" |
| **Plugin** | Select best strategy that satisfies policy | UltimateEncryptionPlugin evaluates hardware, picks best fit |
| **Strategy** | Execute the actual work | Aes256GcmStrategy.Encrypt(data) |

The strategy doesn't need to know about policies. The plugin is the intelligent broker:

```
UltimateEncryptionPlugin:
  policyRequirement: intensity >= 4
  availableStrategies: [
    { strategy: Aes128Ctr,    intensity: 1, protectionScore: 60, hwReq: low },
    { strategy: Aes256Gcm,    intensity: 2, protectionScore: 85, hwReq: medium },
    { strategy: ChaCha20Hmac, intensity: 3, protectionScore: 90, hwReq: medium },
    { strategy: PqHybrid,     intensity: 4, protectionScore: 100, hwReq: high }
  ]

  selectedStrategy = availableStrategies
    .Where(s => s.intensity >= policy.minIntensity)
    .Where(s => hardware.CanSupport(s.hwRequirement))
    .OrderByDescending(s => s.protectionScore)
    .First();
```

### DECISION: AI Integration Through Plugin Hierarchy

```
PluginBase (SDK)
  HAS: PolicyContext (every plugin is policy-aware)
  HAS: PolicyRequirements (what policy demands of this plugin)
  DOES: Reads effective policy, selects strategies accordingly
  |
  +-- IntelligenceAwarePluginBase (SDK)
  |     HAS: IAiHook (connection point for AI observation + tuning)
  |     HAS: ObservationEmitter (sends metrics to ring buffer)
  |     HAS: RecommendationReceiver (gets AI suggestions)
  |     DOES: Allows AI to observe plugin behavior and suggest/apply changes
  |     |
  |     +-- UltimateEncryptionPlugin (inherits IntelligenceAware)
  |     |     AI can observe: cipher overhead, failure rates, hardware utilization
  |     |     AI can suggest: "switch to ChaCha20 on this ARM container"
  |     |
  |     +-- UltimateCompressionPlugin (inherits IntelligenceAware)
  |     |     AI can observe: compression ratios, CPU cost, content patterns
  |     |     AI can suggest: "this container is mostly JPEG, skip compression"
  |     |
  |     +-- UltimateRAIDPlugin, UltimateReplicationPlugin, ... (all others)
  |
  +-- UltimateIntelligencePlugin (inherits PluginBase DIRECTLY, NOT IntelligenceAware)
        DOES NOT have IAiHook (prevents AI-observing-AI loop)
        HAS: PolicyContext (admin fully controls AI behavior via policy)
        Policy is ALWAYS ManualOnly by default
        Only admin/super-admin can change UltimateIntelligence's policy
        allowSelfModification: false (AI cannot change its own config)
        modificationRequiresQuorum: true
```

**Why UltimateIntelligence inherits PluginBase, not IntelligenceAwarePluginBase:**
- Prevents AI observing itself observing itself (infinite loop)
- Prevents AI tuning its own observation frequency
- Prevents AI suggesting changes to its own autonomy level (self-promotion attack)
- AI is the observer, not the observed. It reads hooks from IntelligenceAware plugins.

### DECISION: With Quorum Failsafe, AI Can Manage ALL Policies

Because the quorum can always override AI, the risk calculus changes. Default for high-security:

```
AI Autonomy Defaults (with quorum active):
  security.*:        SuggestExplain    (AI suggests security improvements with rationale)
  compliance.*:      SuggestExplain    (AI tracks CVEs, suggests fixes)
  performance.*:     AutoNotify        (AI optimizes freely, notifies)
  lifecycle.*:       Suggest           (AI suggests, human decides)
  replication.*:     AutoNotify        (AI adjusts replication based on failures)
  governance.*:      Suggest           (AI suggests tag/classification changes)
  intelligence.*:    ManualOnly        (ALWAYS - no self-modification)
```

### DECISION: Persistence Layer is Pluggable, Not TamperProof-Mandatory

```csharp
public interface IPolicyPersistence
{
    Task SavePolicyAsync(FeaturePolicy policy);
    Task<FeaturePolicy?> LoadPolicyAsync(string featureId, PolicyLevel level);
    Task SaveAuditRecordAsync(PolicyAuditRecord record);
    Task SaveEscalationRecordAsync(EscalationRecord record);
    Task SaveQuorumRecordAsync(QuorumRecord record);
}
```

Strategy-pattern implementations:

| Implementation | Use Case |
|---------------|----------|
| InMemoryPolicyPersistence | Testing, ephemeral deployments |
| FilePolicyPersistence | Single-node, writes to VDE superblock or sidecar |
| DatabasePolicyPersistence | Multi-node with replication |
| TamperProofPolicyPersistence | Blockchain-backed, immutable audit chain |
| HybridPolicyPersistence | Policies in DB, audit trail in TamperProof |

Configuration:
```json
{
  "policyEngine": {
    "persistence": {
      "policyStore": "Database",
      "auditStore": "TamperProof",
      "escalationStore": "TamperProof",
      "quorumStore": "TamperProof"
    }
  }
}
```

**Compliance validation:** If a compliance framework (HIPAA, SOC2) is active but auditStore is "File", the engine rejects the configuration: "HIPAA requires immutable audit trails. Change auditStore to TamperProof or remove HIPAA framework."

### New SDK Contracts

```
DataWarehouse.SDK/PolicyEngine/
  IPolicyEngine.cs           -- core resolution interface
  IEffectivePolicy.cs        -- resolved policy at a path
  IPolicyStore.cs            -- persistence of policy configs
  IPolicyPersistence.cs      -- pluggable persistence (NOT TamperProof-mandatory)
  FeaturePolicy.cs           -- policy definition (intensity levels, cascade rules)
  PolicyLevel.cs             -- enum: Block, Chunk, Object, Container, VDE
  CascadeStrategy.cs         -- enum: MostRestrictive, Merge, Enforce, Override, Inherit
  AiAutonomyLevel.cs         -- enum: ManualOnly, Suggest, SuggestExplain, AutoNotify, AutoSilent
  OperationalProfile.cs      -- named presets + custom profiles
  AuthorityChain.cs          -- Admin -> AI -> SuperAdmin override chain
  QuorumPolicy.cs            -- multi-key authorization
  PolicyResolutionContext.cs -- carries path, user, hardware context
  Cache/
    MaterializedPolicyCache.cs   -- pre-computed effective policies
    BloomFilterSkipIndex.cs      -- O(1) "has override?" checks
    CompiledPolicyDelegate.cs    -- JIT-compiled policy functions
  AI/
    IPolicyAdvisor.cs            -- AI suggestion/auto-tune interface
    IHardwareProbe.cs            -- hardware capability detection
    IWorkloadObserver.cs         -- data pattern monitoring
    IThreatSignalReceiver.cs     -- threat feeds into policy engine
    PolicyRecommendation.cs      -- AI output: what to change and why
```

### Backward Compatibility

Any v5.0 deployment upgraded to v6.0:
- All features continue working identically
- All configs auto-migrated to VDE-level policies
- No multi-level behavior unless admin explicitly configures it
- PolicyEngine transparent -- exists but doesn't change behavior
- AI is OFF by default (ManualOnly for all features)

---

## 10. Policy Data Residency -- Where Policy Physically Lives

### DECISION: Policy Travels With the Data It Governs

| Category | What | Where |
|----------|------|-------|
| VDE-level policy | Policies about the VDE itself | Inside VDE file, OUTSIDE user capacity |
| Container-level policy | Policies about containers | Inside VDE, within container metadata (user capacity) |
| Object-level policy | Policies about objects | Inside VDE, within inode xattrs |

### Three Residency Principles

1. **VDE-level policy** is infrastructure overhead (like superblock/bitmap). User pays no capacity cost. A 10MB VDE with 35KB of VDE-level policy = ~10.04MB file, but user sees 10MB usable.

2. **Container-level policy** is tenant data. It lives within the container's allocated space because container admins (tenants) configure their own overrides.

3. **Object-level policy** lives in inode extended attributes (4KB max). Most objects inherit (no policy xattr = zero overhead). Objects with overrides use sparse xattr storage.

---

## 11. DECISION: Custom VDE Format (Not Industry Standard)

### Why Custom, Not VHDX/VMDK/QCOW2

Industry standard VDE formats (VHD/VHDX, VMDK, QCOW2, VDI) are designed for ONE purpose: present a raw block device to an OS so the OS can put a filesystem on it.

Our VDE IS the filesystem. There's no OS layer in between. Using VHDX would mean either:
- (a) Put NTFS/ext4 inside VHDX, lose all deep integration (double indirection, no policy embedding) -- TERRIBLE
- (b) Write our structures directly on raw VHDX blocks, making VHDX a dead-weight wrapper -- POINTLESS

**What standard formats provide that we'd want:**
- Thin provisioning -> Our bitmap already supports this
- Snapshots -> Our CopyOnWrite/SnapshotManager already does this
- Dynamic resize -> Append to data region, update superblock
- Hypervisor mounting -> Not applicable (we're not a VM disk)

**What we need that NO standard provides:**
- Encrypted policy vault with HMAC seal
- Cryptographic binding between policy and data
- Capacity accounting excluding metadata overhead
- Inode-level policy xattrs
- WAL integrated into container
- Policy Overflow with hash chain

**Industry precedent:** ZFS, Ceph/BlueStore, HDFS, SQLite, PostgreSQL, MongoDB/WiredTiger, MinIO XL, Amazon S3 -- ALL use custom formats because the format IS the product.

**Interoperability provided through:**
- Import/export (dw export --format vhdx/raw)
- Standard API access (S3-compatible, FUSE mount, NFS/SMB, REST/gRPC)
- Fully documented public format specification

### Extended VDE Format v2.0

```
[VDE Header][Policy Vault][Superblock][Bitmap][Inode Table][WAL][Checksum Table][B-Tree Index][Data Region][Policy Overflow]
|  512B     |  ~35KB      |<----------------------- User Capacity ----------------------->|  variable  |
|           | (encrypted) |                          (10 MB)                               | (grows)    |
|<------------------------------------- Total File Size (~10.04 MB) ---------------------------------------->|
```

### VDE Header (512 bytes, fixed, sector-aligned)

```
Offset  Size   Field
0x00    4      Magic: "DWVD"
0x04    4      Format Version: 2 (bumped from 1)
0x08    8      Total file size
0x10    8      User capacity (what user configured)
0x18    8      Policy Vault offset
0x20    8      Policy Vault size
0x28    8      Superblock offset (user data region starts)
0x30    8      Policy Overflow offset (end of file)
0x38    8      Policy Overflow size
0x40    32     VDE Identity (unique ID, never changes)
0x60    32     Policy Binding Hash (HMAC covering vault + data region metadata)
0x80    32     Header Integrity Hash (BLAKE3 of bytes 0x00-0x7F)
0xA0    16     Creation timestamp
0xB0    16     Last policy modification timestamp
0xC0    64     Reserved for future use
0x100   256    Policy Vault Key Envelope (encrypted with VDE master key derivative)
```

### Policy Vault (variable, encrypted)

```
[Vault Header: 64B]
  Magic: "PVLT", version, entry count, total size, checksum, encryption indicator

[Policy Directory: variable]
  Array of { featureId(32B), offset(8B), size(8B), hash(32B) }
  Sorted by featureId for binary search O(log n)

[Policy Entries: variable, per feature]
  FeatureId (32B), PolicyLevel (1B), IntensityLevel (4B), CascadeStrategy (1B),
  AiAutonomyLevel (1B), AiEmergencyEscalation (1B), EffectiveTimestamp (8B),
  SetByAuthority (1B: Admin/AI/Quorum), SetByIdentity (32B),
  CustomConfig (variable, CBOR), EntryHash (32B BLAKE3)

[Authority Chain Record]
  Quorum config, super admin public keys, AI autonomy global config, escalation ring buffer

[Compliance Passport Summary]
  Active frameworks, sovereignty constraints, retention minimums, audit requirements

[Vault Seal: 64B]
  HMAC of entire vault using VDE master key
```

### Tamper Resistance (Deep Integration)

**Binding 1: Cryptographic Entanglement**
```
VDE Master Key
  +-- KDF("vde-data")    --> Data Encryption Key
  +-- KDF("vde-policy")  --> Policy Vault Encryption Key
  +-- KDF("vde-binding") --> Policy Binding Key

PolicyBindingHash = HMAC(PolicyBindingKey, PolicyVault || SuperblockHash || InodeTableRootHash || VdeIdentity)
```
- Can't detach vault and attach to different VDE (VdeIdentity mismatch)
- Can't modify data without invalidating binding (SuperblockHash changes)
- Can't modify vault without invalidating binding
- Can't read anything without VDE master key

**Binding 2: Structural Interleaving**
Policy Directory entries reference data region structures (affected inode ranges, data region checkpoints). Stripping the vault and replacing it breaks checkpoint verification.

**Binding 3: VDE Won't Open Without Valid Policy**
Open sequence: Header check -> derive policy key -> decrypt vault -> verify HMAC -> verify binding hash -> IF ANY FAILS: refuse to open, no data access.

**Hex editor attack resistance:**
| Attack | Prevention |
|--------|-----------|
| Read policies | Encrypted (random bytes without key) |
| Strip vault | Data won't decrypt (binding fails) |
| Replace with weaker vault | HMAC seal fails |
| Copy from another VDE | VdeIdentity mismatch |
| Modify single entry | Entry hash + vault seal fail |
| Truncate overflow | Overflow seal fails, degraded mode |

### Policy Overflow Region (end of file, grows over time)

```
[Overflow Header: 64B]
  Magic: "POVF", entry count, linked back to Policy Vault

[Escalation History]
  Ring buffer of last N escalation records (immutable)

[Policy Change Audit Trail]
  Append-only, hash-chained log (each entry hashes previous -- "poor man's TamperProof")

[Overflow Seal: 64B]
  HMAC of overflow region
```

### Size Estimates

| Component | Typical Size |
|-----------|-------------|
| VDE Header | 512 bytes |
| Policy Vault (94 features) | ~35 KB |
| Policy Overflow (after 1 year) | ~100 KB - 1 MB |
| **Total overhead for 10 MB VDE** | **~35 KB (0.35%)** |
| **Total overhead for 10 GB VDE** | **~35 KB (0.00035%)** |

---

## 12. Migration Path (v5.0 -> v6.0)

Phase A: SDK Foundation (PolicyEngine contracts, PluginBase PolicyContext, IntelligenceAwarePluginBase)
Phase B: VDE Format v2.0 (Policy Vault, header extension, migration tool for v1 VDEs)
Phase C: Policy Store (IPolicyPersistence implementations, auto-migrate existing config)
Phase D: Container-Level Policies (extend ContainerConfig with PolicyOverrides in inode)
Phase E: Object-Level Policies (extend InodeStructure with policy xattrs)
Phase F: Cascade Resolution Engine (resolve algorithm, wire to plugins)
Phase G: Fast-Path Optimization (bloom filter, compiled delegates, tier analysis)
Phase H: AI Integration (observation pipeline via IntelligenceAwarePluginBase, advisor, authority chain)
Phase I: Operational Profiles (presets, custom profiles, per-level override)
Phase J: Quorum System (multi-key auth, emergency escalation, dead man's switch)

---

## 11. Testing Strategy

### Layered Approach (total ~680+ tests)

| Layer | Tests | Scope |
|-------|-------|-------|
| PolicyEngine Unit | ~200 | Cascade resolution, policy store, compiled policies |
| Per-Feature Multi-Level | ~280 | Each of 94 features at 3 scenarios |
| Cross-Feature Interaction | ~50 | Feature combinations at different levels |
| AI Behavior | ~100 | Autonomy levels, authority chain, escalation |
| Performance | ~30 | Resolution timing, bloom filter rates, recompilation |
| Property-Based/Fuzz | ~20 generators | Random configs, determinism, in-flight safety |

### Combinatorial Reduction

Use pairwise testing (covering arrays) to reduce 11,750 theoretical combinations to ~200 representative pairs.

### Simulation Mode

PolicyEngine.Simulate(hypotheticalPolicy) -> returns what would change, affected count, estimated performance impact, AI assessment. For admins AND tests to validate without applying.

---

---

## 13. DECISION: Composable VDE Architecture (Not Monolithic)

### The Problem

A fully-specced VDE with ALL 20+ regions enabled has ~3.2% overhead. For a 1 GB military VDE, that's ~32 MB — acceptable. But for a hospital with 1 TB of GDPR-compliant patient records, baking in RAID metadata, streaming ring buffers, compute code cache, and consensus logs they'll never use wastes ~20 GB.

### The Solution: VDE as a Build-Time Profile

The DWVD v2.0 spec defines the **maximum envelope** — all possible regions, inode fields, and block types. At deployment, the user selects which **modules** to integrate. DW creates the VDE format with exactly those modules at runtime.

**Key principle:** Features NOT module-integrated STILL WORK through the plugin pipeline (Tier 2 performance). Module integration extracts the "last drops" of performance and intensity from the format itself (Tier 1).

### Three-Tier Performance Model

| Tier | Name | Performance | Example (Encryption) |
|------|------|-------------|---------------------|
| **Tier 1** | VDE-Integrated | Maximum (zero extra I/O) | KeySlot in inode, EncryptionHeader region, per-block algo in trailer, AEAD tags in Integrity Tree |
| **Tier 2** | Pipeline-Optimized | Very Good (~1 extra lookup/session) | IKeyStore lookup, cached session keys, encryption via pipeline Layer 2 |
| **Tier 3** | Basic | Good (~2 extra lookups/op) | Encrypt/decrypt via pipeline, external key management |

For most deployments, Tier 2 is already excellent (built over v1.0-v5.0). Tier 1 is for environments that need block-level, zero-overhead, format-native integration.

### 19 Composable Modules

Each module is a bit in a 32-bit `ModuleManifest` field in the Superblock:

| Bit | Module | Regions Added | Inode Bytes |
|-----|--------|---------------|-------------|
| 0 | Security (SEC) | PolicyVault + EncryptionHeader | +24 |
| 1 | Compliance (CMPL) | ComplianceVault + AuditLog | +12 |
| 2 | Intelligence (INTL) | IntelligenceCache | +12 |
| 3 | Tags (TAGS) | TagIndexRegion | +136 |
| 4 | Replication (REPL) | ReplicationState | +8 |
| 5 | RAID (RAID) | RAIDMetadata | +4 |
| 6 | Streaming (STRM) | StreamingAppend + DataWAL | +8 |
| 7 | Compute (COMP) | ComputeCodeCache | +0 |
| 8 | Fabric (FABR) | CrossVDEReferenceTable | +0 |
| 9 | Consensus (CNSS) | ConsensusLogRegion | +0 |
| 10 | Compression (CMPR) | DictionaryRegion | +4 |
| 11 | Integrity (INTG) | IntegrityTree (Merkle) | +0 |
| 12 | Snapshot (SNAP) | SnapshotTable | +0 |
| 13 | Query (QURY) | BTreeIndexForest (extended) | +4 |
| 14 | Privacy (PRIV) | AnonymizationTable | +2 |
| 15 | Sustainability (SUST) | (superblock metadata) | +4 |
| 16 | Transit (TRNS) | (superblock metadata) | +1 |
| 17 | Observability (OBSV) | MetricsLogRegion | +0 |
| 18 | AuditLog (ALOG) | AuditLogRegion | +0 |

Examples: `0x00000000` = Minimal core, `0x0000000F` = SEC+CMPL+INTL+TAGS, `0x0007FFFF` = ALL modules.

### Inode is Composable Too

Inode size is **fixed within a VDE** but **varies between VDEs** based on selected modules. An `InodeLayoutDescriptor` in the Superblock makes inodes self-describing — the VDE engine parses correctly regardless of which modules are active.

Inode sizes: 320B (minimal) → 384B (standard) → 512B (enterprise) → 576B (maximum). Padding bytes are reserved for future module additions without migration.

### Online Module Addition (Three Options)

When a user enables a feature later, they choose:

| Option | What Happens | Downtime | Performance |
|--------|-------------|----------|-------------|
| **1. Add to current VDE** | Allocate new region from free space + claim inode padding bytes | None | Tier 1 |
| **2. Create new VDE + migrate** | Build new VDE with module, bulk copy data | Minutes (or zero with fabric hot-swap) | Tier 1 |
| **3. Use without VDE integration** | Feature works through pipeline immediately | None | Tier 2 |

Option 1 works because:
- Region Directory has 127 slots (only 7-15 typically used)
- Inode padding bytes are designed to be claimable by future modules
- All operations are WAL-journaled (crash-safe)
- If inode has no padding left → falls back to background inode table migration (like ext4 online inode resize)

Option 3 is **always available, always instant, always zero-risk**.

### VDE Creation Profiles

| Profile | Modules | InodeSize | Overhead |
|---------|---------|-----------|----------|
| Minimal | Core only | 320B | ~1.4% |
| Standard | SEC + INTG + SNAP + CMPR | 384B | ~2.0% |
| Enterprise | SEC + CMPL + INTL + TAGS + INTG + SNAP + CMPR + ALOG | 512B | ~2.5% |
| Maximum Security | ALL 19 modules | 576B | ~3.2% |
| Edge/IoT | STRM + INTG (512B blocks) | 320B | ~1.8% |
| Analytics | INTL + CMPR + SNAP + QURY | 384B | ~2.0% |
| Fully Custom | User decides at deployment |  | from ~1.4 to ~3.2% |

### Additional VDE Enhancements

1. **dw:// Namespace Signature**: 16-byte magic at offset 0 (`DWVD` + version + `dw://` anchor). Namespace Registration Block with Ed25519-signed URI. VDE knows its own `dw://` address.

2. **External Tamper Detection**: HMAC-BLAKE3 header seal, metadata chain hash, file size sentinel, last writer identity. Configurable response: WARN → READ_ONLY → REQUIRE_AUTH → REFUSE → QUARANTINE.

3. **Emergency Recovery Block**: Fixed at block 9 (always same location). Plaintext VDE UUID, creation date, admin contact. Accessible even with all keys lost.

4. **Forward Compatibility**: Three-tier feature flags (incompatible / read-only-compatible / compatible) following ext4 model. `MinReaderVersion` and `MinWriterVersion` in Superblock.

5. **Thin Provisioning**: Sparse file semantics — unwritten blocks don't consume physical disk. `PhysicalAllocatedBlocks` vs `TotalBlocks` tracking.

6. **VDE Nesting**: VDE within VDE (up to 3 levels) for multi-tenant isolation and defense-in-depth encryption.

Full technical details in `.planning/v6.0-VDE-FORMAT-v2.0-SPEC.md` (1,760 lines).

---

*This document captures the design discussion as of 2026-02-20. It will be consumed by the research and requirements phases when milestone v6.0 is formalized.*

**Decision Log:**
1. Policy at Plugin level, not Strategy level (Plugin selects strategy based on policy)
2. AI integration through IntelligenceAwarePluginBase (UltimateIntelligence excluded to prevent loops)
3. Quorum failsafe enables AI management of ALL policies including security
4. Persistence layer is pluggable (InMemory/File/Database/TamperProof/Hybrid)
5. Custom VDE format (not VHDX/VMDK) -- format IS the product
6. Policy data embedded in VDE with cryptographic binding (not detachable)
7. VDE-level policy outside user capacity, Container/Object-level within user capacity
8. **Composable VDE architecture** -- spec is maximum envelope, user selects modules at deployment, features work at Tier 2 without module integration, three options for later module addition (online modify, new VDE, pipeline fallback)
9. **dw:// namespace embedded in VDE** -- self-identifying format with Ed25519-signed namespace authority
10. **External tamper detection** -- HMAC seals, chain hashes, file size sentinels, configurable tamper response levels
10. **External tamper detection** -- HMAC seals, chain hashes, file size sentinels, configurable tamper response levels
11. **File extension `.dwvd`** -- DataWarehouse Virtual Disk, registered across Windows (ProgID + shell handlers), Linux (freedesktop MIME + libmagic), macOS (UTI conforming to public.disk-image). MIME: `application/vnd.datawarehouse.dwvd`. Secondary extensions: `.dwvd.snap`, `.dwvd.delta`, `.dwvd.meta`, `.dwvd.lock`. Shell handler is NOT a separate project — it's 3 registry entries pointing to the existing `dw` CLI binary, implemented as part of installer/packaging.
12. **Plugin consolidation audit** -- 17 non-Ultimate plugins must be reviewed: each either justified as standalone (orchestrator / unique requirements) or merged as a strategy into the appropriate Ultimate plugin. Added as a late v6.0 phase.
