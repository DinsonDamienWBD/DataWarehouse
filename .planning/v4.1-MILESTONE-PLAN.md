# v4.1 Milestone: Production Readiness Fixes + Verification Cycle

## Philosophy

Iterative fix-then-verify cycle:
1. **v4.x** = Fix & implement (P0, P1, Cloud SDK, Test Coverage, Access Control Hierarchy)
2. **v4.0 re-run** = Re-verify using same audit framework (Phases 42-51)
3. Repeat until v4.0 verification returns **100% production readiness** across ALL criteria

---

## Scope (v4.1 Implementation)

### Wave 1: P0 Critical — MUST complete first

#### 1A. Multi-Level Access Control Hierarchy (NEW — Security Architecture)

##### The Problem

1. **No identity on commands/messages**: `CommandContext`, bus messages, `IntelligenceRequest`, and `AgentContext` carry ZERO user identity. When AI agents execute actions, they use their own (system-level) privileges instead of the delegating user's.

2. **Flat access control**: Current access control checks `SubjectId` against permissions, but there is no unified hierarchy that resolves permissions across System → Tenant → Instance → UserGroup → User levels.

3. **No deny-takes-precedence across levels**: Some strategies (ACL, ABAC) have deny-first internally, but there's no cross-level deny resolution. A system-level deny should override a user-level allow.

##### The Hierarchy

```
System (level 0)
  └── Tenant (level 1)
       └── Instance (level 2)
            └── UserGroup (level 3)
                 └── User (level 4)
```

Each level can define `Allow` and `Deny` rules. Resolution:
- Walk from **most specific** (User) to **least specific** (System)
- **Deny at ANY level = DENY** (deny takes absolute precedence)
- Allow must be granted at the appropriate level and not denied at any higher level
- No explicit rule at a level = inherit from parent level
- No rule anywhere = **default DENY**

##### The Verification Matrix

```
For any action request:

Input: CommandIdentity { ActorId, OnBehalfOfPrincipal, PrincipalType, TenantId, InstanceId, GroupIds[], DelegationChain[] }

Step 1: Resolve the "effective principal" — ALWAYS OnBehalfOfPrincipal, NEVER ActorId
Step 2: Walk the hierarchy top-down (System → Tenant → Instance → UserGroup → User)

| Level    | Check                                              | If DENY found | If ALLOW found | If no rule |
|----------|-----------------------------------------------------|---------------|----------------|------------|
| System   | System-wide policies (global bans, maintenance mode) | DENY (final)  | Continue ↓     | Continue ↓ |
| Tenant   | Tenant-level policies (tenant suspended, quota)      | DENY (final)  | Continue ↓     | Continue ↓ |
| Instance | Instance-level policies (instance locked, read-only) | DENY (final)  | Continue ↓     | Continue ↓ |
| UserGroup| Group-level policies (group permissions, group bans)  | DENY (final)  | Continue ↓     | Continue ↓ |
| User     | User-level policies (personal permissions)            | DENY (final)  | ALLOW          | DENY       |

Result: ALLOW only if no DENY found at any level AND at least one ALLOW found
```

##### The `CommandIdentity` Record

```csharp
/// <summary>
/// Immutable, read-only identity that travels with every command/message.
/// Constructed once at the entry point (CLI/GUI/API), never modified.
/// </summary>
public sealed record CommandIdentity
{
    // WHO is physically executing (for audit trail ONLY — never used for access control)
    public required string ActorId { get; init; }
    public required ActorType ActorType { get; init; } // Human, AiAgent, SystemService, Scheduler

    // ON WHOSE BEHALF (this is what access control evaluates)
    public required string OnBehalfOfPrincipalId { get; init; }
    public required PrincipalType PrincipalType { get; init; } // User, UserGroup, Tenant, System

    // Context for hierarchy resolution
    public required string TenantId { get; init; }
    public required string InstanceId { get; init; }
    public IReadOnlyList<string> GroupIds { get; init; }
    public IReadOnlyList<string> Roles { get; init; } // Resolved from OnBehalfOfPrincipalId

    // Authentication provenance
    public required string AuthenticationMethod { get; init; } // Token, Certificate, ApiKey, Session
    public required DateTimeOffset AuthenticatedAt { get; init; }
    public string? SessionId { get; init; }

    // Delegation chain (audit trail): who delegated to whom
    // e.g., ["user:alice", "ai:gemini-user", "ai:claude-system"]
    // means: Alice asked her Gemini, which asked system Claude
    public IReadOnlyList<string> DelegationChain { get; init; }

    // Enforcement: this is the principal whose permissions are checked
    // ALWAYS equals OnBehalfOfPrincipalId — never ActorId
    public string EffectivePrincipalId => OnBehalfOfPrincipalId;
}

public enum ActorType { Human, AiAgent, SystemService, Scheduler, Webhook, ApiClient }
public enum PrincipalType { User, UserGroup, Tenant, System }
```

##### The `AccessVerificationMatrix`

```csharp
/// <summary>
/// Multi-level access verification engine. Evaluates permissions across the
/// System → Tenant → Instance → UserGroup → User hierarchy.
/// Deny at ANY level = absolute DENY. No exceptions.
/// </summary>
public sealed class AccessVerificationMatrix
{
    /// <summary>
    /// Evaluate whether the effective principal in the CommandIdentity
    /// is allowed to perform the specified action on the specified resource.
    /// </summary>
    public AccessVerdict Evaluate(
        CommandIdentity identity,
        string resource,
        string action)
    {
        // Step 1: System-level check (maintenance mode, global bans)
        // Step 2: Tenant-level check (tenant active, tenant policies)
        // Step 3: Instance-level check (instance policies, locked stages)
        // Step 4: UserGroup-level check (for each group in identity.GroupIds)
        // Step 5: User-level check (identity.EffectivePrincipalId)
        //
        // At each level:
        //   - If explicit DENY → return DENY immediately (short-circuit)
        //   - If explicit ALLOW → mark "allow found at level X", continue
        //   - If no rule → continue to next level
        //
        // After all levels:
        //   - If any DENY found → DENY (but we already short-circuited)
        //   - If at least one ALLOW found → ALLOW
        //   - If no rules at any level → DENY (default deny)
    }
}

public sealed record AccessVerdict
{
    public required bool Allowed { get; init; }
    public required string Reason { get; init; }
    public required HierarchyLevel DecidedAtLevel { get; init; }
    public required string RuleId { get; init; } // Which rule made the decision
    public required CommandIdentity Identity { get; init; } // For audit
    public IReadOnlyList<HierarchyLevelResult> LevelResults { get; init; } // Full trace
}

public enum HierarchyLevel { System = 0, Tenant = 1, Instance = 2, UserGroup = 3, User = 4 }
```

##### AI Delegation Scenarios (all must be enforced)

| Scenario | ActorId | OnBehalfOfPrincipalId | Access Check Uses | Expected Result |
|----------|---------|----------------------|-------------------|-----------------|
| User deletes own data via CLI | user:alice | user:alice | alice's permissions | ALLOW (if permitted) |
| User deletes via GUI | user:alice | user:alice | alice's permissions | ALLOW (if permitted) |
| User asks their Gemini to delete | ai:gemini-alice | user:alice | alice's permissions | DENY (if alice lacks permission) |
| User asks system Claude to delete | ai:claude-system | user:alice | alice's permissions | DENY (if alice lacks permission) |
| Admin asks system Claude to delete | ai:claude-system | user:admin | admin's permissions | ALLOW (admin has permission) |
| System scheduler runs cleanup | svc:scheduler | system:maintenance | system-level permissions | ALLOW (system maintenance role) |
| Tenant admin manages tenant data | user:tenant-admin | tenant:acme | tenant-level permissions | ALLOW (tenant admin role) |

**Key rule:** The AI's own access level is IRRELEVANT. Only `OnBehalfOfPrincipalId` matters. Claude having system-level access means nothing — the check is always against the originating user.

##### Changes Required

**SDK (core):**
1. Add `CommandIdentity` record to `SDK/Security/`
2. Add `AccessVerificationMatrix` to `SDK/Security/`
3. Add `HierarchyLevel` enum and `AccessVerdict` record
4. Extend `ISecurityContext` with `CommandIdentity? Identity { get; }`
5. Add `IMessageEnvelope<T>` wrapper with `CommandIdentity` to message bus
6. Add `CommandIdentity` to `CommandContext` in Shared/Commands/

**Entry points (identity construction):**
7. CLI: Construct `CommandIdentity` from `--auth-token` at startup
8. GUI: Construct `CommandIdentity` from JWT/session at login
9. Launcher API: Construct `CommandIdentity` from API key/JWT in middleware
10. Scheduler: Construct `CommandIdentity` with `ActorType.Scheduler`, `PrincipalType.System`

**Intelligence (AI delegation):**
11. Add `CommandIdentity` to `IntelligenceRequest` and `AgentContext`
12. When AI executes actions, propagate the ORIGINAL user's `CommandIdentity`
13. Append AI agent to `DelegationChain` (audit trail)

**Access Control (enforcement):**
14. Wire `AccessVerificationMatrix` into `UltimateAccessControlPlugin`
15. Update `AccessContext` to include full `CommandIdentity`
16. Update all 14 core strategies to use `EffectivePrincipalId` (not raw SubjectId)
17. Unify `PolicyLevel` (Instance→UserGroup→User→Operation) with `HierarchyLevel` (System→Tenant→Instance→UserGroup→User)

**All plugins (propagation):**
18. Update message bus handlers to extract and forward `CommandIdentity` from envelope
19. Update `IContainerManager` callers to use `CommandIdentity`-derived context

**Estimated effort:** 60-80h (architectural, touches SDK + all consumers)

#### 1B. Existing P0 Security Fixes (21-35h)
- TLS certificate validation: Enable in 15 files (configurable `VerifySsl`, default true)
- XXE: Set `DtdProcessing.Prohibit` in 2 files
- Launcher API auth: Add API key or JWT middleware (integrates with 1A identity)
- Password hashing: Replace SHA256 with Argon2id/PBKDF2
- Default admin password: Remove "admin" fallback

#### 1C. P0 Quality Fixes (12-18h)
- 15 dispose method sync-over-async (proven pattern from Phase 43-04)
- Decompression algorithm selection bug
- PNG compression uses HMAC-SHA256 instead of DEFLATE

### Wave 2: P1 High Priority (348-406h)

#### 2A. Async Cleanup (98-126h)
- Remaining 60 `GetAwaiter().GetResult()` occurrences
- Timer callback async conversions
- Property getter deadlock prevention

#### 2B. Security Hardening (50-80h)
- Rate limiting on all public APIs
- mTLS enforcement for inter-node communication
- Secure file deletion (cryptographic erasure)
- ABAC regex timeout hardening
- Null! suppression cleanup (75 occurrences)

#### 2C. Domain-Specific P1 Fixes (65 items, ~200h)
- RAID scrubbing implementation (replace no-ops)
- HSM crypto operations (PKCS#11)
- Multi-Raft coordinator (extend from single-group)
- Auto-scaler implementation (beyond InMemoryAutoScaler)
- Transcoding: Real FFmpeg integration or clear "requires FFmpeg" pattern
- WASM: Embedded runtime option (not just CLI tools)

### Wave 3: Cloud SDK Integration (60-90h)

- Add AWS SDK NuGet packages (S3, EC2, Lambda, RDS, DynamoDB)
- Add Azure SDK NuGet packages (Blob, VMs, Functions, SQL, Cosmos)
- Add GCP SDK NuGet packages (Cloud Storage, Compute, Functions, Cloud SQL, Firestore)
- Replace stub implementations with real cloud API calls
- Credential loading (env vars, config files, IMDS)
- Error handling (invalid credentials, rate limits, region failover)

### Wave 4: Test Coverage (200-400h)

- Create test projects for 50 untested plugins
- Priority: 7 critical plugins first (DataProtection, DatabaseStorage, DataManagement, DataPrivacy, DataGovernance, DataIntegrity, Blockchain)
- **Priority: Access control hierarchy tests** — specifically test AI delegation denial scenarios
- Integration tests for cross-plugin flows (write pipeline, RAID rebuild, cluster formation)
- Edge case tests (circuit breaker, timeout, OOM, disk full)
- Cross-platform tests (Windows + Linux CI matrix)
- Target: 70% line coverage (from 2.4%)

---

## Verification Cycle

After v4.1 implementation completes, re-run v4.0 verification:

### Cycle 1: v4.1 → v4.0 Re-verify
- Re-run Phase 43 (automated scan) — expect P0 count = 0
- Re-run Phase 44 (domain audit) — spot-check fixed domains + NEW: verify access hierarchy
- Re-run Phase 45 (tier verification) — expect all 7 tiers PASS
- Re-run Phase 47 (security audit) — expect identity delegation verified, AI escalation blocked
- Re-run Phase 48 (test coverage) — expect 70%+ coverage
- **NEW Phase 47.1: AI Delegation Penetration Test** — specifically try the scenarios:
  - User → Gemini → delete unauthorized data → MUST FAIL
  - User → system Claude → delete unauthorized data → MUST FAIL
  - User → Gemini → system Claude → delete unauthorized data → MUST FAIL (chain delegation)
  - Tenant A user → cross-tenant data → MUST FAIL
  - Suspended tenant → any operation → MUST FAIL
  - System maintenance mode → user operations → MUST FAIL (except admin)
- Issue new certification: expect CERTIFIED (no conditions)

### Cycle 2+ (if needed): v4.2 → v4.0 Re-verify
- Fix any remaining findings from Cycle 1
- Re-verify
- Repeat until 100% production readiness

---

## Success Criteria (v4.1 complete)

- [ ] `CommandIdentity` propagated end-to-end (CLI → bus → plugin → AI → back)
- [ ] `AccessVerificationMatrix` enforces System→Tenant→Instance→UserGroup→User hierarchy
- [ ] Deny takes absolute precedence at every level
- [ ] AI delegation CANNOT escalate privileges (verified with specific test cases)
- [ ] `OnBehalfOfPrincipalId` is ALWAYS used for access control, NEVER `ActorId`
- [ ] `DelegationChain` is recorded in audit trail for all AI-initiated actions
- [ ] 0 P0 findings remaining
- [ ] 0 P1 security findings remaining
- [ ] Cloud SDK integration functional (AWS S3 upload, Azure Blob upload, GCS upload)
- [ ] Test coverage >= 70%
- [ ] Build: 0 errors, 0 warnings
- [ ] All tests pass
- [ ] v4.0 re-verification returns CERTIFIED (no conditions)

---

## Phase Structure

| Phase | Name | Plans | Depends On |
|-------|------|-------|------------|
| 52 | Multi-Level Access Hierarchy + CommandIdentity | 6 | — |
| 53 | P0 Security + Quality Fixes | 3 | — |
| 54 | P1 Async Cleanup + Security Hardening | 4 | Phase 53 |
| 55 | P1 Domain-Specific Fixes | 5 | Phase 53 |
| 56 | Cloud SDK Integration | 3 | Phase 52 |
| 57 | Test Coverage Expansion | 5 | Phase 53 |
| 58 | v4.0 Re-verification Cycle | 6 | ALL prior |

### Phase 52 Plan Breakdown

| Plan | Title | Scope |
|------|-------|-------|
| 52-01 | SDK: CommandIdentity + HierarchyLevel + AccessVerdict types | Core types in SDK/Security/ |
| 52-02 | SDK: AccessVerificationMatrix engine | Multi-level evaluation with deny-first |
| 52-03 | SDK: Message bus envelope + CommandContext identity | IMessageEnvelope<T>, CommandContext.Identity |
| 52-04 | Entry points: CLI/GUI/Launcher/Scheduler identity construction | All entry points build CommandIdentity |
| 52-05 | Intelligence: AI delegation chain propagation | IntelligenceRequest/AgentContext carry user identity |
| 52-06 | AccessControl plugin: Wire matrix + update all strategies | UltimateAccessControl uses AccessVerificationMatrix |

---

## Effort Summary

| Wave | Effort | Priority |
|------|--------|----------|
| Wave 1: P0 + Access Hierarchy | 93-133h | Week 1-4 |
| Wave 2: P1 fixes | 348-406h | Week 5-14 |
| Wave 3: Cloud SDK | 60-90h | Week 5-10 (parallel) |
| Wave 4: Test Coverage | 200-400h | Week 5-18 (parallel) |
| Re-verification | 20-40h | Week 19-20 |
| **Total** | **721-1,069h** | **~20 weeks** |
