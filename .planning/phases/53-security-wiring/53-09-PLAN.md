---
phase: 53-security-wiring
plan: 09
type: execute
wave: 3
depends_on: []
files_modified:
  - DataWarehouse.Kernel/DataWarehouseKernel.cs
  - DataWarehouse.SDK/Security/ConfigurationAuditLog.cs
  - DataWarehouse.SDK/Security/CommandIdentity.cs
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.Dashboard/Services/UserAuthenticationService.cs
autonomous: true

must_haves:
  truths:
    - "ConfigurationAuditLog is wired to kernel and logging all config changes"
    - "Audit trail has integrity protection (hash chain or similar)"
    - "PBKDF2 uses at least 600K iterations per NIST recommendation"
    - "Delegation chain has a depth limit"
    - "AI agent identity is validated (not nullable without checks)"
  artifacts:
    - path: "DataWarehouse.Kernel/DataWarehouseKernel.cs"
      provides: "Wired ConfigurationAuditLog"
      contains: "ConfigurationAuditLog|_auditLog"
    - path: "DataWarehouse.SDK/Security/ConfigurationAuditLog.cs"
      provides: "Integrity-protected audit trail"
      contains: "HashChain|_previousHash|IntegrityHash"
  key_links:
    - from: "DataWarehouseKernel.cs"
      to: "ConfigurationAuditLog"
      via: "Kernel passes config changes to audit log"
      pattern: "_auditLog|AuditLog"
---

<objective>
Wire infrastructure security: audit logging, integrity protection, PBKDF2 strengthening, identity hardening.

Purpose: Resolves INFRA-02 (CVSS 6.5 -- env var injection), INFRA-03 (CVSS 5.3 -- audit not wired), INFRA-04 (CVSS 4.7 -- audit tamperable), D04 (CVSS 3.7 -- PBKDF2 iterations), AUTH-11 (CVSS 3.8 -- AI identity), AUTH-12 (CVSS 3.4 -- config controls security), AUTH-13 (CVSS 4.3 -- delegation depth). These are the remaining medium/low findings.

Output: Audit logging wired and integrity-protected; PBKDF2 at NIST levels; identity validation complete.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/47-penetration-testing/47-v4.5-PENTEST-REPORT.md
@.planning/phases/47-penetration-testing/47-v4.5-07-INFRA-FINDINGS.md
@.planning/phases/47-penetration-testing/v4.5-02-AUTH-FINDINGS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ConfigurationAuditLog and add integrity protection</name>
  <files>
    DataWarehouse.Kernel/DataWarehouseKernel.cs,
    DataWarehouse.SDK/Security/ConfigurationAuditLog.cs
  </files>
  <action>
  **INFRA-03: ConfigurationAuditLog not wired (CVSS 5.3)**

  1. Read ConfigurationAuditLog.cs to understand its API (it exists in SDK/Security/)
  2. In DataWarehouseKernel.cs:
     - Create a ConfigurationAuditLog instance during kernel initialization
     - Wire it to log all configuration changes: plugin load/unload, security config changes, system config changes
     - Subscribe to relevant message bus topics (config.*, kernel.plugin.load, kernel.plugin.unload) and audit them
     - Log kernel startup and shutdown events
  3. Ensure the audit log is persisted to disk (check if ConfigurationAuditLog already handles this)

  **INFRA-04: Audit trail file not tamper-protected (CVSS 4.7)**

  In ConfigurationAuditLog.cs (line ~56):
  1. Add a hash chain for integrity protection:
     - Each audit entry includes a SHA-256 hash of (previous_entry_hash + current_entry_data)
     - First entry uses a well-known genesis hash (e.g., SHA-256 of "DataWarehouse-AuditGenesis")
     - This creates a tamper-evident log: modifying any entry breaks all subsequent hashes
  2. Add a verification method `VerifyIntegrity()` that walks the chain and confirms all hashes
  3. Store the current chain head hash in memory for quick append validation

  **INFRA-02: Environment variable configuration injection (CVSS 6.5)**

  In DataWarehouseKernel.cs or the relevant configuration loading code:
  1. Add validation for security-sensitive configuration values that could be set via environment variables:
     - `CreateDefaultAdmin` -- log a warning if set to true via env var
     - `RequireSignedAssemblies` -- cannot be overridden to false via env var in production
     - `VerifySsl*` -- cannot be overridden to false via env var in production
  2. Add an `EnvironmentOverridePolicy` that lists which config keys can be set via environment variables
  3. Log all environment variable configuration overrides to the audit log
  </action>
  <verify>
  - `grep -rn "ConfigurationAuditLog\|_auditLog" DataWarehouse.Kernel/DataWarehouseKernel.cs` returns matches
  - `grep -rn "HashChain\|previousHash\|chainHash\|IntegrityHash" DataWarehouse.SDK/Security/ConfigurationAuditLog.cs` returns matches
  - `dotnet build` full solution with 0 errors
  </verify>
  <done>
  - INFRA-03 (CVSS 5.3) RESOLVED: ConfigurationAuditLog wired to kernel
  - INFRA-04 (CVSS 4.7) RESOLVED: Audit trail has hash chain integrity
  - INFRA-02 (CVSS 6.5) MITIGATED: Security-sensitive env var overrides restricted and logged
  </done>
</task>

<task type="auto">
  <name>Task 2: Strengthen PBKDF2, delegation limits, and AI identity validation</name>
  <files>
    DataWarehouse.Dashboard/Services/UserAuthenticationService.cs,
    DataWarehouse.SDK/Security/CommandIdentity.cs,
    DataWarehouse.SDK/Contracts/PluginBase.cs
  </files>
  <action>
  **D04: PBKDF2 at 100K iterations (CVSS 3.7)**

  In UserAuthenticationService.cs (line ~518):
  1. Change PBKDF2 iteration count from 100,000 to 600,000 (NIST SP 800-63B minimum)
  2. Add a constant: `private const int Pbkdf2Iterations = 600_000;`
  3. Ensure backward compatibility: if stored hashes have a version/iteration prefix, support reading old 100K hashes during login and auto-upgrading to 600K on next password change
  4. If no version prefix exists, add one for new hashes: `$PBKDF2-SHA256$600000$salt$hash`

  **AUTH-13: Delegation chain no depth limit (CVSS 4.3)**

  In CommandIdentity.cs (line ~86-90):
  1. Add a maximum delegation depth: `private const int MaxDelegationDepth = 10;`
  2. In the delegation method, track depth:
     ```csharp
     public CommandIdentity DelegateAs(string delegateName, ...)
     {
         var currentDepth = this.DelegationDepth + 1;
         if (currentDepth > MaxDelegationDepth)
             throw new InvalidOperationException($"Delegation chain depth limit exceeded ({MaxDelegationDepth})");
         return new CommandIdentity(...) { DelegationDepth = currentDepth, ... };
     }
     ```
  3. Add a `DelegationDepth` property (int, default 0) to CommandIdentity

  **AUTH-11: AI agent identity nullable (CVSS 3.8)**

  Check IntelligenceContext.cs (line ~69) referenced in the pentest:
  1. Find where AI agent identity is nullable
  2. Add validation: if an AI agent operation requires identity, throw if identity is null
  3. Use `[NotNull]` attributes or `ArgumentNullException.ThrowIfNull` at operation boundaries

  **AUTH-12: Config controls security with no write protection (CVSS 3.4)**

  In DataWarehouseHost.cs (line ~653) or wherever config is written:
  1. Add write protection for security-sensitive configuration:
     - After initial configuration, security settings should be immutable unless explicitly unlocked
     - Add a `SecurityConfigLock` that prevents runtime modification of security settings
     - Modification requires explicit unlock (admin action + audit log entry)

  **ISO-06: Type confusion via plugin message payload (CVSS 4.8)**

  In PluginMessage (PluginDetails.cs or wherever Payload is defined):
  1. Add type validation for Payload dictionary: `Dictionary<string, object>` should validate types on set
  2. Only allow serializable, known-safe types (string, int, long, double, bool, byte[], DateTime, List<string>)
  3. Reject complex objects that could be used for type confusion attacks
  </action>
  <verify>
  - `grep -rn "600.000\|600_000" DataWarehouse.Dashboard/Services/UserAuthenticationService.cs` returns a match
  - `grep -rn "MaxDelegationDepth" DataWarehouse.SDK/Security/CommandIdentity.cs` returns a match
  - `dotnet build` full solution with 0 errors
  </verify>
  <done>
  - D04 (CVSS 3.7) RESOLVED: PBKDF2 at 600K iterations per NIST
  - AUTH-13 (CVSS 4.3) RESOLVED: Delegation chain depth limited to 10
  - AUTH-11 (CVSS 3.8) RESOLVED: AI identity validated at boundaries
  - AUTH-12 (CVSS 3.4) RESOLVED: Security config has write protection
  - ISO-06 (CVSS 4.8) RESOLVED: Payload type validation
  - Solution builds with 0 errors
  </done>
</task>

</tasks>

<verification>
- Full solution builds with 0 errors
- Audit log wired and has integrity protection
- PBKDF2 iterations at NIST level
- All identity validation in place
</verification>

<success_criteria>
- INFRA-02, INFRA-03, INFRA-04, D04, AUTH-11, AUTH-12, AUTH-13, ISO-06 all RESOLVED
- Audit trail is tamper-evident
- Security configuration is protected
</success_criteria>

<output>
After completion, create `.planning/phases/53-security-wiring/53-09-SUMMARY.md`
</output>
