---
phase: 53-security-wiring
plan: 06
type: execute
wave: 2
depends_on: [53-01]
files_modified:
  - DataWarehouse.SDK/Contracts/IMessageBus.cs
  - DataWarehouse.Kernel/Messaging/MessageBus.cs
  - DataWarehouse.Kernel/Messaging/AdvancedMessageBus.cs
  - DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs
autonomous: true

must_haves:
  truths:
    - "Message bus has per-publisher rate limiting to prevent flooding DoS"
    - "IAuthenticatedMessageBus has at least one implementation with HMAC signing"
    - "Topic names are validated against injection patterns"
    - "Federated message bus authenticates remote messages"
  artifacts:
    - path: "DataWarehouse.Kernel/Messaging/MessageBus.cs"
      provides: "Rate-limited message bus with topic validation"
      contains: "RateLimit|_rateLimiter"
    - path: "DataWarehouse.SDK/Contracts/IMessageBus.cs"
      provides: "IAuthenticatedMessageBus interface"
  key_links:
    - from: "MessageBus.cs"
      to: "Rate limiter"
      via: "Check rate before dispatching"
      pattern: "_rateLimiter|RateLimit|TryAcquire"
---

<objective>
Harden the message bus: rate limiting, message authentication, topic validation, and federated bus security.

Purpose: Resolves BUS-02 (CVSS 8.4 -- no message authentication), BUS-03 (CVSS 7.1 -- no rate limiting/DoS), BUS-04 (CVSS 6.8 -- federated bus no auth), BUS-06 (CVSS 4.3 -- topic name injection). Depends on Plan 01 (access enforcement must be wired first).

Output: Message bus has rate limiting, HMAC authentication for security topics, topic name validation, and federated message authentication.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/47-penetration-testing/47-v4.5-PENTEST-REPORT.md
@.planning/phases/47-penetration-testing/v4.5-03-BUS-FINDINGS.md
@.planning/phases/53-security-wiring/53-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rate limiting and topic validation to DefaultMessageBus</name>
  <files>DataWarehouse.Kernel/Messaging/MessageBus.cs, DataWarehouse.Kernel/Messaging/AdvancedMessageBus.cs</files>
  <action>
  **BUS-03: Message bus flooding DoS (CVSS 7.1)**

  In MessageBus.cs, add per-publisher rate limiting to `PublishAsync` (line ~34-59):
  1. Add a `ConcurrentDictionary<string, RateLimiter>` keyed by publisher identity (or plugin name)
  2. Use `System.Threading.RateLimiting.TokenBucketRateLimiter` (or sliding window):
     - Default: 1000 messages/second per publisher (configurable)
     - Burst: 100 messages
  3. Before dispatching, check rate limiter:
     ```csharp
     var publisherId = message.Identity?.Name ?? "anonymous";
     var limiter = _rateLimiters.GetOrAdd(publisherId, _ => new TokenBucketRateLimiter(new TokenBucketRateLimiterOptions
     {
         TokenLimit = 100,
         ReplenishmentPeriod = TimeSpan.FromSeconds(1),
         TokensPerPeriod = 1000,
         QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
         QueueLimit = 0
     }));
     using var lease = await limiter.AcquireAsync(1, ct);
     if (!lease.IsAcquired)
     {
         _logger?.LogWarning("Rate limit exceeded for publisher {Publisher} on topic {Topic}", publisherId, topic);
         throw new InvalidOperationException($"Rate limit exceeded for publisher {publisherId}");
     }
     ```
  4. Also fix the fire-and-forget `Task.Run` pattern at line ~47 -- exceptions in handlers should be caught and logged, not silently swallowed

  NOTE: Check if `System.Threading.RateLimiting` NuGet package is already referenced. If not, add it to the Kernel project. It's a Microsoft package, no supply chain risk.

  **BUS-06: Topic name injection (CVSS 4.3)**

  In MessageBus.cs, add topic name validation in `PublishAsync` and `SubscribeAsync`:
  1. Topic names must match pattern: `^[a-zA-Z0-9][a-zA-Z0-9._-]{0,255}$`
  2. Reject topics containing: `..`, control characters, whitespace, `*` (except in SubscribePattern), `/`, `\`
  3. This prevents namespace pollution and path-based injection

  Apply the same rate limiting and topic validation to AdvancedMessageBus.cs if it has its own publish/subscribe methods.
  </action>
  <verify>
  - `dotnet build DataWarehouse.Kernel/DataWarehouse.Kernel.csproj` succeeds
  - `grep -rn "RateLimit\|_rateLimiter" DataWarehouse.Kernel/Messaging/MessageBus.cs` returns matches
  - `grep -rn "TopicValidat\|ValidateTopic\|Regex" DataWarehouse.Kernel/Messaging/MessageBus.cs` returns matches
  - Full solution builds with 0 errors
  </verify>
  <done>
  - BUS-03 (CVSS 7.1) RESOLVED: Per-publisher rate limiting on message bus
  - BUS-06 (CVSS 4.3) RESOLVED: Topic name validation prevents injection
  - Fire-and-forget Task.Run properly handles exceptions
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IAuthenticatedMessageBus and secure federated bus</name>
  <files>
    DataWarehouse.SDK/Contracts/IMessageBus.cs,
    DataWarehouse.Kernel/Messaging/MessageBus.cs,
    DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs
  </files>
  <action>
  **BUS-02: No message authentication (CVSS 8.4)**

  The SDK defines IAuthenticatedMessageBus with HMAC-SHA256 signing, but zero implementations exist.

  1. Read IAuthenticatedMessageBus interface in IMessageBus.cs (line ~450) to understand the contract
  2. Create an implementation `AuthenticatedMessageBusDecorator` that wraps any IMessageBus:
     - On Publish: compute HMAC-SHA256 of (topic + serialized payload + nonce + timestamp) using a signing key
     - Set `message.Signature`, `message.Nonce`, `message.ExpiresAt` fields on PluginMessage
     - On Subscribe: verify HMAC before delivering to handler, reject expired/replayed messages
     - Keep a nonce cache (bounded, time-windowed) to detect replays
  3. Wire this decorator for security-sensitive topics: `security.*`, `kernel.*`, `compliance.*`
     - For high-throughput topics (storage.*, pipeline.*), authentication is optional (configurable) since the access enforcer handles authorization
  4. The signing key should come from configuration or the kernel's key management

  **BUS-04: Federated message bus no remote authentication (CVSS 6.8)**

  In FederatedMessageBusBase.cs (line ~59-106):
  1. Add authentication for remote messages arriving from other federation nodes
  2. Remote messages must include an HMAC computed with the federation shared secret
  3. Reject remote messages without valid authentication
  4. Add a `FederationSecret` configuration option
  5. When FederationSecret is configured, all outgoing cross-node messages include HMAC
  6. When not configured, log a warning and operate in insecure mode (backward compatibility)
  </action>
  <verify>
  - `dotnet build` full solution with 0 errors
  - `grep -rn "AuthenticatedMessageBus\|IAuthenticatedMessageBus" DataWarehouse.Kernel/` returns matches
  - `grep -rn "FederationSecret\|hmac\|HMAC" DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs` returns matches
  </verify>
  <done>
  - BUS-02 (CVSS 8.4) RESOLVED: IAuthenticatedMessageBus implemented for security topics
  - BUS-04 (CVSS 6.8) RESOLVED: Federated bus authenticates remote messages
  - Message replay/tampering/spoofing prevented via nonce + HMAC + expiry
  - Solution builds with 0 errors
  </done>
</task>

</tasks>

<verification>
- Full solution builds with 0 errors
- Message bus has rate limiting
- Security topics have HMAC authentication
- Federated bus authenticates remote messages
- Topic names are validated
</verification>

<success_criteria>
- BUS-02, BUS-03, BUS-04, BUS-06 all RESOLVED
- DoS via message flooding prevented
- Message authentication available for sensitive topics
- Cross-node messages authenticated
</success_criteria>

<output>
After completion, create `.planning/phases/53-security-wiring/53-06-SUMMARY.md`
</output>
