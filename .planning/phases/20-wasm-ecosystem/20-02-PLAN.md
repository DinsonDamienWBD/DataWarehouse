---
phase: 20-wasm-ecosystem
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/PythonWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/RubyWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/JavaScriptWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/TypeScriptWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/KotlinWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/SwiftWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/JavaWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/DartWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/PhpWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/LuaWasmLanguageStrategy.cs
autonomous: true
must_haves:
  truths:
    - "All 10 Tier 2A language strategies exist and compile"
    - "Interpreted languages (Python, Ruby, JS, PHP, Lua) correctly document interpreter-in-WASM approach"
    - "Each strategy has real compilation metadata and accurate WASI support levels"
    - "Registry auto-discovers all 10 strategies"
    - "Build passes with zero new errors"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/PythonWasmLanguageStrategy.cs"
      provides: "Python WASM language verification strategy"
      contains: "class PythonWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/JavaScriptWasmLanguageStrategy.cs"
      provides: "JavaScript WASM language verification strategy"
      contains: "class JavaScriptWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/KotlinWasmLanguageStrategy.cs"
      provides: "Kotlin WASM language verification strategy"
      contains: "class KotlinWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/DartWasmLanguageStrategy.cs"
      provides: "Dart WASM language verification strategy"
      contains: "class DartWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/LuaWasmLanguageStrategy.cs"
      provides: "Lua WASM language verification strategy"
      contains: "class LuaWasmLanguageStrategy"
  key_links:
    - from: "Strategies/WasmLanguages/Tier2/*.cs"
      to: "Strategies/WasmLanguages/WasmLanguageStrategyBase.cs"
      via: "class inheritance"
      pattern: ": WasmLanguageStrategyBase"
    - from: "ComputeRuntimeStrategyRegistry.cs"
      to: "Strategies/WasmLanguages/Tier2/*.cs"
      via: "assembly scanning auto-discovery"
      pattern: "DiscoverStrategies"
---

<objective>
Implement 10 Tier 2A WASM language strategies covering interpreted and compiled languages with usable WASM support: Python, Ruby, JavaScript, TypeScript, Kotlin, Swift, Java, Dart, PHP, Lua.

Purpose: Tier 2 languages have varying levels of WASM maturity. Interpreted languages (Python, Ruby, JS, PHP, Lua) use an interpreter-in-WASM approach with larger binaries and slower startup. Compiled languages (Kotlin, Swift, Java/TeaVM, Dart) have native or near-native WASM compilation paths.
Output: 10 Tier 2A strategy classes auto-discovered by the registry with accurate language metadata.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-wasm-ecosystem/20-RESEARCH.md
@.planning/phases/20-wasm-ecosystem/20-01-SUMMARY.md

Key existing files to reference:
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Interpreted Language Strategies (Python, Ruby, JS, PHP, Lua)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/PythonWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/RubyWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/JavaScriptWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/PhpWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/LuaWasmLanguageStrategy.cs
  </files>
  <action>
Create 5 strategy files in `Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/`. Namespace: `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages.Tier2`. Each is `internal sealed class : WasmLanguageStrategyBase`.

CRITICAL: These are interpreter-in-WASM languages (see research pitfall #4). The approach is: compile the language interpreter (CPython, CRuby, QuickJS, Zend, Lua VM) to WASM, then the interpreter runs source code. This means larger binaries, slower startup, and limited stdlib. Document this accurately in each strategy's Notes and BinarySize.

**PythonWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.python"`
- StrategyName: `"Python WASM Language"`
- LanguageInfo: Language="Python", LanguageVersion="3.11+ (CPython)", WasmTarget="wasm32-wasi", Toolchain="pip install componentize-py (WASI P2 components) | Pyodide (browser) | py2wasm", CompileCommand="componentize-py -d wit/world.wit -w my-world componentize app -o output.wasm", WasiSupport=Partial (Preview 1), ComponentModelSupport=false, BinarySize=Large, PerformanceTier=Slow, Notes="Interpreter-in-WASM approach: CPython compiled to WASM runs .py source. 10-30MB binaries. componentize-py for WASI Preview 2 components. Limited stdlib (no threading, no subprocess). Cold start 1-5s."

**RubyWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.ruby"`
- StrategyName: `"Ruby WASM Language"`
- LanguageInfo: Language="Ruby", LanguageVersion="3.2+ (CRuby)", WasmTarget="wasm32-wasi", Toolchain="ruby.wasm project (CRuby compiled via WASI SDK)", CompileCommand="Download pre-built ruby.wasm from ruby/ruby.wasm releases; bundle as interpreter + script", WasiSupport=Partial (Preview 1), ComponentModelSupport=false, BinarySize=Large, PerformanceTier=Slow, Notes="Interpreter-in-WASM: CRuby compiled to WASM. 15-30MB binaries. Limited gem support. Uses ruby.wasm project from ruby/ruby.wasm GitHub."

**JavaScriptWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.javascript"`
- StrategyName: `"JavaScript WASM Language"`
- LanguageInfo: Language="JavaScript", LanguageVersion="ES2023 (QuickJS)", WasmTarget="wasm32-wasi", Toolchain="Javy (Bytecode Alliance) - compiles JS to QuickJS bytecode in WASM", CompileCommand="javy compile input.js -o output.wasm", WasiSupport=Partial (Preview 1), ComponentModelSupport=false, BinarySize=Medium, PerformanceTier=Interpreted, Notes="QuickJS engine compiled to WASM via Javy (Bytecode Alliance). 2-5MB binaries. Server-side JS execution in WASM sandbox. No Node.js APIs - pure ES2023."

**PhpWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.php"`
- StrategyName: `"PHP WASM Language"`
- LanguageInfo: Language="PHP", LanguageVersion="8.2+ (Zend Engine)", WasmTarget="wasm32-wasi", Toolchain="php-wasm project (Zend engine compiled to WASM)", CompileCommand="Build php-wasm from source or use pre-compiled php-wasm binary + script bundling", WasiSupport=Partial, ComponentModelSupport=false, BinarySize=Large, PerformanceTier=Slow, Notes="Interpreter-in-WASM: Zend engine compiled to WASM. 15-30MB binaries. Limited extension support. Community-maintained php-wasm project."

**LuaWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.lua"`
- StrategyName: `"Lua WASM Language"`
- LanguageInfo: Language="Lua", LanguageVersion="5.4", WasmTarget="wasm32-wasi", Toolchain="Compile Lua interpreter with WASI SDK or use wasmoon/wasm_lua", CompileCommand="$WASI_SDK_PATH/bin/clang --sysroot=$WASI_SDK_PATH/share/wasi-sysroot -o lua.wasm lua_sources/*.c", WasiSupport=Partial (Preview 1), ComponentModelSupport=false, BinarySize=Small, PerformanceTier=Interpreted, Notes="Lightweight interpreter-in-WASM. 500KB-3MB binaries (much smaller than Python/Ruby). Lua's minimal runtime is well-suited for WASM. Nelua (compiled Lua subset) can also target WASM directly."

Each strategy must:
- Override `GetSampleWasmBytes()` returning a minimal valid WASM module (can reuse same minimal bytes as Tier 1)
- Have full XML doc comments
- Be `internal sealed class`
- Accurately reflect the interpreter-in-WASM model in Notes
  </action>
  <verify>
`dotnet build` passes. All 5 files exist in `Strategies/WasmLanguages/Tier2/`. Each has unique StrategyId. All notes mention interpreter-in-WASM where applicable.
  </verify>
  <done>
5 interpreted-language WASM strategies compile with accurate documentation of the interpreter-in-WASM approach, including realistic binary sizes, toolchain references, and performance expectations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Compiled Language Strategies (TypeScript, Kotlin, Swift, Java, Dart)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/TypeScriptWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/KotlinWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/SwiftWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/JavaWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/DartWasmLanguageStrategy.cs
  </files>
  <action>
Create 5 strategy files in `Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/`. Namespace: `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages.Tier2`. Each is `internal sealed class : WasmLanguageStrategyBase`.

**TypeScriptWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.typescript"`
- StrategyName: `"TypeScript WASM Language"`
- LanguageInfo: Language="TypeScript", LanguageVersion="5.0+", WasmTarget="Varies (AssemblyScript path or QuickJS path)", Toolchain="Path 1: AssemblyScript (asc) for native WASM; Path 2: Javy for QuickJS-in-WASM", CompileCommand="Path 1 (native): npx asc entry.ts -o output.wasm --optimize; Path 2 (interpreted): tsc entry.ts && javy compile entry.js -o output.wasm", WasiSupport=Partial (QuickJS path only; AS path has None), ComponentModelSupport=false, BinarySize=Medium (varies by path), PerformanceTier=NearNative (AS) / Interpreted (QuickJS), Notes="Two paths: AssemblyScript compiles TS-subset to native WASM (tiny, fast, no WASI) or compile via tsc+Javy for full TS with QuickJS (larger, slower, WASI). Choose based on WASI requirement."

**KotlinWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.kotlin"`
- StrategyName: `"Kotlin WASM Language"`
- LanguageInfo: Language="Kotlin", LanguageVersion="1.9+ (Kotlin/Wasm)", WasmTarget="wasm32", Toolchain="Kotlin compiler with Wasm target (official JetBrains)", CompileCommand="kotlin-wasm compiler target or Gradle: kotlin { wasm { ... } }", WasiSupport=Partial, ComponentModelSupport=false, BinarySize=Medium, PerformanceTier=NearNative, Notes="Official Kotlin/Wasm target from JetBrains (2023+). Currently targets wasm-gc proposal. 5-15MB binaries. Evolving rapidly. WASI support is partial and experimental."

**SwiftWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.swift"`
- StrategyName: `"Swift WASM Language"`
- LanguageInfo: Language="Swift", LanguageVersion="5.9+ (SwiftWasm)", WasmTarget="wasm32-wasi", Toolchain="SwiftWasm toolchain (community fork)", CompileCommand="swiftc -target wasm32-unknown-wasi source.swift -o output.wasm", WasiSupport=Partial (Preview 1), ComponentModelSupport=false, BinarySize=Large, PerformanceTier=NearNative, Notes="Community-maintained SwiftWasm fork. 10-30MB binaries due to Swift runtime. WASI Preview 1 support. Not official Apple toolchain. Active development."

**JavaWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.java"`
- StrategyName: `"Java WASM Language"`
- LanguageInfo: Language="Java", LanguageVersion="17+ (via TeaVM)", WasmTarget="wasm32", Toolchain="TeaVM compiler (bytecode to WASM transpiler)", CompileCommand="java -jar teavm-cli.jar --target wasm -d output/ MyClass.class", WasiSupport=Partial, ComponentModelSupport=false, BinarySize=Medium, PerformanceTier=NearNative, Notes="TeaVM transpiles JVM bytecode to WASM. 5-20MB binaries. Not full JVM -- limited reflection, no dynamic class loading. j2wasm (Google) is an alternative. Kotlin/Wasm is preferred for JVM-family WASM."

**DartWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.dart"`
- StrategyName: `"Dart WASM Language"`
- LanguageInfo: Language="Dart", LanguageVersion="3.0+ (dart2wasm)", WasmTarget="wasm32", Toolchain="Dart SDK (built-in)", CompileCommand="dart compile wasm source.dart -o output.wasm", WasiSupport=Partial (Preview 1), ComponentModelSupport=false, BinarySize=Medium, PerformanceTier=NearNative, Notes="Official dart2wasm compiler in Dart SDK. 3-10MB binaries. Standalone WASM compilation (not just Flutter). GC support via wasm-gc proposal."

Each strategy must:
- Override `GetSampleWasmBytes()` returning minimal valid WASM module bytes
- Have full XML doc comments
- Be `internal sealed class`
- Accurately document the compilation approach and limitations

Run `dotnet build` of the full solution after creating all files.
  </action>
  <verify>
`dotnet build` passes with zero new errors. All 10 Tier 2A strategy files exist in `Strategies/WasmLanguages/Tier2/`. Each has unique StrategyId matching pattern `compute.wasm.lang.*`.
  </verify>
  <done>
10 Tier 2A WASM language strategies compile with complete, accurate language metadata. Interpreted languages document the interpreter-in-WASM approach with realistic binary sizes. Compiled languages document their specific compilation toolchains and WASI support levels. All are auto-discoverable by the registry.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes with zero new errors
2. 10 new files in `Strategies/WasmLanguages/Tier2/`
3. Each strategy has unique StrategyId
4. Python, Ruby, JS, PHP, Lua notes mention "interpreter-in-WASM"
5. No direct plugin references (SDK-only)
6. All classes are `internal sealed`
</verification>

<success_criteria>
- All 10 Tier 2A strategies compile with real language metadata
- Interpreted languages accurately document interpreter-in-WASM approach
- Binary size classifications are realistic (Python/Ruby/PHP = Large, JS = Medium, Lua = Small)
- Registry auto-discovers all strategies
- Build passes with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-wasm-ecosystem/20-02-SUMMARY.md`
</output>
