---
phase: 20-wasm-ecosystem
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageTypes.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/RustWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/CWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/CppWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/DotNetWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/GoWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/AssemblyScriptWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/ZigWasmLanguageStrategy.cs
autonomous: true
must_haves:
  truths:
    - "WasmLanguageStrategyBase provides shared language verification infrastructure"
    - "All 7 Tier 1 language strategies exist and compile"
    - "Each strategy has real compilation metadata, toolchain info, and embedded sample WASM bytes"
    - "Each strategy reports accurate WasiSupportLevel and PerformanceTier"
    - "Registry auto-discovers all 7 Tier 1 strategies"
    - "Build passes with zero new errors"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageStrategyBase.cs"
      provides: "Shared base class extending ComputeRuntimeStrategyBase with WasmLanguageInfo"
      contains: "abstract class WasmLanguageStrategyBase"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageTypes.cs"
      provides: "WasmLanguageInfo record, WasiSupportLevel, WasmBinarySize, PerformanceTier enums"
      contains: "record WasmLanguageInfo"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/RustWasmLanguageStrategy.cs"
      provides: "Rust WASM language verification strategy"
      contains: "class RustWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/CWasmLanguageStrategy.cs"
      provides: "C WASM language verification strategy"
      contains: "class CWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/ZigWasmLanguageStrategy.cs"
      provides: "Zig WASM language verification strategy"
      contains: "class ZigWasmLanguageStrategy"
  key_links:
    - from: "Strategies/WasmLanguages/Tier1/*.cs"
      to: "Strategies/WasmLanguages/WasmLanguageStrategyBase.cs"
      via: "class inheritance"
      pattern: ": WasmLanguageStrategyBase"
    - from: "Strategies/WasmLanguages/WasmLanguageStrategyBase.cs"
      to: "ComputeRuntimeStrategyBase.cs"
      via: "class inheritance"
      pattern: ": ComputeRuntimeStrategyBase"
    - from: "ComputeRuntimeStrategyRegistry.cs"
      to: "Strategies/WasmLanguages/Tier1/*.cs"
      via: "assembly scanning auto-discovery"
      pattern: "DiscoverStrategies"
---

<objective>
Create shared WASM language verification infrastructure and implement all 7 Tier 1 language strategies (Rust, C, C++, .NET, Go/TinyGo, AssemblyScript, Zig).

Purpose: Tier 1 languages have production-ready WASM support and are the foundation of the WASM language ecosystem. This plan creates the base types and verifies the highest-confidence language targets.
Output: WasmLanguageStrategyBase, WasmLanguageTypes, and 7 Tier 1 strategy classes auto-discovered by the registry.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-wasm-ecosystem/20-RESEARCH.md

Key existing files to reference:
@Plugins/DataWarehouse.Plugins.UltimateCompute/ComputeRuntimeStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/Wasm/WasmtimeStrategy.cs
@DataWarehouse.SDK/Contracts/Compute/ComputeTypes.cs
@DataWarehouse.SDK/Contracts/Compute/ComputeCapabilities.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WasmLanguageStrategyBase and WasmLanguageTypes</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageTypes.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageStrategyBase.cs
  </files>
  <action>
Create two foundational files in `Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/`:

**WasmLanguageTypes.cs** - Namespace: `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages`

Define these types (all `internal`):

1. `WasmLanguageInfo` record with fields:
   - `string Language` (e.g., "Rust")
   - `string LanguageVersion` (e.g., "1.75+")
   - `string WasmTarget` (e.g., "wasm32-wasi")
   - `string Toolchain` (installation command)
   - `string CompileCommand` (how to compile to .wasm)
   - `WasiSupportLevel WasiSupport`
   - `bool ComponentModelSupport`
   - `WasmBinarySize BinarySize`
   - `PerformanceTier PerformanceTier`
   - `string Notes`

2. `enum WasiSupportLevel { Full, Partial, Experimental, None }`

3. `enum WasmBinarySize { Tiny, Small, Medium, Large, VeryLarge }`

4. `enum PerformanceTier { Native, NearNative, Interpreted, Slow }`

5. `WasmLanguageVerificationResult` record with fields:
   - `string Language`
   - `bool ToolchainAvailable`
   - `bool CompilationSuccessful`
   - `bool ExecutionSuccessful`
   - `string? ActualOutput`
   - `string? ExpectedOutput`
   - `TimeSpan? ExecutionTime`
   - `long? BinarySizeBytes`
   - `string? ErrorMessage`

**WasmLanguageStrategyBase.cs** - Namespace: `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages`

Create `internal abstract class WasmLanguageStrategyBase : ComputeRuntimeStrategyBase` with:

- `public override ComputeRuntime Runtime => ComputeRuntime.WASM;`
- `public override IReadOnlyList<ComputeRuntime> SupportedRuntimes => [ComputeRuntime.WASM];`
- `public abstract WasmLanguageInfo LanguageInfo { get; }` - abstract property each language overrides
- `public override ComputeCapabilities Capabilities` - returns capabilities using `new ComputeCapabilities(...)` with values derived from `LanguageInfo` (e.g., SupportedLanguages includes language name, MemoryIsolation = Sandbox, SupportsSandboxing = true, MaxMemoryBytes = 2GB, MaxExecutionTime = 5 min, SupportsPrecompilation = true)
- `protected abstract ReadOnlySpan<byte> GetSampleWasmBytes()` - returns embedded minimal WASM module bytes for this language. The WASM bytes represent a minimal valid WASM module (magic number 0x00 0x61 0x73 0x6D + version 0x01 0x00 0x00 0x00 + minimal function that sums an array or returns a constant). Each language strategy provides language-specific compiled bytes.
- `protected virtual string ExpectedSampleOutput => ""` - what the sample function should output
- Override `ExecuteAsync` using the existing pattern from `WasmtimeStrategy.cs`: call `ValidateTask`, wrap in `MeasureExecutionAsync`, write task.Code bytes to temp .wasm file, invoke `wasmtime run --wasi` via `RunProcessAsync`, return stdout as output. If `task.Code` is empty/default, use `GetSampleWasmBytes()` instead.
- Override `InitializeAsync` to check `wasmtime --version` via `IsToolAvailableAsync`.
- Add method `public async Task<WasmLanguageVerificationResult> VerifyLanguageAsync(CancellationToken ct)` that: creates a ComputeTask with the sample WASM bytes, executes it, and returns a `WasmLanguageVerificationResult` comparing actual vs expected output.

Use `using` directives for: `System.Text`, `DataWarehouse.SDK.Contracts.Compute`.
  </action>
  <verify>
Files exist at the specified paths. `dotnet build` of the UltimateCompute project passes.
  </verify>
  <done>
WasmLanguageStrategyBase and all supporting types compile. Base class provides shared execution logic delegating to wasmtime CLI. Each subclass only needs to provide LanguageInfo, StrategyId/Name, and sample WASM bytes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement 7 Tier 1 WASM Language Strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/RustWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/CWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/CppWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/DotNetWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/GoWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/AssemblyScriptWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/ZigWasmLanguageStrategy.cs
  </files>
  <action>
Create 7 strategy files in `Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/`. All use namespace `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages.Tier1`. Each is `internal sealed class : WasmLanguageStrategyBase`.

Each strategy provides unique StrategyId, StrategyName, LanguageInfo, and sample WASM bytes (as a `static ReadOnlySpan<byte>` property returning a byte array literal of a minimal valid WASM module -- at minimum the 8-byte WASM header `0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00` plus type section, function section, export section for a simple function).

**RustWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.rust"`
- StrategyName: `"Rust WASM Language"`
- LanguageInfo: Language="Rust", LanguageVersion="1.75+", WasmTarget="wasm32-wasi", Toolchain="rustup target add wasm32-wasi", CompileCommand="cargo build --target wasm32-wasi --release", WasiSupport=Full, ComponentModelSupport=true, BinarySize=Small, PerformanceTier=Native, Notes="Best WASM support. Smallest binaries. Full WASI + Component Model via cargo-component."
- Sample WASM: Minimal valid WASM module bytes (pre-compiled from Rust). Embed a ~45-byte minimal WASM module with a single exported `_start` function that returns 0.

**CWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.c"`
- StrategyName: `"C WASM Language"`
- LanguageInfo: Language="C", LanguageVersion="C11/C17", WasmTarget="wasm32-wasi", Toolchain="WASI SDK (wasi-sdk)", CompileCommand="$WASI_SDK_PATH/bin/clang --sysroot=$WASI_SDK_PATH/share/wasi-sysroot -o output.wasm input.c", WasiSupport=Full, ComponentModelSupport=false (via wit-bindgen), BinarySize=Small, PerformanceTier=Native, Notes="Smallest possible binaries. Full WASI via WASI SDK. Emscripten for browser targets."

**CppWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.cpp"`
- StrategyName: `"C++ WASM Language"`
- LanguageInfo: Language="C++", LanguageVersion="C++17/C++20", WasmTarget="wasm32-wasi", Toolchain="WASI SDK (wasi-sdk)", CompileCommand="$WASI_SDK_PATH/bin/clang++ --sysroot=$WASI_SDK_PATH/share/wasi-sysroot -o output.wasm input.cpp", WasiSupport=Full, ComponentModelSupport=false, BinarySize=Medium, PerformanceTier=Native, Notes="Full C++ stdlib support via WASI SDK. Larger binaries than C due to C++ runtime."

**DotNetWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.dotnet"`
- StrategyName: `".NET WASM Language"`
- LanguageInfo: Language=".NET (C#/F#)", LanguageVersion=".NET 8+", WasmTarget="wasm", Toolchain="dotnet workload install wasi-experimental", CompileCommand="dotnet build -c Release -r wasi-wasm", WasiSupport=Full, ComponentModelSupport=false (Emerging), BinarySize=Large, PerformanceTier=NearNative, Notes="Large binaries (5-20MB) due to .NET runtime inclusion. WASI support is experimental workload."

**GoWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.go"`
- StrategyName: `"Go WASM Language"`
- LanguageInfo: Language="Go (TinyGo recommended)", LanguageVersion="TinyGo 0.30+ / Go 1.21+", WasmTarget="wasm32-wasi", Toolchain="TinyGo: brew install tinygo; Std Go: built-in", CompileCommand="tinygo build -target=wasi -o output.wasm main.go (recommended) | GOOS=wasip1 GOARCH=wasm go build -o output.wasm (std, produces 50MB+ binary)", WasiSupport=Full, ComponentModelSupport=false, BinarySize=Medium (TinyGo) / VeryLarge (std Go), PerformanceTier=NearNative, Notes="TinyGo produces 100KB-2MB binaries vs std Go 50MB+. Always prefer TinyGo for WASM targets."

**AssemblyScriptWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.assemblyscript"`
- StrategyName: `"AssemblyScript WASM Language"`
- LanguageInfo: Language="AssemblyScript", LanguageVersion="0.27+", WasmTarget="wasm32 (pure WASM, NOT WASI)", Toolchain="npm install assemblyscript", CompileCommand="npx asc entry.ts -o output.wasm --optimize", WasiSupport=None, ComponentModelSupport=false, BinarySize=Tiny, PerformanceTier=NearNative, Notes="WASM-native language with TypeScript-like syntax. Does NOT support WASI (dropped support). Uses env imports for host interaction. Produces smallest possible binaries (1KB-200KB)."
- IMPORTANT: WasiSupport must be `WasiSupportLevel.None` per research pitfall #2.

**ZigWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.zig"`
- StrategyName: `"Zig WASM Language"`
- LanguageInfo: Language="Zig", LanguageVersion="0.12+", WasmTarget="wasm32-wasi", Toolchain="Download from ziglang.org", CompileCommand="zig build-exe -target wasm32-wasi -O ReleaseSmall source.zig", WasiSupport=Full, ComponentModelSupport=false (via wit-bindgen), BinarySize=Small, PerformanceTier=Native, Notes="No libc required. Produces very small binaries (10KB-1MB). Excellent WASI support."

For each strategy:
- Use XML doc comments on the class describing the language and its WASM support level
- Override `GetSampleWasmBytes()` returning a `ReadOnlySpan<byte>` from a `static readonly byte[]` field containing minimal valid WASM module bytes. All strategies can share the same minimal WASM module bytes (the 8-byte header + a minimal type section + function section + export section for `_start`), since the purpose is verification that the execution pipeline works for the language's output format. A minimal valid WASI module is approximately 30-50 bytes.
- All classes: `internal sealed class`, no direct plugin references, SDK-only using directives

Run `dotnet build` of the full solution after creating all files to verify compilation.
  </action>
  <verify>
`dotnet build` passes with zero new errors. All 7 Tier 1 strategy files exist in `Strategies/WasmLanguages/Tier1/`. Each has unique StrategyId. `grep -r "WasmLanguageStrategyBase" Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier1/` returns 7 matches.
  </verify>
  <done>
7 Tier 1 WASM language strategies compile and are auto-discoverable by the ComputeRuntimeStrategyRegistry. Each has production-ready language metadata (toolchain, compile command, WASI level, binary size, performance tier) and embedded sample WASM bytes. AssemblyScript correctly reports WasiSupportLevel.None. Go strategy documents TinyGo recommendation.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes with zero new errors
2. Total of 9 new files created (2 base + 7 Tier 1 strategies)
3. Each strategy has unique StrategyId matching pattern `compute.wasm.lang.*`
4. No direct plugin references (SDK-only)
5. All classes are `internal sealed` (except abstract base)
6. WasmLanguageInfo records have real compilation commands, not placeholders
7. AssemblyScript WasiSupport is None (not Full or Partial)
</verification>

<success_criteria>
- WasmLanguageStrategyBase provides shared execution pipeline via wasmtime CLI
- All 7 Tier 1 strategies compile with complete language metadata
- Registry auto-discovers all strategies via assembly scanning
- Build passes with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-wasm-ecosystem/20-01-SUMMARY.md`
</output>
