---
phase: 20-wasm-ecosystem
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/HaskellWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/OCamlWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/GrainWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/MoonBitWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/NimWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/VWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/CrystalWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/PerlWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/RWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/FortranWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/ScalaWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/ElixirWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/PrologWasmLanguageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/AdaWasmLanguageStrategy.cs
autonomous: true
must_haves:
  truths:
    - "4 remaining Tier 2B strategies (Haskell, OCaml, Grain, MoonBit) exist and compile"
    - "10 Tier 3 strategies exist and compile with accurate experimental/unstable status"
    - "Grain and MoonBit report WasiSupportLevel.Full (WASM-native languages)"
    - "All Tier 3 strategies report WasiSupportLevel.Experimental or None"
    - "Each strategy has honest feasibility assessment in Notes"
    - "Registry auto-discovers all 14 strategies"
    - "Build passes with zero new errors"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/GrainWasmLanguageStrategy.cs"
      provides: "Grain WASM-native language verification strategy"
      contains: "class GrainWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/MoonBitWasmLanguageStrategy.cs"
      provides: "MoonBit WASM-native language verification strategy"
      contains: "class MoonBitWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/NimWasmLanguageStrategy.cs"
      provides: "Nim experimental WASM language verification strategy"
      contains: "class NimWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/ElixirWasmLanguageStrategy.cs"
      provides: "Elixir experimental WASM language verification strategy"
      contains: "class ElixirWasmLanguageStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/AdaWasmLanguageStrategy.cs"
      provides: "Ada experimental WASM language verification strategy"
      contains: "class AdaWasmLanguageStrategy"
  key_links:
    - from: "Strategies/WasmLanguages/Tier2/*.cs"
      to: "Strategies/WasmLanguages/WasmLanguageStrategyBase.cs"
      via: "class inheritance"
      pattern: ": WasmLanguageStrategyBase"
    - from: "Strategies/WasmLanguages/Tier3/*.cs"
      to: "Strategies/WasmLanguages/WasmLanguageStrategyBase.cs"
      via: "class inheritance"
      pattern: ": WasmLanguageStrategyBase"
---

<objective>
Implement 4 remaining Tier 2B language strategies (Haskell, OCaml, Grain, MoonBit) and all 10 Tier 3 experimental language strategies (Nim, V, Crystal, Perl, R, Fortran, Scala, Elixir, Prolog, Ada).

Purpose: Completes the 30+ language ecosystem coverage. Tier 2B includes WASM-native languages (Grain, MoonBit) and emerging functional language support (Haskell, OCaml). Tier 3 covers experimental/unstable WASM targets where honest feasibility reporting is more important than execution success.
Output: 14 strategy classes (4 Tier 2B + 10 Tier 3) auto-discovered by the registry.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-wasm-ecosystem/20-RESEARCH.md
@.planning/phases/20-wasm-ecosystem/20-01-SUMMARY.md

Key existing files to reference:
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Tier 2B Strategies (Haskell, OCaml, Grain, MoonBit)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/HaskellWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/OCamlWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/GrainWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/MoonBitWasmLanguageStrategy.cs
  </files>
  <action>
Create 4 strategy files in `Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier2/`. Namespace: `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages.Tier2`. Each is `internal sealed class : WasmLanguageStrategyBase`.

**HaskellWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.haskell"`
- StrategyName: `"Haskell WASM Language"`
- LanguageInfo: Language="Haskell", LanguageVersion="GHC 9.10+", WasmTarget="wasm32-wasi", Toolchain="GHC WASM backend (ghc-wasm-meta)", CompileCommand="wasm32-wasi-ghc -o output.wasm Main.hs", WasiSupport=Experimental, ComponentModelSupport=false, BinarySize=Large, PerformanceTier=NearNative, Notes="GHC WASM backend in active development (GHC 9.10+). 10-50MB binaries due to Haskell runtime. Requires custom GHC build with WASM backend. Lazy evaluation works but GC is heap-intensive in WASM linear memory."

**OCamlWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.ocaml"`
- StrategyName: `"OCaml WASM Language"`
- LanguageInfo: Language="OCaml", LanguageVersion="5.0+ (wasocaml)", WasmTarget="wasm32", Toolchain="wasocaml (OCaml to WASM compiler fork)", CompileCommand="wasocaml source.ml -o output.wasm", WasiSupport=Experimental, ComponentModelSupport=false, BinarySize=Medium, PerformanceTier=NearNative, Notes="wasocaml is an active OCaml-to-WASM compiler. 5-15MB binaries. Emerging support. Alternative: wasm_of_ocaml (JS-in-WASM path). OCaml 5.0 multicore not available in WASM builds."

**GrainWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.grain"`
- StrategyName: `"Grain WASM Language"`
- LanguageInfo: Language="Grain", LanguageVersion="0.6+", WasmTarget="wasm32-wasi", Toolchain="Grain compiler (grain-lang.org)", CompileCommand="grain compile source.gr -o output.wasm", WasiSupport=Full, ComponentModelSupport=false, BinarySize=Small, PerformanceTier=NearNative, Notes="Designed from the ground up for WebAssembly. Small binaries (50KB-1MB). Full WASI support. Functional language with pattern matching, algebraic data types. Excellent WASM integration."

**MoonBitWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.moonbit"`
- StrategyName: `"MoonBit WASM Language"`
- LanguageInfo: Language="MoonBit", LanguageVersion="2024+", WasmTarget="wasm32", Toolchain="MoonBit toolchain (moonbitlang.com)", CompileCommand="moon build --target wasm", WasiSupport=Full, ComponentModelSupport=false, BinarySize=Tiny, PerformanceTier=Native, Notes="WASM-native language producing industry-leading compact binaries (1KB-100KB). Designed specifically for WASM with Rust-like type system. Static typing, pattern matching, GC via wasm-gc. Smallest WASM output of any high-level language."

Each strategy must:
- Override `GetSampleWasmBytes()` returning minimal valid WASM module bytes
- Have full XML doc comments
- Be `internal sealed class`
- Grain and MoonBit must have WasiSupportLevel.Full (WASM-native languages)
- Haskell and OCaml must have WasiSupportLevel.Experimental
  </action>
  <verify>
`dotnet build` passes. 4 files exist in `Strategies/WasmLanguages/Tier2/`. Grain and MoonBit have WasiSupportLevel.Full. Haskell and OCaml have WasiSupportLevel.Experimental.
  </verify>
  <done>
4 Tier 2B strategies compile with accurate language metadata. WASM-native languages (Grain, MoonBit) correctly report Full WASI support and small/tiny binary sizes. Experimental languages (Haskell, OCaml) honestly report their emerging status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement 10 Tier 3 Experimental Language Strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/NimWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/VWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/CrystalWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/PerlWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/RWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/FortranWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/ScalaWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/ElixirWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/PrologWasmLanguageStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/AdaWasmLanguageStrategy.cs
  </files>
  <action>
Create 10 strategy files in `Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/Tier3/`. Namespace: `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages.Tier3`. Each is `internal sealed class : WasmLanguageStrategyBase`.

CRITICAL: Tier 3 languages have experimental/unstable WASM support (see research pitfall #1). Each strategy must honestly report WasiSupportLevel.Experimental or WasiSupportLevel.None and document specific limitations. Do NOT overstate readiness. These are real feasibility assessments, not aspirational stubs.

**NimWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.nim"`, StrategyName: `"Nim WASM Language"`
- Language="Nim", LanguageVersion="2.0+", WasmTarget="wasm32", Toolchain="nlvm (LLVM-based Nim compiler) with wasm32 target", CompileCommand="nlvm c --cpu:wasm32 --os:standalone source.nim", WasiSupport=Experimental, BinarySize=Medium, PerformanceTier=NearNative, Notes="LLVM backend exists but WASM target is work-in-progress. Nim can also compile to C then use WASI SDK (indirect path). nlvm compiler needed for direct WASM. Medium feasibility."

**VWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.v"`, StrategyName: `"V WASM Language"`
- Language="V (Vlang)", LanguageVersion="0.4+", WasmTarget="wasm32 (via C backend + Emscripten)", Toolchain="V compiler + Emscripten", CompileCommand="v -o output.c source.v && emcc output.c -o output.wasm", WasiSupport=Experimental, BinarySize=Medium, PerformanceTier=NearNative, Notes="Indirect path: V compiles to C, then Emscripten/WASI SDK compiles C to WASM. Unstable. No direct WASM backend. Medium feasibility via C intermediary."

**CrystalWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.crystal"`, StrategyName: `"Crystal WASM Language"`
- Language="Crystal", LanguageVersion="1.10+", WasmTarget="wasm32 (POC)", Toolchain="Crystal compiler LLVM backend (POC PR)", CompileCommand="crystal build --target wasm32-unknown-wasi source.cr (POC only)", WasiSupport=Experimental, BinarySize=Large, PerformanceTier=NearNative, Notes="POC proof-of-concept PR exists in Crystal main repo. Not merged to stable. LLVM-based compiler could theoretically target WASM but runtime/GC are not WASM-ready. Low feasibility."

**PerlWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.perl"`, StrategyName: `"Perl WASM Language"`
- Language="Perl", LanguageVersion="5.36+", WasmTarget="wasm32 (interpreter-in-WASM)", Toolchain="webperl project (Perl interpreter compiled to WASM via Emscripten)", CompileCommand="Use pre-built webperl.wasm or compile Perl source with Emscripten", WasiSupport=None, BinarySize=Large, PerformanceTier=Slow, Notes="Interpreter-in-WASM via webperl project. Limited maintenance. Large binaries. WASI not supported (Emscripten target only). Low feasibility for production use."

**RWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.r"`, StrategyName: `"R WASM Language"`
- Language="R", LanguageVersion="4.3+", WasmTarget="wasm32 (interpreter-in-WASM)", Toolchain="webR project (R interpreter compiled to WASM)", CompileCommand="Use webR distribution (pre-compiled R + flang-wasm for Fortran libs)", WasiSupport=Experimental, BinarySize=VeryLarge, PerformanceTier=Slow, Notes="webR project actively maintained by Posit (RStudio). Large binaries (50MB+) due to R runtime + math libs. Fortran dependencies via flang-wasm. Useful for statistical compute-on-data but heavy. Medium feasibility."

**FortranWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.fortran"`, StrategyName: `"Fortran WASM Language"`
- Language="Fortran", LanguageVersion="F90/F95", WasmTarget="wasm32", Toolchain="flang-wasm (LLVM flang compiled for WASM)", CompileCommand="flang-wasm source.f90 -o output.wasm", WasiSupport=Experimental, BinarySize=Large, PerformanceTier=NearNative, Notes="flang-wasm exists but missing many runtime libraries. Primarily used by webR for R's Fortran dependencies. Standalone Fortran-to-WASM is experimental. Medium feasibility for numerical code."

**ScalaWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.scala"`, StrategyName: `"Scala WASM Language"`
- Language="Scala", LanguageVersion="3.x", WasmTarget="wasm32 (indirect via Scala.js or TeaVM)", Toolchain="TeaVM (JVM bytecode to WASM) or Scala.js + Javy", CompileCommand="scalac to .class files then java -jar teavm-cli.jar --target wasm (TeaVM path)", WasiSupport=Experimental, BinarySize=Large, PerformanceTier=NearNative, Notes="No direct Scala-to-WASM compiler. Indirect paths: (1) Scala bytecode via TeaVM to WASM, (2) Scala.js to JS then Javy to WASM. Both add overhead. Medium feasibility."

**ElixirWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.elixir"`, StrategyName: `"Elixir WASM Language"`
- Language="Elixir/Erlang", LanguageVersion="1.15+ / OTP 26+", WasmTarget="wasm32 (experimental)", Toolchain="Orb (Elixir DSL for WASM) or Lumen (BEAM to WASM, unmaintained)", CompileCommand="Orb: DSL generates WASM directly; Lumen: lumen compile source.ex -o output.wasm (unmaintained)", WasiSupport=Experimental, BinarySize=Large, PerformanceTier=Slow, Notes="Lumen (BEAM-to-WASM compiler) is unmaintained. Orb is an Elixir DSL that generates WASM but is not a full Elixir compiler. BEAM VM in WASM is impractical. Low feasibility for general Elixir code."

**PrologWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.prolog"`, StrategyName: `"Prolog WASM Language"`
- Language="Prolog", LanguageVersion="ISO Prolog", WasmTarget="wasm32 (interpreter-in-WASM)", Toolchain="SWI-Prolog WASM port or Ciao Prolog WASM", CompileCommand="Use pre-compiled SWI-Prolog WASM distribution or Ciao WASM build", WasiSupport=Experimental, BinarySize=Large, PerformanceTier=Slow, Notes="SWI-Prolog has a WASM port but limited maintenance. Ciao Prolog has experimental WASM support. Interpreter-in-WASM approach. Niche use case for logic programming on data. Low feasibility."

**AdaWasmLanguageStrategy.cs:**
- StrategyId: `"compute.wasm.lang.ada"`, StrategyName: `"Ada WASM Language"`
- Language="Ada", LanguageVersion="Ada 2012+", WasmTarget="wasm32 (via GNAT-LLVM)", Toolchain="adawebpack (GNAT-LLVM to WASM)", CompileCommand="gnatmake via adawebpack + Emscripten", WasiSupport=Experimental, BinarySize=Large, PerformanceTier=NearNative, Notes="adawebpack provides GNAT-LLVM to WASM compilation. Niche but functional. Large binaries due to Ada runtime. Primarily for safety-critical embedded code verification. Low feasibility for general use."

Each strategy must:
- Override `GetSampleWasmBytes()` returning minimal valid WASM module bytes
- Have full XML doc comments including a feasibility summary
- Be `internal sealed class`
- Use WasiSupportLevel.Experimental or None (NEVER Full for Tier 3)
- Document specific known limitations honestly in Notes

Run `dotnet build` of the full solution after creating all files.
  </action>
  <verify>
`dotnet build` passes with zero new errors. 10 files exist in `Strategies/WasmLanguages/Tier3/`. No Tier 3 strategy has WasiSupportLevel.Full. Each Notes field contains honest feasibility assessment.
  </verify>
  <done>
14 strategies (4 Tier 2B + 10 Tier 3) compile with accurate, honest feasibility assessments. WASM-native languages (Grain, MoonBit) correctly report high maturity. Experimental languages report their actual status with documented limitations. No false claims of production readiness for unstable toolchains.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes with zero new errors
2. 4 files in `Strategies/WasmLanguages/Tier2/` (Haskell, OCaml, Grain, MoonBit)
3. 10 files in `Strategies/WasmLanguages/Tier3/`
4. Grain and MoonBit have WasiSupportLevel.Full
5. All Tier 3 strategies have WasiSupportLevel.Experimental or None
6. No direct plugin references (SDK-only)
7. Each strategy has unique StrategyId
</verification>

<success_criteria>
- All 14 strategies compile with complete, honest language metadata
- WASM-native languages report accurate high-maturity status
- Experimental languages do not overstate readiness
- Each Notes field contains specific, actionable feasibility information
- Registry auto-discovers all strategies
- Build passes with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-wasm-ecosystem/20-03-SUMMARY.md`
</output>
