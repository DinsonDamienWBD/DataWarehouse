---
phase: 20-wasm-ecosystem
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageBenchmark.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageEcosystemStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageSdkDocumentation.cs
  - Metadata/TODO.md
autonomous: true
must_haves:
  truths:
    - "WasmLanguageBenchmark provides standardized performance comparison across all languages"
    - "WasmLanguageEcosystemStrategy aggregates all language strategies and reports ecosystem status"
    - "WasmLanguageSdkDocumentation provides DW operation binding documentation per language"
    - "Benchmark measures execution time, memory peak, and binary size"
    - "Ecosystem strategy exposes full language catalog with tier classifications"
    - "Build passes with zero new errors"
    - "TODO.md WASM-related tasks are synced to reflect completion"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageBenchmark.cs"
      provides: "Standardized benchmark framework for WASM language comparison"
      contains: "class WasmLanguageBenchmarkStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageEcosystemStrategy.cs"
      provides: "Aggregated ecosystem strategy with full language catalog"
      contains: "class WasmLanguageEcosystemStrategy"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageSdkDocumentation.cs"
      provides: "SDK binding documentation per language for DW operations"
      contains: "class WasmLanguageSdkDocumentation"
  key_links:
    - from: "WasmLanguageEcosystemStrategy.cs"
      to: "ComputeRuntimeStrategyRegistry.cs"
      via: "queries registry for all wasm.lang.* strategies"
      pattern: "GetAllStrategies"
    - from: "WasmLanguageBenchmark.cs"
      to: "WasmLanguageStrategyBase.cs"
      via: "executes sample WASM via each language strategy"
      pattern: "VerifyLanguageAsync"
---

<objective>
Create the SDK bindings documentation, performance benchmark framework, and ecosystem aggregation strategy. Update TODO.md to reflect Phase 20 completion.

Purpose: This plan delivers the remaining Phase 20 success criteria: language-specific SDK binding documentation (SC #5), performance benchmarks (SC #6), and an ecosystem-level strategy that reports the full language catalog. The ecosystem strategy serves as the "table of contents" for all 31 language strategies.
Output: 3 strategy/utility classes plus TODO.md updates for WASM-related tasks.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-wasm-ecosystem/20-RESEARCH.md
@.planning/phases/20-wasm-ecosystem/20-01-SUMMARY.md

Key existing files to reference:
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageTypes.cs
@Plugins/DataWarehouse.Plugins.UltimateCompute/ComputeRuntimeStrategyRegistry.cs
@Plugins/DataWarehouse.Plugins.UltimateSDKPorts/UltimateSDKPortsPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Benchmark, Ecosystem, and SDK Documentation Strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageBenchmark.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageEcosystemStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/WasmLanguageSdkDocumentation.cs
  </files>
  <action>
Create 3 files in `Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/`. Namespace: `DataWarehouse.Plugins.UltimateCompute.Strategies.WasmLanguages`.

**WasmLanguageBenchmark.cs:**

Create `internal sealed class WasmLanguageBenchmarkStrategy : ComputeRuntimeStrategyBase` with:

- StrategyId: `"compute.wasm.benchmark"`
- StrategyName: `"WASM Language Benchmark"`
- Runtime: `ComputeRuntime.WASM`
- SupportedRuntimes: `[ComputeRuntime.WASM]`
- Capabilities: WASM defaults with SupportedLanguages = ["benchmark"]

This strategy orchestrates benchmarks across all language strategies. Key members:

1. `BenchmarkWorkload` internal record: `(string Name, string Description, byte[] WasmBytes, string ExpectedOutputPattern)`. Standard workload: a minimal WASM module that performs computational work.

2. `BenchmarkResult` internal record: `(string Language, string Tier, TimeSpan ExecutionTime, long PeakMemoryBytes, long BinarySizeBytes, bool Success, string? Error)`

3. Method `public async Task<IReadOnlyList<BenchmarkResult>> RunBenchmarksAsync(IEnumerable<WasmLanguageStrategyBase> strategies, CancellationToken ct)`:
   - For each strategy, create a ComputeTask with the strategy's sample WASM bytes
   - Execute via the strategy's ExecuteAsync
   - Measure execution time (from ComputeResult.ExecutionTime), memory (ComputeResult.MemoryUsed), binary size (sample bytes length)
   - Collect results into BenchmarkResult list
   - Sort by ExecutionTime ascending

4. Method `public string GenerateBenchmarkReport(IReadOnlyList<BenchmarkResult> results)`:
   - Returns a formatted string table comparing all languages:
     ```
     | Language | Tier | Execution (ms) | Memory (KB) | Binary (KB) | Status |
     ```
   - Groups by tier (Tier 1, Tier 2, Tier 3)

5. Override `ExecuteAsync` to: run benchmarks on all discovered WasmLanguageStrategyBase strategies in the current assembly (via reflection to find them), generate report, return report as UTF-8 bytes in ComputeResult.

**WasmLanguageEcosystemStrategy.cs:**

Create `internal sealed class WasmLanguageEcosystemStrategy : ComputeRuntimeStrategyBase` with:

- StrategyId: `"compute.wasm.ecosystem"`
- StrategyName: `"WASM Language Ecosystem"`
- Runtime: `ComputeRuntime.WASM`
- SupportedRuntimes: `[ComputeRuntime.WASM]`
- Capabilities: WASM defaults with SupportedLanguages listing all 31 languages

This is the aggregation strategy -- the "table of contents" for the entire WASM language ecosystem.

1. `EcosystemReport` internal record: `(int TotalLanguages, int Tier1Count, int Tier2Count, int Tier3Count, IReadOnlyList<LanguageSummary> Languages)`
2. `LanguageSummary` internal record: `(string Language, string Tier, WasiSupportLevel WasiSupport, PerformanceTier Performance, WasmBinarySize BinarySize, string CompileCommand, string Notes)`

3. Method `public EcosystemReport GetEcosystemReport()`:
   - Discovers all WasmLanguageStrategyBase subclasses in the current assembly via reflection
   - Instantiates each and reads its LanguageInfo
   - Classifies by folder location: Tier1/ = "Tier 1", Tier2/ = "Tier 2", Tier3/ = "Tier 3" (or by namespace suffix)
   - Returns aggregated report

4. Method `public string GenerateEcosystemSummary()`:
   - Human-readable summary of all 31 languages with: language name, tier, WASI support, performance tier, binary size, compile command
   - Formatted as a markdown table

5. Override `ExecuteAsync` to: generate ecosystem summary, return as UTF-8 bytes in ComputeResult.

**WasmLanguageSdkDocumentation.cs:**

Create `internal sealed class WasmLanguageSdkDocumentation` (NOT a strategy -- a documentation utility class) with:

1. Method `public static string GetBindingDocumentation(string language)`:
   Returns DW SDK binding documentation for the specified language. For each language, document how to call DW operations from WASM:

   - **Standard DW Host Functions** (shared across all languages):
     - `dw_storage_read(key_ptr, key_len, buf_ptr, buf_len) -> i32` -- Read from DW storage
     - `dw_storage_write(key_ptr, key_len, val_ptr, val_len) -> i32` -- Write to DW storage
     - `dw_query(query_ptr, query_len, result_ptr, result_len) -> i32` -- Execute a DW query
     - `dw_transform(input_ptr, input_len, output_ptr, output_len) -> i32` -- Transform data
     - `dw_log(level, msg_ptr, msg_len) -> void` -- Log a message

   These are WASI host function imports that the DW runtime provides. Each language accesses them differently:

   - **Rust**: `extern "C" { fn dw_storage_read(...) -> i32; }` with safe wrapper
   - **C/C++**: `__attribute__((import_module("dw"))) int32_t dw_storage_read(...);`
   - **.NET**: `[DllImport("dw")] static extern int DwStorageRead(...);`
   - **Go (TinyGo)**: `//go:wasmimport dw dw_storage_read` with `//export` annotations
   - **AssemblyScript**: `@external("dw", "dw_storage_read") declare function dwStorageRead(...): i32;`
   - **Python (componentize-py)**: Via WIT interface binding
   - **JavaScript (Javy)**: Via host-provided global objects injected at runtime
   - **Other languages**: Generic WASM import pattern documentation

2. Method `public static string GetAllBindingDocumentation()`:
   Returns combined documentation for all languages in a structured format.

3. Method `public static IReadOnlyDictionary<string, string> GetHostFunctionDefinitions()`:
   Returns the DW host function WIT (WebAssembly Interface Types) definitions as key-value pairs.

All methods return real documentation strings (not placeholders) per Rule 13. The documentation should be accurate for each language's FFI/import mechanism.
  </action>
  <verify>
`dotnet build` passes. All 3 files exist. WasmLanguageBenchmarkStrategy and WasmLanguageEcosystemStrategy have unique StrategyIds. WasmLanguageSdkDocumentation contains real binding code examples for at least Rust, C, .NET, Go, AssemblyScript, Python, JavaScript.
  </verify>
  <done>
Benchmark framework can run standardized workloads across all language strategies. Ecosystem strategy aggregates the full 31-language catalog with tier classifications. SDK documentation provides real, language-specific DW host function binding examples for all major languages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TODO.md and Verify Phase Completion</name>
  <files>
    Metadata/TODO.md
  </files>
  <action>
1. Read `Metadata/TODO.md` and find WASM-related task sections (search for "WASM", "wasm", "WebAssembly", "language ecosystem", "compute-on-data", and any Phase 20 / WASM-01/02/03 requirement markers).

2. For each WASM-related sub-task, update status to `[x]` if the work done in Plans 20-01 through 20-04 covers it. Specifically mark complete:
   - Any task about "WASM language support" or "language verification"
   - Any task about "SDK bindings for WASM languages"
   - Any task about "WASM performance benchmarks"
   - Any task about "compute-on-data language ecosystem"

3. Run `dotnet build` of the full solution to verify the entire phase builds cleanly.

4. Count total language strategies: should be 31 (7 Tier 1 + 14 Tier 2 + 10 Tier 3) plus 2 meta-strategies (benchmark + ecosystem) = 33 new strategies.

5. Verify registry discovery: the ComputeRuntimeStrategyRegistry.DiscoverStrategies() should find all 33 new strategies (in addition to the existing 51 from Phase 8) when scanning the UltimateCompute assembly.

6. Validate no direct plugin references: grep the new `WasmLanguages/` directory for any `using DataWarehouse.Plugins.` that is NOT `DataWarehouse.Plugins.UltimateCompute` (the plugin's own namespace). There should be none -- only SDK references.
  </action>
  <verify>
`dotnet build` passes with zero errors. TODO.md WASM tasks are marked [x]. `grep -r "internal sealed class" Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/WasmLanguages/` returns 33 matches (31 languages + benchmark + ecosystem). No references to other plugins.
  </verify>
  <done>
Phase 20 is complete: 31 WASM language strategies (7 Tier 1, 14 Tier 2, 10 Tier 3) plus benchmark and ecosystem meta-strategies. TODO.md is updated. All 6 ROADMAP success criteria are met: (1) Tier 1 verified, (2) Tier 2 verified, (3) Tier 3 feasibility assessed, (4) sample compute functions via embedded WASM bytes, (5) SDK binding documentation, (6) performance benchmark framework. Build passes with zero new errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes with zero new errors
2. 3 new files in `Strategies/WasmLanguages/` root (benchmark, ecosystem, SDK docs)
3. WasmLanguageBenchmarkStrategy has StrategyId `compute.wasm.benchmark`
4. WasmLanguageEcosystemStrategy has StrategyId `compute.wasm.ecosystem`
5. SDK documentation covers at least 7 languages with real binding examples
6. TODO.md WASM tasks synced to [x]
7. Total new strategy count: 33 (31 languages + 2 meta)
8. No direct references to other plugins

**Phase 20 Success Criteria Validation:**
- SC1: Tier 1 (Rust, C, C++, .NET, Go, AssemblyScript, Zig) -- 7 strategies in Tier1/
- SC2: Tier 2 (Python, Ruby, JS, TS, Kotlin, Swift, Java, Dart, PHP, Lua, Haskell, OCaml, Grain, MoonBit) -- 14 strategies in Tier2/
- SC3: Tier 3 (Nim, V, Crystal, Perl, R, Fortran, Scala, Elixir, Prolog, Ada) -- 10 strategies in Tier3/
- SC4: Sample compute functions -- each strategy has embedded sample WASM bytes
- SC5: SDK bindings documentation -- WasmLanguageSdkDocumentation covers all major languages
- SC6: Performance benchmarks -- WasmLanguageBenchmarkStrategy with standardized workload
</verification>

<success_criteria>
- Benchmark framework runs standardized workloads and generates comparison reports
- Ecosystem strategy aggregates full 31-language catalog
- SDK documentation provides real binding examples for 7+ languages
- TODO.md is updated with all WASM tasks marked complete
- Full solution builds with zero new errors
- All 6 Phase 20 ROADMAP success criteria are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/20-wasm-ecosystem/20-04-SUMMARY.md`
</output>
