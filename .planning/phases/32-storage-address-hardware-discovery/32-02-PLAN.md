---
phase: 32-storage-address-hardware-discovery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Hardware/HardwareDeviceType.cs
  - DataWarehouse.SDK/Hardware/HardwareDevice.cs
  - DataWarehouse.SDK/Hardware/IHardwareProbe.cs
  - DataWarehouse.SDK/Hardware/NullHardwareProbe.cs
  - DataWarehouse.SDK/Hardware/HardwareProbeFactory.cs
  - DataWarehouse.SDK/Hardware/WindowsHardwareProbe.cs
  - DataWarehouse.SDK/Hardware/LinuxHardwareProbe.cs
  - DataWarehouse.SDK/Hardware/MacOsHardwareProbe.cs
autonomous: true

must_haves:
  truths:
    - "IHardwareProbe.DiscoverAsync returns HardwareDevice records for PCI, USB, NVMe, GPU, and bus devices on the current platform"
    - "HardwareProbeFactory.Create() returns the correct platform-specific probe on Windows, Linux, and macOS"
    - "NullHardwareProbe returns empty results on unsupported platforms without throwing"
    - "WindowsHardwareProbe uses WMI (System.Management) for device enumeration"
    - "LinuxHardwareProbe reads /sys/class and /proc for device enumeration"
    - "MacOsHardwareProbe provides IOKit-based stub with NullHardwareProbe fallback for non-critical paths"
    - "All platform-specific code is guarded by OperatingSystem.IsWindows/IsLinux/IsMacOS and SupportedOSPlatform attributes"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/IHardwareProbe.cs"
      provides: "IHardwareProbe interface with DiscoverAsync and event-based hardware change notification"
      min_lines: 30
    - path: "DataWarehouse.SDK/Hardware/HardwareDevice.cs"
      provides: "HardwareDevice record type with device identity, type, properties, and capabilities"
      min_lines: 40
    - path: "DataWarehouse.SDK/Hardware/HardwareDeviceType.cs"
      provides: "Flags enum for device type classification"
      min_lines: 20
    - path: "DataWarehouse.SDK/Hardware/WindowsHardwareProbe.cs"
      provides: "WMI-based hardware discovery for Windows"
      min_lines: 150
    - path: "DataWarehouse.SDK/Hardware/LinuxHardwareProbe.cs"
      provides: "sysfs/procfs-based hardware discovery for Linux"
      min_lines: 150
    - path: "DataWarehouse.SDK/Hardware/MacOsHardwareProbe.cs"
      provides: "IOKit-based hardware discovery for macOS (minimal, delegates to NullHardwareProbe where needed)"
      min_lines: 60
    - path: "DataWarehouse.SDK/Hardware/NullHardwareProbe.cs"
      provides: "Fallback probe returning empty results"
      min_lines: 20
    - path: "DataWarehouse.SDK/Hardware/HardwareProbeFactory.cs"
      provides: "Static factory selecting platform-appropriate probe"
      min_lines: 20
  key_links:
    - from: "HardwareProbeFactory"
      to: "WindowsHardwareProbe"
      via: "OperatingSystem.IsWindows() guard"
      pattern: "OperatingSystem\\.IsWindows\\(\\)"
    - from: "HardwareProbeFactory"
      to: "LinuxHardwareProbe"
      via: "OperatingSystem.IsLinux() guard"
      pattern: "OperatingSystem\\.IsLinux\\(\\)"
    - from: "HardwareProbeFactory"
      to: "NullHardwareProbe"
      via: "fallback for unsupported platforms"
      pattern: "NullHardwareProbe"
    - from: "HardwareDevice"
      to: "HardwareDeviceType"
      via: "Type property discriminates device kind"
      pattern: "HardwareDeviceType"
---

<objective>
Implement IHardwareProbe interface and platform-specific hardware discovery implementations (HAL-02) -- the runtime hardware detection system that discovers PCI devices, USB devices, NVMe namespaces, GPUs, and I2C/SPI/GPIO buses.

Purpose: Hardware discovery is foundational for Phase 32's capability registry (plan 03) and driver loading (plan 04). It enables DataWarehouse to know what hardware the platform offers at runtime, enabling automatic optimization and driver selection. All subsequent hardware phases (35, 36) depend on this probe infrastructure.

Output:
- `IHardwareProbe` interface with DiscoverAsync and OnHardwareChanged event
- `HardwareDevice` record type for device representation
- `HardwareDeviceType` flags enum for classification
- `WindowsHardwareProbe` (WMI/System.Management)
- `LinuxHardwareProbe` (sysfs/procfs)
- `MacOsHardwareProbe` (IOKit stubs with NullHardwareProbe delegation)
- `NullHardwareProbe` (graceful fallback)
- `HardwareProbeFactory` (platform selection)
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/32-storage-address-hardware-discovery/32-RESEARCH.md

@DataWarehouse.SDK/Hardware/IHardwareAcceleration.cs
@DataWarehouse.SDK/Primitives/Hardware/HardwareTypes.cs
@DataWarehouse.Shared/Services/PlatformServiceManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hardware Device Types, Records, and IHardwareProbe Interface</name>
  <files>
    DataWarehouse.SDK/Hardware/HardwareDeviceType.cs
    DataWarehouse.SDK/Hardware/HardwareDevice.cs
    DataWarehouse.SDK/Hardware/IHardwareProbe.cs
    DataWarehouse.SDK/Hardware/NullHardwareProbe.cs
    DataWarehouse.SDK/Hardware/HardwareProbeFactory.cs
  </files>
  <action>
**File 1: HardwareDeviceType.cs**

Create in namespace `DataWarehouse.SDK.Hardware`:

```csharp
[Flags]
[SdkCompatibility("3.0.0", Notes = "Phase 32: Hardware device type classification (HAL-02)")]
public enum HardwareDeviceType
```

Members (flags enum, powers of 2):
- `None = 0`
- `PciDevice = 1` -- PCI/PCIe bus devices
- `UsbDevice = 2` -- USB-connected devices
- `NvmeController = 4` -- NVMe storage controllers
- `NvmeNamespace = 8` -- NVMe namespaces (logical storage)
- `GpuAccelerator = 16` -- GPU compute devices (CUDA/ROCm/DirectML)
- `BlockDevice = 32` -- Block storage devices (HDD, SSD, virtual disks)
- `NetworkAdapter = 64` -- Network interface cards
- `GpioController = 128` -- GPIO pin controllers (edge/IoT)
- `I2cBus = 256` -- I2C bus controllers
- `SpiBus = 512` -- SPI bus controllers
- `TpmDevice = 1024` -- Trusted Platform Module
- `HsmDevice = 2048` -- Hardware Security Module
- `QatAccelerator = 4096` -- Intel QuickAssist Technology
- `SerialPort = 8192` -- Serial/UART ports

Add XML docs on each member.

**File 2: HardwareDevice.cs**

Create in namespace `DataWarehouse.SDK.Hardware`:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 32: Hardware device record (HAL-02)")]
public sealed record HardwareDevice
```

Properties (all init-only):
- `string DeviceId { get; init; }` -- unique device identifier (platform-specific: PnP device ID on Windows, sysfs path on Linux)
- `string Name { get; init; }` -- human-readable device name
- `string? Description { get; init; }` -- optional detailed description
- `HardwareDeviceType Type { get; init; }` -- device type flags
- `string? Vendor { get; init; }` -- vendor name (e.g., "Intel", "Samsung")
- `string? VendorId { get; init; }` -- PCI vendor ID or USB VID (hex string)
- `string? ProductId { get; init; }` -- PCI device ID or USB PID (hex string)
- `string? DriverName { get; init; }` -- current driver name
- `string? DevicePath { get; init; }` -- OS device path (/dev/nvme0, \\.\PhysicalDrive0)
- `IReadOnlyDictionary<string, string> Properties { get; init; }` -- additional platform-specific properties

Default `Properties` to `ImmutableDictionary<string, string>.Empty` in a primary constructor or init.

Also create a helper record `HardwareChangeEventArgs`:
- `HardwareDevice Device { get; init; }`
- `HardwareChangeType ChangeType { get; init; }`

And `HardwareChangeType` enum: `Added`, `Removed`, `Modified`.

**File 3: IHardwareProbe.cs**

Create in namespace `DataWarehouse.SDK.Hardware`:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 32: Hardware discovery interface (HAL-02)")]
public interface IHardwareProbe : IDisposable
```

Methods:
- `Task<IReadOnlyList<HardwareDevice>> DiscoverAsync(HardwareDeviceType? typeFilter = null, CancellationToken ct = default)` -- discovers all hardware devices, optionally filtered by type flags. Returns empty list (never null) if no devices found.
- `Task<HardwareDevice?> GetDeviceAsync(string deviceId, CancellationToken ct = default)` -- get specific device by ID, null if not found.
- `event EventHandler<HardwareChangeEventArgs>? OnHardwareChanged` -- fired when hardware is added, removed, or modified (USB plug/unplug, hot-plug events).

Add XML documentation explaining that implementations are platform-specific and callers should use `HardwareProbeFactory.Create()` to get the correct probe.

**File 4: NullHardwareProbe.cs**

Create in namespace `DataWarehouse.SDK.Hardware`:

Sealed class implementing `IHardwareProbe`. All methods return empty results. DiscoverAsync returns empty list. GetDeviceAsync returns null. OnHardwareChanged is declared but never fired. Dispose is no-op. This is the graceful fallback for unsupported platforms. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 32: Fallback probe for unsupported platforms")]`.

**File 5: HardwareProbeFactory.cs**

Create in namespace `DataWarehouse.SDK.Hardware`:

Static class with one method:

```csharp
public static IHardwareProbe Create()
{
    if (OperatingSystem.IsWindows()) return new WindowsHardwareProbe();
    if (OperatingSystem.IsLinux()) return new LinuxHardwareProbe();
    if (OperatingSystem.IsMacOS()) return new MacOsHardwareProbe();
    return new NullHardwareProbe();
}
```

This follows the existing pattern from `PlatformServiceManager.cs` (research source). Add `[SdkCompatibility("3.0.0")]` attribute.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify all 5 files exist. Grep for `IHardwareProbe` in interface file. Grep for `HardwareDeviceType` flags enum. Grep for `NullHardwareProbe` in factory.
  </verify>
  <done>
IHardwareProbe interface defined with DiscoverAsync, GetDeviceAsync, and OnHardwareChanged event. HardwareDevice record with all device properties. HardwareDeviceType flags enum with 14 device categories. NullHardwareProbe provides graceful fallback. HardwareProbeFactory selects platform-appropriate implementation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Platform-Specific Probe Implementations (Windows, Linux, macOS)</name>
  <files>
    DataWarehouse.SDK/Hardware/WindowsHardwareProbe.cs
    DataWarehouse.SDK/Hardware/LinuxHardwareProbe.cs
    DataWarehouse.SDK/Hardware/MacOsHardwareProbe.cs
  </files>
  <action>
**File 1: WindowsHardwareProbe.cs**

Create in namespace `DataWarehouse.SDK.Hardware`. Mark class with `[SupportedOSPlatform("windows")]` and `[SdkCompatibility("3.0.0")]`.

Sealed class implementing `IHardwareProbe`.

`DiscoverAsync` implementation:
1. Use `System.Management.ManagementObjectSearcher` with WMI queries to enumerate devices:
   - `SELECT * FROM Win32_PnPEntity` for PCI/USB devices -- extract DeviceID, Name, Manufacturer, HardwareID
   - `SELECT * FROM Win32_DiskDrive` for block devices -- extract Model, InterfaceType, MediaType, DeviceID, PNPDeviceID
   - `SELECT * FROM Win32_VideoController` for GPUs -- extract Name, AdapterRAM, DriverVersion, PNPDeviceID
2. Map WMI results to `HardwareDevice` records:
   - Parse PNP DeviceID for VendorId/ProductId (format: `PCI\VEN_XXXX&DEV_XXXX` or `USB\VID_XXXX&PID_XXXX`)
   - Classify `HardwareDeviceType` from PNP class or interface type:
     - PCI prefix -> PciDevice
     - USB prefix -> UsbDevice
     - DiskDrive InterfaceType "NVMe" -> NvmeController
     - VideoController -> GpuAccelerator
     - DiskDrive -> BlockDevice
3. For NVMe: Also query `SELECT * FROM MSFT_PhysicalDisk WHERE BusType=17` (StorageWMI) if available, to get NVMe-specific info. Wrap in try/catch since MSFT_PhysicalDisk may not be available on all Windows versions.
4. Apply `typeFilter` if provided (use HasFlag to match).
5. Store `_lastDiscovery` as `IReadOnlyList<HardwareDevice>` for `GetDeviceAsync` lookups.

`GetDeviceAsync`: Search `_lastDiscovery` by DeviceId. If `_lastDiscovery` is null (DiscoverAsync not yet called), call DiscoverAsync first.

`OnHardwareChanged` event: Use `ManagementEventWatcher` with WQL query `SELECT * FROM __InstanceOperationEvent WITHIN 2 WHERE TargetInstance ISA 'Win32_PnPEntity'` to watch for device changes. Parse event type (__InstanceCreationEvent -> Added, __InstanceDeletionEvent -> Removed, __InstanceModificationEvent -> Modified). Fire OnHardwareChanged with the corresponding HardwareDevice. Start watcher in constructor, stop in Dispose. Wrap in try/catch -- if WMI event subscription fails, log and degrade gracefully (no events, but discovery still works).

Thread safety: Lock around `_lastDiscovery` updates with `SemaphoreSlim(1,1)`.

Dispose: Stop ManagementEventWatcher, dispose ManagementObjectSearcher instances, dispose semaphore.

All WMI calls wrapped in try/catch (ManagementException) with graceful degradation -- return empty list, not throw.

**File 2: LinuxHardwareProbe.cs**

Create in namespace `DataWarehouse.SDK.Hardware`. Mark class with `[SupportedOSPlatform("linux")]` and `[SdkCompatibility("3.0.0")]`.

Sealed class implementing `IHardwareProbe`.

`DiscoverAsync` implementation:
1. PCI devices: Read `/sys/bus/pci/devices/*/` directories. For each device:
   - Read `vendor` file (hex VID), `device` file (hex PID), `class` file (device class)
   - Read uevent for DRIVER, PCI_SLOT_NAME
   - Classify by PCI class code: 0x03 = GpuAccelerator, 0x01 = BlockDevice/NvmeController, 0x02 = NetworkAdapter
2. USB devices: Read `/sys/bus/usb/devices/*/` directories. For each (skip hubs):
   - Read `idVendor`, `idProduct`, `manufacturer`, `product`
   - Map to UsbDevice type
3. NVMe: Read `/sys/class/nvme/*/` for controllers and `/sys/class/nvme/nvme*/nvme*n*/` for namespaces:
   - Controller: read `model`, `serial`, `firmware_rev` from sysfs
   - Namespaces: read `size`, `nguid` from sysfs
   - Map controllers to NvmeController, namespaces to NvmeNamespace
4. Block devices: Read `/sys/class/block/*/` (filter out partitions -- skip if `partition` file exists):
   - Read `device/model`, `device/vendor`, `size`
   - Map to BlockDevice type
5. GPIO: Check if `/sys/class/gpio/` exists -- if so, map to GpioController
6. I2C: Read `/sys/class/i2c-adapter/*/` for I2cBus
7. SPI: Read `/sys/class/spi_master/*/` for SpiBus
8. Apply `typeFilter` if provided.

All file reads use `File.ReadAllTextAsync` with try/catch (FileNotFoundException, IOException) for graceful degradation. Missing sysfs entries are silently skipped.

`OnHardwareChanged` event: Use `FileSystemWatcher` on `/dev/` directory (if available) to detect device additions/removals. Debounce with 500ms timer to avoid flooding on rapid USB plug/unplug. Start in constructor, stop in Dispose.

Thread safety: Same pattern as Windows (SemaphoreSlim for _lastDiscovery).

**File 3: MacOsHardwareProbe.cs**

Create in namespace `DataWarehouse.SDK.Hardware`. Mark class with `[SupportedOSPlatform("macos")]` and `[SdkCompatibility("3.0.0")]`.

Sealed class implementing `IHardwareProbe`.

macOS is not the primary target platform. Provide a functional but minimal implementation:

`DiscoverAsync` implementation:
1. Use `Process.Start("system_profiler", "SPHardwareDataType SPStorageDataType SPDisplaysDataType SPUSBDataType -json")` to get hardware info as JSON.
2. Parse the JSON output with System.Text.Json to extract:
   - Storage devices -> BlockDevice / NvmeController
   - Display/GPU -> GpuAccelerator
   - USB devices -> UsbDevice
3. If system_profiler fails (not available, permission denied), fall back to NullHardwareProbe behavior (return empty list).
4. Apply `typeFilter` if provided.

`OnHardwareChanged`: Not implemented on macOS -- event is declared but never fired. Add XML doc noting this limitation.

Dispose: Kill any lingering system_profiler process if async.

Note: Full IOKit P/Invoke support is deferred to Phase 35 if needed. system_profiler provides sufficient hardware inventory for HAL-02 requirements on macOS.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify all 3 files exist. Grep for `SupportedOSPlatform` in all 3 files. Grep for `ManagementObjectSearcher` in WindowsHardwareProbe. Grep for `/sys/bus/pci` or `/sys/class` in LinuxHardwareProbe. Grep for `system_profiler` in MacOsHardwareProbe. Grep for `IHardwareProbe` in all 3 files confirms interface implementation.
  </verify>
  <done>
WindowsHardwareProbe discovers devices via WMI (PCI, USB, NVMe, GPU, Block) with ManagementEventWatcher for hot-plug events. LinuxHardwareProbe discovers devices via sysfs/procfs (PCI, USB, NVMe, GPIO, I2C, SPI, Block) with FileSystemWatcher on /dev/. MacOsHardwareProbe uses system_profiler JSON for basic discovery with graceful fallback. All implementations have platform guards, thread safety, and proper IDisposable cleanup.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 8 new files exist in DataWarehouse.SDK/Hardware/
3. IHardwareProbe interface has DiscoverAsync, GetDeviceAsync, OnHardwareChanged
4. HardwareDevice record has DeviceId, Name, Type, Vendor, DevicePath, Properties
5. HardwareDeviceType is a [Flags] enum with 14 members
6. All platform probes implement IHardwareProbe
7. All platform probes have [SupportedOSPlatform] attributes
8. HardwareProbeFactory.Create() returns correct type per platform
9. NullHardwareProbe returns empty results, never throws
10. All collections are bounded or read-only (IReadOnlyList, IReadOnlyDictionary, ImmutableDictionary)
</verification>

<success_criteria>
- IHardwareProbe interface defined with DiscoverAsync and hardware change events
- HardwareDevice record captures device identity, type, vendor, and properties
- Windows probe uses WMI (System.Management) for real device enumeration
- Linux probe reads sysfs/procfs for real device enumeration
- macOS probe uses system_profiler for basic discovery
- NullHardwareProbe provides graceful fallback on unsupported platforms
- Factory selects correct probe using OperatingSystem.Is* guards (existing 51-file pattern)
- Zero new NuGet dependencies (all .NET 9 BCL)
- Zero existing files modified -- purely additive
</success_criteria>

<output>
After completion, create `.planning/phases/32-storage-address-hardware-discovery/32-02-SUMMARY.md`
</output>
