---
phase: 32-storage-address-hardware-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Storage/StorageAddressKind.cs
  - DataWarehouse.SDK/Storage/StorageAddress.cs
autonomous: true

must_haves:
  truths:
    - "StorageAddress.FromFilePath, FromObjectKey, FromNvme, FromBlockDevice, FromNetworkEndpoint, FromGpioPin, FromI2cBus, FromSpiBus, FromCustom all compile and produce correct variant"
    - "Implicit conversion from string produces ObjectKeyAddress for non-path strings and FilePathAddress for rooted/path-separator strings"
    - "Implicit conversion from Uri produces correct StorageAddress variant via FromUri factory"
    - "ToKey() returns a string key compatible with existing IObjectStorageCore/IStorageStrategy string-based APIs"
    - "ToUri() returns a Uri representation for variants that support it"
    - "ToPath() returns a file system path for FilePathAddress, throws for non-path variants"
    - "All 9 StorageAddress variants are sealed records with value equality"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/StorageAddressKind.cs"
      provides: "Enum for discriminating StorageAddress variants"
      min_lines: 15
    - path: "DataWarehouse.SDK/Storage/StorageAddress.cs"
      provides: "Abstract record base + 9 sealed record variants + implicit conversions + factory methods"
      min_lines: 250
  key_links:
    - from: "StorageAddress"
      to: "PathStorageAdapter"
      via: "FilePathAddress.ToKey() delegates to PathStorageAdapter.NormalizePath"
      pattern: "PathStorageAdapter\\.NormalizePath"
    - from: "StorageAddress"
      to: "StorageAddressKind"
      via: "Each variant overrides Kind property"
      pattern: "StorageAddressKind\\."
---

<objective>
Create the StorageAddress discriminated union type (HAL-01) -- the universal addressing type that can represent any storage location: file path, block device, NVMe namespace, object key, network endpoint, GPIO pin, I2C bus, SPI bus, or custom address.

Purpose: This is the foundational type for all of v3.0. Every subsequent phase depends on StorageAddress to represent storage locations in a type-safe, extensible way. Implicit conversions from string and Uri ensure zero breaking changes to existing code.

Output:
- `DataWarehouse.SDK/Storage/StorageAddressKind.cs` -- Enum with 9 variants
- `DataWarehouse.SDK/Storage/StorageAddress.cs` -- Abstract record base + 9 sealed record variants + factory methods + implicit conversions + ToKey()/ToUri()/ToPath()
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/32-storage-address-hardware-discovery/32-RESEARCH.md

@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
@DataWarehouse.SDK/Storage/PathStorageAdapter.cs
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
@DataWarehouse.SDK/Contracts/ProviderInterfaces.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: StorageAddressKind Enum</name>
  <files>
    DataWarehouse.SDK/Storage/StorageAddressKind.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Storage/StorageAddressKind.cs` in namespace `DataWarehouse.SDK.Storage`.

Define a public enum `StorageAddressKind` with exactly 9 members:
- `FilePath` -- local or network file paths (C:\data, /mnt/data, \\server\share)
- `BlockDevice` -- raw block devices (/dev/sda, \\.\PhysicalDrive0)
- `NvmeNamespace` -- NVMe namespace addressing (controller + namespace ID)
- `ObjectKey` -- object/key-based storage (S3 keys, AD-04 canonical keys)
- `NetworkEndpoint` -- network storage endpoints (host:port with optional scheme)
- `GpioPin` -- GPIO pin on edge devices (pin number + optional board ID)
- `I2cBus` -- I2C bus device (bus ID + device address)
- `SpiBus` -- SPI bus device (bus ID + chip select)
- `CustomAddress` -- extensibility point (scheme + opaque address string)

Add XML documentation on each member explaining the use case. Add `[SdkCompatibility("3.0.0", Notes = "Phase 32: StorageAddress universal addressing")]` attribute on the enum.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Storage/StorageAddressKind.cs`. Grep for all 9 enum members.
  </verify>
  <done>
StorageAddressKind enum exists with all 9 variants, XML-documented, with SdkCompatibility attribute.
  </done>
</task>

<task type="auto">
  <name>Task 2: StorageAddress Abstract Record and All 9 Variants</name>
  <files>
    DataWarehouse.SDK/Storage/StorageAddress.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Storage/StorageAddress.cs` in namespace `DataWarehouse.SDK.Storage`.

**Abstract base record:**

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 32: Universal storage addressing (HAL-01)")]
public abstract record StorageAddress
```

Abstract members:
- `public abstract StorageAddressKind Kind { get; }` -- variant discriminator
- `public abstract string ToKey()` -- returns a string key for backward compat with IObjectStorageCore/IStorageStrategy

Virtual members with sensible defaults:
- `public virtual Uri ToUri()` -- default: creates `new Uri($"{Kind.ToString().ToLowerInvariant()}://{ToKey()}")`. FilePathAddress and NetworkEndpointAddress override with proper URI.
- `public virtual string ToPath()` -- default: throws `NotSupportedException($"StorageAddress of kind {Kind} cannot be converted to a file path")`. Only FilePathAddress overrides.

**Implicit conversion operators (HAL-05 backward compat):**
- `public static implicit operator StorageAddress(string value)` -- if value is null, throw ArgumentNullException. Use `IsObjectKey(value)` heuristic: if the string is NOT path-rooted AND does NOT contain `Path.DirectorySeparatorChar` or `Path.AltDirectorySeparatorChar`, produce `ObjectKeyAddress`. Otherwise produce `FilePathAddress`.
- `public static implicit operator StorageAddress(Uri uri)` -- delegates to `FromUri(uri)`.

**Static factory methods:**
- `FromFilePath(string path)` -- validates non-null/empty, returns `new FilePathAddress(path)`
- `FromObjectKey(string key)` -- validates non-null/empty, returns `new ObjectKeyAddress(key)`
- `FromNvme(int nsid, int? controllerId = null)` -- validates nsid >= 0, returns `new NvmeNamespaceAddress(nsid, controllerId)`
- `FromBlockDevice(string devicePath)` -- validates non-null/empty, returns `new BlockDeviceAddress(devicePath)`
- `FromNetworkEndpoint(string host, int port, string? scheme = null)` -- validates host non-null/empty, port 1-65535, returns `new NetworkEndpointAddress(host, port, scheme)`
- `FromGpioPin(int pin, string? boardId = null)` -- validates pin >= 0, returns `new GpioPinAddress(pin, boardId)`
- `FromI2cBus(int busId, int deviceAddress)` -- validates busId >= 0, deviceAddress 0-127, returns `new I2cBusAddress(busId, deviceAddress)`
- `FromSpiBus(int busId, int chipSelect)` -- validates busId >= 0, chipSelect >= 0, returns `new SpiBusAddress(busId, chipSelect)`
- `FromCustom(string scheme, string address)` -- validates both non-null/empty, returns `new CustomAddress(scheme, address)`
- `FromUri(Uri uri)` -- parses URI scheme to determine variant: "file" -> FilePathAddress (uri.LocalPath), "nvme" -> parse nsid from path, "gpio"/"i2c"/"spi" -> parse from host/path, "block" -> BlockDeviceAddress, http/https/tcp/udp -> NetworkEndpointAddress, default -> ObjectKeyAddress(uri.ToString())

**Private helper:**
- `private static bool IsObjectKey(string s)` -- returns true when string is NOT path-rooted AND does NOT contain `Path.DirectorySeparatorChar` AND does NOT contain `Path.AltDirectorySeparatorChar`. This is the heuristic documented in research (consistent with AD-04 key conventions).

**9 Sealed Record Variants (all in same file):**

1. `FilePathAddress(string Path)` -- Kind = FilePath, ToKey() = `PathStorageAdapter.NormalizePath(Path)`, ToPath() = Path, ToUri() = `new Uri(Path)` (handles UNC and local)
2. `ObjectKeyAddress(string Key)` -- Kind = ObjectKey, ToKey() = Key
3. `NvmeNamespaceAddress(int NamespaceId, int? ControllerId = null)` -- Kind = NvmeNamespace, ToKey() = `$"nvme://{ControllerId ?? 0}/ns/{NamespaceId}"`
4. `BlockDeviceAddress(string DevicePath)` -- Kind = BlockDevice, ToKey() = DevicePath, ToPath() = DevicePath
5. `NetworkEndpointAddress(string Host, int Port, string? Scheme = null)` -- Kind = NetworkEndpoint, ToKey() = `$"{Scheme ?? "tcp"}://{Host}:{Port}"`, ToUri() = `new Uri(ToKey())`
6. `GpioPinAddress(int Pin, string? BoardId = null)` -- Kind = GpioPin, ToKey() = `$"gpio://{BoardId ?? "default"}/pin/{Pin}"`
7. `I2cBusAddress(int BusId, int DeviceAddress)` -- Kind = I2cBus, ToKey() = `$"i2c://{BusId}/0x{DeviceAddress:X2}"`
8. `SpiBusAddress(int BusId, int ChipSelect)` -- Kind = SpiBus, ToKey() = `$"spi://{BusId}/cs/{ChipSelect}"`
9. `CustomAddress(string Scheme, string Address)` -- Kind = CustomAddress, ToKey() = `$"{Scheme}://{Address}"`

Add `override string ToString()` on the base that returns `$"{Kind}:{ToKey()}"` for debugging.

Add comprehensive XML documentation on the abstract base explaining the discriminated union pattern, backward compatibility via implicit conversions, and the recommended usage (explicit factory methods preferred over implicit conversion).

Use `ArgumentNullException.ThrowIfNull` and `ArgumentNullException.ThrowIfNullOrEmpty` (string overload) for parameter validation. Use `ArgumentOutOfRangeException.ThrowIfNegative` for numeric validation where available. These are .NET 9 built-in -- no custom guards needed.

Do NOT add an `IStorageAddress` interface (research anti-pattern). The abstract record IS the abstraction. C# pattern matching (`switch` on Kind or `is` patterns) is sufficient.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Storage/StorageAddress.cs`. Grep for `abstract record StorageAddress` confirms base. Grep for `sealed record FilePathAddress` confirms at least one variant. Grep for `implicit operator StorageAddress` confirms both string and Uri conversions exist. Grep for `PathStorageAdapter.NormalizePath` confirms FilePathAddress uses existing normalization.
  </verify>
  <done>
StorageAddress abstract record exists with all 9 sealed record variants, implicit conversions from string and Uri, factory methods with input validation, ToKey()/ToUri()/ToPath() conversions, and full XML documentation. The type is purely additive -- no existing files modified, zero breaking changes.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Two new files exist: StorageAddressKind.cs, StorageAddress.cs
3. All 9 enum members present in StorageAddressKind
4. All 9 sealed record variants present in StorageAddress.cs
5. Implicit operators exist for both string and Uri
6. All factory methods exist (9 FromX methods + FromUri)
7. ToKey() defined on all variants
8. PathStorageAdapter.NormalizePath used in FilePathAddress.ToKey()
9. Input validation on all factory methods (no null/empty, range checks)
10. SdkCompatibility attribute present on both types
</verification>

<success_criteria>
- StorageAddress discriminated union compiles and all 9 variants are usable
- Implicit conversion from string works: `StorageAddress addr = "my/object/key"` produces ObjectKeyAddress
- Implicit conversion from string works: `StorageAddress addr = "C:\\data\\file.bin"` produces FilePathAddress
- Implicit conversion from Uri works: `StorageAddress addr = new Uri("file:///data/file.bin")` produces FilePathAddress
- ToKey() round-trips correctly for all variants (returns string usable by existing string-based APIs)
- Zero existing files modified -- purely additive
- Zero new NuGet dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/32-storage-address-hardware-discovery/32-01-SUMMARY.md`
</output>
