---
phase: 32-storage-address-hardware-discovery
plan: 05
type: execute
wave: 3
depends_on: ["32-01", "32-02", "32-03", "32-04"]
files_modified:
  - DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
  - DataWarehouse.SDK/Storage/IObjectStorageCore.cs
  - DataWarehouse.SDK/Storage/PathStorageAdapter.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/StoragePluginBase.cs
  - DataWarehouse.SDK/Contracts/ProviderInterfaces.cs
  - DataWarehouse.SDK/Contracts/IListableStorage.cs
  - DataWarehouse.SDK/Contracts/LowLatencyPluginBases.cs
  - DataWarehouse.SDK/Contracts/ICacheableStorage.cs
autonomous: true

must_haves:
  truths:
    - "StorageStrategyBase has new virtual StorageAddress-accepting overloads for all 7 core methods (Store, Retrieve, Delete, Exists, List, GetMetadata, plus GetAvailableCapacity)"
    - "All StorageAddress overloads have default implementations that delegate to the string-key versions via address.ToKey()"
    - "Existing string-key abstract methods (StoreAsyncCore, RetrieveAsyncCore, etc.) are UNCHANGED -- zero signature modifications"
    - "IObjectStorageCore has new StorageAddress overloads with default interface implementations delegating to string versions"
    - "IStorageProvider has a new StoreAsync/LoadAsync/DeleteAsync/ExistsAsync that accepts StorageAddress with default delegation to Uri version"
    - "All 130+ existing storage strategies compile without any modification"
    - "Full solution build succeeds with zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs"
      provides: "StorageAddress overloads on IStorageStrategy and StorageStrategyBase"
      contains: "StorageAddress"
    - path: "DataWarehouse.SDK/Storage/IObjectStorageCore.cs"
      provides: "StorageAddress overloads on IObjectStorageCore"
      contains: "StorageAddress"
    - path: "DataWarehouse.SDK/Storage/PathStorageAdapter.cs"
      provides: "StorageAddress-aware path translation"
      contains: "StorageAddress"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/StoragePluginBase.cs"
      provides: "StorageAddress overloads on StoragePluginBase abstract methods"
      contains: "StorageAddress"
    - path: "DataWarehouse.SDK/Contracts/ProviderInterfaces.cs"
      provides: "StorageAddress overloads on IStorageProvider"
      contains: "StorageAddress"
  key_links:
    - from: "StorageStrategyBase StorageAddress overloads"
      to: "StorageStrategyBase string overloads"
      via: "default implementation calls address.ToKey() and delegates to existing string method"
      pattern: "address\\.ToKey\\(\\)|storageAddress\\.ToKey\\(\\)"
    - from: "IObjectStorageCore StorageAddress overloads"
      to: "IObjectStorageCore string overloads"
      via: "default interface implementation calls address.ToKey()"
      pattern: "address\\.ToKey\\(\\)"
    - from: "IStorageProvider StorageAddress overloads"
      to: "IStorageProvider Uri overloads"
      via: "default interface implementation calls address.ToUri()"
      pattern: "address\\.ToUri\\(\\)"
---

<objective>
Add StorageAddress overloads to all SDK storage contracts for backward-compatible migration (HAL-05) -- the critical integration step that bridges the new StorageAddress type into the existing 130+ strategy ecosystem without breaking a single existing strategy.

Purpose: This is the highest-risk plan in Phase 32. It touches the core storage contract surface that 130+ strategies depend on. The approach is strictly additive: new overloads with default implementations that delegate to existing string/Uri methods via ToKey()/ToUri(). No existing method signatures are modified. No existing abstract methods are changed. Every existing strategy continues to compile and work identically.

Output:
- StorageAddress overloads on IStorageStrategy, StorageStrategyBase (7 core methods)
- StorageAddress overloads on IObjectStorageCore (5 methods)
- StorageAddress-aware PathStorageAdapter
- StorageAddress overloads on StoragePluginBase (6 abstract methods)
- StorageAddress overloads on IStorageProvider (4 methods)
- StorageAddress overloads on IListableStorage, LowLatencyPluginBases, ICacheableStorage
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/32-storage-address-hardware-discovery/32-RESEARCH.md

@DataWarehouse.SDK/Storage/StorageAddress.cs (from 32-01)

@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
@DataWarehouse.SDK/Storage/PathStorageAdapter.cs
@DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/StoragePluginBase.cs
@DataWarehouse.SDK/Contracts/ProviderInterfaces.cs
@DataWarehouse.SDK/Contracts/IListableStorage.cs
@DataWarehouse.SDK/Contracts/LowLatencyPluginBases.cs
@DataWarehouse.SDK/Contracts/ICacheableStorage.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: StorageAddress Overloads on StorageStrategy and IObjectStorageCore</name>
  <files>
    DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
    DataWarehouse.SDK/Storage/IObjectStorageCore.cs
    DataWarehouse.SDK/Storage/PathStorageAdapter.cs
  </files>
  <action>
**CRITICAL: Read each file FULLY before modifying. This task modifies core SDK contracts. Every change must be additive -- NO existing method signatures changed.**

Add `using DataWarehouse.SDK.Storage;` import to each file (for StorageAddress type).

**File 1: StorageStrategy.cs (~766 LOC)**

In `IStorageStrategy` interface, ADD new methods (do NOT remove or modify any existing methods):

```csharp
// StorageAddress overloads (HAL-05) -- all have default implementations delegating to string versions
Task<StorageObjectMetadata> StoreAsync(StorageAddress address, Stream data, IDictionary<string, string>? metadata = null, CancellationToken ct = default)
    => StoreAsync(address.ToKey(), data, metadata, ct);

Task<Stream> RetrieveAsync(StorageAddress address, CancellationToken ct = default)
    => RetrieveAsync(address.ToKey(), ct);

Task DeleteAsync(StorageAddress address, CancellationToken ct = default)
    => DeleteAsync(address.ToKey(), ct);

Task<bool> ExistsAsync(StorageAddress address, CancellationToken ct = default)
    => ExistsAsync(address.ToKey(), ct);

Task<StorageObjectMetadata> GetMetadataAsync(StorageAddress address, CancellationToken ct = default)
    => GetMetadataAsync(address.ToKey(), ct);
```

NOTE: These are C# default interface implementations (DIM). They compile against .NET 9 and do NOT require any implementor to change. Existing strategies that implement IStorageStrategy are unaffected.

In `StorageStrategyBase` abstract class, ADD new virtual methods that also delegate to the string-key abstract core methods:

```csharp
// StorageAddress overloads (HAL-05) -- virtual, can be overridden by strategies that want native StorageAddress support
public virtual Task<StorageObjectMetadata> StoreAsync(StorageAddress address, Stream data, IDictionary<string, string>? metadata = null, CancellationToken ct = default)
    => StoreAsync(address.ToKey(), data, metadata, ct);

public virtual Task<Stream> RetrieveAsync(StorageAddress address, CancellationToken ct = default)
    => RetrieveAsync(address.ToKey(), ct);

public virtual Task DeleteAsync(StorageAddress address, CancellationToken ct = default)
    => DeleteAsync(address.ToKey(), ct);

public virtual Task<bool> ExistsAsync(StorageAddress address, CancellationToken ct = default)
    => ExistsAsync(address.ToKey(), ct);

public virtual Task<StorageObjectMetadata> GetMetadataAsync(StorageAddress address, CancellationToken ct = default)
    => GetMetadataAsync(address.ToKey(), ct);
```

These virtual methods delegate to the PUBLIC StoreAsync(string key, ...) methods on StorageStrategyBase, which in turn call the ABSTRACT StoreAsyncCore(string key, ...) methods. This way, all 130+ strategies that override StoreAsyncCore(string key, ...) automatically work with StorageAddress.

The ABSTRACT methods (`StoreAsyncCore`, `RetrieveAsyncCore`, `DeleteAsyncCore`, `ExistsAsyncCore`, `ListAsyncCore`, `GetMetadataAsyncCore`, `GetHealthAsyncCore`, `GetAvailableCapacityAsyncCore`) are UNCHANGED. Do NOT add StorageAddress variants of these abstract methods. The delegation chain is: StorageAddress overload -> public string method -> protected abstract string core method.

**File 2: IObjectStorageCore.cs (~48 LOC)**

Add StorageAddress overloads with default interface implementations:

```csharp
Task<StorageObjectMetadata> StoreAsync(StorageAddress address, Stream data, IDictionary<string, string>? metadata = null, CancellationToken ct = default)
    => StoreAsync(address.ToKey(), data, metadata, ct);

Task<Stream> RetrieveAsync(StorageAddress address, CancellationToken ct = default)
    => RetrieveAsync(address.ToKey(), ct);

Task DeleteAsync(StorageAddress address, CancellationToken ct = default)
    => DeleteAsync(address.ToKey(), ct);

Task<bool> ExistsAsync(StorageAddress address, CancellationToken ct = default)
    => ExistsAsync(address.ToKey(), ct);

Task<StorageObjectMetadata> GetMetadataAsync(StorageAddress address, CancellationToken ct = default)
    => GetMetadataAsync(address.ToKey(), ct);
```

**File 3: PathStorageAdapter.cs (~143 LOC)**

Add a new method that accepts StorageAddress:

```csharp
/// <summary>
/// Converts a StorageAddress to a normalized file path.
/// For FilePathAddress: returns the normalized path directly.
/// For ObjectKeyAddress: applies key-to-path translation.
/// For other variants: uses ToKey() and applies key-to-path translation.
/// </summary>
public static string ToNormalizedPath(StorageAddress address)
{
    return address switch
    {
        FilePathAddress fp => NormalizePath(fp.Path),
        _ => NormalizePath(address.ToKey())
    };
}
```

Also add a static method for the reverse: `FromPath(string path)` that returns `StorageAddress.FromFilePath(path)`. This is a convenience for callers transitioning from string paths to StorageAddress.

Do NOT modify existing `NormalizePath`, `UriToKey`, or other existing methods. Keep them exactly as they are.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `StorageAddress address` in StorageStrategy.cs to confirm overloads added. Grep for `address.ToKey()` to confirm delegation pattern. Grep for existing abstract methods `StoreAsyncCore(string key` to confirm they are UNCHANGED. Run `dotnet build` on the ENTIRE solution to verify 130+ strategies still compile: `dotnet build DataWarehouse.slnx` (check for zero new errors in plugin projects).
  </verify>
  <done>
IStorageStrategy has StorageAddress default interface implementations for all 5 core operations. StorageStrategyBase has virtual StorageAddress methods delegating to string-based public methods. IObjectStorageCore has StorageAddress DIMs. PathStorageAdapter has ToNormalizedPath(StorageAddress). All existing abstract methods UNCHANGED. All 130+ strategies compile without modification.
  </done>
</task>

<task type="auto">
  <name>Task 2: StorageAddress Overloads on StoragePluginBase, IStorageProvider, and Remaining Contracts</name>
  <files>
    DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/StoragePluginBase.cs
    DataWarehouse.SDK/Contracts/ProviderInterfaces.cs
    DataWarehouse.SDK/Contracts/IListableStorage.cs
    DataWarehouse.SDK/Contracts/LowLatencyPluginBases.cs
    DataWarehouse.SDK/Contracts/ICacheableStorage.cs
  </files>
  <action>
**CRITICAL: Read each file FULLY before modifying. All changes are additive. No existing signatures modified.**

Add `using DataWarehouse.SDK.Storage;` import to each file.

**File 1: StoragePluginBase.cs (~58 LOC)**

Add virtual StorageAddress overloads for the abstract storage methods. These delegate to the string-key versions:

```csharp
// StorageAddress overloads (HAL-05)
public virtual Task<StorageObjectMetadata> StoreAsync(StorageAddress address, Stream data, IDictionary<string, string>? metadata = null, CancellationToken ct = default)
    => StoreAsync(address.ToKey(), data, metadata, ct);

public virtual Task<Stream> RetrieveAsync(StorageAddress address, CancellationToken ct = default)
    => RetrieveAsync(address.ToKey(), ct);

public virtual Task DeleteAsync(StorageAddress address, CancellationToken ct = default)
    => DeleteAsync(address.ToKey(), ct);

public virtual Task<bool> ExistsAsync(StorageAddress address, CancellationToken ct = default)
    => ExistsAsync(address.ToKey(), ct);

public virtual IAsyncEnumerable<StorageObjectMetadata> ListAsync(StorageAddress? prefix = null, CancellationToken ct = default)
    => ListAsync(prefix?.ToKey(), ct);

public virtual Task<StorageObjectMetadata> GetMetadataAsync(StorageAddress address, CancellationToken ct = default)
    => GetMetadataAsync(address.ToKey(), ct);
```

Do NOT modify any existing abstract methods. The existing `StoreAsync(string key, ...)` etc. remain exactly as they are.

**File 2: ProviderInterfaces.cs (~65 LOC)**

In `IStorageProvider` interface, add default interface implementations:

```csharp
// StorageAddress overloads (HAL-05) -- bridge StorageAddress to Uri
Task SaveAsync(StorageAddress address, Stream data)
    => SaveAsync(address.ToUri(), data);

Task<Stream> LoadAsync(StorageAddress address)
    => LoadAsync(address.ToUri());

Task DeleteAsync(StorageAddress address)
    => DeleteAsync(address.ToUri());

Task<bool> ExistsAsync(StorageAddress address)
    => ExistsAsync(address.ToUri());
```

Note: IStorageProvider uses `Uri`, not `string key`. So StorageAddress overloads delegate via `address.ToUri()` (not ToKey()). This bridges the two addressing systems.

**File 3: IListableStorage.cs (~25 LOC)**

If the interface has methods accepting string prefix/key for listing, add StorageAddress overloads with DIM delegating to string via ToKey(). If the interface uses Uri, delegate via ToUri().

Read the file first to determine the exact method signatures. Add corresponding StorageAddress overloads. If the interface is minimal (just an enumerable), the change may be a single method or no change at all.

**File 4: LowLatencyPluginBases.cs**

Find methods like `ReadWithoutCacheAsync(string key, ...)` and `WriteWithoutCacheAsync(string key, ...)`. Add virtual overloads:

```csharp
public virtual Task<Stream?> ReadWithoutCacheAsync(StorageAddress address, CancellationToken ct = default)
    => ReadWithoutCacheAsync(address.ToKey(), ct);

public virtual Task WriteWithoutCacheAsync(StorageAddress address, Stream data, CancellationToken ct = default)
    => WriteWithoutCacheAsync(address.ToKey(), data, ct);
```

Read the file first to match exact signatures. Only add overloads where `string key` parameters exist.

**File 5: ICacheableStorage.cs**

Find cache methods with `string key` parameters. Add StorageAddress overloads with DIM or virtual overloads delegating via ToKey().

Read the file first to determine exact signatures. Pattern is the same: for each method with `string key`, add a corresponding `StorageAddress address` method that calls `address.ToKey()` and delegates.

**CRITICAL VERIFICATION after all changes:**
Run `dotnet build DataWarehouse.slnx` (entire solution). This is the AD-08 zero-regression gate. ALL 130+ storage strategies, ALL plugins, ALL tests must compile. If ANY build error appears in a plugin project that was NOT there before, the change must be rolled back and the approach reconsidered.

Expected result: Zero new build errors. The only changes are additive (new overloads with default implementations). No existing code is affected.
  </action>
  <verify>
Run `dotnet build DataWarehouse.slnx` -- the FULL SOLUTION build. This is the critical HAL-05 and AD-08 verification. Zero new errors must appear. Specifically check:
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- SDK compiles
2. `dotnet build DataWarehouse.slnx` -- ALL 69 projects compile (some may have pre-existing errors CS1729/CS0234 in UltimateCompression and AedsCore -- these are acceptable if they existed before)
3. Grep for `StorageAddress` in each modified file confirms overloads added
4. Grep for existing `StoreAsyncCore(string key` in StorageStrategy.cs confirms abstract methods UNCHANGED
5. Count of `abstract` methods in StorageStrategy.cs is IDENTICAL to before modification (no abstract methods added or removed)
  </verify>
  <done>
StorageAddress overloads added to StoragePluginBase (6 methods), IStorageProvider (4 methods via ToUri()), IListableStorage, LowLatencyPluginBases, and ICacheableStorage. All overloads delegate to existing string/Uri methods via ToKey()/ToUri(). Full solution builds with zero new errors. All 130+ storage strategies compile without modification. AD-08 zero regression policy satisfied.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.slnx` -- FULL SOLUTION compiles with zero NEW errors
2. All 8 modified files have StorageAddress overloads
3. No existing method signatures changed (grep for exact original signatures confirms they exist unchanged)
4. No new abstract methods added (count of `abstract` keyword in StorageStrategy.cs unchanged)
5. All StorageAddress methods delegate to string/Uri versions via ToKey()/ToUri()
6. 130+ storage strategies in UltimateStorage compile without any modification
7. 49 DatabaseStorage strategies compile without any modification
8. All other storage-related plugins compile without any modification
9. Using statement for `DataWarehouse.SDK.Storage` added to each modified file
10. PathStorageAdapter has new ToNormalizedPath(StorageAddress) utility method
</verification>

<success_criteria>
- AD-08 ZERO REGRESSION: Full solution build passes with zero new errors
- All 130+ UltimateStorage strategies compile identically (no modifications needed)
- All 49 DatabaseStorage strategies compile identically
- StorageAddress accepted by IStorageStrategy, StorageStrategyBase, IObjectStorageCore, StoragePluginBase, IStorageProvider, IListableStorage, LowLatencyPluginBases, ICacheableStorage
- All overloads delegate to existing methods -- no new behavior paths, just new entry points
- Implicit conversion means existing string-passing code can transparently pass StorageAddress
</success_criteria>

<output>
After completion, create `.planning/phases/32-storage-address-hardware-discovery/32-05-SUMMARY.md`
</output>
