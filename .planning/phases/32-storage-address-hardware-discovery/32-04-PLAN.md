---
phase: 32-storage-address-hardware-discovery
plan: 04
type: execute
wave: 2
depends_on: ["32-02"]
files_modified:
  - DataWarehouse.SDK/Hardware/StorageDriverAttribute.cs
  - DataWarehouse.SDK/Hardware/IDriverLoader.cs
  - DataWarehouse.SDK/Hardware/DriverLoader.cs
autonomous: true

must_haves:
  truths:
    - "[StorageDriver] attribute marks types as dynamically loadable storage drivers with metadata (name, supported device types, version)"
    - "IDriverLoader.ScanAsync discovers [StorageDriver]-attributed types in a given assembly or directory of assemblies"
    - "IDriverLoader.LoadAsync loads a driver type into the runtime via PluginAssemblyLoadContext isolation"
    - "IDriverLoader.UnloadAsync unloads a driver assembly, releasing the collectible AssemblyLoadContext"
    - "Hot-plug: DriverLoader watches a configured directory and auto-loads/unloads drivers when DLLs appear/disappear"
    - "Loaded drivers are registered and queryable via GetLoadedDrivers()"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/StorageDriverAttribute.cs"
      provides: "Attribute for marking storage driver types with discovery metadata"
      min_lines: 20
    - path: "DataWarehouse.SDK/Hardware/IDriverLoader.cs"
      provides: "Interface for scanning, loading, and unloading storage drivers dynamically"
      min_lines: 40
    - path: "DataWarehouse.SDK/Hardware/DriverLoader.cs"
      provides: "Implementation using PluginAssemblyLoadContext for assembly isolation and hot-plug support"
      min_lines: 200
  key_links:
    - from: "DriverLoader"
      to: "PluginAssemblyLoadContext"
      via: "uses existing SDK assembly isolation for collectible driver loading"
      pattern: "PluginAssemblyLoadContext"
    - from: "DriverLoader"
      to: "StorageDriverAttribute"
      via: "assembly scanning filters types by attribute presence"
      pattern: "StorageDriverAttribute|GetCustomAttribute"
    - from: "DriverLoader"
      to: "IHardwareProbe"
      via: "optional: subscribes to hardware change events for hot-plug driver management"
      pattern: "OnHardwareChanged"
---

<objective>
Create IDriverLoader and dynamic driver loading infrastructure (HAL-04) -- the system that discovers, loads, and unloads storage driver assemblies at runtime without requiring recompilation.

Purpose: Dynamic driver loading enables new hardware support to be added by dropping a DLL into a drivers directory. Combined with hardware change events from IHardwareProbe, this enables hot-plug: when new hardware appears, the corresponding driver loads automatically. This reuses the proven PluginAssemblyLoadContext and PluginReloadManager patterns from the existing SDK infrastructure.

Output:
- `DataWarehouse.SDK/Hardware/StorageDriverAttribute.cs` -- Discovery attribute for driver types
- `DataWarehouse.SDK/Hardware/IDriverLoader.cs` -- Dynamic loading interface
- `DataWarehouse.SDK/Hardware/DriverLoader.cs` -- Implementation with assembly scanning, isolation, and hot-plug
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/32-storage-address-hardware-discovery/32-RESEARCH.md

@DataWarehouse.SDK/Infrastructure/KernelInfrastructure.cs
@DataWarehouse.SDK/Hardware/IHardwareProbe.cs (from 32-02)
@DataWarehouse.SDK/Hardware/HardwareDevice.cs (from 32-02)
@DataWarehouse.SDK/Connectors/ConnectionStrategyRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: StorageDriverAttribute and IDriverLoader Interface</name>
  <files>
    DataWarehouse.SDK/Hardware/StorageDriverAttribute.cs
    DataWarehouse.SDK/Hardware/IDriverLoader.cs
  </files>
  <action>
**File 1: StorageDriverAttribute.cs**

Create in namespace `DataWarehouse.SDK.Hardware`:

```csharp
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
[SdkCompatibility("3.0.0", Notes = "Phase 32: Storage driver discovery attribute (HAL-04)")]
public sealed class StorageDriverAttribute : Attribute
```

Properties:
- `string Name { get; }` -- required, human-readable driver name (e.g., "Samsung NVMe Driver")
- `string? Description { get; set; }` -- optional description
- `string? Version { get; set; }` -- optional version string (e.g., "1.0.0")
- `HardwareDeviceType SupportedDevices { get; set; }` -- flags indicating which device types this driver supports (e.g., `NvmeController | NvmeNamespace`)
- `string? MinimumPlatform { get; set; }` -- optional minimum OS version (e.g., "windows10.0.19041")
- `bool AutoLoad { get; set; } = true` -- whether to auto-load when supported hardware is detected

Constructor takes `string name` (required).

XML documentation explaining:
- Apply to classes that implement IStorageStrategy (or a derived interface) to make them discoverable by IDriverLoader
- SupportedDevices should match the HardwareDeviceType flags of devices this driver can handle
- AutoLoad=true means the driver loads automatically when matching hardware is detected via IHardwareProbe

**File 2: IDriverLoader.cs**

Create in namespace `DataWarehouse.SDK.Hardware`:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 32: Dynamic driver loading interface (HAL-04)")]
public interface IDriverLoader : IDisposable
```

Methods:
- `Task<IReadOnlyList<DriverInfo>> ScanAsync(string assemblyPath, CancellationToken ct = default)` -- scan a single assembly for [StorageDriver]-attributed types. Returns driver info without loading them.
- `Task<IReadOnlyList<DriverInfo>> ScanDirectoryAsync(string directoryPath, string searchPattern = "*.dll", CancellationToken ct = default)` -- scan all matching assemblies in a directory.
- `Task<DriverHandle> LoadAsync(string assemblyPath, string typeName, CancellationToken ct = default)` -- load a specific driver type from an assembly. Uses PluginAssemblyLoadContext for isolation. Returns a handle for managing the loaded driver.
- `Task UnloadAsync(DriverHandle handle, CancellationToken ct = default)` -- unload a previously loaded driver. Triggers graceful shutdown, then releases the AssemblyLoadContext.
- `IReadOnlyList<DriverHandle> GetLoadedDrivers()` -- returns all currently loaded drivers.
- `Task<DriverHandle?> GetDriverAsync(string driverName, CancellationToken ct = default)` -- find a loaded driver by name.
- `event EventHandler<DriverEventArgs>? OnDriverLoaded` -- fired when a driver is loaded
- `event EventHandler<DriverEventArgs>? OnDriverUnloaded` -- fired when a driver is unloaded

Also define supporting types:

`DriverInfo` sealed record:
- `string AssemblyPath { get; init; }` -- path to the assembly
- `string TypeName { get; init; }` -- fully qualified type name
- `string Name { get; init; }` -- from StorageDriverAttribute.Name
- `string? Description { get; init; }` -- from attribute
- `string? Version { get; init; }` -- from attribute
- `HardwareDeviceType SupportedDevices { get; init; }` -- from attribute
- `bool AutoLoad { get; init; }` -- from attribute

`DriverHandle` sealed class:
- `string Id { get; }` -- unique handle ID (Guid)
- `DriverInfo Info { get; }` -- driver metadata
- `Type DriverType { get; }` -- the loaded Type object
- `bool IsLoaded { get; }` -- whether still loaded
- Internal constructor (only DriverLoader creates handles)

`DriverEventArgs` record:
- `DriverHandle Handle { get; init; }`
- `DriverEventType EventType { get; init; }`

`DriverEventType` enum: `Loaded`, `Unloaded`, `LoadFailed`, `UnloadFailed`

XML documentation on IDriverLoader explaining:
- Drivers are loaded in isolated AssemblyLoadContexts (via PluginAssemblyLoadContext)
- Unloading releases the context, allowing GC to collect the assembly
- Hot-plug: use with IHardwareProbe.OnHardwareChanged to auto-load/unload
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify both files exist. Grep for `StorageDriverAttribute` in attribute file. Grep for `IDriverLoader` in interface file. Grep for `DriverInfo` and `DriverHandle` confirms supporting types.
  </verify>
  <done>
StorageDriverAttribute defined with Name, SupportedDevices, AutoLoad metadata. IDriverLoader interface defined with ScanAsync, ScanDirectoryAsync, LoadAsync, UnloadAsync, GetLoadedDrivers, GetDriverAsync, and driver lifecycle events. DriverInfo, DriverHandle, and DriverEventArgs supporting types provide driver metadata and lifecycle management.
  </done>
</task>

<task type="auto">
  <name>Task 2: DriverLoader Implementation with Assembly Isolation and Hot-Plug</name>
  <files>
    DataWarehouse.SDK/Hardware/DriverLoader.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/DriverLoader.cs` in namespace `DataWarehouse.SDK.Hardware`.

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 32: Dynamic driver loading implementation (HAL-04)")]
public sealed class DriverLoader : IDriverLoader
```

**Constructor:**
- `DriverLoaderOptions? options = null` -- optional configuration
- `IHardwareProbe? probe = null` -- optional, for hot-plug support

**Options record:**
```csharp
public sealed record DriverLoaderOptions
{
    public string? DriverDirectory { get; init; }  // Directory to watch for hot-plug
    public bool EnableHotPlug { get; init; } = false;  // Watch directory for new DLLs
    public bool AutoLoadOnHardwareChange { get; init; } = false;  // Load drivers when hardware appears
    public int MaxLoadedDrivers { get; init; } = 100;  // Bounded driver count
    public TimeSpan UnloadGracePeriod { get; init; } = TimeSpan.FromSeconds(5);  // Time for driver shutdown
}
```

**Internal state:**
- `ConcurrentDictionary<string, DriverHandle> _loadedDrivers` -- handle ID -> handle
- `ConcurrentDictionary<string, PluginAssemblyLoadContext> _contexts` -- handle ID -> load context
- `FileSystemWatcher? _directoryWatcher` -- for hot-plug directory monitoring
- `SemaphoreSlim _loadLock = new(1, 1)` -- serializes load/unload operations
- `bool _disposed`

**ScanAsync(string assemblyPath, CancellationToken ct):**
1. Validate assemblyPath exists (throw FileNotFoundException if not)
2. Load assembly in MetadataLoadContext (read-only, no execution) to avoid locking the file. Use `MetadataLoadContext` with `PathAssemblyResolver` for reflection-only loading.
3. If MetadataLoadContext is not available or fails, fall back to: create a temporary PluginAssemblyLoadContext (collectible), load assembly, scan, then immediately unload.
4. Find all types with `[StorageDriver]` attribute: `assembly.GetTypes().Where(t => t.GetCustomAttribute<StorageDriverAttribute>() != null && !t.IsAbstract && t.IsClass)`
   - This is the existing pattern from `ConnectionStrategyRegistry.cs` line 94 (research source).
5. Map each type to `DriverInfo` record with metadata from the attribute.
6. Return as IReadOnlyList<DriverInfo>.

**ScanDirectoryAsync(string directoryPath, string searchPattern, CancellationToken ct):**
1. Validate directory exists.
2. Enumerate `Directory.GetFiles(directoryPath, searchPattern)`.
3. For each file, call `ScanAsync`. Aggregate results. Catch and skip assemblies that fail to load (log warning, continue).
4. Return combined list.

**LoadAsync(string assemblyPath, string typeName, CancellationToken ct):**
1. Check `_loadedDrivers.Count < options.MaxLoadedDrivers` -- throw if limit reached (bounded).
2. Acquire `_loadLock`.
3. Create a new `PluginAssemblyLoadContext` with a unique ID (Guid-based), marking it as collectible (`isCollectible: true`).
   - Reuse the constructor pattern from `KernelInfrastructure.cs` lines 182-222 (research source).
4. Load assembly: `context.LoadFromAssemblyPath(assemblyPath)`.
5. Find the type by `typeName` in the loaded assembly.
6. Verify type has `[StorageDriver]` attribute -- throw InvalidOperationException if not.
7. Create `DriverHandle` with Id=Guid.NewGuid(), Info=from attribute, DriverType=loaded type, IsLoaded=true.
8. Store in `_loadedDrivers` and `_contexts`.
9. Release `_loadLock`.
10. Fire `OnDriverLoaded` event.
11. Return handle.

**UnloadAsync(DriverHandle handle, CancellationToken ct):**
1. Acquire `_loadLock`.
2. Verify handle exists in `_loadedDrivers`.
3. Remove from `_loadedDrivers`.
4. Get corresponding `PluginAssemblyLoadContext` from `_contexts`.
5. Call `context.Unload()` -- this triggers the collectible unload.
6. Remove from `_contexts`.
7. Mark handle as unloaded (set internal IsLoaded to false).
8. Release `_loadLock`.
9. Fire `OnDriverUnloaded` event.
10. Allow GC to collect the unloaded assembly (don't force GC -- let it happen naturally).

**GetLoadedDrivers():** Return `_loadedDrivers.Values.ToList().AsReadOnly()`.

**GetDriverAsync(string driverName, CancellationToken ct):** Search `_loadedDrivers.Values` by `Info.Name`. Return first match or null.

**Hot-plug directory watching (if enabled):**
If `options.EnableHotPlug` and `options.DriverDirectory` is set:
1. Create `FileSystemWatcher` on the driver directory.
2. Watch for `*.dll` Created events: scan the new DLL, auto-load drivers with `AutoLoad=true`.
3. Watch for `*.dll` Deleted events: find loaded drivers from that assembly path, unload them.
4. Debounce with 500ms timer (same pattern as PlatformCapabilityRegistry).

**Hot-plug hardware change (if enabled):**
If `options.AutoLoadOnHardwareChange` and `probe` is provided:
1. Subscribe to `probe.OnHardwareChanged`.
2. When hardware added: scan all loaded drivers' SupportedDevices. If a loaded driver matches the new device type, that's already covered. If no loaded driver matches, scan DriverDirectory for a driver that supports the new device type and auto-load it.
3. When hardware removed: optionally unload drivers whose SupportedDevices only match the removed device type (no other matching hardware present). This is conservative -- only unload if the driver has nothing left to serve.

**Dispose:**
- Unload all loaded drivers (call UnloadAsync for each, with a bounded timeout per driver: options.UnloadGracePeriod).
- Stop FileSystemWatcher.
- Unsubscribe from IHardwareProbe events.
- Dispose _loadLock, _directoryWatcher.

**Thread safety:** `_loadLock` serializes load/unload. `ConcurrentDictionary` for _loadedDrivers and _contexts. FileSystemWatcher callbacks debounced.

**Error handling:** All load/unload operations wrapped in try/catch. On failure: fire event with DriverEventType.LoadFailed/UnloadFailed, log, do not throw to caller of hot-plug paths (only throw for explicit LoadAsync/UnloadAsync calls).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists. Grep for `IDriverLoader` confirms interface implementation. Grep for `PluginAssemblyLoadContext` confirms reuse of existing SDK infrastructure. Grep for `StorageDriverAttribute` confirms attribute scanning. Grep for `FileSystemWatcher` confirms hot-plug directory monitoring. Grep for `MaxLoadedDrivers` confirms bounded driver count.
  </verify>
  <done>
DriverLoader implements IDriverLoader with assembly scanning (existing ConnectionStrategyRegistry pattern), isolated loading (PluginAssemblyLoadContext from KernelInfrastructure), collectible unloading, directory-based hot-plug via FileSystemWatcher, and optional hardware-change-triggered auto-loading via IHardwareProbe. All operations serialized via SemaphoreSlim, bounded to MaxLoadedDrivers, with proper IDisposable cleanup.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Three new files exist in DataWarehouse.SDK/Hardware/
3. StorageDriverAttribute has Name, SupportedDevices, AutoLoad, Version properties
4. IDriverLoader has ScanAsync, ScanDirectoryAsync, LoadAsync, UnloadAsync, GetLoadedDrivers
5. DriverLoader uses PluginAssemblyLoadContext (existing SDK infrastructure)
6. Assembly scanning uses GetCustomAttribute<StorageDriverAttribute> pattern (existing pattern)
7. Hot-plug: FileSystemWatcher monitors driver directory for DLL changes
8. Loaded drivers bounded by MaxLoadedDrivers (default 100)
9. DriverHandle tracks loaded state, driver type, and metadata
10. Events fire on load/unload/failure
</verification>

<success_criteria>
- [StorageDriver] attribute marks types for discovery with metadata (name, supported devices, auto-load)
- ScanAsync discovers attributed types in an assembly without permanently loading it
- LoadAsync loads a driver in an isolated PluginAssemblyLoadContext
- UnloadAsync releases the AssemblyLoadContext for GC collection
- Hot-plug directory watching auto-loads new DLLs and unloads removed DLLs
- Reuses existing SDK infrastructure: PluginAssemblyLoadContext, assembly scanning pattern
- Zero new NuGet dependencies
- Zero existing files modified
</success_criteria>

<output>
After completion, create `.planning/phases/32-storage-address-hardware-discovery/32-04-SUMMARY.md`
</output>
