---
phase: 32-storage-address-hardware-discovery
plan: 03
type: execute
wave: 2
depends_on: ["32-02"]
files_modified:
  - DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
  - DataWarehouse.SDK/Hardware/PlatformCapabilityRegistry.cs
autonomous: true

must_haves:
  truths:
    - "registry.HasCapability('qat.compression') returns bool answering whether QAT compression offload is available"
    - "registry.GetDevices(HardwareDeviceType.GpuAccelerator) returns enumerable of GPU devices"
    - "registry.GetCapabilities() returns all discovered capability strings"
    - "Results are cached with configurable TTL -- repeated queries within TTL do not re-probe hardware"
    - "Hardware change events from IHardwareProbe trigger automatic cache refresh after debounce period"
    - "Cache refresh is thread-safe and does not block concurrent reads"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs"
      provides: "Interface with HasCapability, GetDevices, GetCapabilities query API"
      min_lines: 40
    - path: "DataWarehouse.SDK/Hardware/PlatformCapabilityRegistry.cs"
      provides: "Cached implementation with auto-refresh, TTL, and debounced hardware change response"
      min_lines: 200
  key_links:
    - from: "PlatformCapabilityRegistry"
      to: "IHardwareProbe"
      via: "constructor injection, DiscoverAsync for inventory, OnHardwareChanged for refresh"
      pattern: "IHardwareProbe.*_probe"
    - from: "PlatformCapabilityRegistry"
      to: "HardwareDevice"
      via: "builds capability index from discovered devices"
      pattern: "HardwareDevice"
    - from: "PlatformCapabilityRegistry"
      to: "HardwareDeviceType"
      via: "maps device types to capability strings"
      pattern: "HardwareDeviceType"
---

<objective>
Create IPlatformCapabilityRegistry and its cached implementation (HAL-03) -- the runtime query API that answers "what can this machine do?" based on discovered hardware.

Purpose: The capability registry is the primary consumer-facing API for hardware discovery. Instead of requiring callers to interpret raw device records, the registry provides semantic queries ("Has QAT?", "Has GPU?", "How many NVMe namespaces?"). The registry auto-refreshes on hardware changes (USB plug/unplug) with debouncing to avoid flooding. Phase 35 (hardware accelerators) and Phase 36 (edge/IoT) will register additional capability providers.

Output:
- `DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs` -- Interface with query API
- `DataWarehouse.SDK/Hardware/PlatformCapabilityRegistry.cs` -- Cached implementation with auto-refresh
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/32-storage-address-hardware-discovery/32-RESEARCH.md

@DataWarehouse.SDK/Hardware/IHardwareProbe.cs (from 32-02)
@DataWarehouse.SDK/Hardware/HardwareDevice.cs (from 32-02)
@DataWarehouse.SDK/Hardware/HardwareDeviceType.cs (from 32-02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: IPlatformCapabilityRegistry Interface</name>
  <files>
    DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs` in namespace `DataWarehouse.SDK.Hardware`.

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 32: Platform capability registry (HAL-03)")]
public interface IPlatformCapabilityRegistry : IDisposable
```

Methods:
- `bool HasCapability(string capabilityKey)` -- returns true if the platform has the named capability. Capability keys are hierarchical dot-separated strings: "qat.compression", "qat.encryption", "gpu.cuda", "gpu.rocm", "tpm2", "hsm", "nvme", "gpio", "i2c", "spi". Returns cached result if within TTL.
- `IReadOnlyList<HardwareDevice> GetDevices(HardwareDeviceType typeFilter)` -- returns all discovered devices matching the type filter. Returns empty list (never null).
- `IReadOnlyList<HardwareDevice> GetAllDevices()` -- returns all discovered devices regardless of type.
- `IReadOnlyList<string> GetCapabilities()` -- returns all discovered capability keys.
- `int GetDeviceCount(HardwareDeviceType typeFilter)` -- returns count of devices matching filter (avoids materializing full list for simple count queries).
- `Task RefreshAsync(CancellationToken ct = default)` -- forces a re-probe of hardware and rebuilds the capability cache. Called automatically on hardware change events, but can be called manually.
- `event EventHandler<PlatformCapabilityChangedEventArgs>? OnCapabilityChanged` -- fired when capabilities change (device added/removed after refresh).

Also define `PlatformCapabilityChangedEventArgs` record:
- `IReadOnlyList<string> AddedCapabilities { get; init; }`
- `IReadOnlyList<string> RemovedCapabilities { get; init; }`
- `IReadOnlyList<HardwareDevice> AddedDevices { get; init; }`
- `IReadOnlyList<HardwareDevice> RemovedDevices { get; init; }`

Add comprehensive XML documentation explaining:
- Capability keys are dot-separated hierarchical names
- Results are cached; use RefreshAsync to force update
- Thread-safe for concurrent reads
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists. Grep for `HasCapability` and `GetDevices` confirms query methods. Grep for `RefreshAsync` confirms refresh API.
  </verify>
  <done>
IPlatformCapabilityRegistry interface defined with HasCapability, GetDevices, GetAllDevices, GetCapabilities, GetDeviceCount, RefreshAsync, and OnCapabilityChanged event. PlatformCapabilityChangedEventArgs provides change delta.
  </done>
</task>

<task type="auto">
  <name>Task 2: PlatformCapabilityRegistry Cached Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/PlatformCapabilityRegistry.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/PlatformCapabilityRegistry.cs` in namespace `DataWarehouse.SDK.Hardware`.

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 32: Cached platform capability registry (HAL-03)")]
public sealed class PlatformCapabilityRegistry : IPlatformCapabilityRegistry
```

**Constructor:**
- `IHardwareProbe probe` -- the platform-specific probe (from HardwareProbeFactory)
- `PlatformCapabilityRegistryOptions? options = null` -- optional configuration

**Options record:**
```csharp
public sealed record PlatformCapabilityRegistryOptions
{
    public TimeSpan CacheTtl { get; init; } = TimeSpan.FromMinutes(5);
    public TimeSpan HardwareChangeDebounce { get; init; } = TimeSpan.FromMilliseconds(500);
    public bool AutoRefreshOnHardwareChange { get; init; } = true;
}
```

**Internal state:**
- `IHardwareProbe _probe`
- `IReadOnlyList<HardwareDevice> _devices` -- cached device list (start empty, populate on first query or explicit refresh)
- `HashSet<string> _capabilities` -- cached capability keys
- `DateTimeOffset _lastRefresh` -- when cache was last populated
- `SemaphoreSlim _refreshLock = new(1, 1)` -- prevents concurrent refresh operations
- `ReaderWriterLockSlim _cacheLock = new()` -- allows concurrent reads, exclusive writes
- `Timer? _debounceTimer` -- debounce hardware change events
- `bool _disposed`

**Capability derivation logic (private method `DeriveCapabilities`):**

Given a list of `HardwareDevice` records, produce capability keys:
- Device with Type HasFlag NvmeController -> "nvme", "nvme.controller"
- Device with Type HasFlag NvmeNamespace -> "nvme", "nvme.namespace"
- Device with Type HasFlag GpuAccelerator -> "gpu". Check Properties for vendor: NVIDIA -> "gpu.cuda", AMD -> "gpu.rocm", Intel -> "gpu.directml"
- Device with Type HasFlag QatAccelerator -> "qat", "qat.compression", "qat.encryption"
- Device with Type HasFlag TpmDevice -> "tpm2", "tpm2.sealing", "tpm2.attestation"
- Device with Type HasFlag HsmDevice -> "hsm", "hsm.pkcs11"
- Device with Type HasFlag GpioController -> "gpio"
- Device with Type HasFlag I2cBus -> "i2c"
- Device with Type HasFlag SpiBus -> "spi"
- Device with Type HasFlag BlockDevice -> "block"
- Device with Type HasFlag NetworkAdapter -> "network"
- Device with Type HasFlag UsbDevice -> "usb"

**HasCapability(string key):**
1. Check if cache is stale (`_lastRefresh + CacheTtl < DateTimeOffset.UtcNow`). If stale, trigger async refresh (fire-and-forget via `_ = RefreshAsync()`) but still return cached result (don't block the caller).
2. Acquire read lock, check `_capabilities.Contains(key)`, release read lock, return result.
3. If `_devices` is empty and `_lastRefresh == default` (never initialized), do a synchronous-ish init: call `RefreshAsync().GetAwaiter().GetResult()` once. This avoids the cold-start problem where every first call returns false.

**GetDevices(HardwareDeviceType typeFilter):**
1. Same staleness check as HasCapability.
2. Acquire read lock, filter `_devices.Where(d => d.Type.HasFlag(typeFilter))`, return as IReadOnlyList.

**GetAllDevices():** Acquire read lock, return `_devices`.

**GetCapabilities():** Acquire read lock, return `_capabilities.ToList().AsReadOnly()`.

**GetDeviceCount(HardwareDeviceType typeFilter):** Acquire read lock, count matching devices.

**RefreshAsync(CancellationToken ct):**
1. Acquire `_refreshLock` (await). If already refreshing (can't acquire), return immediately (skip duplicate refresh).
2. Call `_probe.DiscoverAsync(ct: ct)` to get fresh device list.
3. Call `DeriveCapabilities(newDevices)` to get new capability set.
4. Compute delta: added capabilities, removed capabilities, added devices, removed devices.
5. Acquire write lock on `_cacheLock`.
6. Swap `_devices` and `_capabilities` with new values. Update `_lastRefresh`.
7. Release write lock.
8. If delta is non-empty, fire `OnCapabilityChanged` with the delta.
9. Release `_refreshLock`.

**Hardware change event handler:**
In constructor, if `options.AutoRefreshOnHardwareChange`, subscribe to `_probe.OnHardwareChanged`. Handler:
1. Reset debounce timer to `options.HardwareChangeDebounce`.
2. When debounce timer fires, call `_ = RefreshAsync()` (fire-and-forget).
This prevents flooding on rapid USB plug/unplug (research pitfall #5).

**Dispose:**
- Dispose `_debounceTimer`, `_refreshLock`, `_cacheLock`
- Unsubscribe from `_probe.OnHardwareChanged`
- Do NOT dispose `_probe` (injected, not owned)

Thread safety: `ReaderWriterLockSlim` for concurrent reads, `SemaphoreSlim` for refresh serialization. All public methods are safe to call from multiple threads. The debounce timer callback captures CancellationToken.None since it runs on a timer thread.

Bounded collections: `_capabilities` HashSet bounded by device count (14 device types * ~5 capabilities each = max ~70). `_devices` bounded by physical hardware (typically <100 devices).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists. Grep for `IPlatformCapabilityRegistry` confirms interface implementation. Grep for `ReaderWriterLockSlim` confirms concurrent read support. Grep for `SemaphoreSlim` confirms refresh serialization. Grep for `DeriveCapabilities` confirms capability derivation. Grep for `_debounceTimer` confirms debouncing.
  </verify>
  <done>
PlatformCapabilityRegistry provides cached, thread-safe capability queries backed by IHardwareProbe. Cache has configurable TTL with background refresh. Hardware change events trigger debounced re-discovery (500ms default). Capability keys derived from device types and properties. OnCapabilityChanged fires with delta when capabilities change. All access patterns are thread-safe (ReaderWriterLockSlim for reads, SemaphoreSlim for refresh).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Two new files exist in DataWarehouse.SDK/Hardware/
3. IPlatformCapabilityRegistry has HasCapability, GetDevices, GetAllDevices, GetCapabilities, GetDeviceCount, RefreshAsync
4. PlatformCapabilityRegistry implements IPlatformCapabilityRegistry
5. Cache TTL is configurable with sensible default (5 minutes)
6. Hardware change debouncing prevents event flooding (500ms)
7. Thread safety: ReaderWriterLockSlim for reads, SemaphoreSlim for refresh
8. Capability keys derived from device types (nvme, gpu.cuda, tpm2, etc.)
9. OnCapabilityChanged fires with delta when capabilities change
10. Proper IDisposable cleanup of timers, locks, and event subscriptions
</verification>

<success_criteria>
- HasCapability("nvme") returns true on a machine with NVMe drives
- GetDevices(HardwareDeviceType.GpuAccelerator) returns GPU devices
- Cached results served within TTL without re-probing
- Hardware change events trigger auto-refresh after debounce
- Thread-safe for concurrent reads and serialized writes
- Zero new NuGet dependencies
- Zero existing files modified
</success_criteria>

<output>
After completion, create `.planning/phases/32-storage-address-hardware-discovery/32-03-SUMMARY.md`
</output>
