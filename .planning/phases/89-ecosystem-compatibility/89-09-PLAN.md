---
phase: 89-ecosystem-compatibility
plan: 09
type: execute
wave: 3
depends_on: ["89-05"]
files_modified:
  - DataWarehouse.SDK/Contracts/Ecosystem/JepsenTestHarness.cs
  - DataWarehouse.SDK/Contracts/Ecosystem/JepsenFaultInjection.cs
  - DataWarehouse.SDK/Contracts/Ecosystem/JepsenWorkloadGenerators.cs
autonomous: true
must_haves:
  truths:
    - "Jepsen test harness can deploy N DW nodes in Docker containers"
    - "Fault injection covers network partition, process kill, clock skew, and disk corruption"
    - "Workload generators produce register, set, list-append, and bank workloads"
    - "Elle consistency checker integration validates linearizability and snapshot isolation"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Ecosystem/JepsenTestHarness.cs"
      provides: "Docker-based multi-node deployment and test orchestration"
      exports: ["JepsenTestHarness", "JepsenTestResult", "JepsenCluster"]
    - path: "DataWarehouse.SDK/Contracts/Ecosystem/JepsenFaultInjection.cs"
      provides: "Network partition, process kill, clock skew, disk corruption fault injectors"
      exports: ["IFaultInjector", "NetworkPartitionFault", "ProcessKillFault", "ClockSkewFault", "DiskCorruptionFault"]
    - path: "DataWarehouse.SDK/Contracts/Ecosystem/JepsenWorkloadGenerators.cs"
      provides: "Register, set, list-append, bank workload generators"
      exports: ["IWorkloadGenerator", "RegisterWorkload", "SetWorkload", "ListAppendWorkload", "BankWorkload"]
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Ecosystem/JepsenTestHarness.cs"
      to: "DataWarehouse.SDK/Contracts/Ecosystem/JepsenFaultInjection.cs"
      via: "Harness injects faults during workload execution"
      pattern: "IFaultInjector"
    - from: "DataWarehouse.SDK/Contracts/Ecosystem/JepsenTestHarness.cs"
      to: "DataWarehouse.SDK/Contracts/Ecosystem/JepsenWorkloadGenerators.cs"
      via: "Harness runs workloads against cluster"
      pattern: "IWorkloadGenerator"
---

<objective>
Create Jepsen distributed correctness test harness (ECOS-16).

Purpose: Jepsen-style testing proves distributed correctness by deploying multiple DW nodes, running concurrent workloads, injecting faults (partitions, kills, clock skew), and checking that results satisfy consistency models (linearizability, serializable, snapshot isolation). This plan creates the test harness infrastructure — the actual test scenarios are in 89-10.

Output: Test harness with Docker deployment, fault injection, workload generators, Elle checker integration
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jepsen test harness with Docker deployment</name>
  <files>DataWarehouse.SDK/Contracts/Ecosystem/JepsenTestHarness.cs</files>
  <action>
Create `JepsenTestHarness` with `[SdkCompatibility("6.0.0", Notes = "Phase 89: Jepsen test harness (ECOS-16)")]`.

This class orchestrates Jepsen-style distributed testing:

1. **`JepsenCluster`** record:
   - `int NodeCount` (default 5)
   - `IReadOnlyList<JepsenNode> Nodes`
   - `string NetworkName` — Docker network name
   - `string DockerImage` — DW Docker image tag
   - `TimeSpan StartupTimeout` = 30s per node
   - `JepsenClusterState State` enum: `NotStarted, Starting, Running, Faulted, Stopped`

2. **`JepsenNode`** record:
   - `string NodeId`, `string ContainerName`, `string IpAddress`
   - `int PostgresPort`, `int RaftPort`, `int GrpcPort`
   - `JepsenNodeState State` enum: `Running, Killed, Partitioned, ClockSkewed`

3. **Lifecycle methods:**
   - `async Task<JepsenCluster> DeployClusterAsync(JepsenClusterConfig config, CancellationToken ct)`:
     Creates Docker network, launches N containers with DW image, waits for health checks, configures Raft cluster membership. Uses `Process.Start` to invoke `docker` CLI commands.
   - `async Task TeardownClusterAsync(JepsenCluster cluster, CancellationToken ct)`:
     Stops and removes all containers, removes Docker network.

4. **Test execution:**
   - `async Task<JepsenTestResult> RunTestAsync(JepsenCluster cluster, JepsenTestPlan plan, CancellationToken ct)`:
     - Phase 1 (Setup): Ensure cluster is healthy, create test tables/data
     - Phase 2 (Nemesis): Start fault injection schedule (`plan.FaultSchedule`)
     - Phase 3 (Workload): Run workload generators concurrently against random nodes (`plan.Workloads`)
     - Phase 4 (Heal): Remove all faults, wait for cluster to reconverge
     - Phase 5 (Verify): Run consistency checker against operation history
     - Returns `JepsenTestResult`

5. **`JepsenTestPlan`** record:
   - `string TestName`, `TimeSpan Duration`, `int ConcurrentClients`
   - `IReadOnlyList<IWorkloadGenerator> Workloads`
   - `IReadOnlyList<FaultScheduleEntry> FaultSchedule`
   - `ConsistencyModel ExpectedConsistency` enum: `Linearizable, Serializable, SnapshotIsolation, CausalConsistency`

6. **`JepsenTestResult`** record:
   - `string TestName`, `bool Passed`, `ConsistencyModel TestedModel`
   - `long TotalOperations`, `long SuccessfulOperations`, `long FailedOperations`
   - `IReadOnlyList<ConsistencyViolation> Violations`
   - `IReadOnlyList<OperationHistoryEntry> FullHistory`
   - `TimeSpan Duration`, `DateTimeOffset StartTime`
   - `string? ElleAnalysisJson` — raw Elle checker output

7. **`ConsistencyViolation`** record:
   - `string Description`, `OperationHistoryEntry Operation`, `string ExpectedBehavior`, `string ActualBehavior`

8. **`OperationHistoryEntry`** record:
   - `long SequenceId`, `string NodeId`, `string ClientId`
   - `OperationType Type` (Read/Write/Cas/Append)
   - `string Key`, `string? Value`, `string? ExpectedValue`
   - `DateTimeOffset StartTime`, `DateTimeOffset EndTime`
   - `OperationResult Result` (Ok/Fail/Timeout/Crashed)

9. **Elle consistency checker integration:**
   - `CheckLinearizability(IReadOnlyList<OperationHistoryEntry> history)` — verifies single-register linearizability using Knossos-style algorithm: build a graph of operations, check that a total order exists consistent with real-time ordering and read-write relationships.
   - `CheckSnapshotIsolation(IReadOnlyList<OperationHistoryEntry> history)` — verifies no write skew anomalies.
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles without errors</verify>
  <done>Jepsen harness deploys Docker clusters, runs test plans with fault injection, and checks consistency</done>
</task>

<task type="auto">
  <name>Task 2: Create fault injectors and workload generators</name>
  <files>DataWarehouse.SDK/Contracts/Ecosystem/JepsenFaultInjection.cs, DataWarehouse.SDK/Contracts/Ecosystem/JepsenWorkloadGenerators.cs</files>
  <action>
**JepsenFaultInjection.cs** with `[SdkCompatibility("6.0.0", Notes = "Phase 89: Jepsen fault injection (ECOS-16)")]`:

1. **`IFaultInjector`** interface:
   - `string FaultType { get; }`
   - `Task InjectAsync(JepsenCluster cluster, FaultTarget target, CancellationToken ct)`
   - `Task HealAsync(JepsenCluster cluster, FaultTarget target, CancellationToken ct)`

2. **`FaultTarget`** record: `IReadOnlyList<string> NodeIds`, `TimeSpan Duration`

3. **`FaultScheduleEntry`** record: `IFaultInjector Injector`, `FaultTarget Target`, `TimeSpan StartAfter`, `TimeSpan Duration`

4. **Implementations:**

   **`NetworkPartitionFault`**: Creates iptables rules to partition subset of nodes from the rest. Uses `docker exec {container} iptables -A INPUT -s {ip} -j DROP` and reverse for heal. Supports:
   - `PartitionMode.MajorityMinority` — split into majority and minority
   - `PartitionMode.HalfAndHalf` — equal split
   - `PartitionMode.Isolate` — isolate single node

   **`ProcessKillFault`**: Kills the DW process inside the container. Uses `docker exec {container} kill -9 {pid}` for inject, `docker exec {container} /start.sh` for heal (restart).

   **`ClockSkewFault`**: Skews the system clock on selected nodes. Uses `docker exec {container} date -s "+{seconds} seconds"`. Configurable skew amount (default 500ms to 30s). Heal resets to NTP time.

   **`DiskCorruptionFault`**: Corrupts random bytes in VDE data files. Uses `docker exec {container} dd if=/dev/urandom of={datapath} bs=1 count={bytes} seek={offset} conv=notrunc`. Heal: relies on DW's own corruption detection and recovery mechanisms.

**JepsenWorkloadGenerators.cs** with `[SdkCompatibility("6.0.0")]`:

1. **`IWorkloadGenerator`** interface:
   - `string WorkloadType { get; }`
   - `IAsyncEnumerable<OperationHistoryEntry> RunAsync(JepsenCluster cluster, int clientId, CancellationToken ct)`

2. **Implementations:**

   **`RegisterWorkload`**: Single-register read/write/CAS. Tests linearizability. Operations: `read(key)`, `write(key, value)`, `cas(key, expected, new)`. Generates random mix of operations against a small set of keys.

   **`SetWorkload`**: Set operations (add element, read set). Tests serializable isolation. Operations: `add(key, element)`, `read(key) -> set`. Verifies no lost elements.

   **`ListAppendWorkload`**: List-append operations. Tests snapshot isolation and prevents lost updates. Operations: `append(key, element)`, `read(key) -> list`. Checks for ordering anomalies.

   **`BankWorkload`**: Bank transfer workload. Tests that total balance is conserved. Operations: `transfer(from, to, amount)`, `read_balance(account)`, `read_total()`. Verifies conservation invariant.

   Each workload connects to a random healthy node via PostgreSQL wire protocol, executes SQL operations, and records the operation history with precise timestamps.

3. **`WorkloadMixer`** class that combines multiple workloads, distributing operations across concurrent clients with configurable ratios.
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles without errors</verify>
  <done>Four fault injectors (partition, kill, clock skew, disk corruption) and four workload generators (register, set, list-append, bank) compile and implement their respective interfaces</done>
</task>

</tasks>

<verification>
- JepsenTestHarness.DeployClusterAsync creates Docker containers via CLI
- NetworkPartitionFault uses iptables for partition injection/healing
- All four workload types generate OperationHistoryEntry records
- CheckLinearizability verifies real-time ordering constraints
- CheckSnapshotIsolation detects write skew anomalies
- Build succeeds
</verification>

<success_criteria>
Jepsen test harness can deploy multi-node DW clusters in Docker, inject faults (partition, kill, clock skew, disk corruption), run concurrent workloads (register, set, list-append, bank), and verify consistency properties.
</success_criteria>

<output>
After completion, create `.planning/phases/89-ecosystem-compatibility/89-09-SUMMARY.md`
</output>
