---
phase: 89-ecosystem-compatibility
plan: 05
type: execute
wave: 2
depends_on: ["89-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlSqlEngineIntegration.cs
  - Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlTypeMapping.cs
  - Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlCatalogProvider.cs
autonomous: true
must_haves:
  truths:
    - "PostgreSQL wire protocol routes SQL queries through SqlParserEngine -> CostBasedQueryPlanner -> QueryExecutionEngine"
    - "PostgreSQL OID type system maps correctly to DW ColumnDataType"
    - "\\d catalog queries return table/column metadata from VDE storage"
    - "BEGIN/COMMIT/ROLLBACK map to DW MVCC transaction primitives"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlSqlEngineIntegration.cs"
      provides: "Integration layer between PostgreSQL protocol and SQL engine"
      exports: ["PostgreSqlSqlEngineIntegration"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlTypeMapping.cs"
      provides: "PostgreSQL OID to ColumnDataType bidirectional mapping"
      exports: ["PostgreSqlTypeMapping"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlCatalogProvider.cs"
      provides: "pg_catalog schema queries for \\d commands"
      exports: ["PostgreSqlCatalogProvider"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlSqlEngineIntegration.cs"
      to: "DataWarehouse.SDK/Contracts/Query/SqlParserEngine.cs"
      via: "Parses SQL from wire protocol"
      pattern: "SqlParserEngine"
    - from: "Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlSqlEngineIntegration.cs"
      to: "DataWarehouse.SDK/Contracts/Query/CostBasedQueryPlanner.cs"
      via: "Plans query execution"
      pattern: "CostBasedQueryPlanner"
    - from: "Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlSqlEngineIntegration.cs"
      to: "DataWarehouse.SDK/Contracts/Query/QueryExecutionEngine.cs"
      via: "Executes planned query"
      pattern: "QueryExecutionEngine"
---

<objective>
Wire PostgreSQL wire protocol to the SQL engine pipeline (ECOS-02).

Purpose: The PostgreSQL wire protocol receives SQL strings from clients (psql, pgAdmin, etc.) but needs to route them through the DW SQL engine (SqlParserEngine -> CostBasedQueryPlanner -> QueryExecutionEngine) for actual execution against VDE storage. This plan creates the integration layer, type mapping, and catalog provider that make DW appear as a PostgreSQL-compatible database.

Output: SQL engine integration, PostgreSQL OID type mapping, pg_catalog provider for \d queries
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlProtocolStrategy.cs
@DataWarehouse.SDK/Contracts/Query/SqlParserEngine.cs
@DataWarehouse.SDK/Contracts/Query/CostBasedQueryPlanner.cs
@DataWarehouse.SDK/Contracts/Query/QueryExecutionEngine.cs
@DataWarehouse.SDK/Contracts/Query/ColumnarBatch.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL-to-SQL-engine integration layer</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlSqlEngineIntegration.cs</files>
  <action>
Create `PostgreSqlSqlEngineIntegration` class with `[SdkCompatibility("6.0.0", Notes = "Phase 89: PostgreSQL SQL integration (ECOS-02)")]`.

This class bridges the PostgreSQL wire protocol to the DW SQL engine pipeline:

1. **`ExecuteSimpleQueryAsync(string sql, CancellationToken ct)`** — for Simple Query protocol:
   - Parse SQL using `SqlParserEngine.Parse(sql)` -> `SqlStatement`
   - If `SelectStatement`: plan via `CostBasedQueryPlanner.Plan(selectStmt, statsProvider)` -> `QueryPlanNode`, execute via `QueryExecutionEngine.Execute(plan, dataSource)` -> `IAsyncEnumerable<ColumnarBatch>`, convert each batch to PostgreSQL DataRow messages via `PostgreSqlTypeMapping`
   - If `InsertStatement` / `UpdateStatement` / `DeleteStatement`: execute DML and return CommandComplete with affected row count
   - If `CreateTableStatement` / `DropTableStatement`: execute DDL via VDE metadata operations
   - If transaction statement (BEGIN/COMMIT/ROLLBACK): manage transaction state
   - Returns `PostgreSqlQueryResult` containing: `RowDescription` (column names + OIDs), `List<DataRow>` (values), `CommandTag` (e.g., "SELECT 5", "INSERT 0 1")

2. **`ExecuteExtendedQueryAsync(ParsedStatement parsed, BindParameters bind, int maxRows, CancellationToken ct)`** — for Extended Query protocol:
   - Uses cached parsed statement from Parse phase
   - Binds parameter values from Bind message
   - Executes with optional row limit from Execute message
   - Returns same result structure

3. **`PrepareStatementAsync(string name, string sql, int[] paramOids, CancellationToken ct)`** — Parse phase:
   - Parses SQL and caches the AST keyed by statement name
   - Returns `ParameterDescription` (inferred parameter types) and `RowDescription` (result columns)

4. **Transaction management:**
   - `BeginTransactionAsync()` — creates MVCC snapshot
   - `CommitTransactionAsync()` — commits pending changes
   - `RollbackTransactionAsync()` — discards pending changes
   - Tracks transaction state ('I' = idle, 'T' = in transaction, 'E' = failed transaction)

5. **`IDataSourceProvider` implementation** that bridges to VDE storage:
   - `GetTableData(tableName, columns, ct)` reads from VDE columnar regions
   - `GetTableStatistics(tableName)` returns row count and column statistics from VDE metadata

Uses a `ConcurrentDictionary<string, (SqlStatement Ast, QueryPlanNode? Plan)>` for prepared statement cache.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/DataWarehouse.Plugins.UltimateDatabaseProtocol.csproj` compiles</verify>
  <done>SQL engine integration routes queries through parse -> plan -> execute pipeline. Transaction management tracks I/T/E state. Prepared statement caching works.</done>
</task>

<task type="auto">
  <name>Task 2: Create type mapping and catalog provider</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlTypeMapping.cs, Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Strategies/Relational/PostgreSqlCatalogProvider.cs</files>
  <action>
**PostgreSqlTypeMapping.cs** with `[SdkCompatibility("6.0.0")]`:

Bidirectional mapping between PostgreSQL OIDs and DW `ColumnDataType`:

| PostgreSQL OID | PostgreSQL Type | ColumnDataType |
|----------------|----------------|----------------|
| 23 | int4 | Int32 |
| 20 | int8 | Int64 |
| 701 | float8 | Float64 |
| 25 | text | String |
| 1043 | varchar | String |
| 16 | bool | Bool |
| 17 | bytea | Binary |
| 1700 | numeric | Decimal |
| 1114 | timestamp | DateTime |
| 1184 | timestamptz | DateTime |
| 0 | void | Null |

Methods:
- `static int ToOid(ColumnDataType type)` — DW type to PostgreSQL OID
- `static ColumnDataType FromOid(int oid)` — OID to DW type (unknown OIDs -> String)
- `static string ToPostgresTypeName(ColumnDataType type)` — for RowDescription
- `static short GetTypeSize(int oid)` — -1 for variable, 4 for int4, 8 for int8/float8, etc.
- `static int GetTypeModifier(int oid)` — -1 for unmodified
- `static short GetFormatCode(int oid)` — 0 for text, 1 for binary
- `static byte[] SerializeValue(object? value, ColumnDataType type, bool binaryFormat)` — serialize a DW value to PostgreSQL wire format (text or binary)
- `static object? DeserializeValue(ReadOnlySpan<byte> data, int oid, bool binaryFormat)` — deserialize PostgreSQL wire value to DW object

**PostgreSqlCatalogProvider.cs** with `[SdkCompatibility("6.0.0")]`:

Handles `\d` and other catalog queries by implementing virtual pg_catalog tables:

1. `HandleCatalogQuery(string sql, CancellationToken ct)` — detects catalog queries:
   - `\d` / `\dt` -> `SELECT tablename FROM pg_catalog.pg_tables WHERE schemaname = 'public'`
   - `\d tablename` -> `SELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name = 'tablename'`
   - Queries against `pg_catalog.pg_class`, `pg_catalog.pg_attribute`, `pg_catalog.pg_type`, `pg_catalog.pg_namespace`

2. Virtual catalog tables backed by VDE metadata:
   - `pg_tables`: lists all tables in VDE storage
   - `pg_class`: table OIDs and metadata
   - `pg_attribute`: column definitions per table
   - `pg_type`: type OID registry
   - `pg_namespace`: schema names (default: 'public')
   - `information_schema.columns`: standard column metadata view

3. `IsCatalogQuery(string sql)` — returns true if the query targets pg_catalog or information_schema.

Each virtual table returns `ColumnarBatch` results that can be serialized through the normal query result path.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/DataWarehouse.Plugins.UltimateDatabaseProtocol.csproj` compiles</verify>
  <done>Type mapping handles all OID <-> ColumnDataType conversions with text and binary serialization. Catalog provider serves \d queries from VDE metadata.</done>
</task>

</tasks>

<verification>
- SQL flows through SqlParserEngine -> CostBasedQueryPlanner -> QueryExecutionEngine
- OID mapping covers int4, int8, float8, text, varchar, bool, bytea, numeric, timestamp, timestamptz
- Catalog queries return table/column metadata from VDE
- Transaction state tracking (I/T/E) works correctly
- Build succeeds
</verification>

<success_criteria>
`psql` clients can connect and run: CREATE TABLE, INSERT, SELECT, \d, BEGIN/COMMIT/ROLLBACK through the full SQL engine pipeline with correct type mapping.
</success_criteria>

<output>
After completion, create `.planning/phases/89-ecosystem-compatibility/89-05-SUMMARY.md`
</output>
