---
phase: 89-ecosystem-compatibility
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Ecosystem/IConnectionPool.cs
  - DataWarehouse.SDK/Contracts/Ecosystem/ConnectionPoolImplementations.cs
autonomous: true
must_haves:
  truths:
    - "Generic IConnectionPool<TConnection> contract exists with configurable min/max/idle/health parameters"
    - "TCP, gRPC channel, and HTTP/2 pool implementations exist as production-ready SDK contracts"
    - "Per-node connection limits prevent resource exhaustion in distributed topologies"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Ecosystem/IConnectionPool.cs"
      provides: "Generic connection pool contract"
      exports: ["IConnectionPool", "IPooledConnection", "ConnectionPoolOptions", "PoolHealthReport"]
    - path: "DataWarehouse.SDK/Contracts/Ecosystem/ConnectionPoolImplementations.cs"
      provides: "TCP, gRPC, HTTP/2 pool implementations"
      exports: ["TcpConnectionPool", "GrpcChannelPool", "Http2ConnectionPool"]
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Ecosystem/IConnectionPool.cs"
      to: "Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Infrastructure/ConnectionPoolManager.cs"
      via: "Replaces ad-hoc pooling with SDK contract"
      pattern: "IConnectionPool"
---

<objective>
Create the generic SDK connection pooling contract and implementations (ECOS-18).

Purpose: All inter-node communication (Raft, replication, fabric) and client SDK connections must use pooled connections. The SDK contract standardizes pool behavior across TCP, gRPC, and HTTP/2 transports, replacing per-call socket creation with health-checked, bounded pools.

Output: IConnectionPool<T> interface, three transport-specific implementations, pool health reporting
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/Infrastructure/ConnectionPoolManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IConnectionPool SDK contract and options</name>
  <files>DataWarehouse.SDK/Contracts/Ecosystem/IConnectionPool.cs</files>
  <action>
Create the generic connection pool SDK contract with `[SdkCompatibility("6.0.0", Notes = "Phase 89: Connection pooling (ECOS-18)")]`:

1. **`IPooledConnection<TConnection>`** interface:
   - `TConnection Connection { get; }` — the underlying connection
   - `DateTimeOffset AcquiredAt { get; }` — when this lease started
   - `DateTimeOffset CreatedAt { get; }` — when the connection was created
   - `bool IsHealthy { get; }` — current health status
   - Implements `IAsyncDisposable` (returning to pool on dispose)

2. **`IConnectionPool<TConnection>`** interface:
   - `ValueTask<IPooledConnection<TConnection>> AcquireAsync(string nodeId, CancellationToken ct)` — acquire from pool, respecting per-node limits
   - `ValueTask ReleaseAsync(IPooledConnection<TConnection> connection, CancellationToken ct)` — explicit release (also handled by dispose)
   - `ValueTask<PoolHealthReport> GetHealthAsync(CancellationToken ct)` — pool diagnostics
   - `ValueTask DrainAsync(CancellationToken ct)` — graceful shutdown, close all connections
   - `ValueTask DrainNodeAsync(string nodeId, CancellationToken ct)` — drain connections for a specific node
   - Implements `IAsyncDisposable`

3. **`ConnectionPoolOptions`** record:
   - `int MinConnections { get; init; } = 2` — minimum idle connections per node
   - `int MaxConnections { get; init; } = 100` — hard cap per node
   - `int MaxTotalConnections { get; init; } = 1000` — global cap across all nodes
   - `TimeSpan AcquireTimeout { get; init; } = TimeSpan.FromSeconds(30)`
   - `TimeSpan IdleTimeout { get; init; } = TimeSpan.FromMinutes(5)`
   - `TimeSpan MaxLifetime { get; init; } = TimeSpan.FromHours(1)` — force recycle
   - `TimeSpan HealthCheckInterval { get; init; } = TimeSpan.FromSeconds(30)`
   - `bool ValidateOnAcquire { get; init; } = true`
   - `bool ValidateOnRelease { get; init; } = false`
   - `int WarmUpCountPerNode { get; init; } = 2`

4. **`PoolHealthReport`** record:
   - `int TotalConnections`, `int ActiveConnections`, `int IdleConnections`
   - `int FailedHealthChecks`, `int ConnectionsCreated`, `int ConnectionsDestroyed`
   - `Dictionary<string, NodePoolStatus> PerNodeStatus`
   - `DateTimeOffset LastHealthCheck`

5. **`NodePoolStatus`** record:
   - `string NodeId`, `int Active`, `int Idle`, `int Pending`, `bool Healthy`

6. **`IConnectionFactory<TConnection>`** interface:
   - `ValueTask<TConnection> CreateAsync(string endpoint, CancellationToken ct)`
   - `ValueTask<bool> ValidateAsync(TConnection connection, CancellationToken ct)`
   - `ValueTask DestroyAsync(TConnection connection, CancellationToken ct)`
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles without errors</verify>
  <done>IConnectionPool<T>, IPooledConnection<T>, IConnectionFactory<T>, ConnectionPoolOptions, PoolHealthReport all compile as SDK contracts</done>
</task>

<task type="auto">
  <name>Task 2: Create TCP, gRPC, and HTTP/2 pool implementations</name>
  <files>DataWarehouse.SDK/Contracts/Ecosystem/ConnectionPoolImplementations.cs</files>
  <action>
Implement three connection pool specializations, all extending a shared `ConnectionPoolBase<TConnection>` abstract class. All classes get `[SdkCompatibility("6.0.0", Notes = "Phase 89: Connection pooling (ECOS-18)")]`.

**`ConnectionPoolBase<TConnection>`** abstract class:
- Implements `IConnectionPool<TConnection>` with the core pooling logic
- Uses `ConcurrentDictionary<string, ConcurrentBag<PoolEntry<TConnection>>>` for per-node idle pools
- Uses `SemaphoreSlim` per node for max connection enforcement
- Uses a global `SemaphoreSlim` for `MaxTotalConnections`
- Background `Timer` for health checking (calls `IConnectionFactory<T>.ValidateAsync`)
- Background `Timer` for idle eviction (removes connections idle longer than `IdleTimeout`)
- `AcquireAsync`: try idle pool first, else create via factory (respecting semaphores), throw `TimeoutException` if `AcquireTimeout` exceeded
- `ReleaseAsync`: if connection healthy and under max lifetime, return to idle pool; else destroy
- `DrainAsync`: close all connections, cancel background timers
- Tracks metrics for `PoolHealthReport`

**`TcpConnectionPool`**: `ConnectionPoolBase<TcpPooledStream>` where `TcpPooledStream` wraps `System.Net.Sockets.Socket` + `NetworkStream`. Factory creates TCP connections to `endpoint` (parsed as `host:port`). Validate sends a 1-byte probe. Used for Raft, replication, and fabric inter-node communication.

**`GrpcChannelPool`**: `ConnectionPoolBase<GrpcPooledChannel>` where `GrpcPooledChannel` wraps a logical gRPC channel (represented as endpoint string + channel ID since actual Grpc.Net.Client is external). Factory stores endpoint metadata. Validate checks channel state. Used by client SDKs.

**`Http2ConnectionPool`**: `ConnectionPoolBase<Http2PooledConnection>` where `Http2PooledConnection` wraps `HttpClient` configured for HTTP/2. Factory creates `HttpClient` with `HttpVersionPolicy.RequestVersionExact` and `Version = HttpVersion.Version20`. Validate sends a HEAD request. Used for REST and Arrow Flight connections.

Each pool implementation creates its own `IConnectionFactory<T>` as a private nested class.
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles without errors</verify>
  <done>Three pool implementations compile with per-node limits, health checking, idle eviction, and graceful drain</done>
</task>

</tasks>

<verification>
- IConnectionPool<T> contract is generic and transport-agnostic
- Three implementations cover TCP, gRPC, and HTTP/2 transports
- Per-node connection limits enforced via semaphores
- Background health checking and idle eviction implemented
- Build succeeds with zero errors
</verification>

<success_criteria>
SDK connection pooling contract exists with three transport implementations. All inter-node communication patterns (Raft, replication, fabric, client SDK, REST, Arrow Flight) have a pool type to use.
</success_criteria>

<output>
After completion, create `.planning/phases/89-ecosystem-compatibility/89-02-SUMMARY.md`
</output>
