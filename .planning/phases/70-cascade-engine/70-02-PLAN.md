---
phase: 70-cascade-engine
plan: 02
type: execute
wave: 2
depends_on: ["70-01"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/CascadeStrategies.cs
  - DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
  - DataWarehouse.SDK/Infrastructure/Policy/PolicyCategoryDefaults.cs
autonomous: true

must_haves:
  truths:
    - "MostRestrictive picks the lowest intensity and most restrictive AI autonomy across the chain"
    - "Enforce at higher level ALWAYS overrides Override at lower level"
    - "Merge combines custom parameters per-key from the chain"
    - "Default cascade strategy per category is applied: Security=MostRestrictive, Performance=Override, Governance=Merge, Compliance=Enforce"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/CascadeStrategies.cs"
      provides: "Individual cascade strategy implementations"
      contains: "static class CascadeStrategies"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/PolicyCategoryDefaults.cs"
      provides: "Default cascade strategy mapping per feature category"
      contains: "class PolicyCategoryDefaults"
  key_links:
    - from: "PolicyResolutionEngine"
      to: "CascadeStrategies"
      via: "ApplyCascade dispatches to strategy methods"
      pattern: "CascadeStrategies\\."
    - from: "PolicyResolutionEngine"
      to: "PolicyCategoryDefaults"
      via: "Looks up default cascade when no explicit strategy set"
      pattern: "PolicyCategoryDefaults"
---

<objective>
Implement all five cascade strategy algorithms and wire the per-category defaults into the resolution engine.

Purpose: Without strategies, the engine only handles Inherit/Override. This plan completes the strategy set (CASC-02, CASC-05) and ensures the correct default strategy is applied per feature category.
Output: Full cascade strategy implementations, category default mapping, and updated engine dispatch.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/IEffectivePolicy.cs
@.planning/phases/70-cascade-engine/70-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CascadeStrategies and PolicyCategoryDefaults</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/CascadeStrategies.cs
    DataWarehouse.SDK/Infrastructure/Policy/PolicyCategoryDefaults.cs
  </files>
  <action>
Create CascadeStrategies as a static class with a method per strategy. Each method takes IReadOnlyList&lt;FeaturePolicy&gt; (ordered most-specific first) and returns (int intensity, AiAutonomyLevel aiAutonomy, Dictionary&lt;string,string&gt; mergedParams, PolicyLevel decidedAt):

1. **Inherit**: Return the first non-null entry in the chain (most specific that exists). Already the default behavior -- just take chain[0] since nulls are filtered before calling.

2. **Override**: Return the most-specific (chain[0]) entry. Parent values completely discarded. DecidedAt = chain[0].Level.

3. **MostRestrictive**: Walk entire chain. Intensity = Math.Min across all entries. AiAutonomy = lowest enum value (ManualOnly < Suggest < ... < AutoSilent), so take Math.Min of cast int values. MergedParams = intersect keys, take the most restrictive value (lowest if numeric, first alphabetically otherwise). DecidedAt = level of the entry that contributed the min intensity.

4. **Enforce**: Find the HIGHEST-level (closest to VDE, i.e., largest PolicyLevel enum value) entry in the chain that has Cascade=Enforce. If found, that entry's values win unconditionally -- even if a lower-level has Override. If no Enforce entry exists, fall back to Override behavior. This is the CASC-05 critical requirement: "Enforce at higher level overrides Override at lower level."

5. **Merge**: Combine custom parameters from all entries. Start from least-specific (reverse order), overlay more-specific keys on top. Intensity and AiAutonomy come from the most-specific entry (chain[0]). DecidedAt = chain[0].Level. For mergedParams, child keys overwrite parent keys.

Create PolicyCategoryDefaults as a sealed class with:
- A static readonly Dictionary&lt;string, CascadeStrategy&gt; mapping category names to default strategies:
  - "security" -> MostRestrictive
  - "encryption" -> MostRestrictive
  - "access_control" -> MostRestrictive
  - "performance" -> Override
  - "compression" -> Override
  - "governance" -> Merge
  - "compliance" -> Enforce
  - "audit" -> Enforce
  - "replication" -> Inherit
- A static method GetDefaultStrategy(string featureId) that looks up the category (featureId may contain a category prefix like "security.encryption" or be a known feature name). If no match, return Inherit as the safe default.
- Allow user-provided overrides via a constructor parameter Dictionary&lt;string, CascadeStrategy&gt; that supplements/overrides the static defaults.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>All 5 cascade strategies implemented. PolicyCategoryDefaults maps Security=MostRestrictive, Performance=Override, Governance=Merge, Compliance=Enforce per CASC-02.</done>
</task>

<task type="auto">
  <name>Task 2: Wire strategies into PolicyResolutionEngine</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
  </files>
  <action>
Update PolicyResolutionEngine to use CascadeStrategies:

1. Add PolicyCategoryDefaults as an optional constructor parameter (null = use static defaults only).
2. In the ApplyCascade method (or equivalent extensibility point from Plan 01), replace the Inherit/Override-only logic with a switch on CascadeStrategy enum that dispatches to the corresponding CascadeStrategies static method.
3. During ResolveAsync, determine the effective cascade strategy for a feature:
   a. Check the most-specific policy in the resolution chain -- if it has an explicit Cascade value, use that.
   b. If the cascade is Inherit (the zero/default), look up the feature's category default from PolicyCategoryDefaults.
   c. Special handling for Enforce: scan the entire chain for any entry with Cascade=Enforce. If found at a higher level, that entry wins regardless of what lower levels specify. This implements CASC-05.
4. For Enforce specifically: before applying the most-specific-first logic, check if ANY entry in the chain (at a HIGHER level than the most-specific) has Cascade=Enforce. If yes, use the Enforce strategy on the sub-chain starting from that enforcing level upward. This ensures a VDE-level Enforce overrides a Container-level Override.

Do NOT break the existing path-parsing or level-walk logic from Plan 01. Only modify the strategy-application section.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>PolicyResolutionEngine dispatches to all 5 strategies. Enforce at higher level always wins over Override at lower level (CASC-05). Category defaults applied when no explicit cascade set (CASC-02).</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- CascadeStrategies has methods for all 5 strategies
- PolicyCategoryDefaults has correct category-to-strategy mapping
- PolicyResolutionEngine dispatches to correct strategy based on policy and category defaults
</verification>

<success_criteria>
- CASC-02 satisfied: default cascade strategies per category match spec
- CASC-05 satisfied: Enforce at higher level overrides Override at lower level
- All 5 cascade strategies (MostRestrictive, Enforce, Inherit, Override, Merge) fully implemented
</success_criteria>

<output>
After completion, create `.planning/phases/70-cascade-engine/70-02-SUMMARY.md`
</output>
