---
phase: 70-cascade-engine
plan: 03
type: execute
wave: 3
depends_on: ["70-01", "70-02"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/CascadeOverrideStore.cs
  - DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
autonomous: true

must_haves:
  truths:
    - "User can set a cascade strategy override for any feature at any level"
    - "Override is persisted and survives engine restart"
    - "Resolution engine checks override store before applying category defaults"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/CascadeOverrideStore.cs"
      provides: "Per-feature per-level cascade strategy override storage"
      contains: "class CascadeOverrideStore"
  key_links:
    - from: "PolicyResolutionEngine"
      to: "CascadeOverrideStore"
      via: "Checks for user override before category default"
      pattern: "_overrideStore|CascadeOverrideStore"
    - from: "CascadeOverrideStore"
      to: "IPolicyPersistence"
      via: "Persists override configuration"
      pattern: "IPolicyPersistence|SaveAsync"
---

<objective>
Add per-feature per-level cascade strategy override support so users can customize how policies cascade for specific features at specific hierarchy levels.

Purpose: CASC-03 requires user-configurable cascade strategies. Without this, only category defaults apply. Users need to say "for encryption at the Container level, use Enforce instead of the default MostRestrictive."
Output: CascadeOverrideStore with CRUD + persistence, engine integration that checks overrides before defaults.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@.planning/phases/70-cascade-engine/70-01-SUMMARY.md
@.planning/phases/70-cascade-engine/70-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CascadeOverrideStore</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/CascadeOverrideStore.cs
  </files>
  <action>
Create CascadeOverrideStore in DataWarehouse.SDK.Infrastructure.Policy:

- Thread-safe via ConcurrentDictionary&lt;string, CascadeStrategy&gt; keyed by "featureId:level" composite key
- Methods:
  - SetOverride(string featureId, PolicyLevel level, CascadeStrategy strategy): stores the override
  - RemoveOverride(string featureId, PolicyLevel level): removes the override
  - TryGetOverride(string featureId, PolicyLevel level, out CascadeStrategy strategy): returns true if override exists
  - GetAllOverrides(): returns IReadOnlyDictionary&lt;(string FeatureId, PolicyLevel Level), CascadeStrategy&gt;
  - LoadFromPersistence(IPolicyPersistence persistence, CancellationToken ct): loads saved overrides on startup. Use a well-known feature ID convention like "__cascade_override__" to store override config as a FeaturePolicy in the persistence layer, with the overrides serialized in CustomParameters dictionary (key="featureId:level", value=strategy enum name).
  - SaveToPersistence(IPolicyPersistence persistence, CancellationToken ct): persists current overrides using the same convention.

- Bounded capacity (max 10_000 overrides to prevent abuse)
- [SdkCompatibility("6.0.0", Notes = "Phase 70: User cascade overrides (CASC-03)")]

This approach reuses the existing IPolicyPersistence infrastructure without requiring schema changes.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>CascadeOverrideStore compiles with full CRUD, persistence load/save, and bounded capacity.</done>
</task>

<task type="auto">
  <name>Task 2: Wire CascadeOverrideStore into PolicyResolutionEngine</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
  </files>
  <action>
Update PolicyResolutionEngine:

1. Add optional CascadeOverrideStore as constructor parameter (null = no user overrides).
2. In the cascade strategy determination logic (from Plan 02 Task 2), insert override check BEFORE category default lookup:
   a. Check CascadeOverrideStore.TryGetOverride(featureId, level) for the most-specific level in the chain
   b. If override found, use that strategy
   c. If no override, check the policy's explicit Cascade field
   d. If policy's Cascade is Inherit (default), fall back to PolicyCategoryDefaults
3. For Enforce override: if user overrides a feature to Enforce at VDE level, that MUST win over any lower-level Override policies. The existing Enforce logic from Plan 02 already handles this -- just ensure the override-injected strategy participates in the Enforce scan.
4. Add public methods to expose override management through the engine:
   - SetCascadeOverride(string featureId, PolicyLevel level, CascadeStrategy strategy, CancellationToken ct): sets override and persists
   - RemoveCascadeOverride(string featureId, PolicyLevel level, CancellationToken ct): removes override and persists
   - GetCascadeOverrides(): returns current overrides

Do NOT change any existing method signatures. Only ADD the override check in the strategy determination path.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>PolicyResolutionEngine checks CascadeOverrideStore before category defaults. Override management methods exposed. Overrides are persisted via IPolicyPersistence.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- CascadeOverrideStore provides thread-safe CRUD with persistence
- PolicyResolutionEngine cascade strategy resolution order: user override > policy explicit > category default
</verification>

<success_criteria>
- CASC-03 satisfied: user can override cascade strategy per feature per level and the override is respected
- Overrides persist across engine restart via IPolicyPersistence
</success_criteria>

<output>
After completion, create `.planning/phases/70-cascade-engine/70-03-SUMMARY.md`
</output>
