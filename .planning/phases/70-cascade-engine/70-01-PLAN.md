---
phase: 70-cascade-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyStore.cs
  - DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
  - DataWarehouse.SDK/Infrastructure/Policy/EffectivePolicy.cs
autonomous: true

must_haves:
  truths:
    - "PolicyResolutionEngine.ResolveAsync walks VDE hierarchy from most-specific to least-specific level"
    - "Empty intermediate levels are transparently skipped during resolution"
    - "ResolveAsync returns an IEffectivePolicy snapshot with correct SnapshotTimestamp"
    - "InMemoryPolicyStore provides thread-safe CRUD for policy overrides"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyStore.cs"
      provides: "Thread-safe IPolicyStore implementation"
      contains: "class InMemoryPolicyStore"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs"
      provides: "Core cascade resolution engine implementing IPolicyEngine"
      contains: "class PolicyResolutionEngine"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/EffectivePolicy.cs"
      provides: "Concrete IEffectivePolicy implementation"
      contains: "class EffectivePolicy"
  key_links:
    - from: "PolicyResolutionEngine"
      to: "IPolicyStore"
      via: "constructor injection"
      pattern: "IPolicyStore.*_store"
    - from: "PolicyResolutionEngine"
      to: "IPolicyPersistence"
      via: "constructor injection for hydration"
      pattern: "IPolicyPersistence"
    - from: "PolicyResolutionEngine.ResolveAsync"
      to: "IPolicyStore.GetAsync"
      via: "level-by-level walk from Block to VDE"
      pattern: "_store\\.GetAsync"
---

<objective>
Build the PolicyResolutionEngine core, InMemoryPolicyStore, and EffectivePolicy -- the minimum runtime to resolve a policy at any VDE hierarchy path.

Purpose: This is the foundation for all cascade resolution. Without it, stored policies have no runtime meaning. Covers CASC-01 (resolve at any level) and CASC-04 (empty-level skip).
Output: Three production-ready files that let callers call ResolveAsync(featureId, context) and get back a resolved IEffectivePolicy.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyStore.cs
@DataWarehouse.SDK/Contracts/Policy/IEffectivePolicy.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs
@DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyPersistence.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: InMemoryPolicyStore and EffectivePolicy</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyStore.cs
    DataWarehouse.SDK/Infrastructure/Policy/EffectivePolicy.cs
  </files>
  <action>
Create InMemoryPolicyStore implementing IPolicyStore:
- Use ConcurrentDictionary with composite key format "featureId:level:path" (same as persistence layer convention from Phase 69)
- GetAsync returns null when no override exists (this enables empty-level skip in the engine)
- HasOverrideAsync checks any feature at (level, path) -- iterate matching entries or keep a secondary ConcurrentDictionary keyed by "level:path" for O(1) bloom-filter-style check
- SetAsync/RemoveAsync are thread-safe via ConcurrentDictionary
- ListOverridesAsync filters by featureId prefix
- Bounded capacity (configurable, default 100_000) matching InMemoryPolicyPersistence pattern
- Add [SdkCompatibility("6.0.0", Notes = "Phase 70: Cascade engine (CASC-01)")] attribute

Create EffectivePolicy implementing IEffectivePolicy:
- Sealed class (not record -- interface implementation)
- All properties from IEffectivePolicy: FeatureId, EffectiveIntensity, EffectiveAiAutonomy, AppliedCascade, DecidedAtLevel, ResolutionChain, MergedParameters, SnapshotTimestamp
- Constructor takes all values (immutable after creation)
- Namespace: DataWarehouse.SDK.Infrastructure.Policy
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>InMemoryPolicyStore passes compilation, implements all 5 IPolicyStore methods. EffectivePolicy implements all 8 IEffectivePolicy properties.</done>
</task>

<task type="auto">
  <name>Task 2: PolicyResolutionEngine core</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
  </files>
  <action>
Create PolicyResolutionEngine implementing IPolicyEngine:
- Constructor takes IPolicyStore, IPolicyPersistence (for hydration on first use), and optional OperationalProfile (defaults to Standard)
- Store active profile in a volatile field for thread safety

ResolveAsync(featureId, context):
1. Parse context.Path to determine which levels are addressable. Path format: "/vdeName/containerName/objectName/chunkId/blockId". Not all segments present -- derive the deepest level from segment count (1=VDE, 2=Container, 3=Object, 4=Chunk, 5=Block).
2. Walk from the deepest addressable level UP to VDE. At each level, call _store.GetAsync(featureId, level, pathForLevel). pathForLevel is the path prefix up to that level segment.
3. Collect non-null results into a resolution chain (ordered most-specific first).
4. If resolution chain is empty, fall back to the active profile's FeaturePolicies[featureId]. If also missing, return a default policy (intensity 50, Inherit cascade, SuggestExplain AI autonomy).
5. The FIRST non-null policy in the chain (most specific) determines the initial effective values.
6. Apply cascade strategy: for this plan, implement only Inherit and Override as baseline (Plan 02 adds MostRestrictive, Enforce, Merge).
   - Inherit: use first non-null in chain, walk up if current is null (already handled by skip logic)
   - Override: use the most-specific (lowest level) non-null policy, ignore all parents
7. Build EffectivePolicy with: resolved intensity, AI autonomy, applied cascade, decided-at level, full resolution chain, merged custom parameters, DateTimeOffset.UtcNow snapshot timestamp.

ResolveAllAsync: iterate all known feature IDs from the active profile's FeaturePolicies keys, call ResolveAsync for each.

GetActiveProfileAsync / SetActiveProfileAsync: get/set the volatile _activeProfile field. SetActiveProfileAsync also calls _persistence.SaveProfileAsync.

SimulateAsync: clone store state conceptually -- call ResolveAsync but inject the hypothetical policy as if it were stored at the context path/level, without persisting.

Add [SdkCompatibility("6.0.0", Notes = "Phase 70: Cascade engine (CASC-01, CASC-04)")] attribute.

IMPORTANT: Leave the cascade strategy application as a virtual or delegate-based extensibility point so Plan 02 can add MostRestrictive/Enforce/Merge without modifying this file. Use a protected method ApplyCascade(CascadeStrategy strategy, IReadOnlyList&lt;FeaturePolicy&gt; chain) that returns (int intensity, AiAutonomyLevel aiAutonomy, Dictionary&lt;string,string&gt; mergedParams, PolicyLevel decidedAt). Default impl handles Inherit and Override.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>PolicyResolutionEngine compiles, implements all 4 IPolicyEngine methods. ResolveAsync walks hierarchy levels, skips empty levels (CASC-04), returns EffectivePolicy with snapshot timestamp.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- InMemoryPolicyStore implements all IPolicyStore methods
- PolicyResolutionEngine implements all IPolicyEngine methods
- EffectivePolicy implements all IEffectivePolicy members
- Path parsing correctly maps segment count to PolicyLevel
</verification>

<success_criteria>
- CASC-01 partially satisfied: ResolveAsync resolves at VDE, Container, Object, Chunk, Block levels
- CASC-04 satisfied: empty intermediate levels transparently skipped
- Foundation ready for Plan 02 to add remaining cascade strategies
</success_criteria>

<output>
After completion, create `.planning/phases/70-cascade-engine/70-01-SUMMARY.md`
</output>
