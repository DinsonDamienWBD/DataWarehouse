---
phase: 65.4-comprehensive-strategy-dispatch-migration
plan: 09
type: execute
wave: 4
depends_on: ["65.4-02", "65.4-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateReplication/UltimateReplicationPlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateReplication/ReplicationStrategyRegistry.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/UltimateComputePlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompute/ComputeRuntimeStrategyRegistry.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/UltimateStorageProcessingPlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/StorageProcessingStrategyRegistryInternal.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs
autonomous: true

must_haves:
  truths:
    - "UltimateReplication delegates primary lookup to base class StrategyRegistry, keeps dual-index for ConsistencyModel as secondary index"
    - "UltimateCompute delegates primary lookup to base class, keeps dual-index for ComputeRuntime as secondary index"
    - "UltimateStorageProcessing delegates primary lookup to base class, keeps dual-index for category as secondary index"
    - "SemanticSync retains name-based keying (UNIQUE) but wraps base class for standard operations"
    - "All 4 plugins build with 0 errors"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateReplication/UltimateReplicationPlugin.cs"
      provides: "Hybrid migrated replication plugin (base + secondary index)"
      contains: "RegisterReplicationStrategy|ReplicationStrategyRegistry"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/UltimateComputePlugin.cs"
      provides: "Hybrid migrated compute plugin (base + secondary index)"
      contains: "RegisterComputeStrategy|ComputeStrategyRegistry"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateReplication/ReplicationStrategyRegistry.cs"
      to: "DataWarehouse.SDK/Contracts/StrategyRegistry.cs"
      via: "delegates primary to StrategyRegistry<T>"
      pattern: "StrategyRegistry<"
---

<objective>
Migrate UNIQUE pattern plugins that have genuinely different functionality. These plugins delegate PRIMARY strategy lookup to base class StrategyRegistry<T> but KEEP their secondary indexes (dual-index, cross-index, name-based keying).

Purpose: Reduces code duplication while preserving genuinely unique functionality that StrategyRegistry<T> cannot replace.
Output: 4 hybrid-migrated plugins that use base class for standard ops + keep unique secondary indexes.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/65.4-comprehensive-strategy-dispatch-migration/65.4-01-SUMMARY.md
@.planning/phases/65.4-comprehensive-strategy-dispatch-migration/65.4-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hybrid-migrate UltimateReplication and UltimateCompute (dual-index plugins)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateReplication/UltimateReplicationPlugin.cs
    Plugins/DataWarehouse.Plugins.UltimateReplication/ReplicationStrategyRegistry.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/UltimateComputePlugin.cs
    Plugins/DataWarehouse.Plugins.UltimateCompute/ComputeRuntimeStrategyRegistry.cs
  </files>
  <action>
These plugins have DUAL-INDEX registries: primary by StrategyId + secondary by an enum/model. The primary index is standard; the secondary is unique.

**UltimateReplication** (dual-index: StrategyId + ConsistencyModel):
1. Read `ReplicationStrategyRegistry.cs` to identify:
   - Primary index: BoundedDictionary<string, strategy> by StrategyId (DUPLICATE -- delegate to base)
   - Secondary index: Dictionary<ConsistencyModel, List<strategy>> or similar (UNIQUE -- keep)
2. Refactor `ReplicationStrategyRegistry` to:
   - Remove the primary BoundedDictionary -- delegate to inherited `ReplicationStrategyRegistry` (from ReplicationPluginBase, Plan 02) via a reference passed in constructor
   - Keep ONLY the secondary index (ConsistencyModel lookup)
   - `Register()` should: call base.RegisterReplicationStrategy() for primary, AND update secondary index
   - `GetStrategy(id)` should: delegate to base registry
   - `GetByConsistencyModel(model)` should: use secondary index (this is the UNIQUE part)
   - `DiscoverStrategies()` should: delegate to base `DiscoverFromAssembly()`
3. In `UltimateReplicationPlugin.cs`: update initialization to wire the refactored registry

**UltimateCompute** (dual-index: StrategyId + ComputeRuntime enum):
1. Same analysis on `ComputeRuntimeStrategyRegistry.cs`
2. Same refactoring: delegate primary to inherited ComputePluginBase registry, keep secondary ComputeRuntime enum index
3. `GetByRuntime(runtime)` -- keep as unique method
4. Standard CRUD -> delegate to base

For both: The refactored registry becomes a THIN DECORATOR that adds secondary index on top of the inherited base class registry.

CRITICAL: The secondary indexes are genuine business logic (selecting strategies by ConsistencyModel or ComputeRuntime). These MUST be preserved. Only the BoundedDictionary<string, T> primary storage is replaced.
  </action>
  <verify>
Run: `dotnet build Plugins/DataWarehouse.Plugins.UltimateReplication/ --no-restore && dotnet build Plugins/DataWarehouse.Plugins.UltimateCompute/ --no-restore` -- 0 errors.
Grep for `GetByConsistencyModel` or `GetByRuntime` to confirm secondary indexes preserved.
  </verify>
  <done>UltimateReplication and UltimateCompute hybrid-migrated. Primary lookup via base class, secondary indexes preserved.</done>
</task>

<task type="auto">
  <name>Task 2: Hybrid-migrate UltimateStorageProcessing and SemanticSync</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/UltimateStorageProcessingPlugin.cs
    Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/StorageProcessingStrategyRegistryInternal.cs
    Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs
  </files>
  <action>
**UltimateStorageProcessing** (dual-index by category):
1. Read `StorageProcessingStrategyRegistryInternal.cs` to identify primary vs secondary indexes
2. Same decorator pattern: delegate primary to base class, keep category secondary index
3. `GetByCategory(category)` -- keep as unique method
4. Standard CRUD -> delegate to base

**SemanticSync** (keyed by NAME, not StrategyId -- UNIQUE):
1. Read `SemanticSyncPlugin.cs` to find the inline registry pattern
2. SemanticSync uses strategy NAME as key, not StrategyId. This is fundamentally different from StrategyRegistry<T> which expects StrategyId
3. Approach: Keep the name-based registry as-is (it IS genuinely unique). But ALSO register strategies with the base class StrategyRegistry for standard dispatch
4. In the plugin's initialization, add a dual-registration: `base.RegisterStrategy(strategy)` (for standard StrategyId dispatch) AND the existing name-based registration
5. This makes SemanticSync compatible with base class dispatch while preserving its name-based lookup

Do NOT force SemanticSync to change its keying strategy. The name-based approach is a legitimate domain requirement.

CRITICAL: Zero regression. Category lookup and name-based lookup must work identically after migration.
  </action>
  <verify>
Run: `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/ --no-restore && dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/ --no-restore` -- 0 errors.
  </verify>
  <done>UltimateStorageProcessing and SemanticSync hybrid-migrated. Unique functionality preserved.</done>
</task>

</tasks>

<verification>
- All 4 unique-pattern plugins build with 0 errors
- Secondary indexes and name-based keying preserved
- Primary strategy lookup delegated to base class
</verification>

<success_criteria>
All UNIQUE pattern plugins hybrid-migrated: primary dispatch through base class, secondary indexes preserved as domain-specific additions.
</success_criteria>

<output>
After completion, create `.planning/phases/65.4-comprehensive-strategy-dispatch-migration/65.4-09-SUMMARY.md`
</output>
