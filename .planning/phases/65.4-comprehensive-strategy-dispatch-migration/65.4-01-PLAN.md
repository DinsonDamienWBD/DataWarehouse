---
phase: 65.4-comprehensive-strategy-dispatch-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Metadata/audit_custom_registries.py
autonomous: true

must_haves:
  truths:
    - "Python audit script scans all Plugin directories and classifies every custom registry"
    - "Script produces a JSON report with DUPLICATE/UNIQUE/ALREADY_MIGRATED classifications"
    - "Script identifies all BoundedDictionary<string, strategy fields and standalone registry files"
  artifacts:
    - path: "Metadata/audit_custom_registries.py"
      provides: "Automated registry audit and migration report generator"
      min_lines: 100
  key_links:
    - from: "Metadata/audit_custom_registries.py"
      to: "Plugins/DataWarehouse.Plugins.*"
      via: "filesystem scan"
      pattern: "Plugins.*DataWarehouse\\.Plugins"
---

<objective>
Create Python audit script that scans ALL Plugin directories for custom registry patterns and classifies each as DUPLICATE, UNIQUE, or ALREADY_MIGRATED.

Purpose: Provides data-driven migration guidance for Plans 05-09 (plugin migration). Without this, executors would need to manually analyze each plugin.
Output: `Metadata/audit_custom_registries.py` + JSON report on stdout
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Contracts/StrategyRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python audit script for custom registry detection</name>
  <files>Metadata/audit_custom_registries.py</files>
  <action>
Create a Python script that:

1. Scans ALL `Plugins/DataWarehouse.Plugins.*` directories recursively for `.cs` files
2. Detects THREE patterns of custom registries:

   **Pattern A - Standalone registry files:** Files containing a class with:
   - `BoundedDictionary<string,` field storing strategies
   - Methods: `Register(`, `GetStrategy(`, `GetAllStrategies(`, `DiscoverStrategies(`
   - Assembly scanning: `GetTypes().Where(` with `IsAssignableFrom`

   **Pattern B - Inline registry in plugin class:** Plugin files containing:
   - `BoundedDictionary<string,` or `Dictionary<string,` fields named `_strategies` or similar
   - Inline `Register`/`Get` methods for strategies within the plugin class itself

   **Pattern C - Inline registry class:** Plugin files containing:
   - A nested or sibling class that acts as a registry (class name contains "Registry" or "Registr")
   - Same BoundedDictionary pattern as Pattern A but defined inline

3. Classifies each found registry as:
   - `DUPLICATE`: Standard pattern matching StrategyRegistry<T> -- has Register/Get/Discover with BoundedDictionary, single index by StrategyId
   - `UNIQUE`: Has genuinely different functionality -- dual-index (by enum + strategyId), cross-index, weighted selection, name-based keying instead of StrategyId
   - `ALREADY_MIGRATED`: Plugin file contains `EncryptionPluginBase`, `CompressionPluginBase`, or calls to inherited `RegisterStrategy(`, `ResolveStrategy<`, `DispatchEncryptionStrategyAsync`, `DispatchCompressionStrategyAsync`

4. For each registry found, captures:
   - Plugin name, file path, pattern type (A/B/C)
   - Strategy interface name (extracted from BoundedDictionary generic parameter or Register method parameter type)
   - Classification (DUPLICATE/UNIQUE/ALREADY_MIGRATED)
   - Reason for classification
   - List of methods that would be replaced by base class
   - List of methods that are genuinely unique (if UNIQUE)

5. Outputs a JSON report to stdout with structure:
   ```json
   {
     "scan_date": "...",
     "total_plugins_scanned": N,
     "registries_found": N,
     "classifications": {
       "DUPLICATE": N,
       "UNIQUE": N,
       "ALREADY_MIGRATED": N
     },
     "registries": [
       {
         "plugin": "UltimateStorage",
         "file": "StorageStrategyRegistry.cs",
         "pattern": "A",
         "strategy_interface": "IStorageStrategy",
         "classification": "DUPLICATE",
         "reason": "Standard BoundedDictionary + Register/Get/Discover pattern",
         "replaceable_methods": ["Register", "GetStrategy", "GetAllStrategies", "DiscoverStrategies"],
         "unique_methods": []
       }
     ]
   }
   ```

6. Known UNIQUE registries to detect (hardcode recognition):
   - UltimateReplication: Has dual-index by ConsistencyModel + capability
   - UltimateCompute: Has dual-index by ComputeRuntime enum
   - UltimateStorageProcessing: Has dual-index by category
   - SemanticSync: Keyed by name not StrategyId
   - UltimateIntelligence/RegenerationStrategyRegistry: Format cross-index
   - UniversalFabric/BackendRegistryImpl: NOT a strategy registry at all (backend routing)

7. Known ALREADY_MIGRATED to detect:
   - UltimateEncryption: Uses EncryptionPluginBase dispatch
   - UltimateCompression: Uses CompressionPluginBase dispatch
   - UltimateConnector: Uses SDK ConnectionStrategyRegistry

Use regex-based scanning (no AST parsing needed). Script must work with Python 3.8+, no external dependencies.
  </action>
  <verify>
Run: `python Metadata/audit_custom_registries.py` and verify:
- Output is valid JSON
- All 14 Pattern A registries are found
- All 5 Pattern B registries are found
- All 5 Pattern C registries are found
- UltimateEncryption/UltimateCompression classified as ALREADY_MIGRATED
- UltimateReplication/UltimateCompute classified as UNIQUE
- UltimateStorage/UltimateRAID classified as DUPLICATE
  </verify>
  <done>Script runs successfully, produces valid JSON classifying all ~24+ custom registries across 3 patterns with correct DUPLICATE/UNIQUE/ALREADY_MIGRATED classifications</done>
</task>

</tasks>

<verification>
- `python Metadata/audit_custom_registries.py | python -m json.tool` produces valid formatted JSON
- Classification counts match expected: ~14 DUPLICATE, ~5 UNIQUE, ~3 ALREADY_MIGRATED
</verification>

<success_criteria>
Python audit script exists and correctly classifies all custom registries in the codebase, providing actionable migration guidance for subsequent plans.
</success_criteria>

<output>
After completion, create `.planning/phases/65.4-comprehensive-strategy-dispatch-migration/65.4-01-SUMMARY.md`
</output>
