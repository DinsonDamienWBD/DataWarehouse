---
phase: 65.4-comprehensive-strategy-dispatch-migration
plan: "09"
subsystem: unique-pattern-plugins
tags: [strategy-dispatch, hybrid-migration, dual-index, replication, compute, storage-processing, semantic-sync]

# Dependency graph
requires:
  - "65.4-02: ReplicationPluginBase.RegisterReplicationStrategy, ComputePluginBase.RegisterComputeStrategy, PluginBase.RegisterStrategy"
  - "65.4-03: ComputePluginBase.ComputeStrategyRegistry, OrchestrationPluginBase.RegisterOrchestrationStrategy"
provides:
  - "UltimateReplication: dual-registered in ReplicationPluginBase registry (primary) + local ConsistencyModel/capability secondary indexes"
  - "UltimateCompute: dual-registered in ComputePluginBase registry (primary) + local ComputeRuntime secondary index"
  - "UltimateStorageProcessing: dual-registered in PluginBase IStrategy registry (primary) + local category secondary index"
  - "SemanticSync: dual-registered in OrchestrationPluginBase registry (primary) + local name-based registry (unique domain keying)"
affects:
  - "All consumers of these 4 plugins via message bus strategy dispatch"

# Tech tracking
tech-stack:
  added: []
  patterns:
    - "Hybrid dual-registration: local secondary-index registry + inherited base class primary registry"
    - "Decorator pattern: local registry decorates base class registry with domain-specific secondary indexes"
    - "RegisterBothRegistries helper method pattern (UltimateReplication)"
    - "Post-discovery dual-registration loop (UltimateCompute, UltimateStorageProcessing)"
    - "Inline dual-registration in RegisterStrategy method (SemanticSync)"

key-files:
  created: []
  modified:
    - "Plugins/DataWarehouse.Plugins.UltimateReplication/UltimateReplicationPlugin.cs"
    - "Plugins/DataWarehouse.Plugins.UltimateCompute/UltimateComputePlugin.cs"
    - "Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/UltimateStorageProcessingPlugin.cs"
    - "Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs"

key-decisions:
  - "UltimateReplication: EnhancedReplicationStrategyBase extends ReplicationStrategyBase which implements IReplicationStrategy, making it compatible with ReplicationPluginBase.ReplicationStrategyRegistry. Used RegisterBothRegistries() helper to dual-register all 61 strategies."
  - "UltimateCompute: IComputeRuntimeStrategy directly matches ComputePluginBase.ComputeStrategyRegistry<IComputeRuntimeStrategy>. Post-discovery loop calls RegisterComputeStrategy() for each discovered strategy."
  - "UltimateStorageProcessing: IStorageProcessingStrategy does NOT implement IStorageStrategy, so StoragePluginBase.StorageStrategyRegistry is type-incompatible. Used PluginBase.RegisterStrategy(IStrategy) instead (StorageProcessingStrategyBase implements IStrategy via StrategyBase). Category secondary index preserved in local registry."
  - "SemanticSync: Name-based keying is a genuine domain requirement (names like 'classifier-hybrid', 'router-summary' are pipeline identifiers). Dual-registration added inside RegisterStrategy(name, strategy) calls RegisterOrchestrationStrategy(strategy) to populate the base class registry for StrategyId dispatch. Name-based lookup in _strategies dict remains the primary pipeline path."

# Metrics
duration: ~8min
completed: 2026-02-21
tasks_completed: 2
files_modified: 4
---

# Phase 65.4 Plan 09: Unique-Pattern Plugin Hybrid Migration Summary

**Four unique-pattern plugins hybrid-migrated to dual-register strategies with inherited base class registries while preserving their genuinely unique secondary indexes (ConsistencyModel, ComputeRuntime, category, name-based keying)**

## Performance

- **Duration:** ~8 min
- **Completed:** 2026-02-21
- **Tasks:** 2/2
- **Files modified:** 4

## What Was Built

### Task 1: UltimateReplication + UltimateCompute (Dual-Index Plugins)

**UltimateReplication** (`UltimateReplicationPlugin.cs`):
- Added `RegisterBothRegistries(EnhancedReplicationStrategyBase)` helper method
- All 61 strategy registrations updated to call `RegisterBothRegistries()` instead of `_registry.Register()`
- Each strategy now dual-registered: `RegisterReplicationStrategy(strategy)` (base class, primary dispatch by StrategyId) + `_registry.Register(strategy)` (local, secondary ConsistencyModel + capability indexes)
- `GetByConsistencyModel()`, `GetByCapability()`, and `SelectBestStrategy()` all preserved in `ReplicationStrategyRegistry`

**UltimateCompute** (`UltimateComputePlugin.cs`):
- In `OnStartCoreAsync`: after `_registry.DiscoverStrategies()`, a post-discovery loop calls `RegisterComputeStrategy(baseStrategy)` for each `ComputeRuntimeStrategyBase`
- Base class `ComputePluginBase.ComputeStrategyRegistry<IComputeRuntimeStrategy>` now populated for primary StrategyId dispatch
- Local `ComputeRuntimeStrategyRegistry` retains secondary `_byRuntime` index: `GetStrategiesByRuntime(ComputeRuntime)` preserved

### Task 2: UltimateStorageProcessing + SemanticSync

**UltimateStorageProcessing** (`UltimateStorageProcessingPlugin.cs`):
- In `OnStartCoreAsync`: after `DiscoverStrategies()`, post-discovery loop calls `RegisterStrategy(baseStrategy)` (PluginBase `IStrategy` registry) for each `StorageProcessingStrategyBase`
- Design note: `IStorageProcessingStrategy` is a distinct domain type from `IStorageStrategy` (compute-on-storage vs. read/write ops). `StoragePluginBase.StorageStrategyRegistry` cannot hold `IStorageProcessingStrategy`. `PluginBase.RegisterStrategy(IStrategy)` is used instead (all `StorageProcessingStrategyBase` implement `IStrategy` via `StrategyBase`).
- Local `StorageProcessingStrategyRegistryInternal` retains secondary `_byCategory` index: `GetStrategiesByCategory(string)` preserved

**SemanticSync** (`SemanticSyncPlugin.cs`):
- `RegisterStrategy(string name, StrategyBase strategy)`: added `RegisterOrchestrationStrategy(strategy)` call for dual-registration
- Name-based keying in `_strategies` dict preserved as primary pipeline lookup (names like "classifier-hybrid", "router-summary" are domain pipeline identifiers, not standard StrategyIds)
- Standard `IStrategy.StrategyId`-based dispatch now works via `OrchestrationPluginBase.DispatchOrchestrationStrategyAsync`
- All 7 strategies auto-dual-registered during `OnStartCoreAsync` (calls flow through the updated `RegisterStrategy` method)

## Task Commits

| Task | Name | Commit | Files |
|------|------|--------|-------|
| 1 | Hybrid-migrate UltimateReplication and UltimateCompute | `091838e1` | UltimateReplicationPlugin.cs, UltimateComputePlugin.cs |
| 2 | Hybrid-migrate UltimateStorageProcessing and SemanticSync | `5823b1ff` | UltimateStorageProcessingPlugin.cs, SemanticSyncPlugin.cs |

## Verification

All 4 plugins build with 0 errors, 0 warnings:
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateReplication/` → Build succeeded. 0 Warning(s). 0 Error(s).
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompute/` → Build succeeded. 0 Warning(s). 0 Error(s).
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/` → Build succeeded. 0 Warning(s). 0 Error(s).
- `dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/` → Build succeeded. 0 Warning(s). 0 Error(s).

Secondary indexes preserved:
- `ReplicationStrategyRegistry.GetByConsistencyModel()` ✓
- `ReplicationStrategyRegistry.GetByCapability()` ✓
- `ComputeRuntimeStrategyRegistry.GetStrategiesByRuntime()` ✓
- `StorageProcessingStrategyRegistryInternal.GetStrategiesByCategory()` ✓
- `SemanticSyncPlugin.GetStrategy<T>(name)` ✓

## Decisions Made

1. **UltimateReplication compatibility**: `EnhancedReplicationStrategyBase` → `ReplicationStrategyBase` → `IReplicationStrategy`. Compatible with `ReplicationPluginBase.ReplicationStrategyRegistry`. No casting needed.

2. **UltimateStorageProcessing type mismatch**: `IStorageProcessingStrategy` is NOT `IStorageStrategy`. Using `PluginBase.RegisterStrategy(IStrategy)` instead of `StoragePluginBase.RegisterStorageStrategy()`. This registers strategies in the root `StrategyRegistry<IStrategy>` rather than the domain-typed `StorageStrategyRegistry`. Primary dispatch by `StrategyId` still works; the domain registry (`StorageStrategyRegistry`) remains for actual storage read/write strategies.

3. **SemanticSync inline approach**: Rather than a post-discovery loop, dual-registration is done inline in `RegisterStrategy(name, strategy)`. This ensures future registrations (if new strategies are added) also get dual-registered automatically without code changes.

## Deviations from Plan

None — plan executed as written. The type incompatibility between `IStorageProcessingStrategy` and `IStorageStrategy` was handled by using the parent `PluginBase.RegisterStrategy(IStrategy)` as the base class registration path, which correctly achieves the plan's intent of "delegate primary to base class registry" using the most compatible available registry.

## Self-Check: PASSED

Files modified exist:
- `Plugins/DataWarehouse.Plugins.UltimateReplication/UltimateReplicationPlugin.cs` ✓
- `Plugins/DataWarehouse.Plugins.UltimateCompute/UltimateComputePlugin.cs` ✓
- `Plugins/DataWarehouse.Plugins.UltimateStorageProcessing/UltimateStorageProcessingPlugin.cs` ✓
- `Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs` ✓

Commits exist:
- `091838e1` ✓
- `5823b1ff` ✓
