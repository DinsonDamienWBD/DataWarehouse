---
phase: 65.4-comprehensive-strategy-dispatch-migration
plan: 03
type: execute
wave: 2
depends_on: ["65.4-02"]
files_modified:
  - DataWarehouse.SDK/Contracts/Hierarchy/Feature/SecurityPluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/Feature/ObservabilityPluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/Feature/StreamingPluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/Feature/ComputePluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/Feature/MediaPluginBase.cs
autonomous: true

must_haves:
  truths:
    - "SecurityPluginBase has typed StrategyRegistry<ISecurityStrategy> and AuthenticateWithStrategyAsync/AuthorizeWithStrategyAsync domain ops"
    - "ObservabilityPluginBase has typed StrategyRegistry<IObservabilityStrategy> and RecordMetricWithStrategyAsync/TraceWithStrategyAsync domain ops"
    - "StreamingPluginBase has typed StrategyRegistry<IStreamingStrategy> and PublishWithStrategyAsync/SubscribeWithStrategyAsync domain ops"
    - "ComputePluginBase has typed StrategyRegistry<IComputeRuntimeStrategy> and ExecuteWorkloadWithStrategyAsync domain op"
    - "MediaPluginBase has typed StrategyRegistry<IMediaStrategy> and ProcessMediaWithStrategyAsync domain op"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/Feature/SecurityPluginBase.cs"
      provides: "Security strategy dispatch"
      contains: "StrategyRegistry<ISecurityStrategy>"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/Feature/ObservabilityPluginBase.cs"
      provides: "Observability strategy dispatch"
      contains: "StrategyRegistry<IObservabilityStrategy>"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/Feature/ComputePluginBase.cs"
      provides: "Compute strategy dispatch"
      contains: "StrategyRegistry<IComputeRuntimeStrategy>"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Hierarchy/Feature/SecurityPluginBase.cs"
      to: "DataWarehouse.SDK/Contracts/Security/SecurityStrategy.cs"
      via: "ISecurityStrategy type reference"
      pattern: "ISecurityStrategy"
---

<objective>
Add typed strategy registries and domain operations to Feature branch bases batch 1: Security, Observability, Streaming, Compute, Media.

Purpose: These 5 bases serve ~15 plugins. Strategy dispatch here enables plugins to inherit instead of custom-building registries.
Output: Five updated base classes with strategy dispatch following the EncryptionPluginBase pattern.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
@DataWarehouse.SDK/Contracts/StrategyRegistry.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add strategy dispatch to SecurityPluginBase, ObservabilityPluginBase, and StreamingPluginBase</name>
  <files>
    DataWarehouse.SDK/Contracts/Hierarchy/Feature/SecurityPluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/Feature/ObservabilityPluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/Feature/StreamingPluginBase.cs
  </files>
  <action>
For each base, follow the EncryptionPluginBase pattern. Add AFTER existing code, BEFORE `#region Metadata`:

**SecurityPluginBase** (uses `ISecurityStrategy` from `DataWarehouse.SDK.Contracts.Security`):

Add usings: `using DataWarehouse.SDK.Contracts.Security;` (for ISecurityStrategy) and `using DataWarehouse.SDK.Contracts;` (for StrategyRegistry, CommandIdentity)

1. `#region Typed Security Strategy Registry`
2. Lazy `StrategyRegistry<ISecurityStrategy>` with `s => s.StrategyId` key selector
3. `RegisterSecurityStrategy(ISecurityStrategy strategy)` method
4. `DispatchSecurityStrategyAsync<TResult>(string? explicitStrategyId, CommandIdentity? identity, Dictionary<string, object>? dataContext, Func<ISecurityStrategy, Task<TResult>> operation, CancellationToken ct)` method
5. `#endregion`
6. `#region Domain Operations (Strategy-Dispatched)`
7. `AuthenticateWithStrategyAsync(Dictionary<string, object> credentials, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- virtual protected, dispatches to strategy
8. `AuthorizeWithStrategyAsync(string resource, string action, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- virtual protected, dispatches to strategy
9. Override `GetDefaultStrategyId()` returning null
10. `#endregion`

**ObservabilityPluginBase** (uses `IObservabilityStrategy` from `DataWarehouse.SDK.Contracts.Observability`):

Add usings: `using DataWarehouse.SDK.Contracts.Observability;`, `using DataWarehouse.SDK.Contracts;`, `using DataWarehouse.SDK.Security;`, `using System.Threading;`, `using System.Threading.Tasks;`

1. Typed `StrategyRegistry<IObservabilityStrategy>` with lazy init
2. `RegisterObservabilityStrategy(IObservabilityStrategy strategy)` method
3. `DispatchObservabilityStrategyAsync<TResult>(...)` method
4. `RecordMetricWithStrategyAsync(Dictionary<string, object> metric, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- domain op
5. `TraceWithStrategyAsync(Dictionary<string, object> span, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- domain op
6. Override `GetDefaultStrategyId()` returning null

**StreamingPluginBase** (uses `IStreamingStrategy` from `DataWarehouse.SDK.Contracts.Streaming`):

Add usings: `using DataWarehouse.SDK.Contracts.Streaming;`, `using DataWarehouse.SDK.Contracts;`, `using DataWarehouse.SDK.Security;`

1. Typed `StrategyRegistry<IStreamingStrategy>` with lazy init
2. `RegisterStreamingStrategy(IStreamingStrategy strategy)` method
3. `DispatchStreamingStrategyAsync<TResult>(...)` method
4. `PublishWithStrategyAsync(string topic, Stream data, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- domain op
5. `SubscribeWithStrategyAsync(string topic, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- domain op returning IAsyncEnumerable wrapped in Task
6. Override `GetDefaultStrategyId()` returning null

For the Dispatch methods: use SelectOptimalAlgorithmAsync if available (from DataTransformationPluginBase chain), otherwise just use the explicitStrategyId. Feature bases do NOT inherit from DataTransformationPluginBase, so the AI fallback should just use `GetDefaultStrategyId()` if no explicit ID is provided, rather than calling SelectOptimalAlgorithmAsync.

CRITICAL: Do NOT change existing method signatures. All new methods are ADDITIONAL.
  </action>
  <verify>
Run: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors 0 warnings.
Grep all 3 files for `StrategyRegistry<` to confirm typed registries.
  </verify>
  <done>SecurityPluginBase, ObservabilityPluginBase, StreamingPluginBase all have typed strategy registries and domain operations. SDK compiles clean.</done>
</task>

<task type="auto">
  <name>Task 2: Add strategy dispatch to ComputePluginBase and MediaPluginBase</name>
  <files>
    DataWarehouse.SDK/Contracts/Hierarchy/Feature/ComputePluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/Feature/MediaPluginBase.cs
  </files>
  <action>
Same pattern:

**ComputePluginBase** (uses `IComputeRuntimeStrategy` from `DataWarehouse.SDK.Contracts.Compute`):

Add usings: `using DataWarehouse.SDK.Contracts.Compute;`, `using DataWarehouse.SDK.Contracts;`, `using DataWarehouse.SDK.Security;`, `using System;`

1. Typed `StrategyRegistry<IComputeRuntimeStrategy>` with lazy init, key selector `s => s.StrategyId`
2. `RegisterComputeStrategy(IComputeRuntimeStrategy strategy)` method
3. `DispatchComputeStrategyAsync<TResult>(string? explicitStrategyId, CommandIdentity? identity, Dictionary<string, object>? dataContext, Func<IComputeRuntimeStrategy, Task<TResult>> operation, CancellationToken ct)` method
4. `ExecuteWorkloadWithStrategyAsync(Dictionary<string, object> workload, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- virtual protected domain op, dispatches to strategy.ExecuteAsync or similar
5. Override `GetDefaultStrategyId()` returning `RuntimeType`

**MediaPluginBase** (uses `IMediaStrategy` from `DataWarehouse.SDK.Contracts.Media`):

Add usings: `using DataWarehouse.SDK.Contracts.Media;`, `using DataWarehouse.SDK.Contracts;`, `using DataWarehouse.SDK.Security;`, `using System;`, `using System.Threading;`, `using System.Threading.Tasks;`

1. Typed `StrategyRegistry<IMediaStrategy>` with lazy init, key selector `s => s.StrategyId`
2. `RegisterMediaStrategy(IMediaStrategy strategy)` method
3. `DispatchMediaStrategyAsync<TResult>(...)` method
4. `ProcessMediaWithStrategyAsync(Dictionary<string, object> media, string? strategyId, CommandIdentity? identity, CancellationToken ct)` -- virtual protected domain op
5. Override `GetDefaultStrategyId()` returning `MediaType`

For both: The dispatch method pattern is identical to EncryptionPluginBase but without the `SelectOptimalAlgorithmAsync` call (these are Feature bases, not DataTransformation). When `explicitStrategyId` is null, use `GetDefaultStrategyId()` as fallback. If still null, throw InvalidOperationException("No strategy specified and no default configured.").

CRITICAL: Do NOT change existing method signatures.
  </action>
  <verify>
Run: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors 0 warnings.
Grep both files for `StrategyRegistry<` to confirm typed registries.
  </verify>
  <done>ComputePluginBase and MediaPluginBase have typed strategy registries and domain operations. SDK compiles clean.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` passes with 0 errors 0 warnings
- All 5 Feature branch bases (batch 1) have typed strategy registries
</verification>

<success_criteria>
Security, Observability, Streaming, Compute, and Media plugin bases all have strategy dispatch matching the EncryptionPluginBase pattern. SDK compiles clean.
</success_criteria>

<output>
After completion, create `.planning/phases/65.4-comprehensive-strategy-dispatch-migration/65.4-03-SUMMARY.md`
</output>
