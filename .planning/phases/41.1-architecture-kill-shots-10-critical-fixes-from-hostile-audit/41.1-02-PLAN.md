---
phase: 41.1-architecture-kill-shots
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/LineageStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/LineageStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/AdvancedLineageStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/Feature/DataManagementPluginBase.cs
autonomous: true
must_haves:
  truths:
    - "Lineage strategies return BFS-traversed upstream/downstream graphs by default instead of empty arrays"
    - "Impact analysis returns BFS-derived impacted node lists by default instead of empty arrays"
    - "Data management plugins scope all storage operations by tenant ID"
    - "Default tenant is used when no ISecurityContext.TenantId is available"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataLineage/LineageStrategyBase.cs"
      provides: "Default BFS GetUpstreamAsync, GetDownstreamAsync, AnalyzeImpactAsync implementations"
      contains: "virtual.*GetUpstreamAsync"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/Feature/DataManagementPluginBase.cs"
      provides: "Tenant-scoped GetDataAsync/SetDataAsync with persistence delegation"
      contains: "TenantId"
  key_links:
    - from: "LineageStrategyBase"
      to: "_nodes/_edges dictionaries"
      via: "BFS traversal using queue"
      pattern: "Queue.*Enqueue"
    - from: "DataManagementPluginBase"
      to: "ISecurityContext"
      via: "TenantId scoping"
      pattern: "SecurityContext.*TenantId"
---

<objective>
Fix Killshot 9 (lineage default BFS implementations) and Killshot 6+10 (tenant-scoped persistent storage in DataManagementPluginBase).

Purpose: KS9 eliminates 13 stub lineage strategies that return empty arrays — they get working BFS traversal from the base class. KS6+10 adds tenant isolation to DataManagementPluginBase so all data management plugins automatically scope data by tenant.

Output: LineageStrategyBase provides default BFS for GetUpstream/GetDownstream/AnalyzeImpact. DataManagementPluginBase provides tenant-scoped GetDataAsync/SetDataAsync.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateDataLineage/LineageStrategyBase.cs
@DataWarehouse.SDK/Contracts/Hierarchy/Feature/DataManagementPluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Default BFS Implementations in LineageStrategyBase (KS9)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataLineage/LineageStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/LineageStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/AdvancedLineageStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs
  </files>
  <action>
**In LineageStrategyBase.cs:** Change GetUpstreamAsync, GetDownstreamAsync, and AnalyzeImpactAsync from `abstract` to `virtual` with default BFS implementations.

**GetUpstreamAsync default implementation:**
```csharp
public virtual Task<LineageGraph> GetUpstreamAsync(string nodeId, int maxDepth = 10, CancellationToken ct = default)
{
    ThrowIfNotInitialized();
    var visited = new HashSet<string>();
    var nodes = new List<LineageNode>();
    var edges = new List<LineageEdge>();
    var queue = new Queue<(string id, int depth)>();
    queue.Enqueue((nodeId, 0));

    while (queue.Count > 0)
    {
        var (currentId, depth) = queue.Dequeue();
        if (depth > maxDepth || !visited.Add(currentId)) continue;

        if (_nodes.TryGetValue(currentId, out var node))
            nodes.Add(node);

        foreach (var edge in _edges.Values.Where(e => e.TargetNodeId == currentId))
        {
            edges.Add(edge);
            queue.Enqueue((edge.SourceNodeId, depth + 1));
        }
    }

    return Task.FromResult(new LineageGraph
    {
        RootNodeId = nodeId,
        Nodes = nodes.AsReadOnly(),
        Edges = edges.AsReadOnly(),
        Depth = maxDepth,
        UpstreamCount = Math.Max(0, nodes.Count - 1)
    });
}
```

**GetDownstreamAsync:** Same BFS but follow edges WHERE `e.SourceNodeId == currentId` instead of TargetNodeId. Set `DownstreamCount` instead of `UpstreamCount`.

**AnalyzeImpactAsync:** BFS downstream from nodeId, classify depth=1 as DirectlyImpacted, depth>1 as IndirectlyImpacted. ImpactScore = min(100, directCount * 10 + indirectCount * 3).

**In strategy files (LineageStrategies.cs, AdvancedLineageStrategies.cs, ActiveLineageStrategies.cs):** For strategies that currently return `Array.Empty<LineageNode>()` / `Array.Empty<LineageEdge>()`, DELETE the override entirely so they inherit the base class BFS. Keep overrides only in strategies that have actual custom implementations (the first strategy `ColumnLevelLineageStrategy` in LineageStrategies.cs has a real BFS implementation — keep it).

Count all strategy classes in these files first. The research says 13 of 18 are stubs. Identify which 5 have real implementations (non-empty returns) and which 13 are stubs. Delete only stub overrides.
  </action>
  <verify>
Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataLineage/ --no-restore -v q` — 0 errors.
Grep for `Array.Empty<LineageNode>` in UltimateDataLineage strategies — should return 0 results.
  </verify>
  <done>LineageStrategyBase has default BFS for GetUpstreamAsync, GetDownstreamAsync, AnalyzeImpactAsync. All 13 stub strategies inherit from base class. 5 strategies with custom implementations retain their overrides.</done>
</task>

<task type="auto">
  <name>Task 2: Tenant-Scoped Persistent Storage in DataManagementPluginBase (KS6+10)</name>
  <files>DataWarehouse.SDK/Contracts/Hierarchy/Feature/DataManagementPluginBase.cs</files>
  <action>
Add tenant-scoped storage infrastructure to DataManagementPluginBase. This gives all inheriting plugins (governance, catalog, quality, lineage, lake, mesh, privacy) automatic tenant isolation.

Add the following to DataManagementPluginBase:

1. **Tenant-scoped in-memory cache:**
```csharp
private readonly ConcurrentDictionary<string, ConcurrentDictionary<string, object>> _tenantStorage = new();
```

2. **GetDataAsync<T>(string key, CancellationToken ct):**
   - Gets tenantId from `SecurityContext?.TenantId ?? "default"` (SecurityContext is a property on FeaturePluginBase or IntelligenceAwarePluginBase — check the actual hierarchy)
   - Looks up in _tenantStorage[tenantId][key]
   - If not in cache, calls `LoadFromStorageAsync<T>(tenantId, key, ct)` virtual method
   - Returns T? (nullable)

3. **SetDataAsync<T>(string key, T value, CancellationToken ct):**
   - Gets tenantId same way
   - Sets in _tenantStorage[tenantId][key]
   - Calls `SaveToStorageAsync<T>(tenantId, key, value, ct)` virtual method

4. **Virtual persistence hooks:**
```csharp
protected virtual Task<T?> LoadFromStorageAsync<T>(string tenantId, string key, CancellationToken ct)
    => Task.FromResult<T?>(default);
protected virtual Task SaveToStorageAsync<T>(string tenantId, string key, T value, CancellationToken ct)
    => Task.CompletedTask;
```
These have no-op defaults so existing plugins work without changes. Plugins can override to delegate to IStorageEngine via message bus.

5. **GetTenantDataKeysAsync(CancellationToken ct):** Returns all keys for current tenant.

6. **ClearTenantDataAsync(CancellationToken ct):** Clears all data for current tenant.

Add `using System.Collections.Concurrent;` at top.

**IMPORTANT:** Check how to access SecurityContext (ISecurityContext) from the base class hierarchy. Look at IntelligenceAwarePluginBase for a SecurityContext property or field. If none exists, accept it as a parameter or use a protected virtual method `GetCurrentTenantId()` that defaults to "default".
  </action>
  <verify>
Build: `dotnet build DataWarehouse.SDK/ --no-restore -v q` — 0 errors.
Verify DataManagementPluginBase has tenant-scoped methods by grepping for `TenantId` and `GetDataAsync`.
  </verify>
  <done>DataManagementPluginBase provides tenant-scoped GetDataAsync/SetDataAsync with ConcurrentDictionary cache, virtual persistence hooks, tenant key enumeration, and tenant data clearing. All inheriting plugins get tenant isolation automatically.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors
2. No `Array.Empty<LineageNode>` in lineage strategy files (stubs eliminated)
3. DataManagementPluginBase has GetDataAsync, SetDataAsync, tenant scoping
4. All existing tests pass
</verification>

<success_criteria>
- KS9: 13 stub strategies now inherit working BFS from base class
- KS6+10: DataManagementPluginBase has tenant-scoped storage with persistence delegation
- Build: 0 errors
- Tests: All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-02-SUMMARY.md`
</output>
