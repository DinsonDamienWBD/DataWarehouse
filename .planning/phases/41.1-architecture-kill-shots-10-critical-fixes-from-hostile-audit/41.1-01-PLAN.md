---
phase: 41.1-architecture-kill-shots
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.Kernel/DataWarehouseKernel.cs
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/TransitEncryptionPluginBases.cs
  - DataWarehouse.SDK/Hardware/PlatformCapabilityRegistry.cs
  - DataWarehouse.SDK/Hardware/Accelerators/HsmProvider.cs
  - DataWarehouse.SDK/Infrastructure/StorageConnectionRegistry.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Discovery/MdnsServiceDiscovery.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Discovery/ZeroConfigClusterBootstrap.cs
  - DataWarehouse.SDK/Federation/Replication/ReplicaFallbackChain.cs
  - DataWarehouse.SDK/Security/IKeyStore.cs
  - DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/FreeSpaceManager.cs
autonomous: true
must_haves:
  truths:
    - "Plugins receive kernel services (IMessageBus, IStorageEngine) after registration"
    - "No sync-over-async wrappers (.Result, .GetAwaiter().GetResult(), .Wait()) exist in SDK pipeline paths"
    - "Solution builds with 0 errors after all changes"
  artifacts:
    - path: "DataWarehouse.Kernel/DataWarehouseKernel.cs"
      provides: "InjectKernelServices call in RegisterPluginAsync"
      contains: "InjectKernelServices"
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "Async-only pipeline methods (no sync wrappers)"
    - path: "DataWarehouse.SDK/Contracts/TransitEncryptionPluginBases.cs"
      provides: "Async-only transit encryption (no sync wrappers)"
  key_links:
    - from: "DataWarehouse.Kernel/DataWarehouseKernel.cs"
      to: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      via: "InjectKernelServices(plugin) call after handshake"
      pattern: "InjectKernelServices\\(plugin\\)"
---

<objective>
Fix Killshot 2 (Kernel DI wiring) and Killshot 1 (async pipeline sync wrapper removal).

Purpose: KS2 is a 1-line fix that enables plugins to receive kernel services — without it, all plugins silently fail to get IMessageBus/IStorageEngine. KS1 eliminates sync-over-async wrappers that cause threadpool starvation under load.

Output: Kernel correctly injects services into plugins. All sync-over-async wrappers deleted from SDK pipeline hot paths.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-RESEARCH.md
@DataWarehouse.Kernel/DataWarehouseKernel.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Kernel DI Wiring (KS2) — Add InjectKernelServices Call</name>
  <files>DataWarehouse.Kernel/DataWarehouseKernel.cs</files>
  <action>
In `DataWarehouseKernel.RegisterPluginAsync`, add `InjectKernelServices(plugin);` immediately after the handshake success check (`if (response.Success)`) and BEFORE `_registry.Register(plugin)`. The method `InjectKernelServices` is defined on PluginBase (line ~813 of PluginBase.cs) and accepts IMessageBus, ICapabilityRegistry, IKnowledgeLake.

The call should look like:
```csharp
if (response.Success)
{
    // Inject kernel services so plugins can use IMessageBus, IStorageEngine, etc.
    if (plugin is PluginBase pluginBase)
    {
        pluginBase.InjectKernelServices(_messageBus, _capabilityRegistry, _knowledgeLake);
    }

    _registry.Register(plugin);
    // ... rest unchanged
}
```

Check what parameters InjectKernelServices actually accepts by reading PluginBase.cs line 813+ and pass the correct kernel fields. The kernel has `_messageBus`, `_capabilityRegistry`, `_knowledgeLake` fields — match these to the method signature.

Also check `KernelBuilder.cs` for any similar `LoadPluginAsync` path that also omits InjectKernelServices and fix it there too.
  </action>
  <verify>
Build the solution: `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors.
Grep for InjectKernelServices in Kernel files to confirm the call is present.
  </verify>
  <done>RegisterPluginAsync calls InjectKernelServices on the plugin after successful handshake, before registry registration. Both kernel loader paths inject services.</done>
</task>

<task type="auto">
  <name>Task 2: Delete Sync-Over-Async Wrappers (KS1) — All SDK Pipeline Hot Paths</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Contracts/TransitEncryptionPluginBases.cs
    DataWarehouse.SDK/Hardware/PlatformCapabilityRegistry.cs
    DataWarehouse.SDK/Hardware/Accelerators/HsmProvider.cs
    DataWarehouse.SDK/Infrastructure/StorageConnectionRegistry.cs
    DataWarehouse.SDK/Infrastructure/Distributed/Discovery/MdnsServiceDiscovery.cs
    DataWarehouse.SDK/Infrastructure/Distributed/Discovery/ZeroConfigClusterBootstrap.cs
    DataWarehouse.SDK/Federation/Replication/ReplicaFallbackChain.cs
    DataWarehouse.SDK/Security/IKeyStore.cs
    DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/FreeSpaceManager.cs
  </files>
  <action>
Delete or convert all sync-over-async wrappers in SDK files. The known locations are:

1. **PluginBase.cs** (lines ~1190, ~1202, ~1625):
   - `OnWriteAsync(input, context, args).GetAwaiter().GetResult()` — delete the sync wrapper method entirely; callers must use OnWriteAsync
   - `OnReadAsync(stored, context, args).GetAwaiter().GetResult()` — same, delete sync wrapper
   - `DeleteAsync(new Uri(key)).Wait()` — convert to `await DeleteAsync(new Uri(key))` and make containing method async

2. **TransitEncryptionPluginBases.cs** (lines ~419, ~438):
   - `EncryptForTransitAsync(data, options, secCtx).GetAwaiter().GetResult()` — delete sync wrapper, keep async method
   - `DecryptFromTransitAsync(data, metadata, secCtx).GetAwaiter().GetResult()` — same

3. **PlatformCapabilityRegistry.cs** (lines ~128, 156, 184, 212, 240):
   - All 5 occurrences of `RefreshAsync().GetAwaiter().GetResult()` — convert calling methods to async, or use lazy initialization pattern with AsyncLazy. If these are property getters that can't be async, add async method alternatives and mark sync versions `[Obsolete]`.

4. **HsmProvider.cs** (line ~375):
   - `DisconnectAsync().GetAwaiter().GetResult()` in Dispose — convert to `DisposeAsync` pattern: implement IAsyncDisposable, keep sync Dispose as fire-and-forget `DisconnectAsync().AsTask()` only in finalizer path.

5. **StorageConnectionRegistry.cs** (line ~620):
   - `asyncDisposable.DisposeAsync().AsTask().Wait()` — same IAsyncDisposable pattern.

6. **ReplicaFallbackChain.cs** (line ~60):
   - `topologyProvider.GetNodeTopologyAsync(replicaId).Result` — make calling method async.

7. **IKeyStore.cs** (line ~1036):
   - `GetKeyAsync(keyId, CreateSystemContext()).GetAwaiter().GetResult()` in legacy `GetKey` method — mark `[Obsolete("Use GetKeyAsync")]`, keep for backward compat but add TODO comment.

8. **MdnsServiceDiscovery.cs** (line ~448), **ZeroConfigClusterBootstrap.cs** (line ~207):
   - `StopAsync().GetAwaiter().GetResult()` in Dispose — implement IAsyncDisposable pattern.

9. **FreeSpaceManager.cs** (lines ~132, 152):
   - `_lock.Wait()` — these are SemaphoreSlim.Wait() calls (synchronous semaphore acquisition), NOT async-over-sync. Leave these as-is if they're in synchronous code paths. Only change if the surrounding method should be async.

**IMPORTANT:** For each deleted sync wrapper, check all callers in the solution. If callers use the sync method, they must be updated to use the async version. Use `dotnet build` after each file change to catch compilation errors early.

**Strategy for backward compatibility:** When a sync method is part of an interface (like IKeyStore.GetKey), mark it `[Obsolete]` rather than deleting it. For internal methods not in interfaces, delete outright.
  </action>
  <verify>
Build: `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors.
Grep across entire SDK for `.GetAwaiter().GetResult()` and `.Result;` and `.Wait()` — should return 0 results in pipeline hot paths (only acceptable in Dispose/finalizer paths and `[Obsolete]` legacy methods).
  </verify>
  <done>All sync-over-async wrappers removed from SDK pipeline hot paths. Sync Dispose methods use IAsyncDisposable pattern. Legacy IKeyStore.GetKey marked Obsolete. Build compiles with 0 errors.</done>
</task>

<task type="auto">
  <name>Task 3: Update Living Documentation (DOC-21)</name>
  <files>
    .planning/PLUGIN-CATALOG.md
  </files>
  <action>
Update `.planning/PLUGIN-CATALOG.md` to reflect ALL changes made in this plan:

- Update kernel DI wiring section: document that InjectKernelServices is now called in RegisterPluginAsync after successful handshake
- Update async pipeline documentation: note that all sync-over-async wrappers (.Result, .GetAwaiter().GetResult(), .Wait()) have been removed from SDK pipeline hot paths
- Update IKeyStore section: note that legacy GetKey method is now marked [Obsolete("Use GetKeyAsync")]
- Update Dispose patterns: document new IAsyncDisposable pattern for HsmProvider, StorageConnectionRegistry, MdnsServiceDiscovery, ZeroConfigClusterBootstrap
- Review all affected plugin entries to ensure they reflect the async-first SDK changes

Ensure the hierarchy diagrams, plugin entries, and architectural notes are accurate and current. The goal is that after this plan completes, the PLUGIN-CATALOG reflects ground truth — no codebase exploration needed.
  </action>
  <verify>
Read `.planning/PLUGIN-CATALOG.md` and verify it reflects all changes from this plan. Check that hierarchy diagrams, plugin entries, and base class documentation are accurate.
  </verify>
  <done>PLUGIN-CATALOG.md updated to reflect all changes from this plan. Hierarchy diagrams, plugin entries, and architectural notes are current and accurate.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors
2. Grep for `InjectKernelServices` in DataWarehouse.Kernel/ — present in RegisterPluginAsync
3. Grep for `.GetAwaiter().GetResult()` in DataWarehouse.SDK/ — only in [Obsolete] legacy methods
4. All existing tests pass: `dotnet test DataWarehouse.Tests/ --no-build -v q`
</verification>

<success_criteria>
- KS2: InjectKernelServices called in both kernel plugin registration paths
- KS1: Zero sync-over-async wrappers in SDK pipeline hot paths (non-Obsolete)
- Build: 0 errors, 0 new warnings
- Tests: All existing tests pass
- DOC-21: PLUGIN-CATALOG.md updated to reflect all changes from this plan
</success_criteria>

<output>
After completion, create `.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-01-SUMMARY.md`
</output>
