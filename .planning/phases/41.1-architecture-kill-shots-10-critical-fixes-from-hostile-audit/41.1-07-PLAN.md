---
phase: 41.1-architecture-kill-shots
plan: 07
type: execute
wave: 2
depends_on: ["41.1-04"]
files_modified:
  - DataWarehouse.SDK/Primitives/Configuration/DataWarehouseConfiguration.cs
  - DataWarehouse.SDK/Primitives/Configuration/ConfigurationPresets.cs
  - DataWarehouse.SDK/Primitives/Configuration/ConfigurationItem.cs
  - DataWarehouse.SDK/Primitives/Configuration/ConfigurationAuditLog.cs
  - DataWarehouse.SDK/Primitives/Configuration/Presets/unsafe.xml
  - DataWarehouse.SDK/Primitives/Configuration/Presets/minimal.xml
  - DataWarehouse.SDK/Primitives/Configuration/Presets/standard.xml
  - DataWarehouse.SDK/Primitives/Configuration/Presets/secure.xml
  - DataWarehouse.SDK/Primitives/Configuration/Presets/paranoid.xml
  - DataWarehouse.SDK/Primitives/Configuration/Presets/god-tier.xml
  - DataWarehouse.SDK/Primitives/Configuration/PresetSelector.cs
  - DataWarehouse.SDK/Primitives/Configuration/ConfigurationSerializer.cs
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/IntelligenceAwarePluginBase.cs
  - DataWarehouse.SDK/Contracts/Strategy/StrategyBase.cs
  - DataWarehouse.SDK/Infrastructure/Messaging/IMessageBus.cs
  - DataWarehouse.SDK/Hosting/DataWarehouseKernel.cs
  - DataWarehouse.CLI/Commands/Install/InstallCommandHandler.cs
  - DataWarehouse.GUI/ViewModels/InstallWizardViewModel.cs
  - DataWarehouse.Dashboard/Controllers/ConfigurationController.cs
  - DataWarehouse.SDK/DataWarehouse.SDK.csproj
  - .planning/PLUGIN-CATALOG.md
autonomous: true
must_haves:
  truths:
    - "IAutoConfiguration interface exists and defines environment detection, configuration suggestion, validation, optimization"
    - "IHardwareProbe exists with platform-specific implementations (Windows, Linux, macOS)"
    - "HardwareProbeFactory.Create() returns platform-appropriate probe"
    - "EnvironmentProfile, WorkloadType, ConfigurationSuggestion, ConfigurationValidation all exist in ConfigurationTypes.cs"
    - "PluginBase and StrategyBase are base classes for all plugins and strategies"
    - "IMessageBus supports Subscribe/Publish for configuration changes"
    - "InstallConfiguration exists for CLI/GUI install mode"
  artifacts:
    - path: "DataWarehouse.SDK/Primitives/Configuration/DataWarehouseConfiguration.cs"
      provides: "Unified configuration object with all settings"
      contains: "class DataWarehouseConfiguration"
    - path: "DataWarehouse.SDK/Primitives/Configuration/ConfigurationPresets.cs"
      provides: "Factory methods for presets (unsafe, minimal, standard, secure, paranoid, god-tier)"
      contains: "CreateUnsafe, CreateStandard, CreateGodTier"
    - path: "DataWarehouse.SDK/Primitives/Configuration/ConfigurationItem.cs"
      provides: "Generic wrapper with AllowUserToOverride"
      contains: "class ConfigurationItem<T>"
    - path: "DataWarehouse.SDK/Primitives/Configuration/Presets/*.xml"
      provides: "XML preset templates embedded as resources"
      contains: "SecurityConfiguration, StorageConfiguration"
    - path: "DataWarehouse.SDK/Primitives/Configuration/PresetSelector.cs"
      provides: "Hardware probe integration to select best-fit preset"
      contains: "SelectPreset, IHardwareProbe"
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "Configuration property injected to all plugins"
      contains: "DataWarehouseConfiguration Configuration"
    - path: "DataWarehouse.SDK/Contracts/Strategy/StrategyBase.cs"
      provides: "Configuration property injected to all strategies"
      contains: "DataWarehouseConfiguration Configuration"
  key_links:
    - from: "DataWarehouseConfiguration"
      to: "IAutoConfiguration"
      via: "Integrates with auto-configuration interface"
      pattern: "IAutoConfiguration"
    - from: "PresetSelector"
      to: "IHardwareProbe"
      via: "Uses hardware detection to select preset"
      pattern: "IHardwareProbe.*DiscoverAsync"
    - from: "PluginBase"
      to: "DataWarehouseConfiguration"
      via: "Configuration property injection"
      pattern: "protected DataWarehouseConfiguration Configuration"
    - from: "IMessageBus"
      to: "ConfigurationChanged"
      via: "Runtime config change notifications"
      pattern: "ConfigurationChanged.*topic"
---

<objective>
Fix CFG-17 through CFG-20 + ENHANCEMENTS (CFG-18-ENHANCED, CFG-18-AUDIT, DOC-21): Create a unified configuration system with presets, hardware probe integration, per-item override control, BIDIRECTIONAL file persistence, and FULL audit trail.

Purpose: Consolidate ALL configuration settings scattered across KernelConfiguration, SecurityPolicySettings, EmbeddedConfiguration, etc. into a single DataWarehouseConfiguration object. Define 6 preset levels from "unsafe" (zero security, dev/testing) to "god-tier" (everything enabled). Integrate hardware probes into install flow to auto-select best-fit preset. Add per-item AllowUserToOverride control and instance-level configuration injection. ENHANCED: XML/YAML files are COMPLETE living system state files (EVERY setting, not just overrides), loaded at EVERY startup, with runtime changes WRITTEN BACK to the file and FULL AUDIT TRAIL (who, when, what, old→new values).

Output: DataWarehouseConfiguration class, 6 COMPLETE XML preset templates, PresetSelector with hardware integration, ConfigurationItem<T> wrapper, ConfigurationAuditLog with append-only audit trail, bidirectional ConfigurationSerializer (LoadFromFile + SaveToFile), configuration injection in PluginBase/StrategyBase, runtime config change API via IMessageBus with write-back and audit logging, kernel startup flow to load config from file, PLUGIN-CATALOG.md documentation update.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-RESEARCH.md
@.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/REQUIREMENTS.md
@DataWarehouse.SDK/Primitives/Configuration/IAutoConfiguration.cs
@DataWarehouse.SDK/Primitives/Configuration/ConfigurationTypes.cs
@DataWarehouse.SDK/Hardware/IHardwareProbe.cs
@DataWarehouse.SDK/Hardware/HardwareProbeFactory.cs
@DataWarehouse.SDK/Hosting/InstallConfiguration.cs
@DataWarehouse.SDK/Contracts/Hierarchy/Feature/SecurityPluginBase.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Infrastructure/Messaging/IMessageBus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Unified DataWarehouseConfiguration Object (CFG-17)</name>
  <files>
    DataWarehouse.SDK/Primitives/Configuration/DataWarehouseConfiguration.cs
    DataWarehouse.SDK/Primitives/Configuration/ConfigurationItem.cs
    DataWarehouse.SDK/Primitives/Configuration/ConfigurationPresets.cs
  </files>
  <action>
**Step 1: Create ConfigurationItem<T> wrapper** in `DataWarehouse.SDK/Primitives/Configuration/ConfigurationItem.cs`:

```csharp
namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// Wrapper for configuration items with override control.
/// </summary>
/// <typeparam name="T">The type of the configuration value.</typeparam>
public class ConfigurationItem<T>
{
    /// <summary>Gets or sets the configuration value.</summary>
    public T Value { get; set; }

    /// <summary>Gets or sets whether users can override this value at runtime.</summary>
    public bool AllowUserToOverride { get; set; } = true;

    /// <summary>Gets or sets the policy that locked this value (if AllowUserToOverride is false).</summary>
    public string? LockedByPolicy { get; set; }

    /// <summary>Gets or sets the description of this configuration item.</summary>
    public string? Description { get; set; }

    public ConfigurationItem(T value, bool allowOverride = true, string? lockedBy = null, string? description = null)
    {
        Value = value;
        AllowUserToOverride = allowOverride;
        LockedByPolicy = lockedBy;
        Description = description;
    }

    /// <summary>Implicit conversion to T for easier usage.</summary>
    public static implicit operator T(ConfigurationItem<T> item) => item.Value;
}
```

**Step 2: Create DataWarehouseConfiguration.cs** in `DataWarehouse.SDK/Primitives/Configuration/`:

This class consolidates ALL configuration aspects:

```csharp
using System.Xml.Serialization;

namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// Unified configuration object for the entire DataWarehouse system.
/// Consolidates security, storage, networking, replication, encryption, compression,
/// observability, compute, resilience, and all other configurable aspects.
/// </summary>
[XmlRoot("DataWarehouseConfiguration")]
public class DataWarehouseConfiguration
{
    /// <summary>Gets or sets the configuration preset name (unsafe, minimal, standard, secure, paranoid, god-tier).</summary>
    public string PresetName { get; set; } = "standard";

    /// <summary>Gets or sets the configuration version (for migration compatibility).</summary>
    public string Version { get; set; } = "3.0.0";

    /// <summary>Security-related configuration.</summary>
    public SecurityConfiguration Security { get; set; } = new();

    /// <summary>Storage-related configuration.</summary>
    public StorageConfiguration Storage { get; set; } = new();

    /// <summary>Network-related configuration.</summary>
    public NetworkConfiguration Network { get; set; } = new();

    /// <summary>Replication-related configuration.</summary>
    public ReplicationConfiguration Replication { get; set; } = new();

    /// <summary>Encryption-related configuration.</summary>
    public EncryptionConfiguration Encryption { get; set; } = new();

    /// <summary>Compression-related configuration.</summary>
    public CompressionConfiguration Compression { get; set; } = new();

    /// <summary>Observability-related configuration.</summary>
    public ObservabilityConfiguration Observability { get; set; } = new();

    /// <summary>Compute-related configuration.</summary>
    public ComputeConfiguration Compute { get; set; } = new();

    /// <summary>Resilience-related configuration.</summary>
    public ResilienceConfiguration Resilience { get; set; } = new();

    /// <summary>Deployment-related configuration.</summary>
    public DeploymentConfiguration Deployment { get; set; } = new();

    /// <summary>Data management configuration.</summary>
    public DataManagementConfiguration DataManagement { get; set; } = new();

    /// <summary>Message bus configuration.</summary>
    public MessageBusConfiguration MessageBus { get; set; } = new();

    /// <summary>Plugin system configuration.</summary>
    public PluginConfiguration Plugins { get; set; } = new();
}

/// <summary>Security configuration section.</summary>
public class SecurityConfiguration
{
    public ConfigurationItem<bool> EncryptionEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> AuthEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> AuditEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> TlsRequired { get; set; } = new(true);
    public ConfigurationItem<bool> MfaEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> RbacEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> ZeroTrustMode { get; set; } = new(false);
    public ConfigurationItem<bool> FipsMode { get; set; } = new(false);
    public ConfigurationItem<bool> QuantumSafeMode { get; set; } = new(false);
    public ConfigurationItem<bool> HsmRequired { get; set; } = new(false);
    public ConfigurationItem<bool> CertificatePinning { get; set; } = new(false);
    public ConfigurationItem<bool> TamperProofLogging { get; set; } = new(false);
    public ConfigurationItem<int> PasswordMinLength { get; set; } = new(12);
    public ConfigurationItem<int> SessionTimeoutMinutes { get; set; } = new(30);
    public ConfigurationItem<string> DefaultAuthScheme { get; set; } = new("RBAC");
}

/// <summary>Storage configuration section.</summary>
public class StorageConfiguration
{
    public ConfigurationItem<bool> EncryptAtRest { get; set; } = new(true);
    public ConfigurationItem<bool> EnableCompression { get; set; } = new(true);
    public ConfigurationItem<bool> EnableDeduplication { get; set; } = new(false);
    public ConfigurationItem<bool> EnableCaching { get; set; } = new(true);
    public ConfigurationItem<bool> EnableIndexing { get; set; } = new(true);
    public ConfigurationItem<bool> EnableVersioning { get; set; } = new(false);
    public ConfigurationItem<long> CacheSizeBytes { get; set; } = new(1024L * 1024 * 1024); // 1GB
    public ConfigurationItem<int> MaxConnections { get; set; } = new(100);
    public ConfigurationItem<string> DefaultBackend { get; set; } = new("FileSystem");
    public ConfigurationItem<string> DataDirectory { get; set; } = new("./data");
}

/// <summary>Network configuration section.</summary>
public class NetworkConfiguration
{
    public ConfigurationItem<bool> TlsEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> Http2Enabled { get; set; } = new(true);
    public ConfigurationItem<bool> Http3Enabled { get; set; } = new(false);
    public ConfigurationItem<bool> CompressionEnabled { get; set; } = new(true);
    public ConfigurationItem<int> ListenPort { get; set; } = new(8080);
    public ConfigurationItem<int> MaxConnectionsPerEndpoint { get; set; } = new(1000);
    public ConfigurationItem<int> TimeoutSeconds { get; set; } = new(30);
    public ConfigurationItem<string> BindAddress { get; set; } = new("0.0.0.0");
}

/// <summary>Replication configuration section.</summary>
public class ReplicationConfiguration
{
    public ConfigurationItem<bool> Enabled { get; set; } = new(false);
    public ConfigurationItem<bool> MultiMasterEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> CrdtEnabled { get; set; } = new(false);
    public ConfigurationItem<int> ReplicationFactor { get; set; } = new(3);
    public ConfigurationItem<int> ConsistencyLevel { get; set; } = new(1); // 1=ONE, 2=QUORUM, 3=ALL
    public ConfigurationItem<int> SyncIntervalSeconds { get; set; } = new(60);
    public ConfigurationItem<string> ConflictResolutionStrategy { get; set; } = new("LastWriteWins");
}

/// <summary>Encryption configuration section.</summary>
public class EncryptionConfiguration
{
    public ConfigurationItem<bool> Enabled { get; set; } = new(true);
    public ConfigurationItem<bool> EncryptInTransit { get; set; } = new(true);
    public ConfigurationItem<bool> EncryptAtRest { get; set; } = new(true);
    public ConfigurationItem<bool> EnvelopeEncryption { get; set; } = new(true);
    public ConfigurationItem<bool> KeyRotationEnabled { get; set; } = new(false);
    public ConfigurationItem<int> KeyRotationDays { get; set; } = new(90);
    public ConfigurationItem<string> DefaultAlgorithm { get; set; } = new("AES256-GCM");
    public ConfigurationItem<string> KeyStoreBackend { get; set; } = new("FileSystem");
}

/// <summary>Compression configuration section.</summary>
public class CompressionConfiguration
{
    public ConfigurationItem<bool> Enabled { get; set; } = new(true);
    public ConfigurationItem<bool> AutoSelect { get; set; } = new(true);
    public ConfigurationItem<int> CompressionLevel { get; set; } = new(6); // 0-9
    public ConfigurationItem<string> DefaultAlgorithm { get; set; } = new("zstd");
}

/// <summary>Observability configuration section.</summary>
public class ObservabilityConfiguration
{
    public ConfigurationItem<bool> MetricsEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> TracingEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> LoggingEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> HealthCheckEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> AnomalyDetectionEnabled { get; set; } = new(false);
    public ConfigurationItem<string> LogLevel { get; set; } = new("Information");
    public ConfigurationItem<int> MetricsIntervalSeconds { get; set; } = new(60);
}

/// <summary>Compute configuration section.</summary>
public class ComputeConfiguration
{
    public ConfigurationItem<bool> GpuEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> ParallelProcessingEnabled { get; set; } = new(true);
    public ConfigurationItem<int> MaxWorkerThreads { get; set; } = new(0); // 0 = auto-detect
    public ConfigurationItem<int> MaxIoThreads { get; set; } = new(0); // 0 = auto-detect
    public ConfigurationItem<string> SchedulingStrategy { get; set; } = new("FairShare");
}

/// <summary>Resilience configuration section.</summary>
public class ResilienceConfiguration
{
    public ConfigurationItem<bool> CircuitBreakerEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> RetryEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> BulkheadEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> SelfHealingEnabled { get; set; } = new(false);
    public ConfigurationItem<int> MaxRetries { get; set; } = new(3);
    public ConfigurationItem<int> CircuitBreakerThreshold { get; set; } = new(5);
    public ConfigurationItem<int> TimeoutSeconds { get; set; } = new(30);
}

/// <summary>Deployment configuration section.</summary>
public class DeploymentConfiguration
{
    public ConfigurationItem<bool> AirGapMode { get; set; } = new(false);
    public ConfigurationItem<bool> MultiCloudEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> EdgeEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> EmbeddedMode { get; set; } = new(false);
    public ConfigurationItem<string> EnvironmentType { get; set; } = new("Production");
}

/// <summary>Data management configuration section.</summary>
public class DataManagementConfiguration
{
    public ConfigurationItem<bool> CatalogEnabled { get; set; } = new(true);
    public ConfigurationItem<bool> GovernanceEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> QualityEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> LineageEnabled { get; set; } = new(false);
    public ConfigurationItem<bool> MultiTenancyEnabled { get; set; } = new(false);
}

/// <summary>Message bus configuration section.</summary>
public class MessageBusConfiguration
{
    public ConfigurationItem<bool> PersistentMessages { get; set; } = new(false);
    public ConfigurationItem<bool> OrderedDelivery { get; set; } = new(false);
    public ConfigurationItem<int> MaxQueueSize { get; set; } = new(10000);
    public ConfigurationItem<int> DeliveryTimeoutSeconds { get; set; } = new(30);
}

/// <summary>Plugin configuration section.</summary>
public class PluginConfiguration
{
    public ConfigurationItem<bool> AutoLoadPlugins { get; set; } = new(true);
    public ConfigurationItem<bool> AllowHotReload { get; set; } = new(false);
    public ConfigurationItem<int> MaxPlugins { get; set; } = new(100);
    public ConfigurationItem<string> PluginDirectory { get; set; } = new("./plugins");
}
```

**Step 3: Create ConfigurationPresets.cs** with factory methods for each preset:

```csharp
namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// Factory methods for creating preset configurations.
/// </summary>
public static class ConfigurationPresets
{
    /// <summary>UNSAFE preset: Zero security, maximum performance, dev/testing ONLY.</summary>
    public static DataWarehouseConfiguration CreateUnsafe()
    {
        var config = new DataWarehouseConfiguration { PresetName = "unsafe" };

        config.Security.EncryptionEnabled.Value = false;
        config.Security.AuthEnabled.Value = false;
        config.Security.AuditEnabled.Value = false;
        config.Security.TlsRequired.Value = false;
        config.Security.RbacEnabled.Value = false;

        config.Encryption.Enabled.Value = false;
        config.Encryption.EncryptInTransit.Value = false;
        config.Encryption.EncryptAtRest.Value = false;

        config.Storage.EncryptAtRest.Value = false;
        config.Network.TlsEnabled.Value = false;

        return config;
    }

    /// <summary>MINIMAL preset: Basic auth, no encryption, no audit.</summary>
    public static DataWarehouseConfiguration CreateMinimal()
    {
        var config = new DataWarehouseConfiguration { PresetName = "minimal" };

        config.Security.EncryptionEnabled.Value = false;
        config.Security.AuthEnabled.Value = true;
        config.Security.AuditEnabled.Value = false;
        config.Security.TlsRequired.Value = false;
        config.Security.RbacEnabled.Value = true;
        config.Security.DefaultAuthScheme.Value = "Basic";

        config.Encryption.Enabled.Value = false;
        config.Storage.EncryptAtRest.Value = false;
        config.Network.TlsEnabled.Value = false;

        return config;
    }

    /// <summary>STANDARD preset: AES-256, RBAC, basic audit, TLS required.</summary>
    public static DataWarehouseConfiguration CreateStandard()
    {
        // Default values in DataWarehouseConfiguration are already "standard"
        var config = new DataWarehouseConfiguration { PresetName = "standard" };

        config.Security.EncryptionEnabled.Value = true;
        config.Security.AuthEnabled.Value = true;
        config.Security.AuditEnabled.Value = true;
        config.Security.TlsRequired.Value = true;
        config.Security.RbacEnabled.Value = true;

        config.Encryption.Enabled.Value = true;
        config.Encryption.DefaultAlgorithm.Value = "AES256-GCM";

        config.Storage.EncryptAtRest.Value = true;
        config.Network.TlsEnabled.Value = true;

        return config;
    }

    /// <summary>SECURE preset: Quantum-safe crypto, MFA, full audit, encrypted-at-rest, certificate pinning.</summary>
    public static DataWarehouseConfiguration CreateSecure()
    {
        var config = CreateStandard();
        config.PresetName = "secure";

        config.Security.QuantumSafeMode.Value = true;
        config.Security.MfaEnabled.Value = true;
        config.Security.CertificatePinning.Value = true;
        config.Security.PasswordMinLength.Value = 16;
        config.Security.SessionTimeoutMinutes.Value = 15;

        config.Encryption.KeyRotationEnabled.Value = true;
        config.Encryption.KeyRotationDays.Value = 30;

        config.Observability.TracingEnabled.Value = true;
        config.Observability.AnomalyDetectionEnabled.Value = false;

        return config;
    }

    /// <summary>PARANOID preset: FIPS 140-3, HSM keys, air-gap ready, tamper-proof logging, zero-trust.</summary>
    public static DataWarehouseConfiguration CreateParanoid()
    {
        var config = CreateSecure();
        config.PresetName = "paranoid";

        config.Security.FipsMode.Value = true;
        config.Security.HsmRequired.Value = true;
        config.Security.ZeroTrustMode.Value = true;
        config.Security.TamperProofLogging.Value = true;
        config.Security.SessionTimeoutMinutes.Value = 10;

        // Lock critical security settings (cannot be overridden)
        config.Security.EncryptionEnabled.AllowUserToOverride = false;
        config.Security.EncryptionEnabled.LockedByPolicy = "Paranoid Preset";
        config.Security.AuthEnabled.AllowUserToOverride = false;
        config.Security.AuthEnabled.LockedByPolicy = "Paranoid Preset";
        config.Security.TlsRequired.AllowUserToOverride = false;
        config.Security.TlsRequired.LockedByPolicy = "Paranoid Preset";
        config.Security.FipsMode.AllowUserToOverride = false;
        config.Security.FipsMode.LockedByPolicy = "Paranoid Preset";

        config.Encryption.KeyStoreBackend.Value = "HSM";

        config.Deployment.AirGapMode.Value = true;

        return config;
    }

    /// <summary>GOD-TIER preset: Everything enabled, ML anomaly detection, adaptive security, self-healing, auto-rotation.</summary>
    public static DataWarehouseConfiguration CreateGodTier()
    {
        var config = CreateParanoid();
        config.PresetName = "god-tier";

        // Enable all advanced features
        config.Observability.AnomalyDetectionEnabled.Value = true;
        config.Resilience.SelfHealingEnabled.Value = true;

        config.Replication.Enabled.Value = true;
        config.Replication.MultiMasterEnabled.Value = true;
        config.Replication.CrdtEnabled.Value = true;
        config.Replication.ReplicationFactor.Value = 5;
        config.Replication.ConsistencyLevel.Value = 2; // QUORUM

        config.Storage.EnableDeduplication.Value = true;
        config.Storage.EnableVersioning.Value = true;

        config.DataManagement.GovernanceEnabled.Value = true;
        config.DataManagement.QualityEnabled.Value = true;
        config.DataManagement.LineageEnabled.Value = true;
        config.DataManagement.MultiTenancyEnabled.Value = true;

        config.Compute.GpuEnabled.Value = true;

        config.Deployment.MultiCloudEnabled.Value = true;
        config.Deployment.EdgeEnabled.Value = true;

        return config;
    }

    /// <summary>Get preset by name.</summary>
    public static DataWarehouseConfiguration CreateByName(string presetName)
    {
        return presetName.ToLowerInvariant() switch
        {
            "unsafe" => CreateUnsafe(),
            "minimal" => CreateMinimal(),
            "standard" => CreateStandard(),
            "secure" => CreateSecure(),
            "paranoid" => CreateParanoid(),
            "god-tier" or "godtier" => CreateGodTier(),
            _ => CreateStandard()
        };
    }
}
```
  </action>
  <verify>
Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore -v q` — 0 errors.
Grep for `class DataWarehouseConfiguration` — present.
Grep for `CreateGodTier` in ConfigurationPresets.cs — present.
Grep for `ConfigurationItem<T>` — present.
  </verify>
  <done>DataWarehouseConfiguration class created with all configuration sections (Security, Storage, Network, Replication, Encryption, Compression, Observability, Compute, Resilience, Deployment, DataManagement, MessageBus, Plugins). ConfigurationItem<T> wrapper with AllowUserToOverride implemented. ConfigurationPresets factory with 6 presets (unsafe, minimal, standard, secure, paranoid, god-tier).</done>
</task>

<task type="auto">
  <name>Task 2: Create COMPLETE XML Config Files + Bidirectional Persistence (CFG-18-ENHANCED)</name>
  <files>
    DataWarehouse.SDK/Primitives/Configuration/Presets/unsafe.xml
    DataWarehouse.SDK/Primitives/Configuration/Presets/minimal.xml
    DataWarehouse.SDK/Primitives/Configuration/Presets/standard.xml
    DataWarehouse.SDK/Primitives/Configuration/Presets/secure.xml
    DataWarehouse.SDK/Primitives/Configuration/Presets/paranoid.xml
    DataWarehouse.SDK/Primitives/Configuration/Presets/god-tier.xml
    DataWarehouse.SDK/Primitives/Configuration/ConfigurationSerializer.cs
    DataWarehouse.SDK/DataWarehouse.SDK.csproj
  </files>
  <action>
**ENHANCED VISION**: XML/YAML files are COMPLETE living system state files, NOT just bootstrapping templates. They contain EVERY setting in DataWarehouse, neatly categorized and laid out. The same config file is loaded at EVERY startup and persists across runs. Runtime changes are WRITTEN BACK to the file. Analogy: Windows Answer File + Settings/Control Panel hybrid, but comprehensive.

**Step 1: Create directory structure:**

Create directory: `DataWarehouse.SDK/Primitives/Configuration/Presets/`

**Step 2: Create COMPLETE unsafe.xml** (EVERY section, EVERY property from DataWarehouseConfiguration):

```xml
<?xml version="1.0" encoding="utf-8"?>
<DataWarehouseConfiguration>
  <PresetName>unsafe</PresetName>
  <Version>3.0.0</Version>

  <!-- Security Configuration Section -->
  <Security>
    <EncryptionEnabled><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></EncryptionEnabled>
    <AuthEnabled><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></AuthEnabled>
    <AuditEnabled><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></AuditEnabled>
    <TlsRequired><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></TlsRequired>
    <MfaEnabled><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></MfaEnabled>
    <RbacEnabled><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></RbacEnabled>
    <ZeroTrustMode><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></ZeroTrustMode>
    <FipsMode><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></FipsMode>
    <QuantumSafeMode><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></QuantumSafeMode>
    <HsmRequired><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></HsmRequired>
    <CertificatePinning><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></CertificatePinning>
    <TamperProofLogging><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></TamperProofLogging>
    <PasswordMinLength><Value>8</Value><AllowUserToOverride>true</AllowUserToOverride></PasswordMinLength>
    <SessionTimeoutMinutes><Value>120</Value><AllowUserToOverride>true</AllowUserToOverride></SessionTimeoutMinutes>
    <DefaultAuthScheme><Value>None</Value><AllowUserToOverride>true</AllowUserToOverride></DefaultAuthScheme>
  </Security>

  <!-- Storage Configuration Section -->
  <Storage>
    <EncryptAtRest><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></EncryptAtRest>
    <EnableCompression><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></EnableCompression>
    <EnableDeduplication><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></EnableDeduplication>
    <EnableCaching><Value>true</Value><AllowUserToOverride>true</AllowUserToOverride></EnableCaching>
    <EnableIndexing><Value>true</Value><AllowUserToOverride>true</AllowUserToOverride></EnableIndexing>
    <EnableVersioning><Value>false</Value><AllowUserToOverride>true</AllowUserToOverride></EnableVersioning>
    <CacheSizeBytes><Value>536870912</Value><AllowUserToOverride>true</AllowUserToOverride></CacheSizeBytes>
    <MaxConnections><Value>100</Value><AllowUserToOverride>true</AllowUserToOverride></MaxConnections>
    <DefaultBackend><Value>FileSystem</Value><AllowUserToOverride>true</AllowUserToOverride></DefaultBackend>
    <DataDirectory><Value>./data</Value><AllowUserToOverride>true</AllowUserToOverride></DataDirectory>
  </Storage>

  <!-- Network, Replication, Encryption, Compression, Observability, Compute, Resilience, Deployment, DataManagement, MessageBus, Plugins sections follow... -->
  <!-- (Include ALL properties from DataWarehouseConfiguration class) -->
</DataWarehouseConfiguration>
```

**Step 3: Create COMPLETE standard.xml, god-tier.xml, minimal.xml, secure.xml, paranoid.xml** following the same pattern. Each XML file must serialize THE ENTIRE DataWarehouseConfiguration object with all 13 sections and all properties.

**Step 4: Create ConfigurationSerializer.cs with BIDIRECTIONAL file persistence:**

```csharp
using System.Xml.Serialization;

namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// Serializes and deserializes DataWarehouseConfiguration to/from XML/YAML.
/// Supports bidirectional persistence: LoadFromFile at startup, SaveToFile after changes.
/// </summary>
public static class ConfigurationSerializer
{
    private static readonly XmlSerializer _xmlSerializer = new(typeof(DataWarehouseConfiguration));

    /// <summary>Serialize configuration to XML.</summary>
    public static string ToXml(DataWarehouseConfiguration config)
    {
        using var writer = new StringWriter();
        _xmlSerializer.Serialize(writer, config);
        return writer.ToString();
    }

    /// <summary>Deserialize configuration from XML.</summary>
    public static DataWarehouseConfiguration? FromXml(string xml)
    {
        using var reader = new StringReader(xml);
        return _xmlSerializer.Deserialize(reader) as DataWarehouseConfiguration;
    }

    /// <summary>Load configuration from XML file.</summary>
    public static DataWarehouseConfiguration LoadFromFile(string filePath)
    {
        if (!File.Exists(filePath))
        {
            // Create default config if missing
            var defaultConfig = ConfigurationPresets.CreateStandard();
            SaveToFile(defaultConfig, filePath);
            return defaultConfig;
        }

        var xml = File.ReadAllText(filePath);
        return FromXml(xml) ?? ConfigurationPresets.CreateStandard();
    }

    /// <summary>
    /// Save configuration to XML file (BIDIRECTIONAL write-back).
    /// Called after every runtime configuration change.
    /// </summary>
    public static void SaveToFile(DataWarehouseConfiguration config, string filePath)
    {
        var xml = ToXml(config);

        // Ensure directory exists
        var directory = Path.GetDirectoryName(filePath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            Directory.CreateDirectory(directory);

        File.WriteAllText(filePath, xml);
    }

    /// <summary>Load preset from embedded resource.</summary>
    public static DataWarehouseConfiguration LoadPreset(string presetName)
    {
        var assembly = typeof(ConfigurationSerializer).Assembly;
        var resourceName = $"DataWarehouse.SDK.Primitives.Configuration.Presets.{presetName}.xml";

        using var stream = assembly.GetManifestResourceStream(resourceName);
        if (stream == null)
            return ConfigurationPresets.CreateByName(presetName);

        using var reader = new StreamReader(stream);
        var xml = reader.ReadToEnd();
        return FromXml(xml) ?? ConfigurationPresets.CreateByName(presetName);
    }
}
```

**Step 5: Update DataWarehouse.SDK.csproj** to embed XML files as resources:

Add to .csproj:
```xml
<ItemGroup>
  <EmbeddedResource Include="Primitives\Configuration\Presets\*.xml" />
</ItemGroup>
```
  </action>
  <verify>
Verify XML files exist: ls DataWarehouse.SDK/Primitives/Configuration/Presets/*.xml — 6 files.
Build: `dotnet build DataWarehouse.SDK/ --no-restore -v q` — 0 errors.
Grep for `LoadPreset` in ConfigurationSerializer.cs — present.
Grep for `SaveToFile` in ConfigurationSerializer.cs — present (bidirectional write-back).
Grep for `EmbeddedResource` in DataWarehouse.SDK.csproj — present.
Verify XML files are COMPLETE (all 13 sections, all properties serialized).
  </verify>
  <done>6 COMPLETE XML preset templates created (unsafe, minimal, standard, secure, paranoid, god-tier) with ALL 13 configuration sections and ALL properties serialized. ConfigurationSerializer implemented with BIDIRECTIONAL persistence: LoadFromFile at startup, SaveToFile after every runtime change. Auto-creates default config if missing. .csproj updated to embed XML files as resources.</done>
</task>

<task type="auto">
  <name>Task 3: Hardware Probe Integration with PresetSelector (CFG-19)</name>
  <files>
    DataWarehouse.SDK/Primitives/Configuration/PresetSelector.cs
    DataWarehouse.CLI/Commands/Install/InstallCommandHandler.cs
    DataWarehouse.GUI/ViewModels/InstallWizardViewModel.cs
  </files>
  <action>
**Step 1: Create PresetSelector.cs** in `DataWarehouse.SDK/Primitives/Configuration/`:

```csharp
using DataWarehouse.SDK.Hardware;

namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// Selects the best-fit configuration preset based on detected hardware capabilities.
/// </summary>
public static class PresetSelector
{
    /// <summary>
    /// Selects the best configuration preset based on hardware probe results.
    /// </summary>
    /// <param name="probe">Hardware probe to detect resources.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Recommended preset name and configuration.</returns>
    public static async Task<(string PresetName, DataWarehouseConfiguration Config)> SelectPresetAsync(
        IHardwareProbe probe,
        CancellationToken ct = default)
    {
        var devices = await probe.DiscoverAsync(null, ct);

        // Analyze resources
        var cpuCores = GetCpuCores(devices);
        var ramGb = GetRamGigabytes(devices);
        var hasHsm = HasHsm(devices);
        var hasTpm = HasTpm(devices);
        var hasGpu = HasGpu(devices);

        // Decision logic
        if (hasHsm || hasTpm)
        {
            // HSM/TPM detected → paranoid preset
            return ("paranoid", ConfigurationPresets.CreateParanoid());
        }

        if (hasGpu && ramGb >= 128)
        {
            // GPU + large RAM (128GB+) → god-tier preset
            return ("god-tier", ConfigurationPresets.CreateGodTier());
        }

        if (cpuCores >= 16 && ramGb >= 32)
        {
            // High resources (16+ cores, 32+ GB RAM) → secure preset
            return ("secure", ConfigurationPresets.CreateSecure());
        }

        if (cpuCores >= 4 && ramGb >= 8)
        {
            // Standard resources (4-16 cores, 8-32GB RAM) → standard preset
            return ("standard", ConfigurationPresets.CreateStandard());
        }

        // Low resources (< 4 cores, < 8GB RAM) → minimal preset
        return ("minimal", ConfigurationPresets.CreateMinimal());
    }

    private static int GetCpuCores(IReadOnlyList<HardwareDevice> devices)
    {
        var cpu = devices.FirstOrDefault(d => d.Type == HardwareDeviceType.Cpu);
        if (cpu?.Properties.TryGetValue("Cores", out var coresValue) == true && int.TryParse(coresValue, out var cores))
            return cores;

        return Environment.ProcessorCount; // Fallback
    }

    private static int GetRamGigabytes(IReadOnlyList<HardwareDevice> devices)
    {
        var memory = devices.FirstOrDefault(d => d.Type == HardwareDeviceType.Memory);
        if (memory?.Properties.TryGetValue("TotalBytes", out var bytesValue) == true && long.TryParse(bytesValue, out var bytes))
            return (int)(bytes / (1024 * 1024 * 1024));

        return 8; // Fallback: assume 8GB
    }

    private static bool HasHsm(IReadOnlyList<HardwareDevice> devices)
        => devices.Any(d => d.Type == HardwareDeviceType.SecurityModule &&
                            d.Properties.GetValueOrDefault("ModuleType") == "HSM");

    private static bool HasTpm(IReadOnlyList<HardwareDevice> devices)
        => devices.Any(d => d.Type == HardwareDeviceType.SecurityModule &&
                            d.Properties.GetValueOrDefault("ModuleType") == "TPM");

    private static bool HasGpu(IReadOnlyList<HardwareDevice> devices)
        => devices.Any(d => d.Type == HardwareDeviceType.Gpu);
}
```

**Step 2: Integrate into CLI install flow** (read existing InstallCommandHandler.cs, add hardware probe call):

In `InstallCommandHandler.cs`, locate the install flow. Add:

```csharp
// After user confirms install, before applying configuration:
using var probe = HardwareProbeFactory.Create();
var (presetName, suggestedConfig) = await PresetSelector.SelectPresetAsync(probe, ct);

_logger.LogInformation("Detected hardware suggests '{PresetName}' preset", presetName);
_logger.LogInformation("  CPU Cores: {Cores}", Environment.ProcessorCount);
_logger.LogInformation("  Preset: {Preset}", presetName);

// Prompt user for approval/modification
var userApproved = await PromptForPresetApprovalAsync(presetName, suggestedConfig);
if (!userApproved)
{
    // Let user choose different preset
    suggestedConfig = await PromptForAlternativePresetAsync();
}

// Apply configuration
await ApplyConfigurationAsync(suggestedConfig, ct);
```

**Step 3: Integrate into GUI install flow** (read existing InstallWizardViewModel.cs, add hardware detection page):

In `InstallWizardViewModel.cs`, add a "Hardware Detection" step:

```csharp
private async Task DetectHardwareAndSuggestPresetAsync()
{
    using var probe = HardwareProbeFactory.Create();
    var (presetName, suggestedConfig) = await PresetSelector.SelectPresetAsync(probe);

    RecommendedPreset = presetName;
    CurrentConfiguration = suggestedConfig;

    // Display in UI for user review/modification
    NotifyPropertyChanged(nameof(RecommendedPreset));
    NotifyPropertyChanged(nameof(CurrentConfiguration));
}
```
  </action>
  <verify>
Build: `dotnet build DataWarehouse.SDK/ --no-restore -v q` — 0 errors.
Grep for `SelectPresetAsync` in PresetSelector.cs — present.
Grep for `IHardwareProbe` in PresetSelector.cs — present.
Build CLI: `dotnet build DataWarehouse.CLI/ --no-restore -v q` — 0 errors.
Build GUI: `dotnet build DataWarehouse.GUI/ --no-restore -v q` — 0 errors.
  </verify>
  <done>PresetSelector created with hardware-based preset selection logic. Integrated into CLI and GUI install flows. Hardware probe detects CPU cores, RAM, HSM, TPM, GPU and selects best-fit preset (minimal for low resources, standard for typical, secure for high, paranoid for HSM/TPM, god-tier for GPU + large RAM).</done>
</task>

<task type="auto">
  <name>Task 4: Configuration Audit Log + Bidirectional Write-Back (CFG-18-ENHANCED)</name>
  <files>
    DataWarehouse.SDK/Primitives/Configuration/ConfigurationAuditLog.cs
    DataWarehouse.SDK/Primitives/Configuration/ConfigurationChangeApi.cs
    DataWarehouse.SDK/Hosting/DataWarehouseKernel.cs
  </files>
  <action>
**ENHANCED VISION**: Full audit trail for every configuration change with who, when, what setting, old value → new value. All changes written back to the XML/YAML file. Config loaded at EVERY startup.

**Step 1: Create ConfigurationAuditLog.cs:**

```csharp
using System.Text.Json;

namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// Append-only audit log for all configuration changes.
/// Logs who changed what, when, and the before/after values.
/// </summary>
public class ConfigurationAuditLog
{
    private readonly string _auditFilePath;
    private readonly object _lock = new();

    public ConfigurationAuditLog(string auditFilePath)
    {
        _auditFilePath = auditFilePath ?? throw new ArgumentNullException(nameof(auditFilePath));

        // Ensure directory exists
        var directory = Path.GetDirectoryName(_auditFilePath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            Directory.CreateDirectory(directory);
    }

    /// <summary>Audit entry record.</summary>
    public record AuditEntry(
        DateTime Timestamp,
        string User,
        string SettingPath,
        string? OldValue,
        string? NewValue,
        string? Reason);

    /// <summary>
    /// Log a configuration change.
    /// Append-only: never modifies existing entries.
    /// </summary>
    public async Task LogChangeAsync(string user, string settingPath, object? oldValue, object? newValue, string? reason = null)
    {
        var entry = new AuditEntry(
            DateTime.UtcNow,
            user ?? "System",
            settingPath,
            oldValue?.ToString(),
            newValue?.ToString(),
            reason);

        var json = JsonSerializer.Serialize(entry);

        lock (_lock)
        {
            File.AppendAllText(_auditFilePath, json + Environment.NewLine);
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Query configuration changes with optional filters.
    /// </summary>
    public async Task<IReadOnlyList<AuditEntry>> QueryChangesAsync(
        string? settingPathPrefix = null,
        DateTime? since = null,
        DateTime? until = null,
        string? user = null)
    {
        if (!File.Exists(_auditFilePath))
            return Array.Empty<AuditEntry>();

        var lines = await File.ReadAllLinesAsync(_auditFilePath);
        var entries = new List<AuditEntry>();

        foreach (var line in lines)
        {
            if (string.IsNullOrWhiteSpace(line))
                continue;

            try
            {
                var entry = JsonSerializer.Deserialize<AuditEntry>(line);
                if (entry == null)
                    continue;

                // Apply filters
                if (settingPathPrefix != null && !entry.SettingPath.StartsWith(settingPathPrefix, StringComparison.OrdinalIgnoreCase))
                    continue;

                if (since.HasValue && entry.Timestamp < since.Value)
                    continue;

                if (until.HasValue && entry.Timestamp > until.Value)
                    continue;

                if (user != null && !entry.User.Equals(user, StringComparison.OrdinalIgnoreCase))
                    continue;

                entries.Add(entry);
            }
            catch
            {
                // Skip malformed entries
            }
        }

        return entries;
    }
}
```

**Step 2: Update ConfigurationChangeApi to write back to file + audit log:**

In `DataWarehouse.SDK/Primitives/Configuration/ConfigurationChangeApi.cs`, update the class:

```csharp
using DataWarehouse.SDK.Infrastructure.Messaging;

namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// API for runtime configuration changes with AllowUserToOverride enforcement.
/// ENHANCED: Writes changes back to XML file and logs to audit trail.
/// </summary>
public class ConfigurationChangeApi
{
    private readonly DataWarehouseConfiguration _config;
    private readonly IMessageBus? _messageBus;
    private readonly string? _configFilePath;
    private readonly ConfigurationAuditLog? _auditLog;

    public ConfigurationChangeApi(
        DataWarehouseConfiguration config,
        IMessageBus? messageBus = null,
        string? configFilePath = null,
        ConfigurationAuditLog? auditLog = null)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _messageBus = messageBus;
        _configFilePath = configFilePath;
        _auditLog = auditLog;
    }

    /// <summary>
    /// Attempts to update a configuration value.
    /// Respects AllowUserToOverride constraints.
    /// ENHANCED: Writes back to file and logs to audit trail.
    /// </summary>
    /// <param name="path">Configuration path (e.g., "Security.EncryptionEnabled").</param>
    /// <param name="newValue">New value to set.</param>
    /// <param name="changedBy">User/system making the change.</param>
    /// <param name="reason">Optional reason for the change.</param>
    /// <returns>True if change was applied; false if blocked by policy.</returns>
    public async Task<bool> TryUpdateConfigurationAsync(string path, object newValue, string changedBy = "System", string? reason = null)
    {
        var (section, property) = ParsePath(path);
        if (section == null || property == null)
            return false;

        // Use reflection to get the configuration section and property
        var sectionObj = GetSectionByName(_config, section);
        if (sectionObj == null)
            return false;

        var propertyInfo = sectionObj.GetType().GetProperty(property);
        if (propertyInfo == null)
            return false;

        var currentValue = propertyInfo.GetValue(sectionObj);

        // Check if value is a ConfigurationItem<T>
        if (currentValue != null && currentValue.GetType().IsGenericType &&
            currentValue.GetType().GetGenericTypeDefinition() == typeof(ConfigurationItem<>))
        {
            var allowOverrideProperty = currentValue.GetType().GetProperty("AllowUserToOverride");
            var allowOverride = (bool)(allowOverrideProperty?.GetValue(currentValue) ?? true);

            if (!allowOverride)
            {
                // Change blocked by policy
                return false;
            }

            // Update the Value property
            var valueProperty = currentValue.GetType().GetProperty("Value");
            var oldValue = valueProperty?.GetValue(currentValue);
            valueProperty?.SetValue(currentValue, newValue);

            // ENHANCED: Write back to file
            if (_configFilePath != null)
            {
                ConfigurationSerializer.SaveToFile(_config, _configFilePath);
            }

            // ENHANCED: Log to audit trail
            if (_auditLog != null)
            {
                await _auditLog.LogChangeAsync(changedBy, path, oldValue, newValue, reason);
            }

            // Publish change event
            PublishChangeEvent(path, oldValue, newValue, changedBy);
            return true;
        }
        else
        {
            // Direct property (not wrapped in ConfigurationItem)
            var oldValue = propertyInfo.GetValue(sectionObj);
            propertyInfo.SetValue(sectionObj, newValue);

            // ENHANCED: Write back to file
            if (_configFilePath != null)
            {
                ConfigurationSerializer.SaveToFile(_config, _configFilePath);
            }

            // ENHANCED: Log to audit trail
            if (_auditLog != null)
            {
                await _auditLog.LogChangeAsync(changedBy, path, oldValue, newValue, reason);
            }

            PublishChangeEvent(path, oldValue, newValue, changedBy);
            return true;
        }
    }

    private void PublishChangeEvent(string path, object? oldValue, object newValue, string changedBy)
    {
        if (_messageBus != null)
        {
            var changeEvent = new ConfigurationChangeEvent(path, oldValue, newValue, changedBy, DateTime.UtcNow);
            _messageBus.Publish(IMessageBus.ConfigurationChangedTopic, changeEvent);
        }
    }

    private static (string? Section, string? Property) ParsePath(string path)
    {
        var parts = path.Split('.');
        if (parts.Length != 2)
            return (null, null);
        return (parts[0], parts[1]);
    }

    private static object? GetSectionByName(DataWarehouseConfiguration config, string sectionName)
    {
        return sectionName switch
        {
            "Security" => config.Security,
            "Storage" => config.Storage,
            "Network" => config.Network,
            "Replication" => config.Replication,
            "Encryption" => config.Encryption,
            "Compression" => config.Compression,
            "Observability" => config.Observability,
            "Compute" => config.Compute,
            "Resilience" => config.Resilience,
            "Deployment" => config.Deployment,
            "DataManagement" => config.DataManagement,
            "MessageBus" => config.MessageBus,
            "Plugins" => config.Plugins,
            _ => null
        };
    }
}
```

**Step 3: Add kernel startup flow to load config from file:**

In `DataWarehouse.SDK/Hosting/DataWarehouseKernel.cs` (or wherever kernel initialization happens), add:

```csharp
// At kernel startup:
private const string DefaultConfigPath = "./config/datawarehouse-config.xml";
private const string AuditLogPath = "./config/config-audit.log";

public async Task InitializeAsync(CancellationToken ct = default)
{
    // Load configuration from file (or create default if missing)
    _currentConfiguration = ConfigurationSerializer.LoadFromFile(DefaultConfigPath);

    // Initialize audit log
    _auditLog = new ConfigurationAuditLog(AuditLogPath);

    _logger.LogInformation("Configuration loaded from {Path}, preset: {Preset}",
        DefaultConfigPath, _currentConfiguration.PresetName);

    // ... rest of initialization
}
```
  </action>
  <verify>
Build SDK: `dotnet build DataWarehouse.SDK/ --no-restore -v q` — 0 errors.
Grep for `ConfigurationAuditLog` — present with LogChangeAsync and QueryChangesAsync.
Grep for `SaveToFile` in ConfigurationChangeApi — present (write-back).
Grep for `LoadFromFile` in kernel startup — present.
Grep for `AuditEntry` record — present with Timestamp, User, SettingPath, OldValue, NewValue, Reason.
  </verify>
  <done>ConfigurationAuditLog created with append-only audit trail (who, when, what, old→new values, reason). ConfigurationChangeApi updated to write changes back to XML file via SaveToFile() and log to audit trail. Kernel startup flow updated to load config from file at EVERY startup (or create default if missing). Full bidirectional persistence and audit trail complete.</done>
</task>

<task type="auto">
  <name>Task 5: Per-Item AllowUserToOverride + Configuration Injection (CFG-20)</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/IntelligenceAwarePluginBase.cs
    DataWarehouse.SDK/Contracts/Strategy/StrategyBase.cs
    DataWarehouse.SDK/Infrastructure/Messaging/IMessageBus.cs
    DataWarehouse.Dashboard/Controllers/ConfigurationController.cs
  </files>
  <action>
**Step 1: Add Configuration property to PluginBase** (read existing PluginBase.cs, add property):

In `DataWarehouse.SDK/Contracts/PluginBase.cs`, add:

```csharp
using DataWarehouse.SDK.Primitives.Configuration;

// Inside PluginBase class:

/// <summary>
/// Gets the configuration for this plugin instance.
/// Injected by the kernel during plugin registration.
/// </summary>
protected DataWarehouseConfiguration Configuration { get; private set; } = ConfigurationPresets.CreateStandard();

/// <summary>
/// Injects configuration into this plugin.
/// Called by the kernel during registration.
/// </summary>
internal void InjectConfiguration(DataWarehouseConfiguration config)
{
    Configuration = config ?? throw new ArgumentNullException(nameof(config));
}
```

**Step 2: Add Configuration property to StrategyBase** (read existing StrategyBase.cs, add property):

In `DataWarehouse.SDK/Contracts/Strategy/StrategyBase.cs`, add:

```csharp
using DataWarehouse.SDK.Primitives.Configuration;

// Inside StrategyBase class:

/// <summary>
/// Gets the configuration for this strategy instance.
/// Injected by the plugin owning this strategy.
/// </summary>
protected DataWarehouseConfiguration Configuration { get; private set; } = ConfigurationPresets.CreateStandard();

/// <summary>
/// Injects configuration into this strategy.
/// Called by the owning plugin.
/// </summary>
internal void InjectConfiguration(DataWarehouseConfiguration config)
{
    Configuration = config ?? throw new ArgumentNullException(nameof(config));
}
```

**Step 3: Add ConfigurationChanged topic to IMessageBus** (read existing IMessageBus.cs, add topic constant):

In `DataWarehouse.SDK/Infrastructure/Messaging/IMessageBus.cs`, add:

```csharp
// Add to IMessageBus interface or as extension:

/// <summary>Message bus topic for configuration change events.</summary>
public const string ConfigurationChangedTopic = "system.configuration.changed";

/// <summary>Configuration change event payload.</summary>
public record ConfigurationChangeEvent(string Path, object? OldValue, object NewValue, string ChangedBy, DateTime Timestamp);
```

**Step 4: Create ConfigurationChangeApi.cs** with runtime config change API:

```csharp
using DataWarehouse.SDK.Infrastructure.Messaging;

namespace DataWarehouse.SDK.Primitives.Configuration;

/// <summary>
/// API for runtime configuration changes with AllowUserToOverride enforcement.
/// </summary>
public class ConfigurationChangeApi
{
    private readonly DataWarehouseConfiguration _config;
    private readonly IMessageBus? _messageBus;

    public ConfigurationChangeApi(DataWarehouseConfiguration config, IMessageBus? messageBus = null)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _messageBus = messageBus;
    }

    /// <summary>
    /// Attempts to update a configuration value.
    /// Respects AllowUserToOverride constraints.
    /// </summary>
    /// <param name="path">Configuration path (e.g., "Security.EncryptionEnabled").</param>
    /// <param name="newValue">New value to set.</param>
    /// <param name="changedBy">User/system making the change.</param>
    /// <returns>True if change was applied; false if blocked by policy.</returns>
    public bool TryUpdateConfiguration(string path, object newValue, string changedBy = "System")
    {
        var (section, property) = ParsePath(path);
        if (section == null || property == null)
            return false;

        // Use reflection to get the configuration section and property
        var sectionObj = GetSectionByName(_config, section);
        if (sectionObj == null)
            return false;

        var propertyInfo = sectionObj.GetType().GetProperty(property);
        if (propertyInfo == null)
            return false;

        var currentValue = propertyInfo.GetValue(sectionObj);

        // Check if value is a ConfigurationItem<T>
        if (currentValue != null && currentValue.GetType().IsGenericType &&
            currentValue.GetType().GetGenericTypeDefinition() == typeof(ConfigurationItem<>))
        {
            var allowOverrideProperty = currentValue.GetType().GetProperty("AllowUserToOverride");
            var allowOverride = (bool)(allowOverrideProperty?.GetValue(currentValue) ?? true);

            if (!allowOverride)
            {
                // Change blocked by policy
                return false;
            }

            // Update the Value property
            var valueProperty = currentValue.GetType().GetProperty("Value");
            var oldValue = valueProperty?.GetValue(currentValue);
            valueProperty?.SetValue(currentValue, newValue);

            // Publish change event
            PublishChangeEvent(path, oldValue, newValue, changedBy);
            return true;
        }
        else
        {
            // Direct property (not wrapped in ConfigurationItem)
            var oldValue = propertyInfo.GetValue(sectionObj);
            propertyInfo.SetValue(sectionObj, newValue);
            PublishChangeEvent(path, oldValue, newValue, changedBy);
            return true;
        }
    }

    private void PublishChangeEvent(string path, object? oldValue, object newValue, string changedBy)
    {
        if (_messageBus != null)
        {
            var changeEvent = new ConfigurationChangeEvent(path, oldValue, newValue, changedBy, DateTime.UtcNow);
            _messageBus.Publish(IMessageBus.ConfigurationChangedTopic, changeEvent);
        }
    }

    private static (string? Section, string? Property) ParsePath(string path)
    {
        var parts = path.Split('.');
        if (parts.Length != 2)
            return (null, null);
        return (parts[0], parts[1]);
    }

    private static object? GetSectionByName(DataWarehouseConfiguration config, string sectionName)
    {
        return sectionName switch
        {
            "Security" => config.Security,
            "Storage" => config.Storage,
            "Network" => config.Network,
            "Replication" => config.Replication,
            "Encryption" => config.Encryption,
            "Compression" => config.Compression,
            "Observability" => config.Observability,
            "Compute" => config.Compute,
            "Resilience" => config.Resilience,
            "Deployment" => config.Deployment,
            "DataManagement" => config.DataManagement,
            "MessageBus" => config.MessageBus,
            "Plugins" => config.Plugins,
            _ => null
        };
    }
}
```

**Step 5: Update ConfigurationController.cs** in Dashboard to use ConfigurationChangeApi WITH audit log:

In `DataWarehouse.Dashboard/Controllers/ConfigurationController.cs`, add endpoint for runtime updates:

```csharp
[HttpPost("update")]
public async Task<IActionResult> UpdateConfiguration([FromBody] ConfigurationUpdateRequest request)
{
    // ENHANCED: Pass config file path and audit log for write-back
    var api = new ConfigurationChangeApi(
        _currentConfig,
        _messageBus,
        configFilePath: "./config/datawarehouse-config.xml",
        auditLog: _auditLog);

    var success = await api.TryUpdateConfigurationAsync(
        request.Path,
        request.Value,
        User.Identity?.Name ?? "Anonymous",
        request.Reason);

    if (success)
        return Ok(new { Message = "Configuration updated successfully (written to file + audit log)" });
    else
        return BadRequest(new { Error = "Configuration change blocked by policy or invalid path" });
}

public record ConfigurationUpdateRequest(string Path, object Value, string? Reason);
```

**Step 6: Update kernel to inject configuration into plugins** (note: requires modifying DataWarehouseKernel.cs in a future task):

This is a kernel-side change. Add to plugin registration:
```csharp
// After InjectKernelServices(plugin):
plugin.InjectConfiguration(_currentConfiguration);
```
  </action>
  <verify>
Build SDK: `dotnet build DataWarehouse.SDK/ --no-restore -v q` — 0 errors.
Grep for `protected DataWarehouseConfiguration Configuration` in PluginBase.cs — present.
Grep for `protected DataWarehouseConfiguration Configuration` in StrategyBase.cs — present.
Grep for `ConfigurationChangedTopic` in IMessageBus.cs or via ConfigurationChangeEvent — present.
Grep for `TryUpdateConfigurationAsync` in ConfigurationChangeApi.cs — present (enhanced with write-back + audit).
Build Dashboard: `dotnet build DataWarehouse.Dashboard/ --no-restore -v q` — 0 errors.
  </verify>
  <done>Configuration injection implemented in PluginBase and StrategyBase via InjectConfiguration() methods. ConfigurationChangeApi ENHANCED with TryUpdateConfigurationAsync() that respects AllowUserToOverride constraints, writes back to XML file, and logs to audit trail. ConfigurationChanged topic added to IMessageBus for runtime change notifications. Dashboard ConfigurationController updated with runtime update endpoint that includes write-back and audit logging. All plugins and strategies now receive configuration instance-level.</done>
</task>

<task type="auto">
  <name>Task 6: Living Documentation Update (DOC-21)</name>
  <files>
    .planning/PLUGIN-CATALOG.md
  </files>
  <action>
**Step 1: Update PLUGIN-CATALOG.md** with comprehensive configuration system documentation.

Add new section after existing content:

```markdown
---

## Configuration System (v3.0)

### DataWarehouseConfiguration
Unified configuration object consolidating ALL settings across the entire DataWarehouse system.

**Configuration Sections** (13 total):
- **Security**: Encryption, auth, audit, TLS, MFA, RBAC, zero-trust, FIPS, quantum-safe, HSM, cert pinning, tamper-proof logging
- **Storage**: Encrypt-at-rest, compression, deduplication, caching, indexing, versioning, cache size, max connections, backend, data directory
- **Network**: TLS, HTTP/2, HTTP/3, compression, listen port, max connections, timeouts, bind address
- **Replication**: Multi-master, CRDT, replication factor, consistency level, sync interval, conflict resolution
- **Encryption**: In-transit, at-rest, envelope encryption, key rotation, algorithms, key store backend
- **Compression**: Auto-select, compression level, algorithms
- **Observability**: Metrics, tracing, logging, health checks, anomaly detection, log levels, intervals
- **Compute**: GPU, parallel processing, worker threads, I/O threads, scheduling strategies
- **Resilience**: Circuit breaker, retry, bulkhead, self-healing, max retries, thresholds, timeouts
- **Deployment**: Air-gap mode, multi-cloud, edge, embedded, environment type
- **DataManagement**: Catalog, governance, quality, lineage, multi-tenancy
- **MessageBus**: Persistent messages, ordered delivery, max queue size, delivery timeout
- **Plugins**: Auto-load, hot reload, max plugins, plugin directory

### Configuration Presets (6 levels)
Preset files are COMPLETE living system state files containing EVERY setting, not just overrides.

1. **unsafe**: Zero security, maximum performance (dev/testing ONLY)
   - No encryption, no auth, no audit, no TLS
   - Fastest performance, suitable for local development

2. **minimal**: Basic auth, no encryption, no audit
   - RBAC enabled, basic auth scheme
   - Minimal overhead for low-resource environments

3. **standard**: AES-256, RBAC, basic audit, TLS required
   - Default production-ready configuration
   - Balanced security and performance

4. **secure**: Quantum-safe crypto, MFA, full audit, encrypted-at-rest, certificate pinning
   - High-security environments
   - Key rotation enabled (30 days)
   - Tracing enabled

5. **paranoid**: FIPS 140-3, HSM keys, air-gap ready, tamper-proof logging, zero-trust
   - Maximum security, critical infrastructure
   - HSM key storage required
   - Critical settings locked (cannot be overridden)

6. **god-tier**: Everything enabled (ML anomaly detection, adaptive security, self-healing, auto-rotation)
   - All advanced features active
   - Multi-master replication (RF=5, QUORUM consistency)
   - GPU acceleration, multi-cloud, edge support
   - Full governance, quality, lineage, multi-tenancy

### Hardware Probe Integration
`PresetSelector` uses `IHardwareProbe` to auto-select best-fit preset at install time:

**Decision Logic**:
- HSM/TPM detected → **paranoid**
- GPU + 128GB+ RAM → **god-tier**
- 16+ cores, 32+ GB RAM → **secure**
- 4-16 cores, 8-32 GB RAM → **standard**
- < 4 cores, < 8 GB RAM → **minimal**

Integrated into CLI and GUI install flows for automatic hardware-aware configuration.

### Configuration Injection
All plugins and strategies receive `DataWarehouseConfiguration` via property injection:

```csharp
// In PluginBase and StrategyBase:
protected DataWarehouseConfiguration Configuration { get; private set; }

// Kernel calls during registration:
plugin.InjectConfiguration(kernelConfig);
```

Plugins can access any setting via `Configuration.Security.EncryptionEnabled.Value`, etc.

### Per-Item Override Control
Each setting wrapped in `ConfigurationItem<T>`:

```csharp
public class ConfigurationItem<T>
{
    public T Value { get; set; }
    public bool AllowUserToOverride { get; set; } = true;
    public string? LockedByPolicy { get; set; }
    public string? Description { get; set; }
}
```

**Paranoid and God-Tier presets** lock critical security settings (EncryptionEnabled, AuthEnabled, TlsRequired, FipsMode) with `AllowUserToOverride = false`.

### Runtime Configuration Changes
`ConfigurationChangeApi` enforces override policies and publishes change events:

```csharp
var api = new ConfigurationChangeApi(config, messageBus, configFilePath, auditLog);
var success = await api.TryUpdateConfigurationAsync("Security.EncryptionEnabled", true, "admin@example.com", "Enable encryption");
// Returns false if AllowUserToOverride == false
```

Changes trigger:
1. **Validation**: AllowUserToOverride check
2. **Update**: In-memory config updated
3. **Persistence**: XML file written back to disk
4. **Audit**: Change logged to audit trail
5. **Notification**: ConfigurationChanged event published on IMessageBus

### Bidirectional File Persistence
Config file is a COMPLETE living system state (analogy: Windows Answer File + Settings/Control Panel):

**Lifecycle**:
1. **Deploy**: Preset XML copied to `./config/datawarehouse-config.xml`
2. **Startup**: `ConfigurationSerializer.LoadFromFile()` loads config (creates default if missing)
3. **Runtime**: Every change written back via `SaveToFile()`
4. **Persist**: Same config file used across restarts (state survives reboots)

**File Structure**: Full serialization of `DataWarehouseConfiguration` with all 13 sections and all properties.

### Configuration Audit Trail
`ConfigurationAuditLog` provides append-only audit trail at `./config/config-audit.log`:

```csharp
public record AuditEntry(
    DateTime Timestamp,
    string User,
    string SettingPath,
    string? OldValue,
    string? NewValue,
    string? Reason);

// Log every change:
await auditLog.LogChangeAsync("admin@example.com", "Security.MfaEnabled", "false", "true", "Compliance requirement");

// Query changes:
var changes = await auditLog.QueryChangesAsync(
    settingPathPrefix: "Security",
    since: DateTime.UtcNow.AddDays(-7),
    user: "admin@example.com");
```

**Features**:
- Append-only (immutable history)
- JSON format (one entry per line)
- Query support with filters (path prefix, date range, user)
- Records who, when, what, old→new values, reason

### Message Bus Integration
`ConfigurationChanged` topic notifies subscribers of runtime changes:

```csharp
// Publish (via ConfigurationChangeApi):
_messageBus.Publish(IMessageBus.ConfigurationChangedTopic, new ConfigurationChangeEvent(
    Path: "Security.EncryptionEnabled",
    OldValue: false,
    NewValue: true,
    ChangedBy: "admin@example.com",
    Timestamp: DateTime.UtcNow));

// Subscribe (in plugins):
_messageBus.Subscribe<ConfigurationChangeEvent>(IMessageBus.ConfigurationChangedTopic, HandleConfigChange);
```

Plugins can react to config changes in real-time without polling.

### XML Preset Files (Embedded Resources)
6 preset templates embedded in SDK assembly as resources:
- `DataWarehouse.SDK.Primitives.Configuration.Presets.unsafe.xml`
- `DataWarehouse.SDK.Primitives.Configuration.Presets.minimal.xml`
- `DataWarehouse.SDK.Primitives.Configuration.Presets.standard.xml`
- `DataWarehouse.SDK.Primitives.Configuration.Presets.secure.xml`
- `DataWarehouse.SDK.Primitives.Configuration.Presets.paranoid.xml`
- `DataWarehouse.SDK.Primitives.Configuration.Presets.god-tier.xml`

Loaded via `ConfigurationSerializer.LoadPreset("preset-name")` at install time, then deployed to `./config/datawarehouse-config.xml` for ongoing use.

---
```

**Step 2: Update existing sections** if they reference old KernelConfiguration, SecurityPolicySettings, or EmbeddedConfiguration — replace with DataWarehouseConfiguration.

**Step 3: Add cross-references** in plugin sections that consume configuration settings.
  </action>
  <verify>
Grep for `## Configuration System` in PLUGIN-CATALOG.md — present.
Grep for `ConfigurationAuditLog` in PLUGIN-CATALOG.md — present with full documentation.
Grep for `Bidirectional File Persistence` in PLUGIN-CATALOG.md — present with lifecycle explanation.
Grep for `6 preset templates` in PLUGIN-CATALOG.md — present with full list.
Grep for `Hardware Probe Integration` in PLUGIN-CATALOG.md — present with decision logic.
  </verify>
  <done>PLUGIN-CATALOG.md updated with comprehensive Configuration System (v3.0) documentation covering: DataWarehouseConfiguration structure (13 sections), 6 presets with full descriptions, hardware probe integration with decision logic, config injection into PluginBase/StrategyBase, per-item override control, runtime changes via ConfigurationChangeApi, bidirectional file persistence lifecycle, audit trail system, message bus integration, and XML preset files as embedded resources. All cross-references updated.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors
2. DataWarehouseConfiguration exists with 13+ configuration sections
3. ConfigurationItem<T> wrapper with AllowUserToOverride exists
4. 6 preset factory methods exist (CreateUnsafe through CreateGodTier)
5. 6 COMPLETE XML preset templates exist as embedded resources (all 13 sections, all properties)
6. ConfigurationSerializer with bidirectional XML serialization exists (LoadFromFile + SaveToFile)
7. ConfigurationAuditLog exists with LogChangeAsync and QueryChangesAsync
8. PresetSelector with hardware probe integration exists
9. Configuration property exists in PluginBase and StrategyBase
10. ConfigurationChangeApi with TryUpdateConfigurationAsync exists (write-back + audit)
11. IMessageBus has ConfigurationChanged topic
12. CLI and GUI install flows integrate hardware probe
13. Dashboard has runtime config update endpoint with write-back and audit
14. Kernel startup loads config from file at every startup
15. PLUGIN-CATALOG.md updated with Configuration System (v3.0) documentation
</verification>

<success_criteria>
- CFG-17: DataWarehouseConfiguration consolidates ALL settings (security, storage, network, replication, encryption, compression, observability, compute, resilience, deployment, data management, message bus, plugins)
- CFG-18-ENHANCED: 6 COMPLETE XML preset templates (unsafe, minimal, standard, secure, paranoid, god-tier) embedded in SDK assembly with ALL 13 sections and ALL properties serialized. Bidirectional persistence: LoadFromFile at startup, SaveToFile after every runtime change. Auto-creates default config if missing
- CFG-19: PresetSelector integrates IHardwareProbe to auto-select preset based on CPU cores, RAM, HSM, TPM, GPU. Integrated into CLI and GUI install flows
- CFG-20: ConfigurationItem<T> with AllowUserToOverride property. Configuration injected into PluginBase and StrategyBase. ConfigurationChangeApi enforces override policy, writes back to XML file, and logs to audit trail. ConfigurationChanged events on IMessageBus
- CFG-18-AUDIT: ConfigurationAuditLog with append-only audit trail (who, when, what, old→new values, reason). Query support with filters. Every change logged via ConfigurationChangeApi
- DOC-21: PLUGIN-CATALOG.md updated with comprehensive Configuration System (v3.0) documentation: DataWarehouseConfiguration structure, 6 presets with descriptions, hardware probe integration, config injection, per-item override control, runtime changes, bidirectional file persistence lifecycle, audit trail system, message bus integration, XML preset files
- Build: 0 errors
- Tests: All existing tests pass (no new tests required for this plan)
</success_criteria>

<output>
After completion, create `.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-07-SUMMARY.md`
</output>
