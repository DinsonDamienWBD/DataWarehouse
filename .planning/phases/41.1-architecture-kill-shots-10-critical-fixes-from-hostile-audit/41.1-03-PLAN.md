---
plan_id: 41.1-03
phase: 41.1
wave: 1
title: "FIX-14/15/16: Strategy Base Lifecycle, Common Infrastructure, Naming Consistency"
status: not_started
priority: P1
complexity: high
estimated_effort: 4-6 hours
depends_on: []
autonomous: true
created: 2026-02-17
tags: [architecture, strategy-pattern, lifecycle, infrastructure, naming, technical-debt]
---

# Plan 41.1-03: Fix Strategy Base Lifecycle Shadowing, Add Common Infrastructure, Fix Naming

## Objective

Fix 3 critical architecture issues from hostile audit:
- **FIX-14**: Eliminate 4 strategy base lifecycle shadowing bugs (DataMeshStrategy, DataLakeStrategy, ObservabilityStrategyBase, KeyStoreStrategyBase all use `new` to shadow parent fields/methods)
- **FIX-15**: Enhance StrategyBase with 6 common infrastructure methods (guards, lazy init, counters, retry, health caching) and refactor 19 domain strategy bases to use them instead of duplicated implementations
- **FIX-16**: Fix naming inconsistencies (2 StorageStrategyBase collision, DisplayName vs StrategyName standardization)

This is Wave 1 work with no dependencies. All changes are backwards compatible and improve consistency across the entire strategy hierarchy.

## Execution Context

**Files Modified (FIX-14 - 4 files):**
- `DataWarehouse.SDK/Contracts/DataMesh/DataMeshStrategy.cs` - remove `new`, add `override`
- `DataWarehouse.SDK/Contracts/DataLake/DataLakeStrategy.cs` - remove `new`, add `override`
- `DataWarehouse.SDK/Contracts/Observability/ObservabilityStrategyBase.cs` - remove shadowed fields, override methods
- `DataWarehouse.SDK/Security/IKeyStore.cs` (KeyStoreStrategyBase at line 931+) - remove shadowed _initialized field

**Files Modified (FIX-15 - 20 files):**
- `DataWarehouse.SDK/Contracts/StrategyBase.cs` - add 6 infrastructure methods + HealthCheckResult record
- `DataWarehouse.SDK/Contracts/Compression/CompressionStrategyBase.cs` - use IncrementCounter/GetAllCounters
- `DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategyBase.cs` - use IncrementCounter/GetAllCounters
- `DataWarehouse.SDK/Contracts/Storage/StorageStrategyBase.cs` - use all 4 helpers (counters, lazy init, retry, health cache)
- `DataWarehouse.SDK/Contracts/Connection/ConnectionStrategyBase.cs` - use ExecuteWithRetryAsync, GetCachedHealthAsync
- `DataWarehouse.SDK/Contracts/DataTransit/DataTransitStrategyBase.cs` - use IncrementCounter, GetCachedHealthAsync
- `DataWarehouse.SDK/Contracts/Security/SecurityStrategyBase.cs` - use IncrementCounter
- `DataWarehouse.SDK/Contracts/Compliance/ComplianceStrategyBase.cs` - use IncrementCounter
- `DataWarehouse.SDK/Contracts/Observability/ObservabilityStrategyBase.cs` - use EnsureInitializedAsync, GetCachedHealthAsync
- `DataWarehouse.SDK/Security/IKeyStore.cs` (KeyStoreStrategyBase) - use EnsureInitializedAsync, GetCachedHealthAsync
- Plus 10 more domain strategy bases that use counters/retry/health patterns

**Files Modified (FIX-16 - 2-4 files):**
- Discover and rename one of the 2 StorageStrategyBase classes
- Standardize DisplayName/StrategyName properties across all strategy bases

**Build Verification:**
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` - must pass
- `dotnet build DataWarehouse.sln` - must pass with zero warnings on modified files

## Context

### Problem Statement

**FIX-14: Lifecycle Shadowing Bugs**
Four strategy base classes use `new` keyword to shadow parent class lifecycle methods and fields:
- DataMeshStrategy/DataLakeStrategy shadow Initialize/Shutdown methods
- ObservabilityStrategyBase/KeyStoreStrategyBase shadow _initialized/_disposed fields

This breaks polymorphism and causes unpredictable behavior when strategies are used via base class references.

**FIX-15: Duplicated Infrastructure Code**
19 domain strategy bases duplicate common patterns:
- 8 classes have their own counter dictionaries (ConcurrentDictionary<string, long>)
- 3 classes have their own lazy init SemaphoreSlim logic
- 2 classes have their own retry loop implementations
- 5 classes have their own health check caching

All of this should be in StrategyBase as protected helpers.

**FIX-16: Naming Collisions and Inconsistencies**
- Two classes named StorageStrategyBase exist in different namespaces
- Some strategies use DisplayName, others use StrategyName, no consistent pattern

### Architecture Constraints

- All strategy bases must inherit from StrategyBase
- All lifecycle methods (Initialize, Shutdown, Dispose) must use `override`, never `new`
- All shared infrastructure must be `protected` in StrategyBase (not public)
- Health check caching must be thread-safe with configurable TTL
- Retry logic must support exponential backoff and virtual transient exception predicate
- Counter operations must use Interlocked for thread safety
- No breaking changes to public API surface

### Success Criteria

- Zero uses of `new` keyword to shadow parent lifecycle methods/fields
- StrategyBase has 6 new protected helper methods + HealthCheckResult record
- 19 domain strategy bases refactored to use StrategyBase helpers (remove duplicate code)
- Zero naming collisions (unique class names across entire SDK)
- Consistent property naming (DisplayName OR StrategyName, not both)
- `dotnet build DataWarehouse.sln` passes with zero warnings on modified files
- All existing tests pass (no behavioral changes)

## Tasks

<task id="1" type="auto">
<description>FIX-14.1: Fix DataMeshStrategy lifecycle shadowing (DataMesh/DataMeshStrategy.cs)</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/DataMesh/DataMeshStrategy.cs`
2. Find Initialize/Shutdown methods that use `new` keyword
3. Change `public new virtual async Task Initialize()` to `public override async Task Initialize()`
4. Change `public new virtual async Task Shutdown()` to `public override async Task Shutdown()`
5. Ensure base.Initialize() and base.Shutdown() are called
6. Verify no other lifecycle methods use `new`
</actions>
<files>
- DataWarehouse.SDK/Contracts/DataMesh/DataMeshStrategy.cs
</files>
</task>

<task id="2" type="auto">
<description>FIX-14.2: Fix DataLakeStrategy lifecycle shadowing (DataLake/DataLakeStrategy.cs)</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/DataLake/DataLakeStrategy.cs`
2. Find Initialize/Shutdown methods that use `new` keyword
3. Change `public new virtual async Task Initialize()` to `public override async Task Initialize()`
4. Change `public new virtual async Task Shutdown()` to `public override async Task Shutdown()`
5. Ensure base.Initialize() and base.Shutdown() are called
6. Verify no other lifecycle methods use `new`
</actions>
<files>
- DataWarehouse.SDK/Contracts/DataLake/DataLakeStrategy.cs
</files>
</task>

<task id="3" type="auto">
<description>FIX-14.3: Fix ObservabilityStrategyBase field shadowing (Observability/ObservabilityStrategyBase.cs)</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Observability/ObservabilityStrategyBase.cs`
2. Find field declarations that shadow parent: `private new bool _initialized`, `private new bool _disposed`
3. Remove these field redeclarations completely
4. Find any methods that check these fields and change to `override` if they override parent methods
5. Ensure all lifecycle methods properly call base implementations
6. Verify no `new` keyword used anywhere in class
</actions>
<files>
- DataWarehouse.SDK/Contracts/Observability/ObservabilityStrategyBase.cs
</files>
</task>

<task id="4" type="auto">
<description>FIX-14.4: Fix KeyStoreStrategyBase field shadowing (Security/IKeyStore.cs line 931+)</description>
<actions>
1. Read `DataWarehouse.SDK/Security/IKeyStore.cs` (focus on KeyStoreStrategyBase class starting around line 931)
2. Find `private new bool _initialized` field declaration
3. Remove this field redeclaration
4. Find Initialize/Shutdown methods and ensure they use `override` not `new`
5. Ensure base.Initialize() and base.Shutdown() are called
6. Verify no other shadowing in this class
</actions>
<files>
- DataWarehouse.SDK/Security/IKeyStore.cs
</files>
</task>

<task id="5" type="auto">
<description>FIX-15.1: Add 6 common infrastructure methods to StrategyBase</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/StrategyBase.cs`
2. Add HealthCheckResult record at top of file:
   ```csharp
   public record HealthCheckResult(bool IsHealthy, string? Message = null, IReadOnlyDictionary<string, object>? Details = null);
   ```
3. Add private fields for new infrastructure:
   - `private readonly ConcurrentDictionary<string, long> _counters = new();`
   - `private readonly SemaphoreSlim _healthCacheLock = new(1, 1);`
   - `private HealthCheckResult? _cachedHealth;`
   - `private DateTime? _healthCacheExpiry;`
4. Add protected helper methods (all with XML docs):
   A. `protected void ThrowIfNotInitialized()` - check _initialized, throw InvalidOperationException if false
   B. `protected async Task EnsureInitializedAsync(Func<Task> initCore)` - double-check lock pattern with SemaphoreSlim
   C. `protected void IncrementCounter(string name)` - Interlocked.Increment on _counters.AddOrUpdate
   D. `protected long GetCounter(string name)` - return _counters.GetValueOrDefault(name, 0)
   E. `protected IReadOnlyDictionary<string, long> GetAllCounters()` - return snapshot of _counters
   F. `protected void ResetCounters()` - _counters.Clear()
   G. `protected async Task<T> ExecuteWithRetryAsync<T>(Func<CancellationToken, Task<T>> operation, int maxRetries = 3, TimeSpan? baseDelay = null, CancellationToken ct = default)`
      - Exponential backoff with jitter
      - Call virtual `protected virtual bool IsTransientException(Exception ex) => false`
      - Throw AggregateException with all failures if all retries exhausted
   H. `protected async Task<HealthCheckResult> GetCachedHealthAsync(Func<CancellationToken, Task<HealthCheckResult>> healthCheck, TimeSpan? cacheDuration = null, CancellationToken ct = default)`
      - Default cacheDuration = 30 seconds
      - Thread-safe cache with expiry check
      - Use _healthCacheLock SemaphoreSlim
5. Dispose _healthCacheLock in existing Dispose method
</actions>
<files>
- DataWarehouse.SDK/Contracts/StrategyBase.cs
</files>
</task>

<task id="6" type="auto">
<description>FIX-15.2: Refactor CompressionStrategyBase to use StrategyBase counters</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Compression/CompressionStrategyBase.cs`
2. Find private ConcurrentDictionary<string, long> _counters field and remove it
3. Find IncrementCounter/GetCounter/GetAllCounters methods and remove them
4. Replace all calls to local IncrementCounter with calls to base.IncrementCounter
5. Replace all calls to GetAllCounters with base.GetAllCounters()
6. Verify no duplicate counter infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Contracts/Compression/CompressionStrategyBase.cs
</files>
</task>

<task id="7" type="auto">
<description>FIX-15.3: Refactor EncryptionStrategyBase to use StrategyBase counters</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategyBase.cs`
2. Find private ConcurrentDictionary<string, long> _counters field and remove it
3. Find counter-related methods (IncrementCounter, GetCounter, GetAllCounters) and remove them
4. Replace all counter calls with base class equivalents
5. Verify no duplicate counter infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategyBase.cs
</files>
</task>

<task id="8" type="auto">
<description>FIX-15.4: Refactor StorageStrategyBase to use all 4 StrategyBase helpers</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Storage/StorageStrategyBase.cs`
2. Remove duplicate counter infrastructure (fields + methods) → use base.IncrementCounter/GetAllCounters
3. Remove duplicate lazy init SemaphoreSlim → use base.EnsureInitializedAsync
4. Remove duplicate retry logic → use base.ExecuteWithRetryAsync
5. Remove duplicate health caching → use base.GetCachedHealthAsync
6. Update all call sites to use base class methods
7. Verify class is significantly simplified
</actions>
<files>
- DataWarehouse.SDK/Contracts/Storage/StorageStrategyBase.cs
</files>
</task>

<task id="9" type="auto">
<description>FIX-15.5: Refactor ConnectionStrategyBase to use retry and health caching</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Connection/ConnectionStrategyBase.cs`
2. Remove duplicate ExecuteWithRetry implementation → use base.ExecuteWithRetryAsync
3. Remove duplicate health check caching → use base.GetCachedHealthAsync
4. Update all call sites
5. Verify no duplicate infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Contracts/Connection/ConnectionStrategyBase.cs
</files>
</task>

<task id="10" type="auto">
<description>FIX-15.6: Refactor DataTransitStrategyBase to use counters and health caching</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/DataTransit/DataTransitStrategyBase.cs`
2. Remove duplicate counter infrastructure → use base.IncrementCounter/GetAllCounters
3. Remove duplicate health caching → use base.GetCachedHealthAsync
4. Update all call sites
5. Verify no duplicate infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Contracts/DataTransit/DataTransitStrategyBase.cs
</files>
</task>

<task id="11" type="auto">
<description>FIX-15.7: Refactor SecurityStrategyBase to use counters</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Security/SecurityStrategyBase.cs`
2. Remove duplicate counter infrastructure → use base.IncrementCounter/GetAllCounters
3. Update all call sites
4. Verify no duplicate infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Contracts/Security/SecurityStrategyBase.cs
</files>
</task>

<task id="12" type="auto">
<description>FIX-15.8: Refactor ComplianceStrategyBase to use counters</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Compliance/ComplianceStrategyBase.cs`
2. Remove duplicate counter infrastructure → use base.IncrementCounter/GetAllCounters
3. Update all call sites
4. Verify no duplicate infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Contracts/Compliance/ComplianceStrategyBase.cs
</files>
</task>

<task id="13" type="auto">
<description>FIX-15.9: Refactor ObservabilityStrategyBase to use lazy init and health caching</description>
<actions>
1. Read `DataWarehouse.SDK/Contracts/Observability/ObservabilityStrategyBase.cs`
2. Remove duplicate lazy init SemaphoreSlim → use base.EnsureInitializedAsync
3. Remove duplicate health caching → use base.GetCachedHealthAsync
4. Update all call sites
5. Verify no duplicate infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Contracts/Observability/ObservabilityStrategyBase.cs
</files>
</task>

<task id="14" type="auto">
<description>FIX-15.10: Refactor KeyStoreStrategyBase to use lazy init and health caching</description>
<actions>
1. Read `DataWarehouse.SDK/Security/IKeyStore.cs` (KeyStoreStrategyBase class)
2. Remove duplicate lazy init SemaphoreSlim → use base.EnsureInitializedAsync
3. Remove duplicate health caching → use base.GetCachedHealthAsync
4. Update all call sites
5. Verify no duplicate infrastructure remains
</actions>
<files>
- DataWarehouse.SDK/Security/IKeyStore.cs
</files>
</task>

<task id="15" type="auto">
<description>FIX-15.11: Scan and refactor remaining 9 domain strategy bases for counter/retry/health patterns</description>
<actions>
1. Use Grep to find all classes ending in "StrategyBase" in SDK/Contracts and SDK/Security
2. For each domain strategy base not yet refactored (target: 9 more):
   - Check for duplicate counter infrastructure → replace with base.IncrementCounter/GetAllCounters
   - Check for duplicate retry logic → replace with base.ExecuteWithRetryAsync
   - Check for duplicate health caching → replace with base.GetCachedHealthAsync
   - Check for duplicate lazy init → replace with base.EnsureInitializedAsync
3. Document which classes were refactored
4. Verify all 19 domain strategy bases now use StrategyBase helpers
</actions>
<files>
- Multiple files in DataWarehouse.SDK/Contracts/* subdirectories
- Potentially DataWarehouse.SDK/Security/* files
</files>
</task>

<task id="16" type="auto">
<description>FIX-16.1: Identify and fix StorageStrategyBase naming collision</description>
<actions>
1. Use Grep to find all classes named exactly "StorageStrategyBase" in DataWarehouse.SDK
2. Identify the 2 classes with name collision (different namespaces)
3. Analyze usage and namespace context to determine which should be renamed
4. Rename one to more specific name (e.g., StorageProviderStrategyBase, BlobStorageStrategyBase, etc.)
5. Update all references to renamed class
6. Verify no naming collisions remain
</actions>
<files>
- DataWarehouse.SDK/Contracts/Storage/StorageStrategyBase.cs (likely one of them)
- One other file with StorageStrategyBase class
- All files that reference the renamed class
</files>
</task>

<task id="17" type="auto">
<description>FIX-16.2: Standardize DisplayName vs StrategyName across all strategy bases</description>
<actions>
1. Use Grep to find all strategy base classes with DisplayName or StrategyName properties
2. Analyze usage patterns across SDK and plugins
3. Choose ONE standard property name (recommendation: keep StrategyName, it's more domain-specific)
4. For each strategy base:
   - If using DisplayName and StrategyName exists elsewhere, migrate to StrategyName
   - Remove duplicate/conflicting properties
   - Update XML docs for consistency
5. Grep all plugin files for DisplayName/StrategyName references and update if needed
6. Verify consistent naming across entire solution
</actions>
<files>
- All DataWarehouse.SDK/Contracts/*StrategyBase.cs files
- All DataWarehouse.SDK/Security/*StrategyBase classes
- Plugin files that reference DisplayName/StrategyName
</files>
</task>

<task id="18" type="auto">
<description>Build verification: SDK compiles with zero warnings</description>
<actions>
1. Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --configuration Release`
2. Verify zero errors
3. Verify zero warnings on modified files
4. If warnings exist, fix them before proceeding
</actions>
<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --configuration Release
```
Expected: "Build succeeded. 0 Warning(s). 0 Error(s)." on all modified files
</verification>
</task>

<task id="19" type="auto">
<description>Build verification: Full solution compiles</description>
<actions>
1. Run `dotnet build DataWarehouse.sln --configuration Release`
2. Verify zero errors
3. Check for warnings on modified files (acceptable on unmodified files)
4. Verify all plugins still compile
</actions>
<verification>
```bash
dotnet build DataWarehouse.sln --configuration Release
```
Expected: "Build succeeded." with zero errors, warnings only acceptable on unmodified files
</verification>
</task>

<task id="20" type="auto">
<description>LSP diagnostics verification on all modified files</description>
<actions>
1. Run lsp_diagnostics on all modified SDK files
2. Verify zero errors
3. Verify zero warnings (or only acceptable warnings like "unused using")
4. Fix any issues before completion
</actions>
<verification>
Use lsp_diagnostics tool on each modified file to confirm clean build
</verification>
</task>

<task id="21" type="auto">
<description>Update Living Documentation (DOC-21)</description>
<actions>
Update `.planning/PLUGIN-CATALOG.md` to reflect ALL changes made in this plan:

- Update strategy hierarchy section: document that lifecycle bugs are now fixed (no more shadowing with 'new' keyword)
- Update StrategyBase entry: document 6 new protected infrastructure methods (ThrowIfNotInitialized, EnsureInitializedAsync, IncrementCounter, GetCounter, GetAllCounters, ResetCounters, ExecuteWithRetryAsync, GetCachedHealthAsync) plus HealthCheckResult record
- Update all 19 domain strategy base entries: note they now use StrategyBase helpers instead of duplicate counter/retry/health/lazy-init infrastructure
- Document naming standardization (DisplayName vs StrategyName resolution)
- Update hierarchy diagram to reflect corrected lifecycle method overrides (override instead of new)
- Note: StorageStrategyBase collision resolved (if applicable)

Ensure the hierarchy diagrams, plugin entries, and architectural notes are accurate and current. The goal is that after this plan completes, the PLUGIN-CATALOG reflects ground truth — no codebase exploration needed.
</actions>
<files>
- .planning/PLUGIN-CATALOG.md
</files>
</task>

## Verification

### Build Verification
```bash
# SDK must compile cleanly
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --configuration Release

# Full solution must compile
dotnet build DataWarehouse.sln --configuration Release
```

### Code Quality Checks
- All modified files must pass lsp_diagnostics with zero errors
- No uses of `new` keyword to shadow parent lifecycle methods/fields
- No duplicate counter/retry/health infrastructure in domain strategy bases
- No class name collisions in SDK
- Consistent property naming (StrategyName throughout)

### Regression Prevention
- Run existing tests: `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj`
- All tests must pass (no behavioral changes expected)

## Success Criteria

**FIX-14 Complete:**
- [ ] DataMeshStrategy uses `override` for Initialize/Shutdown
- [ ] DataLakeStrategy uses `override` for Initialize/Shutdown
- [ ] ObservabilityStrategyBase removed shadowed _initialized/_disposed fields
- [ ] KeyStoreStrategyBase removed shadowed _initialized field
- [ ] Zero uses of `new` keyword on lifecycle methods in any strategy base

**FIX-15 Complete:**
- [ ] StrategyBase has 6 new protected helper methods (ThrowIfNotInitialized, EnsureInitializedAsync, IncrementCounter, GetCounter, GetAllCounters, ResetCounters, ExecuteWithRetryAsync, GetCachedHealthAsync)
- [ ] StrategyBase has HealthCheckResult record
- [ ] 19 domain strategy bases refactored to use StrategyBase helpers
- [ ] Zero duplicate counter/retry/health/lazy-init infrastructure in domain bases

**FIX-16 Complete:**
- [ ] Zero class name collisions (StorageStrategyBase renamed if needed)
- [ ] Consistent property naming (StrategyName OR DisplayName, not both)
- [ ] All references updated

**Build Quality:**
- [ ] `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with zero warnings on modified files
- [ ] `dotnet build DataWarehouse.sln` passes with zero errors
- [ ] All modified files pass lsp_diagnostics
- [ ] All existing tests pass

**Documentation:**
- [ ] DOC-21: PLUGIN-CATALOG.md updated to reflect all changes from this plan

## Output

**Artifacts:**
- Modified files: 24-28 SDK strategy base files
- Build logs: clean SDK and solution builds
- Documentation: summary of infrastructure consolidation (lines of code removed)

**Metrics:**
- Lines of duplicate code eliminated: ~500-800 lines
- Classes refactored: 19 domain strategy bases
- Shadowing bugs fixed: 4 classes
- Naming collisions fixed: 1-2 classes

**Next Steps:**
- Wave 2 plans can proceed (no dependencies on this plan)
- Consider adding unit tests for new StrategyBase infrastructure methods
- Document StrategyBase helper methods in SDK architecture guide
