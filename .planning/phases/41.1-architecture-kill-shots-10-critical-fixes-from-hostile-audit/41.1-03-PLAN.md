---
phase: 41.1-architecture-kill-shots
plan: 03
type: execute
wave: 2
depends_on: ["41.1-01"]
files_modified:
  - DataWarehouse.SDK/Security/NativeKeyHandle.cs
  - DataWarehouse.SDK/Security/IKeyStore.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/Feature/SecurityPluginBase.cs
  - DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/UltimateKeyManagementPlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs
autonomous: true
must_haves:
  truths:
    - "Cryptographic keys are allocated in unmanaged memory via NativeMemory.AllocZeroed"
    - "NativeKeyHandle securely wipes key material on Dispose"
    - "IKeyStore.GetKeyAsync returns NativeKeyHandle instead of byte[]"
    - "Plugins can register typed message handlers with compile-time safety"
  artifacts:
    - path: "DataWarehouse.SDK/Security/NativeKeyHandle.cs"
      provides: "Unmanaged memory key handle with secure wipe"
      contains: "NativeMemory.AllocZeroed"
    - path: "DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs"
      provides: "RegisterHandler<TRequest, TResponse> method"
      contains: "RegisterHandler"
  key_links:
    - from: "NativeKeyHandle"
      to: "IKeyStore"
      via: "GetKeyAsync return type change"
      pattern: "Task<NativeKeyHandle>"
    - from: "IntelligenceAwarePluginBase"
      to: "IMessageBus"
      via: "RegisterHandler subscribes typed handler"
      pattern: "RegisterHandler.*TRequest.*TResponse"
---

<objective>
Fix Killshot 5 (native key memory) and Killshot 3 (typed message handlers).

Purpose: KS5 moves cryptographic keys off the managed heap into unmanaged memory where GC cannot copy/move them, with guaranteed secure wipe on disposal. KS3 adds type-safe message handler registration to base classes, eliminating unsafe object casting.

Output: NativeKeyHandle class, updated IKeyStore interface, typed RegisterHandler<TRequest, TResponse> in base class.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-RESEARCH.md
@.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-01-SUMMARY.md
@DataWarehouse.SDK/Security/IKeyStore.cs
@DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NativeKeyHandle and Update Key Store Interfaces (KS5)</name>
  <files>
    DataWarehouse.SDK/Security/NativeKeyHandle.cs
    DataWarehouse.SDK/Security/IKeyStore.cs
    DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/Feature/SecurityPluginBase.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/UltimateKeyManagementPlugin.cs
    Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs
  </files>
  <action>
**Step 1: Create NativeKeyHandle.cs** in `DataWarehouse.SDK/Security/`:

```csharp
namespace DataWarehouse.SDK.Security;

/// <summary>
/// Wraps cryptographic key material in unmanaged memory (KS5).
/// Prevents GC from copying key bytes. Guaranteed secure wipe on disposal.
/// </summary>
public sealed unsafe class NativeKeyHandle : IDisposable
{
    private byte* _keyPtr;
    private readonly int _keySize;
    private bool _disposed;

    public NativeKeyHandle(int keySize)
    {
        if (keySize <= 0) throw new ArgumentOutOfRangeException(nameof(keySize));
        _keySize = keySize;
        _keyPtr = (byte*)NativeMemory.AllocZeroed((nuint)keySize);
    }

    public Span<byte> KeySpan
    {
        get
        {
            ObjectDisposedException.ThrowIf(_disposed, this);
            return new Span<byte>(_keyPtr, _keySize);
        }
    }

    public int KeySize => _keySize;

    /// <summary>Creates a NativeKeyHandle from existing key bytes (copies into native memory).</summary>
    public static NativeKeyHandle FromBytes(byte[] keyData)
    {
        var handle = new NativeKeyHandle(keyData.Length);
        keyData.AsSpan().CopyTo(handle.KeySpan);
        // Wipe the managed copy
        CryptographicOperations.ZeroMemory(keyData);
        return handle;
    }

    public void Dispose()
    {
        if (_disposed) return;
        CryptographicOperations.ZeroMemory(new Span<byte>(_keyPtr, _keySize));
        NativeMemory.Free(_keyPtr);
        _keyPtr = null;
        _disposed = true;
        GC.SuppressFinalize(this);
    }

    ~NativeKeyHandle() => Dispose();
}
```

Requires `using System.Runtime.InteropServices;` and `using System.Security.Cryptography;`.

**Step 2: Add GetKeyNativeAsync to IKeyStore** (non-breaking addition):

Add a new method to `IKeyStore` interface:
```csharp
/// <summary>Returns key in unmanaged memory. Caller MUST dispose the handle.</summary>
Task<NativeKeyHandle> GetKeyNativeAsync(string keyId, ISecurityContext context)
{
    // Default interface implementation for backward compatibility
    var keyBytes = await GetKeyAsync(keyId, context);
    return NativeKeyHandle.FromBytes(keyBytes);
}
```

Use default interface implementation (DIM) so existing IKeyStore implementations don't break. Also add to IKeyStoreStrategy.

**Step 3: Update KeyStoreStrategyBase** to override GetKeyNativeAsync with a proper implementation that loads directly into native memory where possible.

**Step 4: Update EncryptionPluginBase and SecurityPluginBase** to prefer GetKeyNativeAsync when available. Find where they call GetKeyAsync and add an overload or wrapper that uses NativeKeyHandle.

**Step 5: Update UltimateKeyManagement and UltimateEncryption** plugins to implement GetKeyNativeAsync properly (load from their backend directly into NativeKeyHandle).

**CRITICAL:** Use default interface methods (DIM) for the new IKeyStore method so ALL existing implementations continue to compile without changes. Only the plugins we explicitly update will have optimized native key paths.

**NOTE:** The `unsafe` keyword requires `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>` in the SDK's .csproj file. Check if it's already set; if not, add it.
  </action>
  <verify>
Build: `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors.
Grep for `NativeMemory.AllocZeroed` in NativeKeyHandle.cs — present.
Grep for `GetKeyNativeAsync` in IKeyStore.cs — present.
  </verify>
  <done>NativeKeyHandle created with NativeMemory.AllocZeroed and secure wipe. IKeyStore extended with GetKeyNativeAsync using DIM for backward compatibility. Key management and encryption plugins updated to use native key handles.</done>
</task>

<task type="auto">
  <name>Task 2: Add Typed Message Handler Registration (KS3)</name>
  <files>
    DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
  </files>
  <action>
Add `RegisterHandler<TRequest, TResponse>()` to IntelligenceAwarePluginBase (the root of the v3.0 hierarchy). This enables compile-time type-safe message handling.

**Implementation:**

1. Add a private dictionary to track registered handlers:
```csharp
private readonly Dictionary<string, Delegate> _typedHandlers = new();
```

2. Add the RegisterHandler method:
```csharp
/// <summary>
/// Registers a type-safe message handler for the given request/response types.
/// Handlers are automatically subscribed to the message bus using the request type's full name as topic.
/// </summary>
protected void RegisterHandler<TRequest, TResponse>(
    Func<TRequest, CancellationToken, Task<TResponse>> handler)
    where TRequest : notnull
{
    var topic = typeof(TRequest).FullName!;
    _typedHandlers[topic] = handler;

    // Subscribe to message bus if available
    var messageBus = GetMessageBus(); // check how to get IMessageBus from the base class
    messageBus?.Subscribe(topic, async msg =>
    {
        if (msg.Payload is TRequest request)
        {
            var response = await handler(request, CancellationToken.None);
            return new PluginMessage { Type = topic + ".response", Payload = response };
        }
        return new PluginMessage { Type = topic + ".error", Payload = new { Error = "Invalid message type" } };
    });
}
```

3. Add a fire-and-forget variant for notifications (no response):
```csharp
protected void RegisterHandler<TNotification>(
    Func<TNotification, CancellationToken, Task> handler)
    where TNotification : notnull
{
    var topic = typeof(TNotification).FullName!;
    _typedHandlers[topic] = handler;

    var messageBus = GetMessageBus();
    messageBus?.Subscribe(topic, async msg =>
    {
        if (msg.Payload is TNotification notification)
        {
            await handler(notification, CancellationToken.None);
        }
        return new PluginMessage { Type = topic + ".ack" };
    });
}
```

4. Add a helper to query registered handlers:
```csharp
protected IReadOnlyDictionary<string, Type> GetRegisteredHandlers()
    => _typedHandlers.ToDictionary(kv => kv.Key, kv => kv.Value.GetType());
```

**IMPORTANT:** Check how IntelligenceAwarePluginBase accesses IMessageBus. It may be through a protected property, a field set by InjectKernelServices, or via the PluginBase base class. Read the actual file to find the correct accessor. If the message bus is null at registration time (because InjectKernelServices hasn't been called yet), store the handlers and subscribe when the bus becomes available — add a hook in the InjectKernelServices override or an OnMessageBusAvailable callback.

**Check the message bus Subscribe signature.** The current IMessageBus.Subscribe may accept `Func<PluginMessage, Task<PluginMessage>>` or similar. Match the actual signature, don't assume.
  </action>
  <verify>
Build: `dotnet build DataWarehouse.SDK/ --no-restore -v q` — 0 errors.
Grep for `RegisterHandler` in IntelligenceAwarePluginBase.cs — present.
Full solution build: `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors.
  </verify>
  <done>IntelligenceAwarePluginBase has RegisterHandler<TRequest, TResponse> and RegisterHandler<TNotification> methods. Handlers are auto-subscribed to message bus. Deferred subscription handles case where message bus is not yet available at registration time.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore -v q` — 0 errors
2. NativeKeyHandle.cs exists with NativeMemory.AllocZeroed and CryptographicOperations.ZeroMemory
3. IKeyStore has GetKeyNativeAsync with default interface implementation
4. IntelligenceAwarePluginBase has RegisterHandler<TRequest, TResponse>
5. All existing tests pass
</verification>

<success_criteria>
- KS5: Keys stored in unmanaged memory, secure wipe on dispose, backward-compatible IKeyStore extension
- KS3: Type-safe handler registration with automatic message bus subscription
- Build: 0 errors
- Tests: All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/41.1-architecture-kill-shots-10-critical-fixes-from-hostile-audit/41.1-03-SUMMARY.md`
</output>
