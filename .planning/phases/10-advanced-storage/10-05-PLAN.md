---
phase: 10-advanced-storage
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/Generative/GenerativeCompressionStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs
  - Metadata/TODO.md
autonomous: true

must_haves:
  truths:
    - "Content analyzer detects data types suitable for generative compression (text, code, images)"
    - "AI models learn content patterns and generate reconstruction parameters"
    - "Compressed representation stores model parameters instead of raw data"
    - "Decompression reconstructs content from learned models"
    - "Fallback to traditional compression (Zstd) when Intelligence plugin unavailable"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/Generative/GenerativeCompressionStrategy.cs"
      provides: "AI-powered compression using learned models"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs"
      provides: "Plugin orchestrator with generative strategy registration"
      contains: "GenerativeCompressionStrategy"
  key_links:
    - from: "GenerativeCompressionStrategy"
      to: "message bus"
      via: "Intelligence plugin for model training and inference"
      pattern: "PublishAsync.*intelligence\\.train"
    - from: "GenerativeCompressionStrategy"
      to: "fallback compression"
      via: "Zstd when AI unavailable"
      pattern: "IsIntelligenceAvailable.*ZstdStrategy"
---

<objective>
Verify and complete generative compression (T84) using AI content analysis for reconstruction from models.

Purpose: Enable next-generation compression that learns content patterns and stores model parameters instead of raw data, achieving higher compression ratios for suitable data types.
Output: Production-ready GenerativeCompressionStrategy with Intelligence integration and fallback to traditional compression.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-advanced-storage/10-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/Generative/GenerativeCompressionStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify GenerativeCompressionStrategy implementation</name>
  <files>
Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/Generative/GenerativeCompressionStrategy.cs
Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs
Plugins/DataWarehouse.Plugins.UltimateCompression/CompressionStrategyRegistry.cs
  </files>
  <action>
**Verification approach:** Research indicates GenerativeCompressionStrategy.cs exists. Verify T84 AI-powered compression is implemented with Intelligence integration.

**Step 1: Read GenerativeCompressionStrategy.cs**
Verify file exists and check for all T84 sub-tasks:

**T84 Sub-Tasks (from TODO.md):**
- **84.1 Content Analyzer:** Detect data types suitable for generative compression (text, code, images, structured data)
- **84.2 Model Trainer:** Train AI models on content patterns
- **84.3 Model Compressor:** Store model parameters instead of raw data
- **84.4 Model Decompressor:** Reconstruct content from learned models
- **84.5 Quality Validator:** Verify reconstruction quality meets thresholds
- **84.6 Fallback Handler:** Use traditional compression when AI unavailable or unsuitable
- **84.7 Model Cache:** Cache trained models for reuse
- **84.8 Compression Ratio Tracker:** Measure generative vs traditional compression

**Step 2: Verify content analyzer**
Check for data type detection:
```csharp
private bool IsSuitableForGenerativeCompression(byte[] data, out ContentType contentType)
{
    contentType = DetectContentType(data);
    return contentType switch
    {
        ContentType.Text => true,
        ContentType.Code => true,
        ContentType.StructuredData => true,
        ContentType.Image => true,  // For certain image types
        _ => false
    };
}
```

**Step 3: Verify Intelligence integration**
Check for message bus communication with Intelligence plugin:
```csharp
// 84.2: Model training via Intelligence plugin
var trainResponse = await _messageBus.PublishAsync(new PluginMessage
{
    Type = "intelligence.train",
    Payload = new Dictionary<string, object>
    {
        ["model"] = "compression",
        ["data"] = contentSample,
        ["contentType"] = contentType.ToString()
    }
});

// 84.3: Compression via model inference
var compressResponse = await _messageBus.PublishAsync(new PluginMessage
{
    Type = "intelligence.infer",
    Payload = new Dictionary<string, object>
    {
        ["model"] = modelId,
        ["operation"] = "compress",
        ["data"] = rawData
    }
});
```

**Step 4: Verify fallback mechanism**
Check for IsIntelligenceAvailable check and fallback:
```csharp
protected override async Task<byte[]> CompressCoreAsync(byte[] data, CancellationToken ct)
{
    if (!IsIntelligenceAvailable || !IsSuitableForGenerativeCompression(data, out var type))
    {
        // 84.6: Fallback to Zstd
        return await _zstdStrategy.CompressAsync(data, ct);
    }

    // Generative compression
    var modelParams = await TrainAndCompressAsync(data, type, ct);
    return SerializeModelParams(modelParams);
}
```

**Step 5: Verify quality validation**
Check for reconstruction quality checks:
```csharp
// 84.5: Quality validation
var reconstructed = await DecompressCoreAsync(compressed, ct);
var quality = CalculateSimilarity(original, reconstructed);

if (quality < _config.MinimumQualityThreshold)
{
    _logger.LogWarning($"Generative compression quality {quality:P} below threshold, using fallback");
    return await _zstdStrategy.CompressAsync(data, ct);
}
```

**Step 6: Verify strategy registration**
Check UltimateCompressionPlugin.cs for GenerativeCompressionStrategy registration:
```bash
grep "GenerativeCompressionStrategy" Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs
```

**Step 7: Build verification**
```bash
dotnet build Plugins/DataWarehouse.Plugins.UltimateCompression/ --no-incremental
```
Expected: 0 errors

**Step 8: Document findings**
Create sub-task verification table:
| Sub-Task | Feature | Status | Notes |
|----------|---------|--------|-------|
| 84.1 Content Analyzer | IsSuitableForGenerativeCompression | ✅/❌ | ... |
| 84.2 Model Trainer | TrainAndCompressAsync | ✅/❌ | ... |
| ... | ... | ... | ... |
  </action>
  <verify>
- GenerativeCompressionStrategy.cs exists and compiles
- All 8 T84 sub-tasks verified present in code
- Intelligence integration via message bus confirmed
- Fallback to Zstd confirmed
- Build passes with 0 errors
- Sub-task verification table completed
  </verify>
  <done>
T84 generative compression implementation status is fully documented. AI-powered compression with Intelligence integration is verified production-ready or gaps are identified for Task 2.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete missing features and update TODO.md</name>
  <files>
Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/Generative/GenerativeCompressionStrategy.cs
Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs
Metadata/TODO.md
  </files>
  <action>
**Based on Task 1 verification**, implement missing sub-tasks if any.

**If all 8 sub-tasks are verified complete:**
- Verify GenerativeCompressionStrategy is registered in UltimateCompressionPlugin
- Mark all T84.1-84.8 sub-tasks as [x] in Metadata/TODO.md
- Update T84 status from [ ] Not Started to [x] Complete
- Skip to verification

**If gaps exist (implement only what's missing):**

**Content Analyzer (84.1):**
```csharp
private ContentType DetectContentType(byte[] data)
{
    // Check for text (UTF-8 BOM or high ASCII ratio)
    if (IsUtf8Text(data)) return ContentType.Text;

    // Check for code (common programming language patterns)
    if (HasCodePatterns(data)) return ContentType.Code;

    // Check for structured data (JSON, XML, CSV headers)
    if (IsStructuredData(data)) return ContentType.StructuredData;

    // Check for images (PNG, JPEG, WebP signatures)
    if (IsImageData(data)) return ContentType.Image;

    return ContentType.Binary;
}

private bool IsSuitableForGenerativeCompression(byte[] data, out ContentType contentType)
{
    contentType = DetectContentType(data);

    // Minimum size threshold (generative compression has overhead)
    if (data.Length < _config.MinimumSizeBytes)
        return false;

    // Only certain content types benefit
    return contentType is ContentType.Text or ContentType.Code or ContentType.StructuredData;
}
```

**Model Trainer (84.2) and Compressor (84.3):**
```csharp
private async Task<ModelParameters> TrainAndCompressAsync(
    byte[] data, ContentType contentType, CancellationToken ct)
{
    // Check if Intelligence plugin is available
    if (!IsIntelligenceAvailable)
        throw new InvalidOperationException("Intelligence plugin required for generative compression");

    // Train model on content patterns
    var trainResponse = await _messageBus.PublishAsync(new PluginMessage
    {
        Type = "intelligence.train",
        Payload = new Dictionary<string, object>
        {
            ["model"] = $"compression-{contentType}",
            ["data"] = Convert.ToBase64String(data),
            ["algorithm"] = "generative-compression",
            ["contentType"] = contentType.ToString()
        }
    }, ct);

    if (trainResponse?.Payload.TryGetValue("modelId", out var modelIdObj) != true)
        throw new InvalidOperationException("Model training failed");

    var modelId = (string)modelIdObj;

    // Compress using trained model
    var compressResponse = await _messageBus.PublishAsync(new PluginMessage
    {
        Type = "intelligence.infer",
        Payload = new Dictionary<string, object>
        {
            ["modelId"] = modelId,
            ["operation"] = "compress",
            ["data"] = Convert.ToBase64String(data)
        }
    }, ct);

    if (compressResponse?.Payload.TryGetValue("parameters", out var paramsObj) != true)
        throw new InvalidOperationException("Compression failed");

    return new ModelParameters
    {
        ModelId = modelId,
        CompressedParams = (byte[])paramsObj,
        ContentType = contentType,
        OriginalSize = data.Length
    };
}
```

**Model Decompressor (84.4):**
```csharp
protected override async Task<byte[]> DecompressCoreAsync(byte[] compressed, CancellationToken ct)
{
    var modelParams = DeserializeModelParams(compressed);

    // Check if this is generative compression
    if (modelParams == null)
    {
        // Fallback compression format
        return await _zstdStrategy.DecompressAsync(compressed, ct);
    }

    // Reconstruct from model
    var response = await _messageBus.PublishAsync(new PluginMessage
    {
        Type = "intelligence.infer",
        Payload = new Dictionary<string, object>
        {
            ["modelId"] = modelParams.ModelId,
            ["operation"] = "decompress",
            ["parameters"] = modelParams.CompressedParams
        }
    }, ct);

    if (response?.Payload.TryGetValue("data", out var dataObj) != true)
        throw new InvalidOperationException("Decompression failed");

    return Convert.FromBase64String((string)dataObj);
}
```

**Quality Validator (84.5):**
```csharp
private double CalculateSimilarity(byte[] original, byte[] reconstructed)
{
    // For text/code: use edit distance or token similarity
    // For images: use SSIM or PSNR
    // For structured data: use schema match percentage

    if (original.Length != reconstructed.Length)
        return 0.0;

    int matches = original.Zip(reconstructed, (a, b) => a == b ? 1 : 0).Sum();
    return (double)matches / original.Length;
}
```

**Fallback Handler (84.6):**
Already verified in Step 4 - ensure it exists and works correctly.

**Update TODO.md:**
Mark all implemented T84 sub-tasks as [x]. Update status to [x] Complete.

**Build verification:**
```bash
dotnet build Plugins/DataWarehouse.Plugins.UltimateCompression/ --no-incremental
```
Must pass with 0 errors.
  </action>
  <verify>
- Build passes with 0 errors
- All 8 T84 sub-tasks marked [x] in Metadata/TODO.md
- GenerativeCompressionStrategy registered in UltimateCompressionPlugin
- No forbidden patterns in modified files
- Intelligence integration via message bus verified
- Fallback to Zstd when AI unavailable verified
  </verify>
  <done>
All T84 generative compression sub-tasks are production-ready. AI-powered compression with model training, inference, quality validation, and fallback works correctly.
  </done>
</task>

</tasks>

<verification>
**Build verification:**
```bash
dotnet build Plugins/DataWarehouse.Plugins.UltimateCompression/ --no-incremental
```
Expected: 0 errors

**Forbidden pattern scan:**
```bash
grep -r "NotImplementedException\|TODO.*implement\|STUB\|MOCK" Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/Generative/ --include="*.cs" | grep -v obj/
```
Expected: 0 matches

**Intelligence dependency check:**
```bash
grep "IsIntelligenceAvailable\|intelligence\\." Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/Generative/GenerativeCompressionStrategy.cs
```
Expected: Multiple matches showing AI integration and fallback
</verification>

<success_criteria>
1. GenerativeCompressionStrategy compiles without errors
2. All 8 T84 sub-tasks verified implemented (content analyzer, model trainer, compressor, decompressor, quality validator, fallback, cache, ratio tracker)
3. Intelligence plugin integration via message bus for training and inference
4. Graceful fallback to Zstd when Intelligence plugin unavailable
5. Quality validation ensures reconstruction meets thresholds
6. Zero forbidden patterns in codebase
7. Metadata/TODO.md updated with T84 completion status
</success_criteria>

<output>
After completion, create `.planning/phases/10-advanced-storage/10-05-SUMMARY.md`
</output>
