---
phase: 10-advanced-storage
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/BlockLevelTieringStrategy.cs
  - Metadata/TODO.md
autonomous: true

must_haves:
  truths:
    - "Block access frequency is tracked per block, not per file"
    - "Heatmaps visualize block temperature distribution (Hot/Warm/Cold/Archive/Glacier)"
    - "Hot blocks reside on NVMe while cold blocks of the same file reside on S3"
    - "Transparent reassembly makes multi-tier storage invisible to applications"
    - "Cost optimizer balances performance vs storage cost per block"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/BlockLevelTieringStrategy.cs"
      provides: "Block-level tiering with heatmap, migration, and cost optimization"
      min_lines: 2000
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataManagement/UltimateDataManagementPlugin.cs"
      provides: "Plugin orchestrator registering tiering strategies"
      contains: "BlockLevelTieringStrategy"
  key_links:
    - from: "BlockLevelTieringStrategy"
      to: "message bus"
      via: "tier migration requests to storage plugin"
      pattern: "PublishAsync.*storage\\.migrate"
    - from: "BlockLevelTieringStrategy"
      to: "intelligence plugin"
      via: "predictive prefetch via AI"
      pattern: "PublishAsync.*intelligence\\.predict"
---

<objective>
Verify and complete block-level tiering (T81) with heatmaps, predictive prefetch, and cost optimization.

Purpose: Enable sub-file granularity tiering where hot blocks stay on fast storage (NVMe) while cold blocks of the same file move to cheap storage (S3), transparently.
Output: Production-ready BlockLevelTieringStrategy with all 10 T81 sub-tasks verified or implemented.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-advanced-storage/10-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/BlockLevelTieringStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify BlockLevelTieringStrategy implementation</name>
  <files>
Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/BlockLevelTieringStrategy.cs
Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/TieringStrategyBase.cs
Plugins/DataWarehouse.Plugins.UltimateDataManagement/UltimateDataManagementPlugin.cs
  </files>
  <action>
**Verification approach:** Research indicates BlockLevelTieringStrategy.cs exists with 2250 lines implementing all T81 sub-tasks. Verify implementation completeness.

**Step 1: Read BlockLevelTieringStrategy.cs**
Verify file exists and has 2000+ lines (indicates comprehensive implementation).

Check for all T81 sub-tasks in code comments or implementation:
- **81.1 Block Access Tracker:** Track access frequency per block (not file)
- **81.2 Heatmap Generator:** Visual/queryable block heat distribution
- **81.3 Block Splitter:** Split files into independently movable blocks
- **81.4 Transparent Reassembly:** Seamlessly reassemble blocks for reads
- **81.5 Tier Migration Engine:** Move individual blocks between storage tiers
- **81.6 Predictive Prefetch:** Anticipate block access and pre-stage
- **81.7 Block Metadata Index:** Track which blocks are on which tier
- **81.8 Cost Optimizer:** Balance performance vs storage cost per block
- **81.9 Database Optimization:** Special handling for database file patterns
- **81.10 Real-time Rebalancing:** Continuous optimization as access patterns change

**Step 2: Verify key methods exist**
Search for these critical methods (from research):
```csharp
public BlockHeatmap GenerateHeatmap(string objectId)  // 81.2
public async Task<TierRecommendation> EvaluateCoreAsync(...)  // 81.5
private BlockAccessStats TrackBlockAccess(...)  // 81.1
private async Task<byte[]> ReassembleBlocksAsync(...)  // 81.4
private void DetectDatabaseFile(...)  // 81.9
private CostOptimizationAnalysis AnalyzeCostOptimization(...)  // 81.8
private void FindChunkBoundary(...)  // Content-defined chunking for 81.3
```

**Step 3: Verify configuration**
Check for `BlockTierConfig` class with tunable parameters:
- Block size (default 4MB from research)
- Heat thresholds for tier classification
- Prefetch settings
- Cost models

**Step 4: Verify tier classification**
Check heatmap tier mapping:
```csharp
StorageTier tier = heatValue switch
{
    >= 0.7 => StorageTier.Hot,      // NVMe/SSD
    >= 0.4 => StorageTier.Warm,     // HDD
    >= 0.2 => StorageTier.Cold,     // Network storage
    >= 0.05 => StorageTier.Archive, // S3 Standard
    _ => StorageTier.Glacier        // S3 Glacier
};
```

**Step 5: Verify message bus integration**
Check for message bus usage (no direct plugin references):
```csharp
await _messageBus.PublishAsync(new PluginMessage("storage.migrate", ...))
await _messageBus.PublishAsync(new PluginMessage("intelligence.predict", ...))
```

**Step 6: Build verification**
```bash
dotnet build Plugins/DataWarehouse.Plugins.UltimateDataManagement/ --no-incremental
```
Expected: 0 errors

**Step 7: Document findings**
Create sub-task verification table:
| Sub-Task | Method/Feature | Status | Notes |
|----------|---------------|--------|-------|
| 81.1 Block Access Tracker | TrackBlockAccess | ✅/❌ | ... |
| 81.2 Heatmap Generator | GenerateHeatmap | ✅/❌ | ... |
| ... | ... | ... | ... |
  </action>
  <verify>
- BlockLevelTieringStrategy.cs exists with 2000+ lines
- All 10 T81 sub-tasks verified implemented
- Build passes with 0 errors
- Sub-task verification table completed
  </verify>
  <done>
T81 block-level tiering implementation status is fully documented. All sub-tasks are verified production-ready or gaps are identified for Task 2.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete missing sub-tasks and update TODO.md</name>
  <files>
Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/BlockLevelTieringStrategy.cs
Plugins/DataWarehouse.Plugins.UltimateDataManagement/UltimateDataManagementPlugin.cs
Metadata/TODO.md
  </files>
  <action>
**Based on Task 1 verification**, implement missing sub-tasks if any.

**If all 10 sub-tasks are verified complete:**
- Verify BlockLevelTieringStrategy is registered in UltimateDataManagementPlugin
- Mark all T81.1-81.10 sub-tasks as [x] in Metadata/TODO.md
- Update T81 status from [ ] Not Started to [x] Complete
- Skip to verification

**If gaps exist (implement only what's missing):**

**For missing sub-tasks, follow these patterns:**

**Block Access Tracker (81.1):**
```csharp
private ConcurrentDictionary<string, BlockAccessStats> _blockStats = new();

private void TrackBlockAccess(string objectId, int blockIndex)
{
    var stats = _blockStats.GetOrAdd(objectId, _ => new BlockAccessStats());
    stats.BlockAccessCounts[blockIndex]++;
    stats.LastAccessTimes[blockIndex] = DateTime.UtcNow;
    stats.AccessesLast24Hours[blockIndex]++;
}
```

**Heatmap Generator (81.2):**
Use weighted heat calculation from research (lines 665-731 of BlockLevelTieringStrategy.cs):
- countHeat * 0.3 (total access count)
- recencyHeat * 0.4 (time decay)
- rateHeat * 0.3 (recent access rate)

**Transparent Reassembly (81.4):**
```csharp
private async Task<byte[]> ReassembleBlocksAsync(string objectId, BlockMap blockMap)
{
    var blocks = new byte[blockMap.BlockCount][];
    var tasks = new Task[blockMap.BlockCount];

    for (int i = 0; i < blockMap.BlockCount; i++)
    {
        var tier = blockMap.BlockLocations[i].Tier;
        tasks[i] = ReadBlockFromTierAsync(objectId, i, tier);
    }

    await Task.WhenAll(tasks);
    return ConcatenateBlocks(blocks);
}
```

**Predictive Prefetch (81.6):**
Use Intelligence plugin via message bus:
```csharp
private async Task PredictivePrefetchAsync(string objectId, int currentBlock)
{
    var prediction = await _messageBus.PublishAsync(new PluginMessage
    {
        Type = "intelligence.predict",
        Payload = new { objectId, currentBlock, context = "block-access" }
    });

    if (prediction?.Payload.TryGetValue("nextBlocks", out var blocks))
    {
        foreach (int blockIndex in (int[])blocks)
            await PrefetchBlockAsync(objectId, blockIndex);
    }
}
```

**Cost Optimizer (81.8):**
```csharp
private CostOptimizationAnalysis AnalyzeCostOptimization(BlockHeatmap heatmap)
{
    decimal totalCost = 0;
    var recommendations = new List<TierMigrationRecommendation>();

    for (int i = 0; i < heatmap.BlockCount; i++)
    {
        var currentTier = heatmap.RecommendedTiers[i];
        var tierCost = GetTierCostPerGB(currentTier);
        var accessCost = GetAccessCostPerOperation(currentTier);

        // Calculate cost-performance tradeoff
        if (ShouldMigrateForCost(heatmap.HeatValues[i], tierCost, accessCost))
            recommendations.Add(new TierMigrationRecommendation { BlockIndex = i, ... });
    }

    return new CostOptimizationAnalysis { TotalMonthlyCost = totalCost, ... };
}
```

**Database Optimization (81.9):**
Detect database files and optimize block placement for sequential reads:
```csharp
private DatabaseType? DetectDatabaseFile(string path)
{
    return Path.GetExtension(path).ToLowerInvariant() switch
    {
        ".mdf" or ".ldf" => DatabaseType.SqlServer,
        ".sqlite" or ".db" => DatabaseType.SQLite,
        ".pgdata" => DatabaseType.PostgreSQL,
        _ => null
    };
}
```

**Update TODO.md:**
Mark implemented sub-tasks as [x]. Update T81 status to [x] Complete if all sub-tasks done.

**Build verification:**
```bash
dotnet build Plugins/DataWarehouse.Plugins.UltimateDataManagement/ --no-incremental
```
Must pass with 0 errors.
  </action>
  <verify>
- Build passes with 0 errors
- All 10 T81 sub-tasks marked [x] in Metadata/TODO.md
- BlockLevelTieringStrategy registered in plugin orchestrator
- No forbidden patterns in modified files
- Message bus integration verified (no direct plugin references)
  </verify>
  <done>
All T81 block-level tiering sub-tasks are production-ready. Heatmap-driven tier placement with cost optimization works transparently across multi-tier storage.
  </done>
</task>

</tasks>

<verification>
**Build verification:**
```bash
dotnet build Plugins/DataWarehouse.Plugins.UltimateDataManagement/ --no-incremental
```
Expected: 0 errors

**Forbidden pattern scan:**
```bash
grep -r "NotImplementedException\|TODO.*implement\|STUB\|MOCK" Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/ --include="*.cs" | grep -v obj/
```
Expected: 0 matches

**Sub-task coverage:**
```bash
grep "81\\.[0-9]" Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/Tiering/BlockLevelTieringStrategy.cs | wc -l
```
Expected: ≥10 (all sub-tasks referenced in code comments or implementation)
</verification>

<success_criteria>
1. BlockLevelTieringStrategy compiles without errors
2. All 10 T81 sub-tasks verified implemented (block tracker, heatmap, splitter, reassembly, migration, prefetch, metadata index, cost optimizer, DB optimization, rebalancing)
3. Heatmap classification uses 5-tier system (Hot/Warm/Cold/Archive/Glacier)
4. Transparent reassembly works across multi-tier storage
5. Message bus integration for storage migration and AI prediction
6. Zero forbidden patterns in codebase
7. Metadata/TODO.md updated with T81 completion status
</success_criteria>

<output>
After completion, create `.planning/phases/10-advanced-storage/10-03-SUMMARY.md`
</output>
