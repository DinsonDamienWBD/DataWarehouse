---
phase: 26-distributed-contracts-resilience
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Resilience/ICircuitBreaker.cs
  - DataWarehouse.SDK/Contracts/Resilience/IBulkheadIsolation.cs
  - DataWarehouse.SDK/Contracts/Resilience/IDeadLetterQueue.cs
  - DataWarehouse.SDK/Contracts/Resilience/ITimeoutPolicy.cs
  - DataWarehouse.SDK/Contracts/Resilience/IGracefulShutdown.cs
autonomous: true

must_haves:
  truths:
    - "ICircuitBreaker provides a focused circuit breaker contract with Open/Closed/HalfOpen states"
    - "IBulkheadIsolation defines per-plugin resource limits for memory, CPU, and connections"
    - "IDeadLetterQueue defines failed message handling with retry policies"
    - "ITimeoutPolicy provides unified timeout configuration for all async operations"
    - "IGracefulShutdown defines shutdown coordination from kernel through plugins to strategies"
    - "Existing IResiliencePolicy is NOT modified or replaced -- ICircuitBreaker coexists"
    - "Build compiles with zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Resilience/ICircuitBreaker.cs"
      provides: "ICircuitBreaker focused interface with trip/reset/half-open probe, CircuitBreakerConfig, CircuitBreakerStatistics"
      contains: "interface ICircuitBreaker"
    - path: "DataWarehouse.SDK/Contracts/Resilience/IBulkheadIsolation.cs"
      provides: "IBulkheadIsolation for per-plugin resource partitioning"
      contains: "interface IBulkheadIsolation"
    - path: "DataWarehouse.SDK/Contracts/Resilience/IDeadLetterQueue.cs"
      provides: "IDeadLetterQueue for failed messages with retry policies"
      contains: "interface IDeadLetterQueue"
    - path: "DataWarehouse.SDK/Contracts/Resilience/ITimeoutPolicy.cs"
      provides: "ITimeoutPolicy for unified timeout configuration"
      contains: "interface ITimeoutPolicy"
    - path: "DataWarehouse.SDK/Contracts/Resilience/IGracefulShutdown.cs"
      provides: "IGracefulShutdown for coordinated shutdown propagation"
      contains: "interface IGracefulShutdown"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Resilience/ICircuitBreaker.cs"
      to: "DataWarehouse.SDK/Contracts/IKernelInfrastructure.cs"
      via: "References existing CircuitState enum from IKernelInfrastructure"
      pattern: "CircuitState"
    - from: "DataWarehouse.SDK/Contracts/Resilience/IDeadLetterQueue.cs"
      to: "DataWarehouse.SDK/Contracts/IMessageBus.cs"
      via: "DeadLetterMessage wraps PluginMessage for failed delivery"
      pattern: "PluginMessage"
---

<objective>
Define all 5 resilience contracts (RESIL-01 through RESIL-05) as SDK interfaces in a new `Contracts/Resilience/` directory.

Purpose: Resilience contracts let any plugin use circuit breakers, bulkhead isolation, timeout policies, dead letter queues, and graceful shutdown coordination through SDK-defined interfaces. These are independent of the existing IResiliencePolicy (which is preserved as-is).

Output: 5 new interface files in `DataWarehouse.SDK/Contracts/Resilience/` with full XML documentation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-distributed-contracts-resilience/26-RESEARCH.md

Key existing files to reference:
@DataWarehouse.SDK/Contracts/IKernelInfrastructure.cs (IResiliencePolicy, CircuitState, ResiliencePolicyConfig)
@DataWarehouse.SDK/Contracts/IMessageBus.cs (PluginMessage, IAdvancedMessageBus)
@DataWarehouse.SDK/Contracts/PluginBase.cs (ShutdownAsync lifecycle)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ICircuitBreaker, IBulkheadIsolation, and ITimeoutPolicy contracts</name>
  <files>
    DataWarehouse.SDK/Contracts/Resilience/ICircuitBreaker.cs
    DataWarehouse.SDK/Contracts/Resilience/IBulkheadIsolation.cs
    DataWarehouse.SDK/Contracts/Resilience/ITimeoutPolicy.cs
  </files>
  <action>
    Create the `DataWarehouse.SDK/Contracts/Resilience/` directory and 3 new files. All use namespace `DataWarehouse.SDK.Contracts.Resilience`.

    **ICircuitBreaker.cs** (RESIL-01):
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Resilience contracts")]`
    - `interface ICircuitBreaker` with:
      - `string Name { get; }` -- identifier for this circuit breaker instance
      - `CircuitState State { get; }` -- reuses EXISTING `CircuitState` enum from `DataWarehouse.SDK.Contracts.IKernelInfrastructure` (Open/Closed/HalfOpen). Add `using DataWarehouse.SDK.Contracts;` to reference it. Do NOT define a new CircuitState enum.
      - `event Action<CircuitBreakerStateChanged>? OnStateChanged`
      - `Task<T> ExecuteAsync<T>(Func<CancellationToken, Task<T>> action, CancellationToken ct = default)` -- executes with circuit breaker protection
      - `Task ExecuteAsync(Func<CancellationToken, Task> action, CancellationToken ct = default)` -- void version
      - `void Trip(string reason)` -- manually trip to Open
      - `void Reset()` -- manually reset to Closed
      - `CircuitBreakerStatistics GetStatistics()`
    - `record CircuitBreakerStateChanged` with init props: `string Name`, `CircuitState PreviousState`, `CircuitState NewState`, `string? Reason`, `DateTimeOffset Timestamp`
    - `record CircuitBreakerStatistics` with init props: `string Name`, `CircuitState CurrentState`, `long TotalRequests`, `long SuccessfulRequests`, `long FailedRequests`, `long RejectedRequests`, `DateTimeOffset? LastFailureAt`, `DateTimeOffset? LastSuccessAt`, `TimeSpan? TimeInCurrentState`
    - `record CircuitBreakerOptions` with init props: `int FailureThreshold` (default 5), `TimeSpan FailureWindow` (default 60s), `TimeSpan BreakDuration` (default 30s), `int HalfOpenMaxAttempts` (default 1), `Func<Exception, bool>? ShouldHandle` (filter which exceptions count as failures)

    **IBulkheadIsolation.cs** (RESIL-02):
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Resilience contracts")]`
    - `interface IBulkheadIsolation` with:
      - `string Name { get; }` -- identifier (typically plugin ID)
      - `Task<BulkheadLease> AcquireAsync(CancellationToken ct = default)` -- acquire a slot in the bulkhead
      - `BulkheadStatistics GetStatistics()`
      - `BulkheadOptions Options { get; }`
    - `interface IBulkheadLease : IAsyncDisposable` with: -- disposing releases the slot
      - `bool IsAcquired { get; }`
      - `DateTimeOffset AcquiredAt { get; }`
    - Use `IBulkheadLease` as return type of AcquireAsync (not BulkheadLease record)
    - `record BulkheadOptions` with init props: `int MaxConcurrency` (default 10), `int MaxQueueSize` (default 0 -- reject immediately if full), `TimeSpan? QueueTimeout`
    - `record BulkheadStatistics` with init props: `string Name`, `int CurrentConcurrency`, `int MaxConcurrency`, `int QueueLength`, `int MaxQueueSize`, `long TotalExecuted`, `long TotalRejected`

    **ITimeoutPolicy.cs** (RESIL-03):
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Resilience contracts")]`
    - `interface ITimeoutPolicy` with:
      - `TimeSpan DefaultTimeout { get; }` -- default timeout for operations
      - `Task<T> ExecuteAsync<T>(Func<CancellationToken, Task<T>> action, CancellationToken ct = default)` -- wraps with timeout
      - `Task<T> ExecuteAsync<T>(Func<CancellationToken, Task<T>> action, TimeSpan timeout, CancellationToken ct = default)` -- override timeout
      - `Task ExecuteAsync(Func<CancellationToken, Task> action, CancellationToken ct = default)` -- void version
      - `Task ExecuteAsync(Func<CancellationToken, Task> action, TimeSpan timeout, CancellationToken ct = default)` -- void version with override
      - `event Action<TimeoutEvent>? OnTimeout`
    - `record TimeoutOptions` with init props: `TimeSpan DefaultTimeout` (default 30s), `TimeoutStrategy Strategy` (default Optimistic)
    - `enum TimeoutStrategy { Optimistic, Pessimistic }` -- Optimistic: relies on CancellationToken. Pessimistic: races task against timer.
    - `record TimeoutEvent` with init props: `string OperationName`, `TimeSpan ElapsedTime`, `TimeSpan ConfiguredTimeout`, `DateTimeOffset Timestamp`
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero new errors. Verify that `CircuitState` is referenced from existing IKernelInfrastructure (not re-defined).
  </verify>
  <done>
    ICircuitBreaker, IBulkheadIsolation, ITimeoutPolicy are defined with full XML docs. ICircuitBreaker reuses existing CircuitState enum. No existing types duplicated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IDeadLetterQueue and IGracefulShutdown contracts</name>
  <files>
    DataWarehouse.SDK/Contracts/Resilience/IDeadLetterQueue.cs
    DataWarehouse.SDK/Contracts/Resilience/IGracefulShutdown.cs
  </files>
  <action>
    Create 2 new files in `DataWarehouse.SDK/Contracts/Resilience/`.

    **IDeadLetterQueue.cs** (RESIL-05):
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Resilience contracts")]`
    - `interface IDeadLetterQueue` with:
      - `Task EnqueueAsync(DeadLetterMessage message, CancellationToken ct = default)` -- add failed message to DLQ
      - `Task<IReadOnlyList<DeadLetterMessage>> PeekAsync(int maxCount, CancellationToken ct = default)` -- view without removing
      - `Task<DeadLetterMessage?> DequeueAsync(CancellationToken ct = default)` -- remove and return oldest
      - `Task<bool> RetryAsync(string messageId, CancellationToken ct = default)` -- re-publish the failed message
      - `Task<bool> DiscardAsync(string messageId, string reason, CancellationToken ct = default)` -- permanently remove
      - `Task<int> GetCountAsync(CancellationToken ct = default)` -- number of messages in DLQ
      - `Task PurgeAsync(CancellationToken ct = default)` -- remove all messages
      - `event Action<DeadLetterEvent>? OnDeadLetterEvent`
    - `record DeadLetterMessage` with init props: `string MessageId`, `string OriginalTopic`, `PluginMessage OriginalMessage` (reference existing PluginMessage from SDK.Utilities), `string FailureReason`, `Exception? Exception`, `int RetryCount`, `int MaxRetries`, `DateTimeOffset FailedAt`, `DateTimeOffset? NextRetryAt`, `DeadLetterRetryPolicy RetryPolicy`
    - Add `using DataWarehouse.SDK.Utilities;` for PluginMessage reference
    - `record DeadLetterRetryPolicy` with init props: `int MaxRetries` (default 3), `TimeSpan InitialDelay` (default 1s), `TimeSpan MaxDelay` (default 60s), `double BackoffMultiplier` (default 2.0), `DeadLetterRetryStrategy Strategy`
    - `enum DeadLetterRetryStrategy { Fixed, ExponentialBackoff, LinearBackoff }`
    - `record DeadLetterEvent` with init props: `DeadLetterEventType EventType`, `string MessageId`, `string OriginalTopic`, `DateTimeOffset Timestamp`, `string? Detail`
    - `enum DeadLetterEventType { Enqueued, Retried, RetrySucceeded, RetryFailed, Discarded, Purged }`

    **IGracefulShutdown.cs** (RESIL-04):
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Resilience contracts")]`
    - `interface IGracefulShutdown` with:
      - `Task InitiateShutdownAsync(ShutdownContext context, CancellationToken ct = default)` -- starts coordinated shutdown
      - `Task RegisterShutdownHandlerAsync(IShutdownHandler handler, CancellationToken ct = default)` -- register a handler
      - `Task DeregisterShutdownHandlerAsync(string handlerId, CancellationToken ct = default)` -- deregister
      - `ShutdownState GetState()` -- current shutdown state
      - `event Action<ShutdownEvent>? OnShutdownEvent`
    - `interface IShutdownHandler` with:
      - `string HandlerId { get; }` -- unique identifier
      - `int Priority { get; }` -- lower = shutdown first (0=first, 100=last)
      - `Task OnShutdownAsync(ShutdownContext context, CancellationToken ct = default)` -- called during shutdown
    - `record ShutdownContext` with init props: `string Reason`, `ShutdownUrgency Urgency`, `TimeSpan MaxWaitTime`, `DateTimeOffset InitiatedAt`
    - `enum ShutdownUrgency { Graceful, Urgent, Immediate }` -- Graceful: full drain. Urgent: abbreviated. Immediate: minimal.
    - `enum ShutdownState { Running, ShuttingDown, Completed, Failed }`
    - `record ShutdownEvent` with init props: `ShutdownEventType EventType`, `string? HandlerId`, `DateTimeOffset Timestamp`, `string? Detail`
    - `enum ShutdownEventType { ShutdownInitiated, HandlerStarted, HandlerCompleted, HandlerFailed, ShutdownCompleted, ShutdownFailed }`

    **Patterns:** Full XML docs, SdkCompatibility attributes, CancellationToken on all async methods, init properties on records.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero new errors. Verify DeadLetterMessage references PluginMessage (not a new type). Verify all 5 resilience interfaces exist.
  </verify>
  <done>
    IDeadLetterQueue and IGracefulShutdown are defined with full XML docs. DeadLetterMessage wraps existing PluginMessage. All 5 resilience contracts (RESIL-01 through RESIL-05) are complete.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
2. `grep -r "interface ICircuitBreaker" DataWarehouse.SDK/Contracts/Resilience/` -- confirms RESIL-01
3. `grep -r "interface IBulkheadIsolation" DataWarehouse.SDK/Contracts/Resilience/` -- confirms RESIL-02
4. `grep -r "interface ITimeoutPolicy" DataWarehouse.SDK/Contracts/Resilience/` -- confirms RESIL-03
5. `grep -r "interface IGracefulShutdown" DataWarehouse.SDK/Contracts/Resilience/` -- confirms RESIL-04
6. `grep -r "interface IDeadLetterQueue" DataWarehouse.SDK/Contracts/Resilience/` -- confirms RESIL-05
7. ICircuitBreaker.State uses existing CircuitState (not a new enum)
8. DeadLetterMessage.OriginalMessage references existing PluginMessage
9. Existing IResiliencePolicy in IKernelInfrastructure.cs is UNCHANGED
</verification>

<success_criteria>
- 5 new interface files exist in `DataWarehouse.SDK/Contracts/Resilience/`
- Each interface has full XML documentation
- ICircuitBreaker reuses existing CircuitState enum (no duplication)
- IDeadLetterQueue references existing PluginMessage type
- Existing IResiliencePolicy and IResiliencePolicyManager are not modified
- SDK builds with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-distributed-contracts-resilience/26-03-SUMMARY.md`
</output>
