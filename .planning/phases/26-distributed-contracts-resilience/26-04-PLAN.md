---
phase: 26-distributed-contracts-resilience
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Observability/ISdkActivitySource.cs
  - DataWarehouse.SDK/Contracts/Observability/ICorrelatedLogger.cs
  - DataWarehouse.SDK/Contracts/Observability/IResourceMeter.cs
  - DataWarehouse.SDK/Contracts/Observability/IAuditTrail.cs
  - DataWarehouse.SDK/Contracts/PluginBase.cs
autonomous: true

must_haves:
  truths:
    - "ISdkActivitySource bridges to System.Diagnostics.ActivitySource for standard .NET tracing"
    - "ICorrelatedLogger provides structured logging with mandatory correlation IDs"
    - "IResourceMeter provides per-plugin resource usage metering (memory, CPU, I/O)"
    - "IAuditTrail provides immutable, append-only audit trail for security operations"
    - "PluginBase has a virtual CheckHealthAsync that returns Healthy by default (OBS-03)"
    - "Existing IDistributedTracing and IObservabilityStrategy are NOT modified"
    - "Existing IHealthCheck interfaces are NOT duplicated"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Observability/ISdkActivitySource.cs"
      provides: "ISdkActivitySource wrapping System.Diagnostics.ActivitySource for SDK operations"
      contains: "interface ISdkActivitySource"
    - path: "DataWarehouse.SDK/Contracts/Observability/ICorrelatedLogger.cs"
      provides: "ICorrelatedLogger with automatic correlation ID attachment"
      contains: "interface ICorrelatedLogger"
    - path: "DataWarehouse.SDK/Contracts/Observability/IResourceMeter.cs"
      provides: "IResourceMeter for per-plugin resource metering"
      contains: "interface IResourceMeter"
    - path: "DataWarehouse.SDK/Contracts/Observability/IAuditTrail.cs"
      provides: "IAuditTrail for immutable audit trail"
      contains: "interface IAuditTrail"
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "Virtual CheckHealthAsync method returning Healthy by default"
      contains: "CheckHealthAsync"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Observability/ISdkActivitySource.cs"
      to: "System.Diagnostics.ActivitySource"
      via: "Wraps .NET built-in ActivitySource for standard OTEL integration"
      pattern: "System\\.Diagnostics"
    - from: "DataWarehouse.SDK/Contracts/Observability/ICorrelatedLogger.cs"
      to: "Microsoft.Extensions.Logging.ILogger"
      via: "Extends ILogger semantics with correlation ID"
      pattern: "ILogger|CorrelationId"
    - from: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      to: "DataWarehouse.SDK/Infrastructure/KernelInfrastructure.cs"
      via: "CheckHealthAsync returns HealthCheckResult compatible with HealthCheckAggregator"
      pattern: "HealthCheckResult|CheckHealthAsync"
---

<objective>
Define all 5 observability contracts (OBS-01 through OBS-05) and add IHealthCheck integration to PluginBase.

Purpose: Observability contracts give every plugin access to distributed tracing (via standard .NET ActivitySource), correlated logging, resource metering, and audit trails. Making IHealthCheck part of PluginBase ensures the kernel can aggregate health from ALL plugins.

Output: 4 new interface files in `DataWarehouse.SDK/Contracts/Observability/` and a virtual CheckHealthAsync on PluginBase.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-distributed-contracts-resilience/26-RESEARCH.md

Key existing files:
@DataWarehouse.SDK/Contracts/IKernelInfrastructure.cs (IDistributedTracing, IMetricsCollector, IHealthCheck, HealthStatus, HealthCheckResult)
@DataWarehouse.SDK/Contracts/Observability/IObservabilityStrategy.cs
@DataWarehouse.SDK/Contracts/Observability/TraceTypes.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Infrastructure/KernelInfrastructure.cs (HealthCheckAggregator, IHealthCheck)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ISdkActivitySource, ICorrelatedLogger, IResourceMeter, and IAuditTrail</name>
  <files>
    DataWarehouse.SDK/Contracts/Observability/ISdkActivitySource.cs
    DataWarehouse.SDK/Contracts/Observability/ICorrelatedLogger.cs
    DataWarehouse.SDK/Contracts/Observability/IResourceMeter.cs
    DataWarehouse.SDK/Contracts/Observability/IAuditTrail.cs
  </files>
  <action>
    Create 4 new files in the EXISTING `DataWarehouse.SDK/Contracts/Observability/` directory (already contains IObservabilityStrategy.cs, MetricTypes.cs, etc.).

    **ISdkActivitySource.cs** (OBS-01):
    - Namespace: `DataWarehouse.SDK.Contracts.Observability`
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: ActivitySource integration for distributed tracing")]`
    - `interface ISdkActivitySource` with:
      - `System.Diagnostics.Activity? StartActivity(string name, System.Diagnostics.ActivityKind kind = System.Diagnostics.ActivityKind.Internal)` -- starts an activity (span)
      - `System.Diagnostics.Activity? StartActivity(string name, System.Diagnostics.ActivityKind kind, System.Diagnostics.ActivityContext parentContext)` -- starts with parent context
      - `void RecordException(System.Diagnostics.Activity activity, Exception exception)` -- adds exception to current activity
      - `void SetTag(System.Diagnostics.Activity activity, string key, object? value)` -- adds tag to activity
      - `string SourceName { get; }` -- name of the activity source (e.g., "DataWarehouse.SDK")
      - `string? SourceVersion { get; }` -- version of the activity source
    - Add `using System.Diagnostics;` at top
    - This bridges the SDK to standard .NET ActivitySource. Existing IDistributedTracing is NOT replaced -- this is a parallel standard-compliant integration.
    - Note: `System.Diagnostics.Activity` and `ActivitySource` are part of `System.Diagnostics.DiagnosticSource` which is included in the .NET runtime (no additional NuGet package needed)

    **ICorrelatedLogger.cs** (OBS-02):
    - Namespace: `DataWarehouse.SDK.Contracts.Observability`
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Structured logging with correlation")]`
    - `interface ICorrelatedLogger` with:
      - `string CorrelationId { get; }` -- current correlation ID (auto-generated if not set)
      - `ICorrelatedLogger WithCorrelationId(string correlationId)` -- creates a scoped logger with specific correlation ID
      - `ICorrelatedLogger WithProperty(string key, object? value)` -- adds a structured property
      - `void LogTrace(string message, params object[] args)`
      - `void LogDebug(string message, params object[] args)`
      - `void LogInformation(string message, params object[] args)`
      - `void LogWarning(string message, params object[] args)`
      - `void LogError(Exception? exception, string message, params object[] args)`
      - `void LogCritical(Exception? exception, string message, params object[] args)`
      - `IDisposable BeginScope(string scopeName)` -- begins a logging scope with correlation ID
    - Do NOT reference Microsoft.Extensions.Logging directly in the interface -- this is a SDK-level abstraction. Implementations will bridge to ILogger.

    **IResourceMeter.cs** (OBS-04):
    - Namespace: `DataWarehouse.SDK.Contracts.Observability`
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Per-plugin resource metering")]`
    - `interface IResourceMeter` with:
      - `string PluginId { get; }` -- the plugin being metered
      - `Task<ResourceSnapshot> GetCurrentUsageAsync(CancellationToken ct = default)` -- current resource usage
      - `Task<IReadOnlyList<ResourceSnapshot>> GetHistoryAsync(TimeSpan window, CancellationToken ct = default)` -- historical usage
      - `void RecordAllocation(ResourceType type, long amount)` -- record a resource allocation
      - `void RecordDeallocation(ResourceType type, long amount)` -- record a resource deallocation
      - `event Action<ResourceAlert>? OnResourceAlert` -- alerts when limits exceeded
    - `record ResourceSnapshot` with init props: `string PluginId`, `long MemoryBytes`, `double CpuPercent`, `long IoReadBytes`, `long IoWriteBytes`, `int ActiveConnections`, `int ActiveThreads`, `DateTimeOffset Timestamp`
    - `enum ResourceType { Memory, Cpu, IoRead, IoWrite, Connections, Threads }`
    - `record ResourceLimits` with init props: `long MaxMemoryBytes`, `double MaxCpuPercent`, `int MaxConnections`, `int MaxThreads`
    - `record ResourceAlert` with init props: `string PluginId`, `ResourceType Type`, `long CurrentValue`, `long LimitValue`, `ResourceAlertSeverity Severity`, `DateTimeOffset Timestamp`
    - `enum ResourceAlertSeverity { Warning, Critical }`

    **IAuditTrail.cs** (OBS-05):
    - Namespace: `DataWarehouse.SDK.Contracts.Observability`
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Immutable audit trail")]`
    - `interface IAuditTrail` with:
      - `Task RecordAsync(AuditEntry entry, CancellationToken ct = default)` -- append an audit entry (immutable, append-only)
      - `Task<IReadOnlyList<AuditEntry>> QueryAsync(AuditQuery query, CancellationToken ct = default)` -- query audit entries
      - `Task<long> GetCountAsync(AuditQuery? query = null, CancellationToken ct = default)` -- count matching entries
      - `event Action<AuditEntry>? OnAuditRecorded` -- event when entry recorded
    - `record AuditEntry` with init props: `string EntryId`, `DateTimeOffset Timestamp`, `string Actor` (user/plugin/system), `string Action`, `string ResourceType`, `string ResourceId`, `AuditOutcome Outcome`, `string? Detail`, `string? CorrelationId`, `IReadOnlyDictionary<string, string>? Metadata`
    - `enum AuditOutcome { Success, Failure, Denied }`
    - `record AuditQuery` with init props: `string? Actor`, `string? Action`, `string? ResourceType`, `string? ResourceId`, `DateTimeOffset? From`, `DateTimeOffset? To`, `int MaxResults` (default 100), `AuditOutcome? Outcome`
    - Factory methods on AuditEntry: `static AuditEntry Create(string actor, string action, string resourceType, string resourceId, AuditOutcome outcome, string? detail = null)` which auto-generates EntryId (Guid) and Timestamp (UtcNow)

    **ALL files:** Full XML documentation, SdkCompatibility attributes, CancellationToken on async methods, init properties on records.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero new errors. Verify ISdkActivitySource uses System.Diagnostics types (not custom types). Verify no duplication of existing IDistributedTracing, IMetricsCollector, or IHealthCheck.
  </verify>
  <done>
    ISdkActivitySource, ICorrelatedLogger, IResourceMeter, IAuditTrail are defined with full XML docs. ISdkActivitySource bridges to System.Diagnostics.ActivitySource. No existing observability contracts are duplicated or modified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add virtual CheckHealthAsync to PluginBase for OBS-03</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
  </files>
  <action>
    Modify `DataWarehouse.SDK/Contracts/PluginBase.cs` to make IHealthCheck available to all plugins.

    **Read the entire PluginBase.cs first.** Also read `DataWarehouse.SDK/Infrastructure/KernelInfrastructure.cs` to find the canonical `HealthCheckResult` record and `HealthStatus` enum that `HealthCheckAggregator` uses.

    **IMPORTANT: IHealthCheck namespace conflict.** IHealthCheck exists in TWO places:
    1. `DataWarehouse.SDK.Contracts.IKernelInfrastructure` (inside `InfrastructurePluginBases`) -- nested interface
    2. `DataWarehouse.SDK.Infrastructure` (in `KernelInfrastructure.cs`) -- standalone interface

    Per the research recommendation, use the `DataWarehouse.SDK.Infrastructure` version (standalone, used by HealthCheckAggregator). However, DO NOT make PluginBase implement that interface directly (it would require implementing Name and Tags properties which conflict with PluginBase's existing Name property).

    Instead, add a **virtual method** to PluginBase that returns a health check result:

    ```csharp
    /// <summary>
    /// Performs a health check for this plugin.
    /// Called by the kernel's HealthCheckAggregator to determine plugin health.
    /// <para>
    /// Default implementation returns <see cref="Infrastructure.HealthStatus.Healthy"/>.
    /// Override in plugins that need to report degraded or unhealthy status
    /// based on internal state (e.g., connection failures, resource exhaustion).
    /// </para>
    /// </summary>
    /// <param name="ct">Cancellation token for the health check operation.</param>
    /// <returns>A <see cref="Infrastructure.HealthCheckResult"/> indicating plugin health.</returns>
    [SdkCompatibility("2.0.0", Notes = "Phase 26: IHealthCheck required by all plugins (OBS-03)")]
    public virtual Task<Infrastructure.HealthCheckResult> CheckHealthAsync(CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();
        return Task.FromResult(new Infrastructure.HealthCheckResult
        {
            Status = Infrastructure.HealthStatus.Healthy,
            Description = $"{Name} is healthy",
            CheckedAt = DateTimeOffset.UtcNow
        });
    }
    ```

    **Add using statement** at top of file: `using DataWarehouse.SDK.Infrastructure;` (if not already present). If this causes ambiguity with existing usings, use fully qualified names (`Infrastructure.HealthCheckResult`, `Infrastructure.HealthStatus`).

    **Placement:** Add in the `#region Explicit Lifecycle Methods (HIER-02)` section, after ActivateAsync (if Plan 26-02 ran) or after ShutdownAsync.

    **CRITICAL rules:**
    - MUST be `virtual` (NOT abstract) -- default returns Healthy
    - Do NOT add PluginBase : IHealthCheck (would conflict with existing Name property)
    - Do NOT change any existing methods
    - Do NOT introduce any type ambiguities -- use fully qualified names where needed
    - Watch for existing `HealthStatus` in `DataWarehouse.SDK.Contracts.Storage.StorageStrategy` -- avoid importing that namespace
    - If `using DataWarehouse.SDK.Infrastructure;` causes CS0104 ambiguity, remove it and use fully qualified `DataWarehouse.SDK.Infrastructure.HealthCheckResult` and `DataWarehouse.SDK.Infrastructure.HealthStatus` inline

    **Test approach:** After modification, build the entire solution to confirm no plugin breaks. Grep for ambiguous reference errors.
  </action>
  <verify>
    1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
    2. `dotnet build DataWarehouse.slnx --no-restore 2>&1 | grep "error CS"` -- confirm no new plugin build breaks (pre-existing errors in UltimateCompression/AedsCore expected)
    3. Grep PluginBase.cs for "CheckHealthAsync" to confirm it exists and is virtual
    4. Grep PluginBase.cs for "abstract" to confirm no new abstract methods
  </verify>
  <done>
    PluginBase has virtual CheckHealthAsync returning Healthy by default. All 60+ plugins build unchanged. Kernel can now call CheckHealthAsync on any plugin to get health status.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
2. Full solution build -- no new plugin breaks
3. 4 new observability contracts in `DataWarehouse.SDK/Contracts/Observability/`
4. ISdkActivitySource references System.Diagnostics.Activity (standard .NET)
5. ICorrelatedLogger has CorrelationId property and scoped logging
6. IResourceMeter has per-plugin metering with ResourceSnapshot
7. IAuditTrail is immutable append-only with query support
8. PluginBase.CheckHealthAsync exists as virtual returning Healthy
9. Existing IDistributedTracing, IObservabilityStrategy, IMetricsCollector UNCHANGED
10. No new type ambiguities (HealthStatus, IHealthCheck)
</verification>

<success_criteria>
- 4 new observability interface files in `DataWarehouse.SDK/Contracts/Observability/`
- ISdkActivitySource bridges to System.Diagnostics.ActivitySource
- ICorrelatedLogger provides mandatory correlation ID logging
- IResourceMeter enables per-plugin metering
- IAuditTrail is immutable and append-only
- PluginBase.CheckHealthAsync is virtual with Healthy default
- No duplication of existing types, no modification of existing contracts
- SDK and all plugins build with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-distributed-contracts-resilience/26-04-SUMMARY.md`
</output>
