---
phase: 26-distributed-contracts-resilience
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/Distributed/IFederatedMessageBus.cs
  - DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs
  - DataWarehouse.SDK/Contracts/PluginBase.cs
autonomous: true

must_haves:
  truths:
    - "IFederatedMessageBus extends IMessageBus with transparent local/remote routing"
    - "FederatedMessageBusBase abstract class provides default local/remote routing logic"
    - "PluginBase has a virtual ActivateAsync method for 3-phase initialization (construction -> initialization -> activation)"
    - "ActivateAsync is backward-compatible -- default is no-op, existing plugins work unchanged"
    - "Existing PluginBase lifecycle (InitializeAsync, ExecuteAsync, ShutdownAsync) is preserved exactly"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Distributed/IFederatedMessageBus.cs"
      provides: "IFederatedMessageBus extending IMessageBus with routing awareness, IConsistentHashRing, MessageRoutingDecision"
      contains: "interface IFederatedMessageBus"
    - path: "DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs"
      provides: "Abstract base class with local/remote routing template pattern"
      contains: "abstract class FederatedMessageBusBase"
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "ActivateAsync virtual method added to existing PluginBase"
      contains: "ActivateAsync"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Distributed/IFederatedMessageBus.cs"
      to: "DataWarehouse.SDK/Contracts/IMessageBus.cs"
      via: "IFederatedMessageBus : IMessageBus"
      pattern: "IFederatedMessageBus.*:.*IMessageBus"
    - from: "DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs"
      to: "DataWarehouse.SDK/Contracts/Distributed/IClusterMembership.cs"
      via: "Uses IClusterMembership for node routing decisions"
      pattern: "IClusterMembership"
    - from: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      to: "Existing lifecycle methods"
      via: "ActivateAsync fits between InitializeAsync and ExecuteAsync"
      pattern: "virtual.*Task.*ActivateAsync"
---

<objective>
Define the FederatedMessageBus architecture (DIST-08) and add multi-phase plugin initialization (DIST-09) to PluginBase.

Purpose: FederatedMessageBus enables transparent local/remote message routing so existing single-node code works unchanged when deployed in a cluster. Multi-phase initialization (construction -> initialization -> activation) prevents circular dependency deadlocks when plugins coordinate across nodes.

Output: IFederatedMessageBus interface, FederatedMessageBusBase abstract class, and ActivateAsync on PluginBase.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-distributed-contracts-resilience/26-RESEARCH.md
@.planning/phases/26-distributed-contracts-resilience/26-01-SUMMARY.md

Key existing files:
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/NullObjects.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IFederatedMessageBus and FederatedMessageBusBase</name>
  <files>
    DataWarehouse.SDK/Contracts/Distributed/IFederatedMessageBus.cs
    DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs
  </files>
  <action>
    Create 2 new files in `DataWarehouse.SDK/Contracts/Distributed/`.

    **IFederatedMessageBus.cs** (DIST-08):
    - Namespace: `DataWarehouse.SDK.Contracts.Distributed`
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Federated message bus")]`
    - `interface IFederatedMessageBus : IMessageBus` with:
      - `IClusterMembership ClusterMembership { get; }` -- access to cluster topology
      - `Task PublishToNodeAsync(string nodeId, string topic, PluginMessage message, CancellationToken ct = default)` -- explicit node targeting
      - `Task PublishToAllNodesAsync(string topic, PluginMessage message, CancellationToken ct = default)` -- broadcast to all cluster nodes
      - `MessageRoutingDecision GetRoutingDecision(string topic, PluginMessage message)` -- inspect routing without sending
      - `bool IsLocalMessage(string topic, PluginMessage message)` -- check if message targets this node
    - `interface IConsistentHashRing` with:
      - `string GetNode(string key)` -- get responsible node for a key
      - `IReadOnlyList<string> GetNodes(string key, int count)` -- get N responsible nodes for replication
      - `void AddNode(string nodeId)` -- add node to hash ring
      - `void RemoveNode(string nodeId)` -- remove node from hash ring
      - `int VirtualNodeCount { get; }` -- number of virtual nodes per physical node
    - `record MessageRoutingDecision` with init props: `MessageRoutingTarget Target`, `string? TargetNodeId`, `IReadOnlyList<string>? BroadcastNodeIds`, `string Reason`
    - `enum MessageRoutingTarget { Local, Remote, Broadcast, ConsistentHash }`

    **FederatedMessageBusBase.cs**:
    - Namespace: `DataWarehouse.SDK.Contracts.Distributed`
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Federated message bus base class")]`
    - `abstract class FederatedMessageBusBase : IFederatedMessageBus` with:
      - Constructor takes `IMessageBus localBus, IClusterMembership clusterMembership`
      - Stores `_localBus` (protected) and `_clusterMembership` (protected)
      - **IMessageBus methods delegate to local bus by default** -- all standard IMessageBus methods (PublishAsync, SendAsync, Subscribe, etc.) call through to `_localBus` so existing code works unchanged
      - `PublishAsync` override: calls `GetRoutingDecision(topic, message)` then either routes locally via `_localBus.PublishAsync` or calls `abstract Task SendToRemoteNodeAsync(string nodeId, string topic, PluginMessage message, CancellationToken ct)`
      - `abstract Task SendToRemoteNodeAsync(...)` -- subclasses implement actual remote transport (gRPC, HTTP, etc.)
      - `virtual MessageRoutingDecision GetRoutingDecision(...)` -- default: always local (single-node safe)
      - `virtual bool IsLocalMessage(...)` -- default: always true (single-node safe)
      - `PublishToNodeAsync` -- if nodeId == self, use local bus; else call SendToRemoteNodeAsync
      - `PublishToAllNodesAsync` -- publish to local + all remote cluster members
      - Properties: `IClusterMembership ClusterMembership` (from constructor), `IMessageBus LocalBus` (protected)

    **CRITICAL backward compatibility:**
    - FederatedMessageBusBase implements IMessageBus so it can be used anywhere IMessageBus is expected
    - All standard IMessageBus methods MUST delegate to _localBus (not throw NotImplementedException)
    - Single-node mode: routing always returns Local, so behavior is identical to a plain IMessageBus
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero new errors. Verify IFederatedMessageBus extends IMessageBus.
  </verify>
  <done>
    IFederatedMessageBus and FederatedMessageBusBase are defined. FederatedMessageBusBase wraps any IMessageBus with transparent local/remote routing. All standard IMessageBus methods delegate to the local bus for backward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ActivateAsync to PluginBase for 3-phase initialization</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
  </files>
  <action>
    Modify `DataWarehouse.SDK/Contracts/PluginBase.cs` to add the third lifecycle phase.

    **Read the entire PluginBase.cs first** to understand the existing lifecycle methods (InitializeAsync, ExecuteAsync, ShutdownAsync).

    **Add ActivateAsync** in the `#region Explicit Lifecycle Methods (HIER-02)` section, between `InitializeAsync` and `ExecuteAsync`:

    ```csharp
    /// <summary>
    /// Activates the plugin for distributed coordination.
    /// Called after all plugins have completed InitializeAsync, when the cluster
    /// membership is resolved and cross-node capabilities are discovered.
    /// <para>
    /// This is Phase 3 of the 3-phase plugin initialization:
    /// <list type="number">
    ///   <item><description>Construction: Zero dependencies (constructor)</description></item>
    ///   <item><description>InitializeAsync: MessageBus available, local setup</description></item>
    ///   <item><description>ActivateAsync: Distributed coordination available, cross-node discovery</description></item>
    /// </list>
    /// </para>
    /// <para>
    /// Default implementation is a no-op. Override in plugins that need cluster-level
    /// coordination (e.g., distributed caching, cross-node replication, federated queries).
    /// Plugins that do not override this method work exactly as before.
    /// </para>
    /// </summary>
    /// <param name="ct">Cancellation token for the activation operation.</param>
    /// <returns>A task representing the activation operation.</returns>
    [SdkCompatibility("2.0.0", Notes = "Phase 26: Multi-phase plugin initialization (DIST-09)")]
    public virtual Task ActivateAsync(CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();
        return Task.CompletedTask;
    }
    ```

    **CRITICAL rules:**
    - ActivateAsync MUST be `virtual` (NOT abstract) -- default is no-op
    - Do NOT change InitializeAsync, ExecuteAsync, or ShutdownAsync in any way
    - Do NOT add any new abstract methods to PluginBase
    - Do NOT change the constructor or any existing properties
    - Place the method in the correct region between InitializeAsync and ExecuteAsync
    - Add `using DataWarehouse.SDK.Contracts` at top if SdkCompatibilityAttribute needs it (check if already imported)
    - Ensure the SdkCompatibility using is present (should be -- it was added in Phase 25a)

    **Verification approach:** After modification, search for all `abstract` members in PluginBase to confirm no new abstract methods were added. Confirm ActivateAsync is virtual with Task.CompletedTask default.
  </action>
  <verify>
    1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
    2. `dotnet build DataWarehouse.sln --no-restore 2>&1 | grep -c "error CS"` -- confirm no plugin build breaks (pre-existing errors in UltimateCompression/AedsCore expected)
    3. Grep PluginBase.cs for "abstract" to confirm no new abstract methods
    4. Grep PluginBase.cs for "ActivateAsync" to confirm it exists and is virtual
  </verify>
  <done>
    PluginBase has virtual ActivateAsync(CancellationToken) with no-op default. All 60+ plugins continue to build unchanged. The 3-phase initialization model (construction, initialization, activation) is established.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
2. Full solution build -- no new plugin breaks (pre-existing UltimateCompression/AedsCore errors expected)
3. IFederatedMessageBus extends IMessageBus (grep confirms inheritance)
4. FederatedMessageBusBase delegates all IMessageBus methods to local bus
5. PluginBase.ActivateAsync exists as virtual with Task.CompletedTask default
6. No new abstract methods on PluginBase
7. Existing InitializeAsync/ExecuteAsync/ShutdownAsync unchanged
</verification>

<success_criteria>
- IFederatedMessageBus interface extends IMessageBus with routing-aware methods
- FederatedMessageBusBase abstract class wraps IMessageBus + IClusterMembership with local/remote routing
- PluginBase.ActivateAsync is virtual with no-op default (backward compatible)
- All 60+ existing plugins compile without changes
- SDK builds with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-distributed-contracts-resilience/26-02-SUMMARY.md`
</output>
