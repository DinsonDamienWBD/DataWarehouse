---
phase: 26-distributed-contracts-resilience
plan: 05
type: execute
wave: 3
depends_on: ["26-01", "26-02", "26-03", "26-04"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryClusterMembership.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryLoadBalancerStrategy.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryP2PNetwork.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoScaler.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryReplicationSync.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoTier.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoGovernance.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryFederatedMessageBus.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryCircuitBreaker.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryBulkheadIsolation.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryDeadLetterQueue.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryResourceMeter.cs
  - DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAuditTrail.cs
autonomous: true

must_haves:
  truths:
    - "In-memory single-node implementations exist for all 7 distributed contracts + FederatedMessageBus"
    - "In-memory implementations exist for ICircuitBreaker, IBulkheadIsolation, IDeadLetterQueue, IResourceMeter, IAuditTrail"
    - "Each in-memory implementation works on a single node with zero configuration"
    - "Each in-memory implementation is simple and production-ready (not stubs -- Rule 13)"
    - "InMemoryFederatedMessageBus delegates all operations to a local IMessageBus"
    - "InMemoryClusterMembership reports self as only member"
    - "SDK builds with zero new errors and all plugins compile"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryClusterMembership.cs"
      provides: "Single-node cluster membership -- always self as only member"
      contains: "class InMemoryClusterMembership"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryLoadBalancerStrategy.cs"
      provides: "Always-self load balancer"
      contains: "class InMemoryLoadBalancerStrategy"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryP2PNetwork.cs"
      provides: "No-op P2P/gossip (no peers in single-node mode)"
      contains: "class InMemoryP2PNetwork"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoScaler.cs"
      provides: "No-op scaling (single node, no scale events)"
      contains: "class InMemoryAutoScaler"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryReplicationSync.cs"
      provides: "Local-only sync (always reports synced, no conflicts)"
      contains: "class InMemoryReplicationSync"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoTier.cs"
      provides: "Single-tier auto-placement (all data stays in default tier)"
      contains: "class InMemoryAutoTier"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoGovernance.cs"
      provides: "No-op governance (all operations allowed)"
      contains: "class InMemoryAutoGovernance"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryFederatedMessageBus.cs"
      provides: "Local-only message bus wrapper with no remote routing"
      contains: "class InMemoryFederatedMessageBus"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryCircuitBreaker.cs"
      provides: "In-memory circuit breaker with state machine"
      contains: "class InMemoryCircuitBreaker"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryBulkheadIsolation.cs"
      provides: "In-memory bulkhead with SemaphoreSlim"
      contains: "class InMemoryBulkheadIsolation"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryDeadLetterQueue.cs"
      provides: "In-memory DLQ with ConcurrentQueue"
      contains: "class InMemoryDeadLetterQueue"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryResourceMeter.cs"
      provides: "In-memory resource meter tracking allocations"
      contains: "class InMemoryResourceMeter"
    - path: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAuditTrail.cs"
      provides: "In-memory append-only audit trail"
      contains: "class InMemoryAuditTrail"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryFederatedMessageBus.cs"
      to: "DataWarehouse.SDK/Contracts/Distributed/FederatedMessageBusBase.cs"
      via: "Extends FederatedMessageBusBase, overrides SendToRemoteNodeAsync as no-op"
      pattern: "FederatedMessageBusBase"
    - from: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryCircuitBreaker.cs"
      to: "DataWarehouse.SDK/Contracts/Resilience/ICircuitBreaker.cs"
      via: "Implements ICircuitBreaker with actual state machine"
      pattern: "ICircuitBreaker"
    - from: "All InMemory implementations"
      to: "Their respective interface contracts"
      via: "Direct interface implementation"
      pattern: "sealed class InMemory.*:"
---

<objective>
Create in-memory single-node implementations for all distributed, resilience, and observability contracts (DIST-10, DIST-11, plus implementations for plans 26-01 through 26-04 contracts).

Purpose: In-memory implementations ensure the SDK works on a single laptop with zero cluster configuration. They are the defaults when no distributed infrastructure is configured. Each is production-ready (not a stub) but trivially simple -- single-node, no threading complexity.

Output: 13 new implementation files in `DataWarehouse.SDK/Infrastructure/InMemory/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-distributed-contracts-resilience/26-RESEARCH.md
@.planning/phases/26-distributed-contracts-resilience/26-01-SUMMARY.md
@.planning/phases/26-distributed-contracts-resilience/26-02-SUMMARY.md
@.planning/phases/26-distributed-contracts-resilience/26-03-SUMMARY.md
@.planning/phases/26-distributed-contracts-resilience/26-04-SUMMARY.md

Key existing files:
@DataWarehouse.SDK/Contracts/NullObjects.cs (NullMessageBus pattern)
@DataWarehouse.SDK/Infrastructure/KernelInfrastructure.cs (existing in-memory patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create in-memory distributed contract implementations (7 files + FederatedMessageBus)</name>
  <files>
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryClusterMembership.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryLoadBalancerStrategy.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryP2PNetwork.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoScaler.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryReplicationSync.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoTier.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAutoGovernance.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryFederatedMessageBus.cs
  </files>
  <action>
    Create the `DataWarehouse.SDK/Infrastructure/InMemory/` directory and 8 files. All use namespace `DataWarehouse.SDK.Infrastructure.InMemory`. All classes are `sealed` with `[SdkCompatibility("2.0.0")]`.

    **Design principle for ALL in-memory implementations:**
    - Single-node only -- no threading, no complex state machines, no simulated failures
    - Return sensible defaults (self as only member, always healthy, always allowed, etc.)
    - Implement ALL interface methods without throwing NotImplementedException
    - Each file should be under 100 lines (per research pitfall guidance)
    - Events declared but never fired in single-node mode (no membership changes, no peer events)
    - Production-ready: these ARE the real implementations for single-node deployments (Rule 13)

    **InMemoryClusterMembership.cs:**
    - Constructor takes `string nodeId, string address = "localhost", int port = 5000`
    - Creates a single `ClusterNode` (self) with Role=Leader, Status=Active
    - `GetMembers()` returns `[self]`
    - `GetLeader()` returns self
    - `GetSelf()` returns self
    - `JoinAsync` -- no-op (already the only member)
    - `LeaveAsync` -- no-op
    - `IsHealthyAsync` -- returns true if nodeId matches self

    **InMemoryLoadBalancerStrategy.cs:**
    - `AlgorithmName` returns "SingleNode"
    - `SelectNode` returns first available node (self)
    - `SelectNodeAsync` wraps SelectNode
    - `ReportNodeHealth` -- stores in dictionary but not used in single-node

    **InMemoryP2PNetwork.cs:**
    - Also implements `IGossipProtocol`
    - `DiscoverPeersAsync` returns empty list (no peers)
    - `SendToPeerAsync` throws InvalidOperationException("No peers available in single-node mode")
    - `BroadcastAsync` -- no-op (no peers)
    - `RequestFromPeerAsync` throws InvalidOperationException("No peers available in single-node mode")
    - `SpreadAsync` -- no-op (no peers to gossip to)
    - `GetPendingAsync` returns empty list

    **InMemoryAutoScaler.cs:**
    - Also implements `IScalingPolicy`
    - `PolicyName` returns "SingleNode"
    - `EvaluateAsync` returns `ScalingDecision` with `NoAction` (single node doesn't scale)
    - `ScaleOutAsync` returns failure result ("Scaling not available in single-node mode")
    - `ScaleInAsync` returns failure result
    - `GetCurrentState()` returns state with 1 node
    - `ShouldScaleAsync` returns NoAction
    - Addresses DIST-11: IAutoScaler.ScaleOutAsync is the contract entry point for scaling prompts. In single-node mode it returns a result indicating single-node mode.

    **InMemoryReplicationSync.cs:**
    - `CurrentMode` returns `SyncMode.Offline` (no replication in single-node)
    - `SyncAsync` returns success with 0 items synced
    - `GetSyncStatusAsync` returns Completed status
    - `ResolveConflictAsync` returns LocalWins (no remote to conflict with)

    **InMemoryAutoTier.cs:**
    - Constructor takes `string defaultTierName = "default"`
    - `EvaluatePlacementAsync` always recommends keeping data in default tier
    - `MigrateAsync` returns success (but it's a no-op -- same tier)
    - `GetTiersAsync` returns single tier info (default, Hot performance class)

    **InMemoryAutoGovernance.cs:**
    - `EvaluateAsync` returns `PolicyEvaluationResult` with `IsAllowed=true`, empty violations (no policies enforced)
    - `GetActivePoliciesAsync` returns empty list
    - `RegisterPolicyAsync` stores policy in `ConcurrentDictionary<string, GovernancePolicy>`
    - `DeregisterPolicyAsync` removes from dictionary
    - When policies are registered, `EvaluateAsync` should actually evaluate them (basic exact-match on OperationType)

    **InMemoryFederatedMessageBus.cs:**
    - Extends `FederatedMessageBusBase` (from Plan 26-02)
    - Constructor takes `IMessageBus localBus, IClusterMembership clusterMembership`
    - `SendToRemoteNodeAsync` -- throws InvalidOperationException("Remote messaging not available in single-node mode") because there are no remote nodes
    - `GetRoutingDecision` -- always returns Local
    - `IsLocalMessage` -- always returns true
    - This ensures all messages go through the local bus unchanged
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero new errors. Verify each file implements its interface (grep for `: I` pattern). Count 8 files in InMemory directory.
  </verify>
  <done>
    All 7 distributed contract in-memory implementations plus InMemoryFederatedMessageBus are created. Each works in single-node mode with zero configuration. InMemoryFederatedMessageBus routes all messages locally.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create in-memory resilience and observability implementations (5 files)</name>
  <files>
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryCircuitBreaker.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryBulkheadIsolation.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryDeadLetterQueue.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryResourceMeter.cs
    DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAuditTrail.cs
  </files>
  <action>
    Create 5 files in `DataWarehouse.SDK/Infrastructure/InMemory/`. All `sealed` with `[SdkCompatibility("2.0.0")]`.

    **InMemoryCircuitBreaker.cs:**
    - Implements `ICircuitBreaker` (from Contracts.Resilience)
    - Constructor takes `string name, CircuitBreakerOptions? options = null`
    - Actual working state machine (this IS production-ready, not a no-op):
      - `_state` field (default Closed), `_failureCount`, `_lastFailureTime`, `_statistics`
      - `ExecuteAsync<T>`: If Open and break duration not elapsed, throw `CircuitBreakerOpenException`. If HalfOpen, allow one attempt. On success, reset to Closed. On failure, increment counter; if threshold exceeded, Trip to Open.
      - `Trip(reason)` sets state to Open, fires OnStateChanged
      - `Reset()` sets state to Closed, resets counters, fires OnStateChanged
      - `GetStatistics()` returns current stats
    - `sealed class CircuitBreakerOpenException : InvalidOperationException` with `string CircuitBreakerName` property
    - Keep under ~80 lines with compact implementation

    **InMemoryBulkheadIsolation.cs:**
    - Implements `IBulkheadIsolation` (from Contracts.Resilience)
    - Constructor takes `string name, BulkheadOptions? options = null`
    - Uses `SemaphoreSlim` for concurrency limiting
    - `AcquireAsync` tries to enter semaphore (with optional queue timeout), returns `IBulkheadLease`
    - Internal `sealed class InMemoryBulkheadLease : IBulkheadLease` -- disposing releases the semaphore slot
    - If semaphore full and no queue space, throw `BulkheadRejectedException`
    - `sealed class BulkheadRejectedException : InvalidOperationException` with `string BulkheadName` property
    - `GetStatistics()` returns current concurrency count, queue length, totals

    **InMemoryDeadLetterQueue.cs:**
    - Implements `IDeadLetterQueue` (from Contracts.Resilience)
    - Uses `ConcurrentDictionary<string, DeadLetterMessage>` for storage (keyed by MessageId)
    - `EnqueueAsync` adds message, fires OnDeadLetterEvent with Enqueued
    - `PeekAsync` returns up to N messages ordered by FailedAt
    - `DequeueAsync` removes and returns oldest message
    - `RetryAsync` -- removes from DLQ, fires RetrySucceeded event, returns true (actual re-publish is caller's responsibility)
    - `DiscardAsync` -- removes from DLQ, fires Discarded event
    - `GetCountAsync` returns count
    - `PurgeAsync` clears all, fires Purged event
    - Bounded: default max 10,000 entries (configurable), oldest evicted when full

    **InMemoryResourceMeter.cs:**
    - Implements `IResourceMeter` (from Contracts.Observability)
    - Constructor takes `string pluginId`
    - Tracks allocations/deallocations in `long` fields per ResourceType using `Interlocked.Add`
    - `GetCurrentUsageAsync` returns snapshot from current tracked values
    - `GetHistoryAsync` returns list with single current snapshot (no history persistence in memory)
    - `RecordAllocation` / `RecordDeallocation` update tracking fields
    - `OnResourceAlert` fires when allocation exceeds configurable limits (optional `ResourceLimits` in constructor)

    **InMemoryAuditTrail.cs:**
    - Implements `IAuditTrail` (from Contracts.Observability)
    - Uses `ConcurrentQueue<AuditEntry>` for immutable append-only storage
    - `RecordAsync` enqueues entry, fires OnAuditRecorded
    - `QueryAsync` filters entries by AuditQuery fields (Actor, Action, ResourceType, ResourceId, From, To, Outcome) and returns up to MaxResults
    - `GetCountAsync` counts matching entries (or total if no query)
    - Bounded: default max 100,000 entries (configurable), oldest dequeued when full
    - Entries are immutable records -- once recorded, never modified

    **ALL implementations:**
    - Full XML documentation on class and public members
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: In-memory implementation")]`
    - Thread-safe using concurrent collections or Interlocked operations
    - No external dependencies (pure .NET BCL)
    - Each file aims for ~60-100 lines (compact but complete)
  </action>
  <verify>
    1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
    2. `dotnet build DataWarehouse.slnx --no-restore 2>&1 | grep "error CS"` -- no new plugin breaks
    3. Count files in InMemory directory -- should be 13 total (8 from Task 1 + 5 from Task 2)
    4. Verify InMemoryCircuitBreaker has actual state machine (grep for CircuitState.Open)
    5. Verify InMemoryBulkheadIsolation uses SemaphoreSlim
    6. Verify InMemoryAuditTrail uses ConcurrentQueue (append-only)
  </verify>
  <done>
    All 13 in-memory implementations exist and compile. InMemoryCircuitBreaker has a real state machine. InMemoryBulkheadIsolation uses SemaphoreSlim. InMemoryAuditTrail is append-only. The SDK runs on a single laptop with zero cluster configuration.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
2. Full solution build -- no new plugin breaks
3. 13 files in `DataWarehouse.SDK/Infrastructure/InMemory/`
4. Each implements its respective interface
5. InMemoryClusterMembership reports self as only member
6. InMemoryFederatedMessageBus routes all messages locally
7. InMemoryCircuitBreaker has working state machine (Open/Closed/HalfOpen)
8. InMemoryBulkheadIsolation limits concurrency with SemaphoreSlim
9. InMemoryDeadLetterQueue stores and retrieves failed messages
10. InMemoryAuditTrail is immutable append-only
11. No implementation throws NotImplementedException
12. No implementation exceeds ~100 lines
</verification>

<success_criteria>
- 13 in-memory implementation files exist in `DataWarehouse.SDK/Infrastructure/InMemory/`
- All 7 distributed contracts have in-memory implementations (DIST-10)
- IAutoScaler in-memory handles DIST-11 (returns single-node-mode result for scale requests)
- FederatedMessageBus, ICircuitBreaker, IBulkheadIsolation, IDeadLetterQueue, IResourceMeter, IAuditTrail all have in-memory implementations
- Each implementation is production-ready for single-node deployment (Rule 13)
- No NotImplementedException anywhere
- SDK and all plugins build with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-distributed-contracts-resilience/26-05-SUMMARY.md`
</output>
