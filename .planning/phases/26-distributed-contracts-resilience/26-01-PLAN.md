---
phase: 26-distributed-contracts-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Distributed/IClusterMembership.cs
  - DataWarehouse.SDK/Contracts/Distributed/ILoadBalancerStrategy.cs
  - DataWarehouse.SDK/Contracts/Distributed/IP2PNetwork.cs
  - DataWarehouse.SDK/Contracts/Distributed/IAutoScaler.cs
  - DataWarehouse.SDK/Contracts/Distributed/IReplicationSync.cs
  - DataWarehouse.SDK/Contracts/Distributed/IAutoTier.cs
  - DataWarehouse.SDK/Contracts/Distributed/IAutoGovernance.cs
autonomous: true

must_haves:
  truths:
    - "All 7 distributed contracts are defined as public interfaces in the SDK with full XML documentation"
    - "Each contract follows established SDK patterns (CancellationToken on async methods, init properties, records for DTOs)"
    - "No duplicate types -- new contracts reference existing SDK types where applicable (VectorClock, LoadBalancingAlgorithm, etc.)"
    - "Build compiles with zero new errors after adding all 7 contracts"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Distributed/IClusterMembership.cs"
      provides: "IClusterMembership interface with node join/leave/discovery, health monitoring, ClusterNode record, ClusterMembershipEvent"
      contains: "interface IClusterMembership"
    - path: "DataWarehouse.SDK/Contracts/Distributed/ILoadBalancerStrategy.cs"
      provides: "ILoadBalancerStrategy interface with pluggable algorithm contract, SelectNode, LoadBalancerContext"
      contains: "interface ILoadBalancerStrategy"
    - path: "DataWarehouse.SDK/Contracts/Distributed/IP2PNetwork.cs"
      provides: "IP2PNetwork and IGossipProtocol interfaces for peer-to-peer data distribution"
      contains: "interface IP2PNetwork"
    - path: "DataWarehouse.SDK/Contracts/Distributed/IAutoScaler.cs"
      provides: "IAutoScaler and IScalingPolicy interfaces for elastic scaling"
      contains: "interface IAutoScaler"
    - path: "DataWarehouse.SDK/Contracts/Distributed/IReplicationSync.cs"
      provides: "IReplicationSync interface supporting online/offline sync with conflict resolution"
      contains: "interface IReplicationSync"
    - path: "DataWarehouse.SDK/Contracts/Distributed/IAutoTier.cs"
      provides: "IAutoTier interface for automatic data placement by access patterns"
      contains: "interface IAutoTier"
    - path: "DataWarehouse.SDK/Contracts/Distributed/IAutoGovernance.cs"
      provides: "IAutoGovernance interface for SDK-level policy enforcement"
      contains: "interface IAutoGovernance"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Distributed/IClusterMembership.cs"
      to: "DataWarehouse.SDK/Contracts/IFederationNode.cs"
      via: "ClusterNode references IFederationNode for node-level RPC"
      pattern: "IFederationNode"
    - from: "DataWarehouse.SDK/Contracts/Distributed/IReplicationSync.cs"
      to: "DataWarehouse.SDK/Replication/IMultiMasterReplication.cs"
      via: "Uses existing VectorClock and ConsistencyLevel types"
      pattern: "VectorClock|ConsistencyLevel"
---

<objective>
Define all 7 distributed infrastructure contracts (DIST-01 through DIST-07) as SDK interfaces in a new `Contracts/Distributed/` directory.

Purpose: These contracts define the pluggable distributed infrastructure that any plugin can use. They are contract-first -- interfaces only, no implementations. Phase 29 provides real distributed implementations; Plan 26-05 provides in-memory single-node implementations.

Output: 7 new interface files in `DataWarehouse.SDK/Contracts/Distributed/` with full XML documentation, supporting records/enums, and events.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-distributed-contracts-resilience/26-RESEARCH.md

Key existing files to reference for patterns and types:
@DataWarehouse.SDK/Contracts/IFederationNode.cs
@DataWarehouse.SDK/Contracts/IKernelInfrastructure.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Replication/IMultiMasterReplication.cs
@DataWarehouse.SDK/Configuration/LoadBalancingConfig.cs
@DataWarehouse.SDK/Contracts/NullObjects.cs
@DataWarehouse.SDK/Contracts/SdkCompatibilityAttribute.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IClusterMembership, ILoadBalancerStrategy, IP2PNetwork, and IAutoScaler contracts</name>
  <files>
    DataWarehouse.SDK/Contracts/Distributed/IClusterMembership.cs
    DataWarehouse.SDK/Contracts/Distributed/ILoadBalancerStrategy.cs
    DataWarehouse.SDK/Contracts/Distributed/IP2PNetwork.cs
    DataWarehouse.SDK/Contracts/Distributed/IAutoScaler.cs
  </files>
  <action>
    Create 4 new interface files in `DataWarehouse.SDK/Contracts/Distributed/`. All files use namespace `DataWarehouse.SDK.Contracts.Distributed`.

    **IClusterMembership.cs** (DIST-01):
    - `[SdkCompatibility("2.0.0")]` on all public types
    - `interface IClusterMembership` with:
      - `event Action<ClusterMembershipEvent>? OnMembershipChanged`
      - `IReadOnlyList<ClusterNode> GetMembers()`
      - `ClusterNode? GetLeader()`
      - `ClusterNode GetSelf()`
      - `Task JoinAsync(ClusterJoinRequest request, CancellationToken ct = default)`
      - `Task LeaveAsync(string reason, CancellationToken ct = default)`
      - `Task<bool> IsHealthyAsync(string nodeId, CancellationToken ct = default)`
    - `record ClusterNode` with init props: `string NodeId`, `string Address`, `int Port`, `ClusterNodeRole Role`, `ClusterNodeStatus Status`, `DateTimeOffset JoinedAt`, `IReadOnlyDictionary<string, string> Metadata`
    - `record ClusterJoinRequest` with init props: `string NodeId`, `string Address`, `int Port`, `ClusterNodeRole RequestedRole`, `IReadOnlyDictionary<string, string> Metadata`
    - `record ClusterMembershipEvent` with init props: `ClusterMembershipEventType EventType`, `ClusterNode Node`, `DateTimeOffset Timestamp`, `string? Reason`
    - `enum ClusterNodeRole { Leader, Follower, Observer, Candidate }`
    - `enum ClusterNodeStatus { Active, Joining, Leaving, Suspected, Dead }`
    - `enum ClusterMembershipEventType { NodeJoined, NodeLeft, NodeSuspected, NodeDead, LeaderChanged }`

    **ILoadBalancerStrategy.cs** (DIST-02):
    - `interface ILoadBalancerStrategy` with:
      - `string AlgorithmName { get; }`
      - `ClusterNode SelectNode(LoadBalancerContext context)`
      - `Task<ClusterNode> SelectNodeAsync(LoadBalancerContext context, CancellationToken ct = default)`
      - `void ReportNodeHealth(string nodeId, NodeHealthReport report)`
    - `record LoadBalancerContext` with init props: `string RequestKey`, `IReadOnlyList<ClusterNode> AvailableNodes`, `IReadOnlyDictionary<string, string> Metadata`
    - `record NodeHealthReport` with init props: `double CpuUsage`, `double MemoryUsage`, `long ActiveConnections`, `TimeSpan AverageLatency`, `DateTimeOffset ReportedAt`
    - Reference but do NOT duplicate existing `LoadBalancingAlgorithm` enum from `SDK/Configuration/LoadBalancingConfig.cs`

    **IP2PNetwork.cs** (DIST-03):
    - `interface IP2PNetwork` with:
      - `event Action<PeerEvent>? OnPeerEvent`
      - `Task<IReadOnlyList<PeerInfo>> DiscoverPeersAsync(CancellationToken ct = default)`
      - `Task SendToPeerAsync(string peerId, byte[] data, CancellationToken ct = default)`
      - `Task BroadcastAsync(byte[] data, CancellationToken ct = default)`
      - `Task<byte[]> RequestFromPeerAsync(string peerId, byte[] request, CancellationToken ct = default)`
    - `interface IGossipProtocol` with:
      - `Task SpreadAsync(GossipMessage message, CancellationToken ct = default)`
      - `Task<IReadOnlyList<GossipMessage>> GetPendingAsync(CancellationToken ct = default)`
      - `event Action<GossipMessage>? OnGossipReceived`
    - `record PeerInfo` with init props: `string PeerId`, `string Address`, `int Port`, `DateTimeOffset LastSeen`, `IReadOnlyDictionary<string, string> Metadata`
    - `record PeerEvent` with init props: `PeerEventType EventType`, `PeerInfo Peer`, `DateTimeOffset Timestamp`
    - `enum PeerEventType { PeerDiscovered, PeerLost, PeerUpdated }`
    - `record GossipMessage` with init props: `string MessageId`, `string OriginNodeId`, `byte[] Payload`, `int Generation`, `DateTimeOffset Timestamp`

    **IAutoScaler.cs** (DIST-04):
    - `interface IAutoScaler` with:
      - `event Action<ScalingEvent>? OnScalingEvent`
      - `Task<ScalingDecision> EvaluateAsync(ScalingContext context, CancellationToken ct = default)`
      - `Task<ScalingResult> ScaleOutAsync(ScaleOutRequest request, CancellationToken ct = default)`
      - `Task<ScalingResult> ScaleInAsync(ScaleInRequest request, CancellationToken ct = default)`
      - `ScalingState GetCurrentState()`
    - `interface IScalingPolicy` with:
      - `string PolicyName { get; }`
      - `Task<ScalingDecision> ShouldScaleAsync(ScalingMetrics metrics, CancellationToken ct = default)`
    - Supporting records: `ScalingDecision` (Action enum: ScaleOut/ScaleIn/NoAction, Reason string, TargetNodeCount int), `ScalingContext`, `ScalingMetrics` (CpuUsage, MemoryUsage, StorageUsage, ActiveConnections, QueueDepth), `ScaleOutRequest`, `ScaleInRequest`, `ScalingResult`, `ScalingEvent`, `ScalingState`
    - `enum ScalingAction { NoAction, ScaleOut, ScaleIn }`

    **Common patterns for ALL files:**
    - Full XML documentation on every public type and member (per BUILD-04)
    - `using System;` `using System.Collections.Generic;` `using System.Threading;` `using System.Threading.Tasks;` as needed
    - `[SdkCompatibility("2.0.0", Notes = "Phase 26: Distributed contracts")]` on each interface
    - All async methods take `CancellationToken ct = default` as last parameter
    - Use `init` properties on all record types
    - Use factory methods (.Ok(), .Error()) on result types where appropriate
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero new errors. Grep for all 4 interface names to confirm they exist in the expected files.
  </verify>
  <done>
    IClusterMembership, ILoadBalancerStrategy, IP2PNetwork/IGossipProtocol, IAutoScaler/IScalingPolicy are defined with full XML docs, proper records/enums, SdkCompatibility attributes, and the SDK compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IReplicationSync, IAutoTier, and IAutoGovernance contracts</name>
  <files>
    DataWarehouse.SDK/Contracts/Distributed/IReplicationSync.cs
    DataWarehouse.SDK/Contracts/Distributed/IAutoTier.cs
    DataWarehouse.SDK/Contracts/Distributed/IAutoGovernance.cs
  </files>
  <action>
    Create 3 new interface files in `DataWarehouse.SDK/Contracts/Distributed/`.

    **IReplicationSync.cs** (DIST-05):
    - `interface IReplicationSync` with:
      - `Task<SyncResult> SyncAsync(SyncRequest request, CancellationToken ct = default)`
      - `Task<SyncStatus> GetSyncStatusAsync(string targetNodeId, CancellationToken ct = default)`
      - `Task<ConflictResolutionResult> ResolveConflictAsync(SyncConflict conflict, CancellationToken ct = default)`
      - `event Action<SyncEvent>? OnSyncEvent`
      - `SyncMode CurrentMode { get; }`
    - `enum SyncMode { Online, Offline, AirGap, Hybrid }`
    - `record SyncRequest` with init props: `string TargetNodeId`, `SyncMode Mode`, `IReadOnlyList<string>? DataSetFilter`, `DateTimeOffset? SinceTimestamp`
    - `record SyncResult` with init props: `bool Success`, `long ItemsSynced`, `long ConflictsDetected`, `TimeSpan Duration`, `string? ErrorMessage` plus factory methods
    - `record SyncStatus` with init props: `string TargetNodeId`, `SyncState State`, `double ProgressPercent`, `DateTimeOffset LastSyncAt`
    - `enum SyncState { Idle, Syncing, Paused, Error, Completed }`
    - `record SyncConflict` with init props: `string Key`, `byte[] LocalValue`, `byte[] RemoteValue`, `DateTimeOffset LocalTimestamp`, `DateTimeOffset RemoteTimestamp`
    - `record ConflictResolutionResult` with init props: `string Key`, `ConflictResolutionStrategy Strategy`, `byte[] ResolvedValue`
    - `enum ConflictResolutionStrategy { LocalWins, RemoteWins, LatestWins, Merge, Custom }`
    - `record SyncEvent` with init props: `SyncEventType EventType`, `string TargetNodeId`, `DateTimeOffset Timestamp`, `string? Detail`
    - `enum SyncEventType { SyncStarted, SyncCompleted, SyncFailed, ConflictDetected, ConflictResolved }`
    - Reference existing `VectorClock` from `DataWarehouse.SDK.Replication` where relevant (add using statement)

    **IAutoTier.cs** (DIST-06):
    - `interface IAutoTier` with:
      - `Task<TierPlacement> EvaluatePlacementAsync(TierEvaluationContext context, CancellationToken ct = default)`
      - `Task<TierMigrationResult> MigrateAsync(TierMigrationRequest request, CancellationToken ct = default)`
      - `Task<IReadOnlyList<TierInfo>> GetTiersAsync(CancellationToken ct = default)`
      - `event Action<TierEvent>? OnTierEvent`
    - `record TierPlacement` with init props: `string DataKey`, `string RecommendedTier`, `string CurrentTier`, `string Reason`, `double ConfidenceScore`
    - `record TierEvaluationContext` with init props: `string DataKey`, `long DataSizeBytes`, `int AccessCount`, `DateTimeOffset LastAccessedAt`, `DateTimeOffset CreatedAt`, `IReadOnlyDictionary<string, string> Metadata`
    - `record TierMigrationRequest` with init props: `string DataKey`, `string SourceTier`, `string TargetTier`, `bool DeleteFromSource`
    - `record TierMigrationResult` with init props: `bool Success`, `string DataKey`, `string SourceTier`, `string TargetTier`, `TimeSpan Duration`, `string? ErrorMessage` plus factory methods
    - `record TierInfo` with init props: `string TierName`, `string Description`, `long CapacityBytes`, `long UsedBytes`, `double CostPerGBMonth`, `TierPerformanceClass PerformanceClass`
    - `enum TierPerformanceClass { Hot, Warm, Cool, Cold, Archive }`
    - `record TierEvent` with init props: `TierEventType EventType`, `string DataKey`, `string? FromTier`, `string? ToTier`, `DateTimeOffset Timestamp`
    - `enum TierEventType { PlacementEvaluated, MigrationStarted, MigrationCompleted, MigrationFailed }`
    - Do NOT duplicate `ITieredStorage` or `ITierManager` -- IAutoTier is an auto-placement decision contract, not a storage contract

    **IAutoGovernance.cs** (DIST-07):
    - `interface IAutoGovernance` with:
      - `Task<PolicyEvaluationResult> EvaluateAsync(GovernanceContext context, CancellationToken ct = default)`
      - `Task<IReadOnlyList<GovernancePolicy>> GetActivePoliciesAsync(CancellationToken ct = default)`
      - `Task RegisterPolicyAsync(GovernancePolicy policy, CancellationToken ct = default)`
      - `Task DeregisterPolicyAsync(string policyId, CancellationToken ct = default)`
      - `event Action<GovernanceEvent>? OnGovernanceEvent`
    - `record GovernancePolicy` with init props: `string PolicyId`, `string Name`, `string Description`, `GovernancePolicyType Type`, `string Expression`, `GovernanceAction Action`, `int Priority`, `bool IsEnabled`
    - `enum GovernancePolicyType { Retention, Classification, Compliance, Access, DataResidency }`
    - `enum GovernanceAction { Allow, Deny, Audit, Quarantine, Encrypt, Notify }`
    - `record GovernanceContext` with init props: `string OperationType`, `string ResourceId`, `string? UserId`, `IReadOnlyDictionary<string, string> Metadata`
    - `record PolicyEvaluationResult` with init props: `bool IsAllowed`, `IReadOnlyList<PolicyViolation> Violations`, `IReadOnlyList<GovernanceAction> RequiredActions`, `string? AuditMessage` plus factory methods
    - `record PolicyViolation` with init props: `string PolicyId`, `string PolicyName`, `string Description`, `GovernanceAction Action`
    - `record GovernanceEvent` with init props: `GovernanceEventType EventType`, `string PolicyId`, `string ResourceId`, `DateTimeOffset Timestamp`, `string? Detail`
    - `enum GovernanceEventType { PolicyEvaluated, PolicyViolated, PolicyRegistered, PolicyDeregistered }`

    **Same patterns as Task 1**: Full XML docs, SdkCompatibility attributes, CancellationToken, init properties, records for DTOs.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero new errors. Grep all 3 interface names to confirm they exist. Count total of 7 interfaces across both tasks.
  </verify>
  <done>
    IReplicationSync, IAutoTier, IAutoGovernance are defined with full XML docs, proper records/enums, and the SDK compiles with all 7 distributed contracts present.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- zero new errors
2. `grep -r "interface IClusterMembership" DataWarehouse.SDK/Contracts/Distributed/` -- confirms DIST-01
3. `grep -r "interface ILoadBalancerStrategy" DataWarehouse.SDK/Contracts/Distributed/` -- confirms DIST-02
4. `grep -r "interface IP2PNetwork" DataWarehouse.SDK/Contracts/Distributed/` -- confirms DIST-03
5. `grep -r "interface IAutoScaler" DataWarehouse.SDK/Contracts/Distributed/` -- confirms DIST-04
6. `grep -r "interface IReplicationSync" DataWarehouse.SDK/Contracts/Distributed/` -- confirms DIST-05
7. `grep -r "interface IAutoTier" DataWarehouse.SDK/Contracts/Distributed/` -- confirms DIST-06
8. `grep -r "interface IAutoGovernance" DataWarehouse.SDK/Contracts/Distributed/` -- confirms DIST-07
9. All files have `[SdkCompatibility("2.0.0")]` attributes
10. No duplicate types introduced (no new HealthStatus, VectorClock, LoadBalancingAlgorithm, etc.)
</verification>

<success_criteria>
- 7 new interface files exist in `DataWarehouse.SDK/Contracts/Distributed/`
- Each interface has full XML documentation on every public member
- All supporting records use `init` properties
- All async methods accept `CancellationToken ct = default`
- No existing types duplicated -- existing SDK types referenced where applicable
- SDK builds with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-distributed-contracts-resilience/26-01-SUMMARY.md`
</output>
