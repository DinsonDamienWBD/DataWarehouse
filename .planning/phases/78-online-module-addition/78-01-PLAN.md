---
phase: 78-online-module-addition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FreeSpaceScanner.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/OnlineRegionAddition.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/WalJournaledRegionWriter.cs
autonomous: true

must_haves:
  truths:
    - "A new region can be allocated from VDE free space without dismounting the VDE"
    - "Region addition is WAL-journaled so crash during addition leaves VDE in prior valid state"
    - "Both RegionDirectory and RegionPointerTable are updated atomically within a single WAL transaction"
    - "Free space detection correctly scans allocation bitmap for contiguous free block runs"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FreeSpaceScanner.cs"
      provides: "Contiguous free block detection from allocation bitmap"
      exports: ["FreeSpaceScanner"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/OnlineRegionAddition.cs"
      provides: "End-to-end online region addition orchestrator"
      exports: ["OnlineRegionAddition", "RegionAdditionResult"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/WalJournaledRegionWriter.cs"
      provides: "WAL-journaled atomic region write operations"
      exports: ["WalJournaledRegionWriter"]
  key_links:
    - from: "OnlineRegionAddition"
      to: "FreeSpaceScanner"
      via: "FindContiguousFreeBlocks call"
      pattern: "FreeSpaceScanner\\.FindContiguous"
    - from: "OnlineRegionAddition"
      to: "WalJournaledRegionWriter"
      via: "Atomic commit of region + directory updates"
      pattern: "WalJournaledRegionWriter\\.Commit"
    - from: "WalJournaledRegionWriter"
      to: "RegionDirectory"
      via: "Adds region slot within WAL transaction"
      pattern: "RegionDirectory\\.AddRegion"
---

<objective>
Implement online region addition (Option 1) for adding a new VDE module's dedicated region(s) to a running VDE without dismounting. The operation detects free space in the allocation bitmap, allocates contiguous blocks for the new region, and commits the region directory + region pointer table update within a single WAL transaction so that a crash at any point leaves the VDE in its prior valid state.

Purpose: This is the primary zero-downtime path for adding a module that requires a dedicated region (e.g., adding the Tags module which needs a TagIndexRegion). Most module additions will use this option when sufficient contiguous free space exists.

Output: Three production-ready classes in a new `ModuleManagement/` directory under VirtualDiskEngine.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionDirectory.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionPointerTable.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/DualWalHeader.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockGroup.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Free space scanner and WAL-journaled region writer</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FreeSpaceScanner.cs
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/WalJournaledRegionWriter.cs
  </files>
  <action>
Create directory `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/`.

**FreeSpaceScanner.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:
- `[SdkCompatibility("6.0.0")]` sealed class `FreeSpaceScanner`
- Constructor takes `Stream vdeStream`, `int blockSize`, `long bitmapStartBlock`, `long bitmapBlockCount`
- Method `FindContiguousFreeBlocks(long requiredBlocks)` returns `FreeBlockRange?` (nullable struct with `StartBlock`, `BlockCount`)
  - Reads allocation bitmap blocks from the stream
  - Each bit represents one block (bit=0 means free, bit=1 means allocated)
  - Scans for first contiguous run of `requiredBlocks` free bits
  - Returns null if no sufficient contiguous run found
- Method `FindAllFreeRanges(long minimumBlocks = 1)` returns `IReadOnlyList<FreeBlockRange>` for diagnostic use
- Method `GetTotalFreeBlocks()` returns `long` count of all free blocks
- `FreeBlockRange` readonly record struct: `long StartBlock`, `long BlockCount`
- All reads use `ArrayPool<byte>.Shared` for buffer management
- Thread-safe: uses no shared mutable state (reads stream with explicit position)

**WalJournaledRegionWriter.cs** -- same namespace:
- `[SdkCompatibility("6.0.0")]` sealed class `WalJournaledRegionWriter`
- Constructor takes `Stream vdeStream`, `int blockSize`, `long metadataWalStartBlock`, `long metadataWalBlockCount`
- Inner record `WalTransaction` with list of `WalEntry` (each entry: `long targetBlock`, `byte[] originalData`, `byte[] newData`)
- Method `BeginTransaction()` returns `WalTransaction`
- Method `AddRegionDirectoryUpdate(WalTransaction txn, RegionDirectory directory)` -- serializes new directory state, captures old state as undo record
- Method `AddRegionPointerTableUpdate(WalTransaction txn, RegionPointerTable table)` -- same pattern for RPT
- Method `AddSuperblockUpdate(WalTransaction txn, SuperblockV2 superblock, int blockSize)` -- captures superblock changes
- Method `AddBitmapUpdate(WalTransaction txn, long bitmapBlock, byte[] oldBits, byte[] newBits)` -- tracks bitmap changes
- Method `async Task CommitAsync(WalTransaction txn, CancellationToken ct)`:
  1. Write WAL entries (redo records) to metadata WAL region sequentially
  2. Write WAL commit marker
  3. Apply all newData writes to their target blocks
  4. Write WAL completion marker
  5. If crash between steps 2-4, recovery replays redo records
- Method `async Task RollbackAsync(WalTransaction txn, CancellationToken ct)` -- writes undo records if needed
- WAL entry format: `[TargetBlock:8][DataLength:4][Data:N]` with XxHash64 checksum per entry
- Increment `WalHeader.SequenceEnd` and `TotalEntries` on commit
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. Both classes exist in the ModuleManagement directory with all specified public methods.
  </verify>
  <done>
FreeSpaceScanner can scan an allocation bitmap stream and find contiguous free block ranges. WalJournaledRegionWriter can create WAL transactions with redo/undo records and commit atomically.
  </done>
</task>

<task type="auto">
  <name>Task 2: Online region addition orchestrator</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/OnlineRegionAddition.cs
  </files>
  <action>
**OnlineRegionAddition.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:
- `[SdkCompatibility("6.0.0")]` sealed class `OnlineRegionAddition`
- `RegionAdditionResult` readonly record struct: `bool Success`, `string? ErrorMessage`, `int RegionSlotIndex`, `long StartBlock`, `long BlockCount`
- Constructor takes `Stream vdeStream`, `int blockSize`
- Main method `async Task<RegionAdditionResult> AddModuleRegionsAsync(ModuleId module, CancellationToken ct)`:
  1. Read current superblock from blocks 0-3 (via SuperblockGroup.Deserialize pattern) to get current manifest, block counts, region info
  2. Validate module is not already active in manifest (`ModuleManifestField.IsModuleActive`)
  3. Look up module's required regions via `ModuleRegistry.GetModule(module).RegionNames`
  4. For each required region:
     a. Determine required block count (use sensible defaults: min 64 blocks for small regions, 256 for large)
     b. Locate allocation bitmap region in the RegionPointerTable (tag BMAP)
     c. Use `FreeSpaceScanner` to find contiguous free blocks
     d. If insufficient free space, return failure result with descriptive error
  5. Begin WAL transaction via `WalJournaledRegionWriter.BeginTransaction()`
  6. For each region to add:
     a. Mark blocks as allocated in the bitmap (flip bits 0->1)
     b. Add `WalJournaledRegionWriter.AddBitmapUpdate()`
     c. Add region to `RegionDirectory` and `RegionPointerTable`
     d. Add `AddRegionDirectoryUpdate()` and `AddRegionPointerTableUpdate()`
  7. Update superblock: set module bit in ModuleManifest, update FreeBlocks count, increment CheckpointSequence, update ModifiedTimestampUtc
  8. Update InodeSize in superblock if module has inode fields (recalculate via `InodeSizeCalculator.Calculate`)
  9. Add `AddSuperblockUpdate()` to transaction
  10. Commit transaction (`CommitAsync`)
  11. Return success result with slot index and block range

- Private helper `int CalculateRegionBlocks(VdeModule module, long totalBlocks)`:
  - Small regions (< 3 region names): max(64, totalBlocks / 1024)
  - Large regions (Streaming, etc.): max(256, totalBlocks / 256)
  - Capped at totalBlocks / 16 (never use more than 6.25% of VDE per region)

- Method `async Task<bool> CanAddModuleAsync(ModuleId module, CancellationToken ct)` -- pre-flight check: reads superblock, verifies module not active, checks free space sufficiency without actually writing

- All block reads/writes go through the `Stream` parameter using `stream.Seek()` + `ReadAsync`/`WriteAsync` with `ArrayPool<byte>.Shared` buffers

- Use `BlockTypeTags` to resolve region type tags from region names (follow pattern in VdeCreator.ResolveBlockTypeTag)
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. `OnlineRegionAddition` class has `AddModuleRegionsAsync` and `CanAddModuleAsync` public methods. The class references `FreeSpaceScanner` and `WalJournaledRegionWriter` from Task 1.
  </verify>
  <done>
Online region addition can add a module's regions to a running VDE from free space. The entire operation is WAL-journaled: crash at any point leaves the VDE in its previous valid state. Both RegionDirectory and RegionPointerTable are updated within the same WAL transaction.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- All three files exist in `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/`
- `OnlineRegionAddition.AddModuleRegionsAsync` orchestrates: free space scan -> WAL begin -> bitmap update -> region directory update -> RPT update -> superblock update -> WAL commit
- No mocks, stubs, or placeholder implementations (Rule 13)
- All classes have `[SdkCompatibility("6.0.0")]` attribute
</verification>

<success_criteria>
1. FreeSpaceScanner reads allocation bitmap and finds contiguous free block runs
2. WalJournaledRegionWriter creates atomic WAL transactions with redo/undo records
3. OnlineRegionAddition orchestrates end-to-end region addition without VDE dismount
4. All metadata updates (RegionDirectory, RPT, Superblock, Bitmap) happen within single WAL transaction
5. Build succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/78-online-module-addition/78-01-SUMMARY.md`
</output>
