---
phase: 78-online-module-addition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/InodePaddingClaim.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/PaddingInventory.cs
autonomous: true

must_haves:
  truths:
    - "A module's inode fields can be claimed from existing padding bytes without rebuilding the inode table"
    - "Padding inventory accurately reports available padding and which modules can fit"
    - "Lazy initialization means inode fields are zero-filled on claim and populated on first access"
    - "InodeLayoutDescriptor is updated to include the new module field entry after padding claim"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/PaddingInventory.cs"
      provides: "Padding analysis for inode module field addition feasibility"
      exports: ["PaddingInventory", "PaddingAnalysis"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/InodePaddingClaim.cs"
      provides: "Claims padding bytes for new module inode fields with lazy init"
      exports: ["InodePaddingClaim", "PaddingClaimResult"]
  key_links:
    - from: "InodePaddingClaim"
      to: "InodeSizeCalculator"
      via: "CanAddModuleWithoutMigration check"
      pattern: "InodeSizeCalculator\\.CanAddModuleWithoutMigration"
    - from: "InodePaddingClaim"
      to: "InodeLayoutDescriptor"
      via: "Adds new ModuleFieldEntry to descriptor"
      pattern: "ModuleFieldEntry.*FlagActive"
    - from: "PaddingInventory"
      to: "ModuleRegistry"
      via: "Looks up InodeFieldBytes for candidate modules"
      pattern: "ModuleRegistry\\.GetModule"
---

<objective>
Implement inode padding claim (Option 2) for adding a module's inode fields by claiming reserved padding bytes at the end of each inode. When the existing inode size has sufficient padding (due to 64-byte alignment), a new module's fields can be carved out of that padding without any inode table migration. Fields are lazily initialized (zero-filled) and populated on first access.

Purpose: This is the fastest, lowest-risk option when available. Many module additions fit within existing padding -- e.g., adding RAID (4 bytes) or Compression (4 bytes) to a VDE with 28 bytes of padding. No inode table rebuild, no data movement, no downtime.

Output: Two classes: PaddingInventory for analysis, InodePaddingClaim for execution.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeLayoutDescriptor.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeSizeCalculator.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleManifest.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleConfig.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Padding inventory and analysis</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/PaddingInventory.cs
  </files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/PaddingInventory.cs` -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:

**PaddingAnalysis** readonly record struct:
- `int CurrentInodeSize` -- current inode size from superblock
- `int CurrentPaddingBytes` -- current padding bytes at end of inode
- `int CurrentModuleFieldBytes` -- total module field bytes in use
- `IReadOnlyList<ModuleId> ActiveModules` -- currently active modules
- `IReadOnlyList<ModuleFitResult> FitResults` -- which inactive modules can fit in padding

**ModuleFitResult** readonly record struct:
- `ModuleId Module` -- the candidate module
- `int RequiredBytes` -- bytes this module needs
- `bool FitsInPadding` -- true if RequiredBytes <= available padding
- `int RemainingPaddingAfter` -- padding left if this module were added (may be negative if doesn't fit)

**PaddingInventory** sealed class with `[SdkCompatibility("6.0.0")]`:
- Constructor takes `uint moduleManifest` (current manifest from superblock)
- Method `PaddingAnalysis Analyze()`:
  1. Use `InodeSizeCalculator.Calculate(moduleManifest)` to get current layout
  2. For each ModuleId not in the current manifest (bit not set):
     a. Get `ModuleRegistry.GetModule(id).InodeFieldBytes`
     b. If InodeFieldBytes == 0, skip (module has no inode fields)
     c. Check `InodeSizeCalculator.CanAddModuleWithoutMigration(currentPadding, id)`
     d. Calculate remaining padding: currentPadding - InodeFieldBytes
     e. Create `ModuleFitResult`
  3. Return complete `PaddingAnalysis`

- Method `bool CanFitModule(ModuleId module)` -- shortcut: returns true if module fits in current padding
- Method `IReadOnlyList<ModuleId> GetAllFittingModules()` -- returns all modules that fit
- Method `PaddingAnalysis AnalyzeAfterAdding(ModuleId module)` -- simulates what padding looks like AFTER adding a module (for chained additions)
  - Creates new manifest with module bit set, calls Analyze on that new manifest

All calculations are pure (no I/O), operating on the manifest value and ModuleRegistry lookups.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. PaddingInventory class exists with Analyze, CanFitModule, GetAllFittingModules, AnalyzeAfterAdding methods.
  </verify>
  <done>
PaddingInventory can analyze a VDE's current inode padding and report which modules can fit without inode table migration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Inode padding claim with lazy initialization</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/InodePaddingClaim.cs
  </files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/InodePaddingClaim.cs` -- same namespace:

**PaddingClaimResult** readonly record struct:
- `bool Success`
- `string? ErrorMessage`
- `InodeLayoutDescriptor NewLayout` -- updated layout with new module field
- `int BytesClaimed` -- number of padding bytes claimed
- `int RemainingPadding` -- padding bytes remaining after claim

**InodePaddingClaim** sealed class with `[SdkCompatibility("6.0.0")]`:
- Constructor takes `Stream vdeStream`, `int blockSize`

- Main method `async Task<PaddingClaimResult> ClaimPaddingForModuleAsync(ModuleId module, CancellationToken ct)`:
  1. Read superblock to get current moduleManifest and InodeLayoutDescriptor
  2. Validate module not already active
  3. Get module's InodeFieldBytes from ModuleRegistry
  4. If InodeFieldBytes == 0, succeed immediately (module has no inode fields, only needs manifest update)
  5. Use `InodeSizeCalculator.CanAddModuleWithoutMigration(currentPadding, module)` to verify fit
  6. If doesn't fit, return failure with descriptive error
  7. Build new InodeLayoutDescriptor:
     a. Copy all existing ModuleFieldEntry items
     b. Add new ModuleFieldEntry for the module:
        - moduleId: (byte)module
        - fieldOffset: currentCoreFieldsEnd + currentModuleFieldBytes (right after existing module fields)
        - fieldSize: module's InodeFieldBytes
        - fieldVersion: 1
        - flags: FlagActive
     c. Reduce PaddingBytes by the module's InodeFieldBytes
     d. InodeSize stays the same (we're using padding, not growing)
     e. Increment ModuleFieldCount
  8. NOTE: Do NOT rewrite every inode. The inode field data bytes that were previously padding (zeroed) are now "claimed" by the new module. Zero is a valid initial state for all module fields (lazy initialization).
  9. Update the superblock's InodeLayoutDescriptor in Superblock Block 2 (ExtendedMetadata) -- serialize the new descriptor
  10. Update ModuleManifest bit in superblock Block 0
  11. Both updates should use WalJournaledRegionWriter if available, or direct write with fsync if Plan 01 hasn't executed yet. To keep this plan independent, implement a minimal `WriteWithFsync` helper that:
      a. Writes the old block data as a backup to a temporary location in the metadata WAL region
      b. Writes the new block data
      c. Calls `stream.Flush()`
      d. Writes a completion marker
  12. Return PaddingClaimResult with new layout

- Method `bool CanClaimPadding(uint moduleManifest, ModuleId module)` -- pure pre-flight check, no I/O
  - Delegates to `InodeSizeCalculator.CanAddModuleWithoutMigration`

- Private method `InodeLayoutDescriptor BuildUpdatedLayout(InodeLayoutDescriptor current, ModuleId module)`:
  - Implements step 7 above
  - Validates that new field doesn't overlap existing fields
  - Returns the new descriptor

Key design: Inode data on disk does NOT change. The bytes that were padding (zeros) are now interpreted as the new module's fields. Since all module field initial values are zero (encryption key slot 0 = none, replication generation 0 = initial, RAID shard 0 = unassigned, etc.), this is correct by design. The InodeLayoutDescriptor change in the superblock is sufficient.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. InodePaddingClaim class exists with ClaimPaddingForModuleAsync and CanClaimPadding methods.
  </verify>
  <done>
Inode padding claim can repurpose existing inode padding bytes for a new module's fields. No inode table rebuild needed. The InodeLayoutDescriptor is updated in the superblock to reflect the new field mapping. Lazy initialization means zero-filled fields are valid initial state.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- Both files exist in `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/`
- PaddingInventory.Analyze() correctly calculates which modules fit in current padding
- InodePaddingClaim updates InodeLayoutDescriptor without touching inode data on disk
- No mocks, stubs, or placeholder implementations (Rule 13)
- All classes have `[SdkCompatibility("6.0.0")]` attribute
</verification>

<success_criteria>
1. PaddingInventory reports accurate padding analysis for any module manifest
2. InodePaddingClaim carves module fields from existing padding without inode table rebuild
3. InodeLayoutDescriptor is correctly updated with new ModuleFieldEntry
4. Zero-filled padding bytes are valid initial state for all module fields (lazy init)
5. Build succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/78-online-module-addition/78-02-SUMMARY.md`
</output>
