---
phase: 78-online-module-addition
plan: 03
type: execute
wave: 2
depends_on: ["78-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/BackgroundInodeMigration.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/MigrationCheckpoint.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ExtentAwareVdeCopy.cs
autonomous: true

must_haves:
  truths:
    - "Background inode migration can resize all inodes to accommodate a new module without VDE downtime"
    - "Migration is crash-safe with progress checkpoints so it can resume after failure"
    - "Extent-aware VDE copy transfers data faster than naive file copy by skipping sparse/unallocated regions"
    - "Migration progress is tracked per-inode so partial completion is valid"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/BackgroundInodeMigration.cs"
      provides: "Crash-safe background inode table migration engine"
      exports: ["BackgroundInodeMigration", "MigrationResult", "MigrationProgress"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/MigrationCheckpoint.cs"
      provides: "Progress checkpoint persistence for crash recovery"
      exports: ["MigrationCheckpoint", "CheckpointData"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ExtentAwareVdeCopy.cs"
      provides: "Extent-aware bulk VDE copy for Option 4"
      exports: ["ExtentAwareVdeCopy", "CopyResult", "CopyProgress"]
  key_links:
    - from: "BackgroundInodeMigration"
      to: "MigrationCheckpoint"
      via: "Persists progress every N inodes"
      pattern: "MigrationCheckpoint\\.Save"
    - from: "BackgroundInodeMigration"
      to: "WalJournaledRegionWriter"
      via: "WAL-journaled inode table region swap"
      pattern: "WalJournaledRegionWriter\\.CommitAsync"
    - from: "ExtentAwareVdeCopy"
      to: "FreeSpaceScanner"
      via: "Reads source allocation bitmap to skip unallocated blocks"
      pattern: "FreeSpaceScanner\\."
---

<objective>
Implement background inode migration (Option 3) for when padding bytes are insufficient, and extent-aware VDE copy (Option 4) for creating a new VDE with the desired module configuration and bulk-migrating data. Both options are crash-safe with progress checkpointing.

Purpose: Option 3 handles the case where a module's inode fields exceed available padding (e.g., adding Tags module with 136 bytes when only 16 bytes of padding exist). Option 4 is the fallback when the VDE's block layout makes in-place migration impractical. Both ensure no data loss on crash.

Output: Three production-ready classes for migration and copy operations.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/78-online-module-addition/78-01-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeLayoutDescriptor.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeSizeCalculator.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/VdeCreator.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/WalJournaledRegionWriter.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FreeSpaceScanner.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Crash-safe background inode migration with progress checkpoints</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/BackgroundInodeMigration.cs
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/MigrationCheckpoint.cs
  </files>
  <action>
**MigrationCheckpoint.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:

`CheckpointData` readonly record struct:
- `Guid MigrationId` -- unique ID for this migration operation
- `ModuleId TargetModule` -- module being added
- `uint OriginalManifest` -- manifest before migration (for rollback)
- `uint TargetManifest` -- manifest after migration
- `long TotalInodes` -- total inodes to migrate
- `long MigratedInodes` -- inodes successfully migrated so far
- `long NewInodeTableStartBlock` -- where the new inode table region starts
- `long NewInodeTableBlockCount` -- size of new inode table region
- `long OldInodeTableStartBlock` -- original inode table location (for rollback)
- `long OldInodeTableBlockCount` -- original inode table size
- `DateTimeOffset StartedUtc` -- when migration began
- `DateTimeOffset LastCheckpointUtc` -- when last checkpoint was saved
- `MigrationPhase Phase` -- enum: `Allocating`, `CopyingInodes`, `SwappingRegions`, `Complete`, `RollingBack`

`MigrationPhase` enum with values above.

`[SdkCompatibility("6.0.0")]` sealed class `MigrationCheckpoint`:
- Constructor takes `Stream vdeStream`, `int blockSize`, `long checkpointBlock` (a reserved block for checkpoint data)
- Method `async Task SaveAsync(CheckpointData data, CancellationToken ct)`:
  - Serialize CheckpointData to a block-sized buffer using BinaryPrimitives
  - Write XxHash64 checksum at end of data (before block trailer)
  - Write to checkpoint block with `UniversalBlockTrailer` (tag: custom MCHK)
  - Flush stream
- Method `async Task<CheckpointData?> LoadAsync(CancellationToken ct)`:
  - Read checkpoint block
  - Verify trailer and checksum
  - If valid, deserialize and return CheckpointData
  - If invalid/empty, return null (no pending migration)
- Method `async Task ClearAsync(CancellationToken ct)` -- zero out checkpoint block

**BackgroundInodeMigration.cs** -- same namespace:

`MigrationProgress` readonly record struct:
- `long TotalInodes`, `long MigratedInodes`, `double PercentComplete`, `MigrationPhase Phase`

`MigrationResult` readonly record struct:
- `bool Success`, `string? ErrorMessage`, `long InodesMigrated`, `TimeSpan Duration`, `InodeLayoutDescriptor NewLayout`

`[SdkCompatibility("6.0.0")]` sealed class `BackgroundInodeMigration`:
- Constructor takes `Stream vdeStream`, `int blockSize`
- Event `Action<MigrationProgress>? OnProgress` -- progress callback
- Property `int CheckpointIntervalInodes { get; set; } = 1000` -- save checkpoint every N inodes

- Main method `async Task<MigrationResult> MigrateAsync(ModuleId module, CancellationToken ct)`:
  1. Read superblock to get current manifest, inode table region, inode layout
  2. Calculate new inode size with the module added: `InodeSizeCalculator.Calculate(newManifest)`
  3. Check for existing checkpoint (resume support):
     a. Load checkpoint via `MigrationCheckpoint.LoadAsync()`
     b. If checkpoint exists with same MigrationId pattern (same module + manifest), resume from `MigratedInodes`
     c. If checkpoint exists for different migration, return error (cannot run concurrent migrations)
  4. Phase: Allocating
     a. Calculate blocks needed for new inode table: `existingInodeCount * newInodeSize / blockSize`
     b. Use `FreeSpaceScanner` to find contiguous free blocks for new inode table
     c. If insufficient space, return failure
     d. Mark blocks as allocated in bitmap (via WalJournaledRegionWriter)
     e. Save checkpoint with Phase=Allocating
  5. Phase: CopyingInodes
     a. For each inode in the old table (read sequentially):
        - Deserialize with old InodeLayoutDescriptor
        - Create new byte[] of new inode size
        - Copy core fields (304 bytes)
        - Copy existing module field data
        - New module's field area is zero-filled (lazy init)
        - Serialize with new InodeLayoutDescriptor to new inode table location
        - Every `CheckpointIntervalInodes`, save checkpoint and report progress
     b. All reads/writes use `ArrayPool<byte>.Shared`
  6. Phase: SwappingRegions
     a. Begin WAL transaction
     b. Update RegionDirectory: change INOD region pointer to new location
     c. Update RegionPointerTable: same
     d. Update Superblock: new manifest, new InodeSize, new FreeBlocks, increment CheckpointSequence
     e. Commit WAL transaction
     f. Save checkpoint with Phase=SwappingRegions
  7. Phase: Complete
     a. Old inode table blocks can be marked as free (deferred -- just leave allocated for safety)
     b. Clear checkpoint
     c. Return success result

- Method `async Task<MigrationResult> ResumeAsync(CancellationToken ct)`:
  - Load checkpoint, validate, resume from recorded phase/inode position
  - Same logic as MigrateAsync but skips already-completed work

- Method `async Task RollbackAsync(CancellationToken ct)`:
  - If checkpoint exists and Phase < SwappingRegions:
    - Free the new inode table blocks in bitmap
    - Clear checkpoint
  - If Phase == SwappingRegions (mid-swap):
    - Restore old region pointers from checkpoint's OldInodeTable fields
    - Clear checkpoint
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. BackgroundInodeMigration has MigrateAsync, ResumeAsync, RollbackAsync. MigrationCheckpoint has SaveAsync, LoadAsync, ClearAsync.
  </verify>
  <done>
Background inode migration can resize inodes crash-safely. Progress checkpoints persist every N inodes so migration resumes after crash. Old and new inode tables coexist during migration. Region swap is atomic via WAL transaction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extent-aware VDE copy (Option 4)</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ExtentAwareVdeCopy.cs
  </files>
  <action>
**ExtentAwareVdeCopy.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:

`CopyProgress` readonly record struct:
- `long TotalBlocks`, `long CopiedBlocks`, `long SkippedBlocks`, `double PercentComplete`, `long BytesPerSecond`

`CopyResult` readonly record struct:
- `bool Success`, `string? ErrorMessage`, `string DestinationPath`, `long BlocksCopied`, `long BlocksSkipped`, `TimeSpan Duration`, `double SpeedupOverNaive` -- ratio of blocks skipped to total

`[SdkCompatibility("6.0.0")]` sealed class `ExtentAwareVdeCopy`:
- Constructor takes `Stream sourceStream`, `int blockSize`
- Event `Action<CopyProgress>? OnProgress`
- Property `int MaxIopsPerSecond { get; set; } = 0` -- 0 = unlimited, positive = throttle

- Main method `async Task<CopyResult> CopyToNewVdeAsync(string destinationPath, ModuleId moduleToAdd, CancellationToken ct)`:
  1. Read source superblock to get current manifest, total blocks, region layout
  2. Create new manifest with moduleToAdd bit set
  3. Create new VDE at destinationPath using `VdeCreator.CreateVdeAsync()` with new manifest
     - Pass all current settings (block size, volume label, etc.) plus new module
     - This creates proper metadata with the new module's regions pre-allocated
  4. Open destination stream
  5. Read source allocation bitmap to identify allocated blocks
  6. For each allocated block range (using FreeSpaceScanner.FindAllFreeRanges inverted -- find allocated ranges):
     a. Skip metadata blocks that were recreated by VdeCreator (superblocks, region directory, bitmap, inode table, WAL headers)
     b. Copy data blocks from source to equivalent position in destination
     c. Use large buffer (64KB or 16 blocks) for sequential I/O efficiency
     d. Track progress and report via OnProgress
     e. If MaxIopsPerSecond > 0, apply throttling via `Task.Delay`
  7. Migrate inodes from source to destination:
     a. Read each inode from source with old InodeLayoutDescriptor
     b. Write to destination with new InodeLayoutDescriptor (adding zero-filled module fields)
     c. Extent references (block numbers) remain valid because data blocks are at same positions
  8. Update destination superblock: copy over source's CheckpointSequence + 1, timestamps, etc.
  9. Return CopyResult with statistics

- Method `async Task<long> EstimateCopyBlocksAsync(CancellationToken ct)`:
  - Reads bitmap, counts allocated blocks, returns count (for progress estimation)

- Private helper for IOPS throttling:
  ```csharp
  private async Task ThrottleIfNeeded(Stopwatch sw, long opsCompleted, CancellationToken ct)
  {
      if (MaxIopsPerSecond <= 0) return;
      double targetElapsedMs = (double)opsCompleted / MaxIopsPerSecond * 1000;
      double actualElapsedMs = sw.Elapsed.TotalMilliseconds;
      if (actualElapsedMs < targetElapsedMs)
          await Task.Delay(TimeSpan.FromMilliseconds(targetElapsedMs - actualElapsedMs), ct);
  }
  ```

Key optimization: Only copy allocated blocks. A 1TB VDE with 10GB of actual data copies ~10GB, not 1TB. The speedup ratio in the result quantifies this: `SpeedupOverNaive = totalBlocks / blocksCopied`.

Use `ArrayPool<byte>.Shared` for all buffers. Dispose properly.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. ExtentAwareVdeCopy class exists with CopyToNewVdeAsync and EstimateCopyBlocksAsync methods.
  </verify>
  <done>
Extent-aware VDE copy creates a new VDE with the desired module configuration and copies only allocated blocks from the source. This is faster than naive file copy proportional to VDE utilization. IOPS throttling prevents I/O saturation.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- All three files exist in `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/`
- BackgroundInodeMigration persists checkpoints and can resume after crash
- ExtentAwareVdeCopy skips unallocated blocks for faster-than-naive copy
- No mocks, stubs, or placeholder implementations (Rule 13)
- All classes have `[SdkCompatibility("6.0.0")]` attribute
</verification>

<success_criteria>
1. Background inode migration resizes all inodes with per-inode checkpoint granularity
2. Migration checkpoint persists to disk and survives crash (XxHash64 verified)
3. Region swap from old to new inode table is atomic via WAL transaction
4. Extent-aware copy only transfers allocated blocks (speedup proportional to sparsity)
5. IOPS throttling works for both migration and copy
6. Build succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/78-online-module-addition/78-03-SUMMARY.md`
</output>
