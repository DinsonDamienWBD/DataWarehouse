---
phase: 78-online-module-addition
plan: 04
type: execute
wave: 3
depends_on: ["78-01", "78-02", "78-03"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ModuleAdditionOrchestrator.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ModuleAdditionOptions.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/Tier2FallbackGuard.cs
autonomous: true

must_haves:
  truths:
    - "User is presented with all options (1-4) with a performance/downtime/risk comparison before committing"
    - "Tier 2 fallback is always available: feature works via processing pipeline even before module is added"
    - "ModuleManifest and ModuleConfig update atomically within a WAL transaction"
    - "Orchestrator selects the optimal option automatically or defers to user choice"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ModuleAdditionOrchestrator.cs"
      provides: "Central orchestrator that analyzes, recommends, and executes module addition"
      exports: ["ModuleAdditionOrchestrator", "ModuleAdditionAnalysis", "AdditionOption"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ModuleAdditionOptions.cs"
      provides: "Option comparison data model with performance/downtime/risk ratings"
      exports: ["ModuleAdditionOptions", "OptionComparison", "RiskLevel"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/Tier2FallbackGuard.cs"
      provides: "Ensures Tier 2 fallback is always available for module features"
      exports: ["Tier2FallbackGuard", "FallbackStatus"]
  key_links:
    - from: "ModuleAdditionOrchestrator"
      to: "OnlineRegionAddition"
      via: "Delegates Option 1 execution"
      pattern: "OnlineRegionAddition\\.AddModuleRegionsAsync"
    - from: "ModuleAdditionOrchestrator"
      to: "InodePaddingClaim"
      via: "Delegates Option 2 execution"
      pattern: "InodePaddingClaim\\.ClaimPaddingForModuleAsync"
    - from: "ModuleAdditionOrchestrator"
      to: "BackgroundInodeMigration"
      via: "Delegates Option 3 execution"
      pattern: "BackgroundInodeMigration\\.MigrateAsync"
    - from: "ModuleAdditionOrchestrator"
      to: "ExtentAwareVdeCopy"
      via: "Delegates Option 4 execution"
      pattern: "ExtentAwareVdeCopy\\.CopyToNewVdeAsync"
---

<objective>
Implement the user-facing orchestrator that analyzes a VDE, presents all module addition options with a comparison table, ensures Tier 2 fallback is always available, and executes the chosen option with atomic ModuleManifest + ModuleConfig updates.

Purpose: This is the API surface that callers (CLI, GUI, API) interact with. It hides the complexity of the four options behind a clean analyze-then-execute flow. The comparison table satisfies OMOD-06 (user sees all options with performance/downtime/risk). The Tier 2 fallback guard satisfies OMOD-05 and MRES-06/07 (feature works via pipeline even without VDE module).

Output: Three classes: orchestrator, options model, and Tier 2 fallback guard.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/78-online-module-addition/78-01-SUMMARY.md
@.planning/phases/78-online-module-addition/78-02-SUMMARY.md
@.planning/phases/78-online-module-addition/78-03-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/OnlineRegionAddition.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/InodePaddingClaim.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/BackgroundInodeMigration.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ExtentAwareVdeCopy.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/PaddingInventory.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FreeSpaceScanner.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleManifest.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleConfig.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Option comparison model and Tier 2 fallback guard</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ModuleAdditionOptions.cs
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/Tier2FallbackGuard.cs
  </files>
  <action>
**ModuleAdditionOptions.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:

`RiskLevel` enum: `None`, `Low`, `Medium`, `High`

`DowntimeEstimate` enum: `Zero`, `SubSecond`, `Seconds`, `Minutes`, `MinutesToHours`

`AdditionOption` readonly record struct:
- `int OptionNumber` -- 1, 2, 3, or 4
- `string Name` -- "Online Region Addition", "Inode Padding Claim", "Background Inode Migration", "New VDE + Bulk Migration"
- `string Description` -- 1-2 sentence explanation
- `bool Available` -- whether this option is feasible for the current VDE state
- `string? UnavailableReason` -- why not available (null if available)
- `RiskLevel Risk` -- risk assessment
- `DowntimeEstimate Downtime` -- expected downtime
- `string PerformanceImpact` -- e.g., "None during operation", "~10% I/O overhead during migration"
- `TimeSpan EstimatedDuration` -- rough time estimate
- `bool IsRecommended` -- true for the best option

`OptionComparison` sealed class:
- `IReadOnlyList<AdditionOption> Options` -- all 4 options
- `AdditionOption? Recommended` -- the recommended option (or null if none available)
- Method `string ToComparisonTable()` -- returns a formatted ASCII table:
  ```
  | # | Option                      | Available | Downtime | Risk   | Est. Duration | Recommended |
  |---|---------------------------- |-----------|----------|--------|---------------|-------------|
  | 1 | Online Region Addition      | Yes       | Zero     | Low    | < 1s          | *           |
  | 2 | Inode Padding Claim         | Yes       | Zero     | None   | < 1s          |             |
  | 3 | Background Inode Migration  | Yes       | Zero     | Low    | ~5 min        |             |
  | 4 | New VDE + Bulk Migration    | Yes       | Minutes  | Medium | ~30 min       |             |
  ```
- Method `string ToDetailedReport()` -- returns multi-paragraph explanation of each option

**Tier2FallbackGuard.cs** -- same namespace:

`FallbackStatus` readonly record struct:
- `ModuleId Module`
- `bool Tier2Available` -- true if the feature works via processing pipeline
- `string FallbackDescription` -- e.g., "Tags module: tag data served from plugin TagIndexRegion fallback"
- `bool VdeModuleActive` -- true if the VDE module bit is set (Tier 1)

`[SdkCompatibility("6.0.0")]` sealed class `Tier2FallbackGuard`:
- Static method `FallbackStatus CheckFallback(ModuleId module, uint currentManifest)`:
  - If module is already active in manifest, return Tier2Available=true, VdeModuleActive=true
  - For every module, Tier 2 fallback is always available because:
    - The processing pipeline (plugin layer) handles all module features independently
    - VDE-level module storage is Tier 1 (optimized on-disk), plugin processing is Tier 2
    - Example: Tags module -- without VDE TagIndexRegion, tags are stored in plugin's own storage and served via processing pipeline. Adding the VDE module moves tag data into the VDE for faster native access.
  - Return Tier2Available=true, VdeModuleActive=false, with appropriate description

- Static method `IReadOnlyList<FallbackStatus> CheckAllModules(uint currentManifest)`:
  - Returns fallback status for all 19 modules

- Static method `string GetFallbackDescription(ModuleId module)`:
  - Returns human-readable description of what Tier 2 fallback means for each module
  - Switch on ModuleId with descriptions like:
    - Security: "Encryption/policy handled by UltimateEncryption+UltimateAccessControl plugins"
    - Compliance: "Compliance vault served from UltimateCompliance plugin storage"
    - Tags: "Tag index served from plugin-managed tag storage"
    - Replication: "Replication state managed by UltimateReplication plugin"
    - etc. for all 19 modules

- Static method `bool EnsureTier2Active(ModuleId module)`:
  - Always returns true (Tier 2 is structurally always available via the plugin architecture)
  - This method exists as a formal contract: callers can assert Tier 2 availability before starting any module addition
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. OptionComparison.ToComparisonTable() returns formatted output. Tier2FallbackGuard.CheckFallback returns Tier2Available=true for all modules.
  </verify>
  <done>
Option comparison model provides structured data and formatted tables for all 4 options. Tier 2 fallback guard formally guarantees that every module's features work via the processing pipeline regardless of VDE module state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Module addition orchestrator</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/ModuleAdditionOrchestrator.cs
  </files>
  <action>
**ModuleAdditionOrchestrator.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:

`ModuleAdditionAnalysis` readonly record struct:
- `ModuleId Module`
- `VdeModule ModuleInfo` -- from ModuleRegistry
- `bool AlreadyActive` -- module already in manifest
- `bool HasInodeFields` -- module contributes inode bytes
- `bool HasRegions` -- module requires dedicated regions
- `OptionComparison Options` -- all 4 options with availability
- `FallbackStatus Tier2Status` -- Tier 2 fallback status

`ModuleAdditionResult` readonly record struct:
- `bool Success`
- `string? ErrorMessage`
- `int OptionUsed` -- which option was executed (1-4)
- `uint NewManifest` -- updated module manifest
- `InodeLayoutDescriptor? NewLayout` -- updated inode layout (if changed)
- `TimeSpan Duration`

`[SdkCompatibility("6.0.0")]` sealed class `ModuleAdditionOrchestrator`:
- Constructor takes `Stream vdeStream`, `int blockSize`
- Event `Action<string>? OnStatus` -- status messages for UI

- Method `async Task<ModuleAdditionAnalysis> AnalyzeAsync(ModuleId module, CancellationToken ct)`:
  1. Read superblock to get current manifest, inode layout, free blocks, region info
  2. Check if module already active -- if so, return with AlreadyActive=true, all options unavailable
  3. Get module info from ModuleRegistry
  4. Evaluate Option 1 (Online Region Addition):
     - Available if module has regions AND sufficient free space exists
     - Use FreeSpaceScanner to check
     - Risk: Low (WAL-journaled), Downtime: Zero, Duration: < 1 second
  5. Evaluate Option 2 (Inode Padding Claim):
     - Available if module has inode fields AND they fit in current padding
     - Use PaddingInventory.CanFitModule()
     - Risk: None (no data movement), Downtime: Zero, Duration: < 1 second
  6. Evaluate Option 3 (Background Inode Migration):
     - Available if module has inode fields that don't fit in padding AND sufficient free space for new inode table
     - Calculate new inode table size, check free space
     - Risk: Low (checkpointed), Downtime: Zero (background), Duration: proportional to inode count
  7. Evaluate Option 4 (New VDE + Bulk Migration):
     - Always available (requires destination path)
     - Risk: Medium (two VDEs exist temporarily), Downtime: Minutes (switchover), Duration: proportional to data size
  8. Determine recommended option:
     - If module needs regions: must use Option 1 (or 4 if no free space)
     - If module needs inode fields: prefer Option 2 > Option 3 > Option 4
     - If module needs both: combine Option 1 + Option 2 (or 1 + 3)
  9. Build and return ModuleAdditionAnalysis

- Method `async Task<ModuleAdditionResult> ExecuteAsync(ModuleId module, int optionNumber, CancellationToken ct, string? destinationPath = null)`:
  1. Verify Tier 2 fallback via `Tier2FallbackGuard.EnsureTier2Active(module)`
  2. Re-read superblock (state may have changed since analysis)
  3. Execute based on optionNumber:
     - **Option 1**: `new OnlineRegionAddition(vdeStream, blockSize).AddModuleRegionsAsync(module, ct)`
     - **Option 2**: `new InodePaddingClaim(vdeStream, blockSize).ClaimPaddingForModuleAsync(module, ct)`
     - **Option 3**: `new BackgroundInodeMigration(vdeStream, blockSize).MigrateAsync(module, ct)`
     - **Option 4**: `new ExtentAwareVdeCopy(vdeStream, blockSize).CopyToNewVdeAsync(destinationPath!, module, ct)` (destinationPath required)
  4. If module needs BOTH regions and inode fields, execute in order:
     a. First: region addition (Option 1)
     b. Then: inode field handling (Option 2 or 3)
     c. Both within the same logical operation
  5. Atomic manifest + config update (OMOD-07):
     - After option execution, ensure ModuleManifest bit is set AND ModuleConfig level is updated
     - Both fields live in the superblock, which is written atomically as one block
     - Use WalJournaledRegionWriter to update both superblock + mirror in one transaction
     - Default ModuleConfig level for newly added module: 1 (basic/enabled)
  6. Return ModuleAdditionResult

- Method `async Task<ModuleAdditionResult> ExecuteRecommendedAsync(ModuleId module, CancellationToken ct, string? destinationPath = null)`:
  - Calls AnalyzeAsync, then ExecuteAsync with the recommended option

- Method `async Task<IReadOnlyList<ModuleAdditionAnalysis>> AnalyzeMultipleAsync(IEnumerable<ModuleId> modules, CancellationToken ct)`:
  - Analyzes adding multiple modules, considering cumulative effects (adding module A reduces padding for module B)
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. ModuleAdditionOrchestrator has AnalyzeAsync, ExecuteAsync, ExecuteRecommendedAsync methods. Calling AnalyzeAsync returns an analysis with all 4 options evaluated.
  </verify>
  <done>
ModuleAdditionOrchestrator provides a complete analyze-then-execute API. Users see all options with comparison table before committing. ModuleManifest and ModuleConfig update atomically. Tier 2 fallback is verified before any operation.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- All three files exist in `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/`
- AnalyzeAsync returns all 4 options with availability, risk, downtime ratings
- ExecuteAsync handles combined region + inode operations for modules needing both
- ModuleManifest + ModuleConfig update is atomic (same superblock write, WAL-journaled)
- Tier2FallbackGuard.CheckFallback returns true for every module
- No mocks, stubs, or placeholder implementations (Rule 13)
- All classes have `[SdkCompatibility("6.0.0")]` attribute
</verification>

<success_criteria>
1. AnalyzeAsync evaluates all 4 options and recommends the best one (OMOD-06)
2. Comparison table shows performance/downtime/risk for each option
3. Tier 2 fallback is guaranteed available for all modules (OMOD-05, MRES-06)
4. ModuleManifest and ModuleConfig update atomically within WAL transaction (OMOD-07)
5. Orchestrator handles modules needing both regions and inode fields
6. Build succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/78-online-module-addition/78-04-SUMMARY.md`
</output>
