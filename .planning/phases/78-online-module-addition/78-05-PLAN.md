---
phase: 78-online-module-addition
plan: 05
type: execute
wave: 4
depends_on: ["78-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/RegionIndirectionLayer.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/OnlineDefragmenter.cs
  - DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FragmentationMetrics.cs
autonomous: true

must_haves:
  truths:
    - "Region indirection layer translates logical block addresses to physical locations"
    - "Background block relocation moves blocks without interrupting active I/O"
    - "Defragmentation achieves zero-downtime compaction of fragmented regions"
    - "Fragmentation metrics report current fragmentation level and estimated improvement"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/RegionIndirectionLayer.cs"
      provides: "Logical-to-physical block address translation for region indirection"
      exports: ["RegionIndirectionLayer", "BlockMapping", "IndirectionTable"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/OnlineDefragmenter.cs"
      provides: "Background block relocation engine with zero-downtime guarantee"
      exports: ["OnlineDefragmenter", "DefragResult", "DefragProgress"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FragmentationMetrics.cs"
      provides: "Fragmentation analysis and reporting"
      exports: ["FragmentationMetrics", "FragmentationReport"]
  key_links:
    - from: "OnlineDefragmenter"
      to: "RegionIndirectionLayer"
      via: "Updates indirection table during block relocation"
      pattern: "RegionIndirectionLayer\\.RemapBlock"
    - from: "OnlineDefragmenter"
      to: "WalJournaledRegionWriter"
      via: "WAL-journals each block relocation for crash safety"
      pattern: "WalJournaledRegionWriter\\.CommitAsync"
    - from: "FragmentationMetrics"
      to: "RegionDirectory"
      via: "Reads region layout for fragmentation analysis"
      pattern: "RegionDirectory\\.GetActiveRegions"
---

<objective>
Implement online defragmentation via a region indirection layer that allows background block relocation with zero downtime. The indirection layer translates logical block addresses to physical locations, enabling blocks to be moved transparently. Fragmentation metrics provide visibility into the current state and expected improvement.

Purpose: After multiple module additions and removals, the VDE's block layout becomes fragmented. Online defragmentation compacts regions and reclaims freed space without stopping the VDE. This satisfies VADV-02 (online defragmentation via region indirection).

Output: Three production-ready classes for indirection, defragmentation, and metrics.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/78-online-module-addition/78-01-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionDirectory.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionPointerTable.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/WalJournaledRegionWriter.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FreeSpaceScanner.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Region indirection layer and fragmentation metrics</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/RegionIndirectionLayer.cs
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/FragmentationMetrics.cs
  </files>
  <action>
**RegionIndirectionLayer.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:

`BlockMapping` readonly record struct:
- `long LogicalBlock` -- the block number callers use
- `long PhysicalBlock` -- the actual on-disk block number
- `bool IsRemapped` -- true if logical != physical

`IndirectionTable` sealed class:
- Internal storage: `Dictionary<long, long>` mapping logical -> physical
- Only blocks that have been moved have entries; unmoved blocks have identity mapping (logical == physical)
- Property `int RemappedBlockCount` -- number of non-identity mappings
- Method `long Resolve(long logicalBlock)` -- returns physical block (identity if not in table)
- Method `void RemapBlock(long logicalBlock, long newPhysicalBlock)` -- adds/updates mapping
- Method `void RemoveMapping(long logicalBlock)` -- removes mapping (block moved back to original position)
- Method `IReadOnlyList<BlockMapping> GetAllMappings()` -- returns all non-identity mappings
- Method `bool HasMapping(long logicalBlock)` -- checks if block is remapped

Serialization for on-disk persistence:
- Header: `[MagicINDR:4][Version:2][EntryCount:4][Reserved:6]` = 16 bytes
- Each entry: `[LogicalBlock:8][PhysicalBlock:8]` = 16 bytes per entry
- Checksum at end of data (XxHash64)
- Method `static void Serialize(IndirectionTable table, Span<byte> buffer)` -- to block-sized buffer
- Method `static IndirectionTable Deserialize(ReadOnlySpan<byte> buffer)` -- from block-sized buffer

`[SdkCompatibility("6.0.0")]` sealed class `RegionIndirectionLayer`:
- Constructor takes `Stream vdeStream`, `int blockSize`, `long indirectionTableBlock` (block number where the indirection table is stored)
- Method `async Task<long> ReadBlockAsync(long logicalBlock, Memory<byte> buffer, CancellationToken ct)`:
  - Resolve logical -> physical via IndirectionTable
  - Read from physical location
  - Return physical block number used
- Method `async Task WriteBlockAsync(long logicalBlock, ReadOnlyMemory<byte> data, CancellationToken ct)`:
  - Resolve logical -> physical
  - Write to physical location
- Method `void RemapBlock(long logicalBlock, long newPhysicalBlock)`:
  - Update indirection table in memory
- Method `async Task PersistTableAsync(CancellationToken ct)`:
  - Serialize indirection table to its on-disk block
  - Flush stream
- Method `async Task LoadTableAsync(CancellationToken ct)`:
  - Read indirection table block from disk
  - If valid, deserialize into memory
  - If empty/invalid, create empty table (no remappings)

**FragmentationMetrics.cs** -- same namespace:

`FragmentationReport` readonly record struct:
- `double OverallFragmentationPercent` -- 0% = perfectly contiguous, 100% = maximally fragmented
- `long TotalRegions` -- number of active regions
- `long TotalGaps` -- number of free gaps between regions
- `long LargestContiguousFreeBlocks` -- biggest free run
- `long SmallestContiguousFreeBlocks` -- smallest free run (excluding zero)
- `double AverageFreeRunLength` -- average free gap size
- `long WastedBlocks` -- blocks lost to fragmentation (too small to use)
- `IReadOnlyList<RegionFragInfo> RegionDetails` -- per-region fragmentation

`RegionFragInfo` readonly record struct:
- `uint RegionTypeId`, `long StartBlock`, `long BlockCount`, `long GapAfter` (free blocks after this region before next)

`[SdkCompatibility("6.0.0")]` sealed class `FragmentationMetrics`:
- Constructor takes `Stream vdeStream`, `int blockSize`
- Method `async Task<FragmentationReport> AnalyzeAsync(CancellationToken ct)`:
  1. Read RegionDirectory to get all active regions with their block ranges
  2. Sort regions by StartBlock
  3. Calculate gaps between consecutive regions
  4. Measure fragmentation: `fragmentationPercent = 1 - (largestFreeRun / totalFreeBlocks)` (higher is more fragmented)
  5. Calculate wasted blocks: sum of free runs smaller than MinUsefulRunSize (e.g., 16 blocks)
  6. Build per-region detail with gap-after info
  7. Return FragmentationReport

- Method `async Task<double> EstimateImprovementAsync(CancellationToken ct)`:
  - Simulates perfect compaction: all regions contiguous, one large free run
  - Returns percentage improvement in largest contiguous free space

- Static method `string FormatReport(FragmentationReport report)`:
  - Returns human-readable fragmentation report with ASCII bar chart
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. RegionIndirectionLayer resolves logical to physical blocks. FragmentationMetrics.AnalyzeAsync returns a complete fragmentation report.
  </verify>
  <done>
Region indirection layer provides transparent logical-to-physical block translation. Indirection table persists to disk. Fragmentation metrics accurately measure region layout quality.
  </done>
</task>

<task type="auto">
  <name>Task 2: Online defragmenter with background block relocation</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/OnlineDefragmenter.cs
  </files>
  <action>
**OnlineDefragmenter.cs** -- namespace `DataWarehouse.SDK.VirtualDiskEngine.ModuleManagement`:

`DefragProgress` readonly record struct:
- `long TotalBlocksToMove`, `long BlocksMoved`, `double PercentComplete`, `DefragPhase Phase`

`DefragPhase` enum: `Analyzing`, `RelocatingBlocks`, `UpdatingRegionPointers`, `CompactingIndirectionTable`, `Complete`

`DefragResult` readonly record struct:
- `bool Success`, `string? ErrorMessage`, `long BlocksRelocated`, `long FreeSpaceReclaimed`, `double FragmentationBefore`, `double FragmentationAfter`, `TimeSpan Duration`

`[SdkCompatibility("6.0.0")]` sealed class `OnlineDefragmenter`:
- Constructor takes `Stream vdeStream`, `int blockSize`
- Event `Action<DefragProgress>? OnProgress`
- Property `int MaxIopsPerSecond { get; set; } = 0` -- throttle I/O
- Property `int BatchSize { get; set; } = 64` -- blocks per batch before WAL commit

- Main method `async Task<DefragResult> DefragmentAsync(CancellationToken ct)`:
  1. Phase: Analyzing
     - Use FragmentationMetrics to get current state
     - If fragmentation < 5%, return success with "already well-compacted"
     - Build a compaction plan: target layout where all regions are contiguous, ordered by StartBlock

  2. Phase: RelocatingBlocks
     - For each region that needs to move (from current position to target position):
       a. Initialize RegionIndirectionLayer
       b. For each batch of blocks in the region:
          - Read batch from current physical location
          - Write batch to target physical location
          - Update indirection table: old logical -> new physical
          - WAL-journal the batch write (via WalJournaledRegionWriter)
          - After each batch commit, the region is readable at both old and new locations
       c. Report progress after each batch
       d. Apply IOPS throttling if configured
     - Key invariant: at ALL times during relocation, every block is readable. The indirection table ensures readers find the latest copy.

  3. Phase: UpdatingRegionPointers
     - Once all blocks for a region are relocated:
       a. Begin WAL transaction
       b. Update RegionDirectory: change StartBlock to new location
       c. Update RegionPointerTable: same
       d. Update allocation bitmap: free old blocks, mark new blocks as allocated
       e. Commit WAL transaction
       f. Remove indirection mappings for this region (now at canonical location)

  4. Phase: CompactingIndirectionTable
     - After all regions relocated, persist final indirection table (should be empty if all regions fully moved)
     - Clear indirection table block if empty

  5. Phase: Complete
     - Get final fragmentation metrics
     - Return DefragResult with before/after comparison

- Method `async Task<DefragResult> DefragmentRegionAsync(uint regionTypeId, CancellationToken ct)`:
  - Defragments a single region (useful for targeted compaction)
  - Same algorithm but scoped to one region

- Method `CompactionPlan BuildCompactionPlan(FragmentationReport report)`:
  - Sorts regions by StartBlock
  - Calculates target positions: each region immediately after the previous
  - Returns list of (RegionTypeId, CurrentStart, TargetStart, BlockCount) tuples
  - Skips fixed regions (superblocks at 0-7, region directory at 8-9)

`CompactionPlan` internal sealed class:
- `IReadOnlyList<RegionMove> Moves` -- ordered list of region relocations
- `long TotalBlocksToMove` -- sum of all block moves
- `long FreeSpaceAfter` -- contiguous free space after compaction

`RegionMove` readonly record struct:
- `uint RegionTypeId`, `long CurrentStartBlock`, `long TargetStartBlock`, `long BlockCount`
- `bool NeedsMove => CurrentStartBlock != TargetStartBlock`

Zero-downtime guarantee: The indirection layer ensures that during block relocation, both old and new copies exist. Readers going through the indirection layer always get valid data. The region pointer update is atomic (WAL), so there's never a moment when a region pointer points to unwritten blocks.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. OnlineDefragmenter.DefragmentAsync returns DefragResult with before/after fragmentation metrics.
  </verify>
  <done>
Online defragmenter relocates blocks in the background via the region indirection layer. Each block batch is WAL-journaled. Region pointer updates are atomic. Zero-downtime: blocks are always readable during relocation. Fragmentation metrics report improvement.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- All three files exist in `DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/`
- RegionIndirectionLayer provides logical->physical block translation with on-disk persistence
- OnlineDefragmenter relocates blocks without interrupting reads
- FragmentationMetrics accurately measures fragmentation and estimates improvement
- No mocks, stubs, or placeholder implementations (Rule 13)
- All classes have `[SdkCompatibility("6.0.0")]` attribute
</verification>

<success_criteria>
1. Region indirection layer transparently translates logical to physical block addresses (VADV-02)
2. Indirection table serializes to disk and survives crash
3. Online defragmenter moves blocks in batches with WAL journaling per batch
4. During block relocation, both old and new copies exist (zero-downtime guarantee)
5. Region pointer update is atomic via WAL transaction
6. Fragmentation metrics report before/after comparison
7. Build succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/78-online-module-addition/78-05-SUMMARY.md`
</output>
