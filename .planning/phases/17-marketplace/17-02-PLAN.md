---
phase: 17-marketplace
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs
autonomous: true
must_haves:
  truths:
    - "Plugins can be certified through a multi-stage validation pipeline with real security checks"
    - "Users can submit ratings and reviews for installed plugins"
    - "Review system tracks reliability, performance, and documentation quality dimensions"
    - "Revenue tracking records developer earnings with commission calculation"
    - "Certification pipeline uses existing PluginLoader security validation via message bus"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs"
      provides: "Certification pipeline, rating/review system, revenue tracking added to existing plugin"
      contains: "CertificationPipeline"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs"
      to: "DataWarehouse.Kernel/Plugins/PluginLoader.cs"
      via: "Message bus topic kernel.plugin.validate for security validation during certification"
      pattern: "kernel\\.plugin\\.validate"
    - from: "Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs"
      to: "DataWarehouse.GUI/Components/Pages/Marketplace.razor"
      via: "Reviews and ratings data returned in marketplace.list response"
      pattern: "reviews|ratingCount|rating"
---

<objective>
Add certification pipeline, rating/review system, and revenue tracking to the PluginMarketplace plugin.

Purpose: T57 requires a certification program (security review, testing), rating/reviews (community feedback), and revenue sharing (monetization). These features complete the marketplace ecosystem beyond basic install/uninstall.

Output: PluginMarketplacePlugin.cs expanded with certification, reviews, and revenue tracking. All integrated with the existing catalog and message handlers from Plan 01.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-marketplace/17-RESEARCH.md
@.planning/phases/17-marketplace/17-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.DataMarketplace/DataMarketplacePlugin.cs (Review record pattern, ReviewsResponse, ReviewSubmission)
@DataWarehouse.Kernel/Plugins/PluginLoader.cs (PluginSecurityConfig, ValidateAssemblySecurity method)
@Metadata/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add certification pipeline with real security validation</name>
  <files>Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs</files>
  <action>
  Add the certification pipeline to PluginMarketplacePlugin.cs. This adds new record types, a multi-stage certification pipeline, and a new message handler.

  **A) New Record Types (append after existing records):**

  `CertificationRequest`:
  - PluginId, Version, RequestedBy, AssemblyPath, SubmittedAt (DateTime)

  `CertificationResult`:
  - PluginId, Version, Level (CertificationLevel), OverallScore (double 0-100), Stages (CertificationStageResult[]), CertifiedAt (DateTime?), ExpiresAt (DateTime?), CertifiedBy (string)

  `CertificationStageResult`:
  - StageName (string), Passed (bool), Score (double 0-100), Details (string), Warnings (string[]), Errors (string[]), ExecutedAt (DateTime), DurationMs (long)

  `CertificationPolicy`:
  - RequireSignedAssembly (bool, default false), MaxAssemblySizeMb (int, default 50), RequireSdkCompatibility (bool, default true), MinimumScore (double, default 60.0), CertificationValidityDays (int, default 365)

  **B) Certification Pipeline Implementation:**

  Add `ConcurrentDictionary<string, CertificationResult> _certifications` field.
  Add `CertificationPolicy _certificationPolicy` field initialized from config.

  Implement `CertifyPluginAsync(CertificationRequest request, CancellationToken ct)` that runs 5 stages sequentially:

  **Stage 1: Security Scan**
  - Send message to kernel topic `kernel.plugin.validate` with assembly path
  - Parse response for security validation results (signed, hash verified, size within limits, not blocked)
  - If kernel validation unavailable (message bus timeout), perform local checks:
    - Check file exists and size <= MaxAssemblySizeMb
    - Compute SHA-256 hash of assembly
    - Check assembly is a valid .NET assembly (try to read AssemblyName from file using System.Reflection.AssemblyName.GetAssemblyName)
  - Score: Pass/fail on each sub-check, weighted average for stage score

  **Stage 2: SDK Compatibility Check**
  - Verify the assembly references DataWarehouse.SDK (check assembly references via AssemblyName.GetAssemblyName and metadata inspection)
  - Verify it does NOT reference DataWarehouse.Kernel or other plugin projects (forbidden references)
  - Check the SDK version compatibility (assembly metadata version vs current SDK version)
  - Score: 100 if compatible, 0 if incompatible

  **Stage 3: Dependency Validation**
  - Load declared dependencies from catalog entry
  - For each dependency, verify it exists in catalog and has a compatible version available
  - Check for circular dependency chains
  - Score: (satisfied dependencies / total dependencies) * 100

  **Stage 4: Static Analysis**
  - Check assembly for forbidden patterns by reading the assembly metadata:
    - No direct plugin-to-plugin references (check all referenced assemblies)
    - Assembly name follows naming convention (DataWarehouse.Plugins.*)
    - Has XML documentation file alongside the DLL (check for .xml file)
  - Score based on checks passed

  **Stage 5: Certification Scoring**
  - Compute weighted composite: Security (30%), Compatibility (25%), Dependencies (20%), Static Analysis (25%)
  - Determine CertificationLevel:
    - Score >= 90 and all stages passed -> FullyCertified
    - Score >= 60 and Security+Compatibility passed -> BasicCertified
    - Score < 60 or Security failed -> Uncertified
    - Any critical error -> Rejected
  - Set ExpiresAt = CertifiedAt + CertificationValidityDays

  Persist certification result to `{storagePath}/certifications/{pluginId}.json`.
  Update catalog entry's CertificationLevel field.

  **C) Message Handler for `marketplace.certify`:**
  Add case in OnMessageAsync switch for `"marketplace.certify"`:
  - Extract pluginId, version, assemblyPath from payload
  - Create CertificationRequest and call CertifyPluginAsync
  - Return CertificationResult via message response

  **D) Persistence:**
  - `SaveCertificationAsync(CertificationResult)` writes to certifications/ directory
  - `LoadCertificationsAsync()` reads all certification files on startup (called from LoadStateAsync)
  </action>
  <verify>
  Run: `dotnet build Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj`
  Must compile with zero errors.
  Verify: grep for "CertifyPluginAsync" shows the method exists with 5 stages.
  Verify: grep for "marketplace.certify" shows the message handler.
  Verify: No NotImplementedException or placeholder logic.
  </verify>
  <done>
  - 5-stage certification pipeline implemented with real validation logic
  - Security stage uses kernel message bus with local fallback
  - Compatibility stage checks SDK-only references
  - Certification results persist to JSON files
  - marketplace.certify message handler wired
  - Build passes with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rating/review system and revenue tracking</name>
  <files>Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs</files>
  <action>
  Add the rating/review system and revenue tracking to PluginMarketplacePlugin.cs.

  **A) Review Record Types (following DataMarketplace Review pattern):**

  `PluginReviewEntry`:
  - Id (string, generated), PluginId, ReviewerId, ReviewerName, OverallRating (int, 1-5), Title (string?), Content (string?), ReliabilityRating (int?, 1-5), PerformanceRating (int?, 1-5), DocumentationRating (int?, 1-5), IsVerifiedInstall (bool), ReviewStatus (ReviewModerationStatus enum), CreatedAt, OwnerResponse (string?), OwnerRespondedAt (DateTime?)

  `PluginReviewSubmission`:
  - PluginId, ReviewerId, ReviewerName, OverallRating (int), Title (string?), Content (string?), ReliabilityRating (int?), PerformanceRating (int?), DocumentationRating (int?)

  `PluginReviewsResponse`:
  - PluginId, Reviews (PluginReviewEntry[]), TotalCount (int), AverageRating (double), RatingDistribution (Dictionary<int, int>)

  `ReviewModerationStatus` enum: Pending, Approved, Rejected, Flagged

  **B) Review System Implementation:**

  Add `ConcurrentDictionary<string, List<PluginReviewEntry>> _reviews` field.

  `SubmitReviewAsync(PluginReviewSubmission submission, CancellationToken ct)`:
  - Validate: OverallRating 1-5, PluginId exists in catalog, ReviewerId not empty
  - Verify reviewer has the plugin installed (IsVerifiedInstall = catalog[pluginId].IsInstalled)
  - Check for duplicate review (same ReviewerId + PluginId -> update existing instead of adding)
  - Create PluginReviewEntry with generated ID (format: "rev-{Guid}")
  - Set ReviewStatus = Approved (auto-approve for now, moderation is enhancement)
  - Add to _reviews dictionary
  - Recalculate AverageRating and RatingCount on the catalog entry
  - Persist review to `{storagePath}/reviews/{pluginId}.json`

  `GetPluginReviewsAsync(string pluginId, int offset, int limit, CancellationToken ct)`:
  - Return PluginReviewsResponse with paginated reviews, total count, average, distribution
  - RatingDistribution: Dictionary mapping 1-5 to count of reviews at each star level

  **C) Update marketplace.list handler** to include review data:
  - For each catalog entry, include topReview (most recent approved review with highest rating)
  - Include reviews list (top 5 by date, approved only) for the details modal
  - These fields match what Marketplace.razor ParsePlugins expects

  **D) Message handler for `marketplace.review`:**
  Add case in OnMessageAsync:
  - Extract PluginReviewSubmission fields from payload
  - Call SubmitReviewAsync
  - Return success/failure

  **E) Revenue Tracking Record Types:**

  `DeveloperRevenueRecord`:
  - DeveloperId, PluginId, Period (string, "yyyy-MM"), TotalEarnings (decimal), CommissionRate (decimal, default 0.30), CommissionAmount (decimal), NetEarnings (decimal), InstallCount (int), PayoutStatus (PayoutStatus enum)

  `PayoutStatus` enum: Pending, Processing, Paid, Failed

  `RevenueConfig`:
  - DefaultCommissionRate (decimal, default 0.30), MinimumPayoutThreshold (decimal, default 50.00), PayoutCurrency (string, default "USD")

  **F) Revenue Tracking Implementation:**

  Add `ConcurrentDictionary<string, List<DeveloperRevenueRecord>> _revenueRecords` field.

  `RecordInstallRevenueAsync(string pluginId, string developerId, decimal price, CancellationToken ct)`:
  - Calculate commission: price * CommissionRate
  - Calculate net: price - commission
  - Create or update DeveloperRevenueRecord for current period
  - Persist to `{storagePath}/revenue/{developerId}/{period}.json`

  `GetDeveloperRevenueAsync(string developerId, string? period, CancellationToken ct)`:
  - Return revenue records for the developer, optionally filtered by period

  **G) Wire revenue tracking into install handler:**
  - In marketplace.install handler, after successful install, check if plugin has a price in catalog metadata
  - If priced, call RecordInstallRevenueAsync with the plugin's author as developerId

  **CRITICAL:**
  - Review validation must check rating range (1-5) and reject invalid
  - Verified install check uses actual catalog installed status
  - Revenue tracking uses real decimal arithmetic, not floating point
  - All new types have XML documentation
  - Thread safety with ConcurrentDictionary and locks on file I/O
  </action>
  <verify>
  Run: `dotnet build Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj`
  Must compile with zero errors.
  Verify: grep for "SubmitReviewAsync" shows review submission method.
  Verify: grep for "marketplace.review" shows the message handler.
  Verify: grep for "DeveloperRevenueRecord" shows revenue tracking types.
  Verify: grep for "topReview" in marketplace.list handler shows review data is returned to GUI.
  </verify>
  <done>
  - Rating/review system with 3 quality dimensions (reliability, performance, documentation)
  - Verified install check ensures only installers can review
  - Review data flows to GUI via marketplace.list response (topReview, reviews, ratingCount, rating fields)
  - Revenue tracking with commission calculation and period-based records
  - Revenue wired into install handler
  - All types have XML docs
  - Build passes with zero errors
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj` succeeds
2. grep for "CertifyPluginAsync" confirms 5-stage pipeline
3. grep for "SubmitReviewAsync" confirms review system
4. grep for "RecordInstallRevenueAsync" confirms revenue tracking
5. grep for "marketplace.certify|marketplace.review" confirms both message handlers
6. No `TODO`, `HACK`, `FIXME`, `NotImplementedException`, `Task.Delay` patterns
</verification>

<success_criteria>
- Certification pipeline validates plugins through 5 real stages
- Review system supports multi-dimensional ratings
- Revenue tracking calculates commissions correctly
- All data persists to JSON files
- GUI receives review/rating data in marketplace.list responses
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-marketplace/17-02-SUMMARY.md`
</output>
