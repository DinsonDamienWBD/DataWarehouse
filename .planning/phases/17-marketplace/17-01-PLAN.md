---
phase: 17-marketplace
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj
  - Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs
  - DataWarehouse.slnx
autonomous: true
must_haves:
  truths:
    - "GUI can call marketplace.list and receive a list of available/installed plugins with metadata"
    - "GUI can call marketplace.install with pluginId and version and the plugin is installed via kernel message bus"
    - "GUI can call marketplace.uninstall and the plugin is unloaded via kernel message bus"
    - "GUI can call marketplace.update and the plugin is upgraded with old version archived"
    - "Plugin catalog persists to disk and survives restarts"
    - "Dependency resolution prevents installation when required dependencies are missing"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj"
      provides: "Plugin project referencing only SDK"
      contains: "DataWarehouse.SDK.csproj"
    - path: "Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs"
      provides: "Main plugin with catalog, message handlers, dependency resolution, version archive"
      min_lines: 800
    - path: "DataWarehouse.slnx"
      provides: "Solution registration for the new plugin"
      contains: "DataWarehouse.Plugins.PluginMarketplace"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs"
      to: "DataWarehouse.GUI/Components/Pages/Marketplace.razor"
      via: "Message bus handlers for marketplace.list, marketplace.install, marketplace.uninstall, marketplace.update"
      pattern: "case \"marketplace\\.(list|install|uninstall|update)\""
    - from: "Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs"
      to: "DataWarehouse.Kernel/Plugins/PluginLoader.cs"
      via: "Message bus topics kernel.plugin.load, kernel.plugin.unload"
      pattern: "kernel\\.plugin\\.(load|unload)"
---

<objective>
Create the PluginMarketplace plugin (T57) with core catalog management, all 4 GUI message handlers, dependency resolution, and version archiving.

Purpose: The Marketplace.razor GUI already calls marketplace.list/install/uninstall/update via InstanceManager.ExecuteAsync. This plan creates the backend plugin that handles those messages, manages a persistent catalog of available/installed plugins, resolves dependencies before install, archives old versions for rollback, and coordinates with the Kernel PluginLoader via message bus.

Output: A compilable PluginMarketplacePlugin extending FeaturePluginBase with all GUI-expected message handlers wired and working.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-marketplace/17-RESEARCH.md
@Plugins/DataWarehouse.Plugins.DataMarketplace/DataMarketplacePlugin.cs (reference pattern for FeaturePluginBase, message handling, persistence, record types)
@Plugins/DataWarehouse.Plugins.DataMarketplace/DataWarehouse.Plugins.DataMarketplace.csproj (reference for .csproj structure)
@DataWarehouse.GUI/Components/Pages/Marketplace.razor (the GUI that calls marketplace.list/install/uninstall/update -- understand what fields it expects)
@DataWarehouse.SDK/Utilities/PluginDetails.cs (PluginDescriptor, PluginDependency, PluginCapabilityDescriptor)
@DataWarehouse.SDK/Contracts/PluginBase.cs (FeaturePluginBase definition)
@DataWarehouse.SDK/Contracts/IKernelInfrastructure.cs (IPluginReloader interface)
@DataWarehouse.SDK/Infrastructure/KernelInfrastructure.cs (PluginReloadManager implementation)
@Metadata/CLAUDE.md (architecture rules, plugin isolation, Rule 13)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PluginMarketplace project and plugin with catalog, message handlers, dependency resolution</name>
  <files>
    Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj
    Plugins/DataWarehouse.Plugins.PluginMarketplace/PluginMarketplacePlugin.cs
    DataWarehouse.slnx
  </files>
  <action>
  Create the PluginMarketplace plugin project and single-file implementation. Follow the DataMarketplacePlugin pattern exactly.

  **Step 1: Create .csproj** at `Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj`
  - Copy structure from DataMarketplace .csproj (net10.0, ImplicitUsings, Nullable, TreatWarningsAsErrors, GenerateDocumentationFile, NoWarn CS1591)
  - Only ProjectReference: `..\..\DataWarehouse.SDK\DataWarehouse.SDK.csproj` (no other plugin refs)
  - Description: "Production-ready Plugin Marketplace plugin for DataWarehouse implementing T57"

  **Step 2: Add to DataWarehouse.slnx** in the `/Plugins/` folder section:
  ```xml
  <Project Path="Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj" />
  ```
  Insert alphabetically among existing plugin entries.

  **Step 3: Create PluginMarketplacePlugin.cs** â€” a single sealed class extending `FeaturePluginBase`. This is a LARGE file (~1200-1500 lines) containing ALL types inline (following the DataMarketplacePlugin pattern where all records are in the same file).

  The plugin MUST implement:

  **A) Core Plugin Structure:**
  - `Id` => `"datawarehouse.plugins.marketplace.plugin"` (distinct from DataMarketplace's commerce ID)
  - `Name` => `"Plugin Marketplace (T57)"`
  - `Version` => `"1.0.0"`
  - `Category` => `PluginCategory.FeatureProvider`
  - Constructor accepting optional `PluginMarketplaceConfig` with storage path `{LocalApplicationData}/DataWarehouse/plugin-marketplace/`
  - `OnHandshakeAsync` loads state, `StartAsync` creates directories, `StopAsync` saves state
  - `GetCapabilities()` returning capabilities for: `plugin.marketplace.list`, `plugin.marketplace.install`, `plugin.marketplace.uninstall`, `plugin.marketplace.update`, `plugin.marketplace.search`, `plugin.marketplace.certify`, `plugin.marketplace.review`, `plugin.marketplace.analytics`
  - `GetMetadata()` returning TotalPlugins, InstalledPlugins, CertifiedPlugins, AverageRating

  **B) Record Types (all sealed records with XML docs, inside the same file after the plugin class):**

  `PluginCatalogEntry`:
  - Id, Name, Author, Description, FullDescription, Category, Tags (string[]), CurrentVersion, LatestVersion, AvailableVersions (string[]), IsInstalled, HasUpdate, CertificationLevel (enum), AverageRating (double), RatingCount (int), InstallCount (long), Dependencies (PluginDependencyInfo[]), CreatedAt, UpdatedAt, InstalledAt (DateTime?)

  `PluginDependencyInfo`:
  - PluginId, MinVersion, MaxVersion, IsOptional, Reason

  `PluginVersionInfo`:
  - PluginId, VersionNumber, Changelog, ReleaseDate, AssemblyHash (string), AssemblySize (long), SdkCompatibility (string), IsPreRelease (bool)

  `PluginInstallRequest`:
  - PluginId, Version, IncludeDependencies (bool, default true)

  `PluginInstallResult`:
  - Success, PluginId, InstalledVersion, Message, InstalledDependencies (string[])

  `PluginMarketplaceConfig`:
  - StoragePath (default: {LocalApplicationData}/DataWarehouse/plugin-marketplace/), CatalogRefreshInterval (TimeSpan, default 1 hour), MaxInstallRetries (int, default 3), RequireCertification (bool, default false), AutoUpdateEnabled (bool, default false)

  `MarketplaceState`:
  - LastCatalogRefresh (DateTime), TotalInstalls (long), TotalUninstalls (long), ActivePluginCount (int)

  **Enums:**
  `CertificationLevel`: Uncertified, BasicCertified, FullyCertified, Rejected
  `PluginInstallStatus`: Available, Installing, Installed, Updating, Uninstalling, Failed

  **C) Persistent Catalog Management:**
  - `ConcurrentDictionary<string, PluginCatalogEntry> _catalog` for in-memory catalog
  - `ConcurrentDictionary<string, List<PluginVersionInfo>> _versionHistory` for version tracking
  - JSON file persistence to `{storagePath}/catalog/{pluginId}.json` and `{storagePath}/versions/{pluginId}.json`
  - `LoadCatalogAsync()` reads all JSON files from catalog/ directory on startup
  - `SaveCatalogEntryAsync(PluginCatalogEntry)` writes individual entry
  - `SaveStateAsync()` / `LoadStateAsync()` for MarketplaceState
  - On first startup, auto-populate catalog by scanning the Plugins directory (enumerate known plugin assemblies from the build output directory, using reflection to read PluginDescriptor metadata if available, or by maintaining a built-in catalog of all DataWarehouse plugins with their metadata)

  **D) Message Bus Handlers (OnMessageAsync switch):**

  `marketplace.list`:
  - Return all catalog entries as List<Dictionary<string, object>> matching what Marketplace.razor ParsePlugins expects
  - Fields MUST match: id, name, author, description, fullDescription, category, version, latestVersion, downloads, rating, ratingCount, isInstalled, hasUpdate, isVerified (mapped from CertificationLevel >= BasicCertified), lastUpdated
  - Also include topReview (author, text, rating) and versions (number, changelog, releaseDate) and reviews (author, text, rating, date) if available
  - Support optional search/filter parameters from message payload (searchQuery, category, sortBy)

  `marketplace.install`:
  - Extract pluginId and version from message.Payload
  - Run dependency resolution: check all PluginDependencyInfo for the requested plugin, verify each dependency is installed (or install if IncludeDependencies), fail with clear error if required dependency missing
  - Send message to kernel via MessageBus: topic `kernel.plugin.load` with the assembly path and plugin ID
  - Update catalog entry: IsInstalled=true, InstalledAt=DateTime.UtcNow, CurrentVersion=version, increment InstallCount
  - Persist updated catalog entry

  `marketplace.uninstall`:
  - Extract pluginId from message.Payload
  - Check no other installed plugin depends on this one (reverse dependency check)
  - Send message to kernel via MessageBus: topic `kernel.plugin.unload` with plugin ID
  - Update catalog: IsInstalled=false, InstalledAt=null
  - Persist updated catalog entry

  `marketplace.update`:
  - Extract pluginId and version from message.Payload
  - Archive current version: copy assembly to `{storagePath}/versions/{pluginId}/{currentVersion}/` before updating
  - Run dependency resolution for new version
  - Send `kernel.plugin.unload` then `kernel.plugin.load` with new version's assembly path
  - Update catalog: CurrentVersion=newVersion, HasUpdate=false
  - If load fails, rollback: restore archived assembly, reload old version
  - Persist updated catalog entry

  **E) Dependency Resolution Algorithm:**
  - `ResolveDependenciesAsync(string pluginId, string version)` -> returns ordered list of (pluginId, version) to install
  - Uses topological sort on dependency graph
  - Detects circular dependencies and throws with clear error message
  - For each dependency: check if already installed at compatible version; if not, add to install list
  - Version compatibility: check MinVersion/MaxVersion ranges

  **F) Version Archive for Rollback:**
  - `ArchivePluginVersionAsync(string pluginId, string version)` -> copies assembly + metadata to versions directory
  - `RestorePluginVersionAsync(string pluginId, string version)` -> copies assembly back from archive
  - Maintain version directory structure: `{storagePath}/versions/{pluginId}/{version}/assembly.dll` + `metadata.json`

  **CRITICAL RULES:**
  - Plugin references ONLY the SDK (no Kernel, no other plugin references)
  - All kernel communication via message bus (kernel.plugin.load, kernel.plugin.unload topics)
  - No mock/stub/placeholder implementations (Rule 13). Every method must have real logic.
  - All public types have XML documentation
  - Internal sealed classes where appropriate
  - Thread-safe with ConcurrentDictionary and SemaphoreSlim for file I/O
  - Use System.Text.Json for serialization (already in SDK)
  </action>
  <verify>
  Run: `dotnet build Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj`
  Must compile with zero errors. Warnings acceptable if only CS1591 (suppressed in csproj).
  Verify: The .csproj only references SDK (grep for ProjectReference should show only DataWarehouse.SDK).
  Verify: PluginMarketplacePlugin.cs contains OnMessageAsync with cases for marketplace.list, marketplace.install, marketplace.uninstall, marketplace.update.
  Verify: No references to DataWarehouse.Kernel or any other plugin project.
  </verify>
  <done>
  - PluginMarketplacePlugin extends FeaturePluginBase and compiles
  - All 4 GUI-expected message handlers (list, install, uninstall, update) are implemented with real logic
  - Dependency resolution with topological sort is implemented
  - Version archiving and rollback are implemented
  - Persistent JSON catalog management is implemented
  - Plugin registered in DataWarehouse.slnx
  - Build passes with zero errors
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.PluginMarketplace/DataWarehouse.Plugins.PluginMarketplace.csproj` succeeds
2. grep for `ProjectReference` in .csproj shows only SDK reference
3. grep for `marketplace.list|marketplace.install|marketplace.uninstall|marketplace.update` in PluginMarketplacePlugin.cs shows all 4 handlers
4. grep for `kernel.plugin.load|kernel.plugin.unload` shows message bus communication with kernel
5. No `TODO`, `HACK`, `FIXME`, `NotImplementedException`, `Task.Delay` patterns in the file
</verification>

<success_criteria>
- Plugin project compiles successfully with SDK-only dependency
- All 4 message handlers match what Marketplace.razor GUI expects
- Dependency resolution prevents broken installs
- Version archive enables rollback on failed updates
- Catalog persists to JSON files
- Plugin is registered in solution file
</success_criteria>

<output>
After completion, create `.planning/phases/17-marketplace/17-01-SUMMARY.md`
</output>
