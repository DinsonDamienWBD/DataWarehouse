---
phase: 85-competitive-edge
plan: 05
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/Database/StreamingSql/IStreamingSqlEngine.cs
  - DataWarehouse.SDK/Database/StreamingSql/StreamingSqlEngine.cs
  - DataWarehouse.SDK/Database/StreamingSql/WindowOperators.cs
autonomous: true

must_haves:
  truths:
    - "Continuous queries process streaming events with windowed aggregations"
    - "Tumbling, hopping, session, and sliding window types all produce correct results"
    - "Materialized views update in real-time as new events arrive"
    - "Stream-table joins correlate streaming events with static reference data"
  artifacts:
    - path: "DataWarehouse.SDK/Database/StreamingSql/IStreamingSqlEngine.cs"
      provides: "Contract for streaming SQL engine with continuous queries"
      exports: ["IStreamingSqlEngine", "ContinuousQuery", "StreamEvent", "MaterializedView"]
    - path: "DataWarehouse.SDK/Database/StreamingSql/StreamingSqlEngine.cs"
      provides: "Streaming SQL engine implementation with watermark and backpressure"
      exports: ["StreamingSqlEngine"]
    - path: "DataWarehouse.SDK/Database/StreamingSql/WindowOperators.cs"
      provides: "Window aggregation operators for all four window types"
      exports: ["TumblingWindow", "HoppingWindow", "SessionWindow", "SlidingWindow"]
  key_links:
    - from: "StreamingSqlEngine"
      to: "WindowOperators"
      via: "Engine dispatches events to active window instances"
      pattern: "IWindowOperator\\.Process"
    - from: "StreamingSqlEngine"
      to: "MaterializedView"
      via: "Query results update materialized views"
      pattern: "MaterializedView\\.Update"
---

<objective>
Implement a streaming SQL engine (ksqlDB-equivalent) with continuous queries, four window types (tumbling/hopping/session/sliding), materialized views, stream-table joins, watermark-based late event handling, and backpressure propagation.

Purpose: Streaming SQL is a competitive gap -- most storage products require external stream processors. Native streaming SQL enables real-time analytics without leaving the DataWarehouse ecosystem.
Output: IStreamingSqlEngine contract, StreamingSqlEngine, four window operator types.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Database/QueryResult.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Streaming SQL contracts and engine</name>
  <files>
    DataWarehouse.SDK/Database/StreamingSql/IStreamingSqlEngine.cs
    DataWarehouse.SDK/Database/StreamingSql/StreamingSqlEngine.cs
  </files>
  <action>
Create the StreamingSql directory under Database.

**IStreamingSqlEngine.cs**: Types and contract:
- `StreamEvent` record: `string Key`, `ReadOnlyMemory<byte> Value`, `DateTimeOffset EventTime`, `DateTimeOffset ProcessingTime`, `Dictionary<string, string>? Headers`
- `ContinuousQuery` record: `string QueryId` (GUID), `string SqlText`, `WindowSpec? Window`, `string? GroupByKey`, `AggregationKind[] Aggregations`, `string? JoinTable`, `string? JoinKey`
- `AggregationKind` enum: Count, Sum, Avg, Min, Max, First, Last, CountDistinct
- `WindowSpec` record: `WindowType Type`, `TimeSpan Size`, `TimeSpan? Advance` (for hopping), `TimeSpan? GapTimeout` (for session), `TimeSpan? GracePeriod` (late events)
- `WindowType` enum: Tumbling, Hopping, Session, Sliding
- `MaterializedView` class: `string ViewId`, `ContinuousQuery SourceQuery`, `ConcurrentDictionary<string, object> State`, `long Version` (incremented on update), `DateTimeOffset LastUpdated`
  - `void Update(string key, object value)` -- thread-safe state update with Interlocked version increment
  - `object? Get(string key)` -- read from materialized state
  - `IReadOnlyDictionary<string, object> Snapshot()` -- point-in-time snapshot
- `QueryOutput` record: `string QueryId`, `string Key`, `IReadOnlyDictionary<string, object> Values`, `DateTimeOffset WindowStart`, `DateTimeOffset WindowEnd`
- `IStreamingSqlEngine` interface:
  - `ValueTask<string> RegisterQueryAsync(ContinuousQuery query, CancellationToken ct)` -- returns queryId
  - `ValueTask UnregisterQueryAsync(string queryId, CancellationToken ct)`
  - `ValueTask IngestAsync(StreamEvent evt, CancellationToken ct)` -- feed event to all matching queries
  - `ValueTask IngestBatchAsync(IReadOnlyList<StreamEvent> events, CancellationToken ct)` -- batch ingest
  - `IAsyncEnumerable<QueryOutput> SubscribeAsync(string queryId, CancellationToken ct)` -- subscribe to query output
  - `MaterializedView? GetMaterializedView(string queryId)`
  - `StreamingEngineStats GetStats()`
- `StreamingEngineStats` record: `long TotalEventsIngested`, `long TotalOutputsEmitted`, `long LateEventsDropped`, `int ActiveQueries`, `int ActiveWindows`

**StreamingSqlEngine.cs**: Implementation:
- Constructor takes optional `ILogger` and `StreamingSqlEngineConfig config`
- `StreamingSqlEngineConfig` record: `int MaxActiveQueries` (default 1000), `int MaxBufferedEvents` (default 100_000), `TimeSpan WatermarkInterval` (default 1s), `bool EnableBackpressure` (default true)
- Maintains `ConcurrentDictionary<string, ActiveQuery>` for registered queries
- `ActiveQuery` internal class: holds ContinuousQuery definition, IWindowOperator instance, MaterializedView, Channel<QueryOutput> for subscribers, watermark (DateTimeOffset)
- IngestAsync: for each active query, dispatch event to its window operator; if event is late (eventTime < watermark - gracePeriod), increment LateEventsDropped
- Watermark advances as max(eventTime) - WatermarkInterval; window fires when watermark passes window end
- Backpressure: if Channel is full (BoundedChannelOptions with MaxBufferedEvents), IngestAsync returns ValueTask that completes only when space available (natural backpressure via Channel)
- Stream-table join: if query has JoinTable + JoinKey, look up static value from a ConcurrentDictionary<string, object> that can be populated via `RegisterTableAsync(string tableName, IReadOnlyDictionary<string, object> data)`
- Thread-safe via ConcurrentDictionary + Channel<T>; Interlocked for stats counters
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors.
  </verify>
  <done>IStreamingSqlEngine and StreamingSqlEngine exist with continuous query registration, event ingestion, watermark tracking, backpressure, and materialized views.</done>
</task>

<task type="auto">
  <name>Task 2: Window aggregation operators</name>
  <files>
    DataWarehouse.SDK/Database/StreamingSql/WindowOperators.cs
  </files>
  <action>
**WindowOperators.cs**: All four window types plus base:
- `IWindowOperator` interface:
  - `void ProcessEvent(StreamEvent evt)`
  - `IReadOnlyList<WindowResult> FireExpiredWindows(DateTimeOffset watermark)` -- returns results for windows that should fire
  - `int ActiveWindowCount { get; }`
- `WindowResult` record: `string GroupKey`, `DateTimeOffset WindowStart`, `DateTimeOffset WindowEnd`, `IReadOnlyDictionary<string, object> Aggregations`
- `WindowAggregator` class: accumulates aggregations for a single window:
  - `void Add(StreamEvent evt, string? groupByKey, AggregationKind[] aggregations)` -- updates running aggregates
  - `IReadOnlyDictionary<string, object> GetResult()` -- returns final aggregation values
  - Internally tracks: count (long), sum (double), min (double), max (double), first (object?), last (object?), distinct (HashSet<string>) per aggregation kind
  - Thread-safe via lock (windows are per-query, low contention)

**TumblingWindow**: Fixed-size, non-overlapping windows:
  - Implements IWindowOperator
  - Constructor takes `TimeSpan windowSize`, `string? groupByKey`, `AggregationKind[] aggregations`
  - ProcessEvent: compute window bucket as `eventTime.Ticks / windowSize.Ticks * windowSize.Ticks`; add to bucket's WindowAggregator
  - FireExpiredWindows: return results for all buckets where windowEnd <= watermark; remove fired buckets
  - Uses SortedDictionary<long, WindowAggregator> keyed by window start ticks

**HoppingWindow**: Fixed-size, overlapping by advance interval:
  - Constructor adds `TimeSpan advance`
  - ProcessEvent: event belongs to all windows where windowStart <= eventTime < windowStart + windowSize; compute all applicable window starts as `floor(eventTime / advance) * advance` going back `windowSize / advance` hops
  - FireExpiredWindows: same as tumbling but per-hop bucket

**SessionWindow**: Dynamic windows that close after gap of inactivity:
  - Constructor takes `TimeSpan gapTimeout`
  - ProcessEvent: find existing session for groupKey where lastEventTime + gapTimeout >= eventTime; if found, extend session; if not, create new session
  - FireExpiredWindows: fire sessions where lastEventTime + gapTimeout <= watermark
  - Uses Dictionary<string, SessionState> keyed by groupKey; SessionState has start, lastEvent, aggregator

**SlidingWindow**: Emit result whenever window contents change:
  - Constructor takes `TimeSpan windowSize`
  - ProcessEvent: add event to time-ordered list; emit window result covering [eventTime - windowSize, eventTime]
  - FireExpiredWindows: purge events older than watermark - windowSize
  - Uses LinkedList<StreamEvent> for efficient removal of old events

All operators handle the case where groupByKey is null (single global group) vs non-null (per-key groups).
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors and 0 warnings.
  </verify>
  <done>All four window operators (tumbling, hopping, session, sliding) implement IWindowOperator with correct windowing semantics and per-group aggregation.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors, 0 warnings
- All three files exist under DataWarehouse.SDK/Database/StreamingSql/
- IStreamingSqlEngine defines RegisterQuery, Ingest, Subscribe, GetMaterializedView
- StreamingSqlEngine handles watermarks, backpressure via Channel, and stream-table joins
- All four window types produce correct windowed aggregation results
</verification>

<success_criteria>
- Streaming SQL engine contract and implementation exist in SDK
- Four window types (tumbling, hopping, session, sliding) with correct semantics
- Materialized views with thread-safe state and versioning
- Watermark-based late event handling with configurable grace periods
- Backpressure via bounded Channel when consumers are slow
- Stream-table joins for correlating with static reference data
- Full solution builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/85-competitive-edge/85-05-SUMMARY.md`
</output>
