---
phase: 85-competitive-edge
plan: 06
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/IO/DeterministicIo/IDeterministicIoPath.cs
  - DataWarehouse.SDK/IO/DeterministicIo/PreAllocatedBufferPool.cs
  - DataWarehouse.SDK/IO/DeterministicIo/DeadlineScheduler.cs
autonomous: true

must_haves:
  truths:
    - "Deterministic I/O mode uses only pre-allocated buffers on the hot path"
    - "WCET annotations exist on all critical I/O operations"
    - "Deadline scheduler enforces bounded-latency guarantees"
  artifacts:
    - path: "DataWarehouse.SDK/IO/DeterministicIo/IDeterministicIoPath.cs"
      provides: "Contract for deterministic bounded-latency I/O with WCET metadata"
      exports: ["IDeterministicIoPath", "WcetAnnotation", "IoDeadline", "DeterministicIoConfig"]
    - path: "DataWarehouse.SDK/IO/DeterministicIo/PreAllocatedBufferPool.cs"
      provides: "Fixed-size pre-allocated buffer pool with zero dynamic allocation"
      exports: ["PreAllocatedBufferPool", "PooledBuffer"]
    - path: "DataWarehouse.SDK/IO/DeterministicIo/DeadlineScheduler.cs"
      provides: "EDF deadline scheduler for bounded-latency I/O operations"
      exports: ["DeadlineScheduler", "ScheduledIoOperation"]
  key_links:
    - from: "DeadlineScheduler"
      to: "PreAllocatedBufferPool"
      via: "Acquires buffer before scheduling I/O"
      pattern: "PreAllocatedBufferPool\\.Rent"
    - from: "IDeterministicIoPath"
      to: "DeadlineScheduler"
      via: "All deterministic I/O goes through scheduler"
      pattern: "DeadlineScheduler\\.Schedule"
---

<objective>
Implement deterministic I/O mode for safety-critical deployments: pre-allocated buffer pools with zero hot-path dynamic allocation, WCET (Worst Case Execution Time) annotations on critical paths, and an EDF (Earliest Deadline First) scheduler with bounded-latency guarantees.

Purpose: Safety-critical environments (DO-178C, IEC 61508) require bounded, predictable I/O latency. This makes DataWarehouse suitable for avionics, automotive, industrial control, and medical device storage.
Output: IDeterministicIoPath contract, PreAllocatedBufferPool, DeadlineScheduler.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/IO/PushToPullStreamAdapter.cs
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Deterministic I/O contract and pre-allocated buffer pool</name>
  <files>
    DataWarehouse.SDK/IO/DeterministicIo/IDeterministicIoPath.cs
    DataWarehouse.SDK/IO/DeterministicIo/PreAllocatedBufferPool.cs
  </files>
  <action>
Create the DeterministicIo directory under IO.

**IDeterministicIoPath.cs**: Types and contract for deterministic I/O:
- `WcetAnnotation` attribute: `[AttributeUsage(AttributeTargets.Method)]` with `TimeSpan MaxExecutionTime`, `string Justification`, `string CertificationRef` (e.g., "DO-178C DAL-A"). Apply this to all deterministic I/O methods.
- `IoDeadline` record: `DateTimeOffset Deadline`, `TimeSpan MaxLatency`, `IoDeadlinePriority Priority`, `string OperationId`
- `IoDeadlinePriority` enum: Critical (must complete or system faults), High, Normal, BestEffort
- `DeterministicIoConfig` record: `int PreAllocatedBufferCount` (default 1024), `int BufferSizeBytes` (default 4096, matches VDE block size), `TimeSpan DefaultDeadline` (default 10ms), `bool EnableWcetEnforcement` (default true), `bool FailOnDeadlineMiss` (default false for logging only, true for safety-critical)
- `DeadlineMissAction` enum: Log, Throw, CircuitBreak
- `IDeterministicIoPath` interface:
  - `[WcetAnnotation(MaxExecutionTimeMs = 10, Justification = "Single block read from pre-allocated pool")]` `ValueTask<PooledBuffer> ReadBlockDeterministicAsync(long blockAddress, IoDeadline deadline, CancellationToken ct)`
  - `[WcetAnnotation(MaxExecutionTimeMs = 10)]` `ValueTask WriteBlockDeterministicAsync(long blockAddress, ReadOnlyMemory<byte> data, IoDeadline deadline, CancellationToken ct)`
  - `[WcetAnnotation(MaxExecutionTimeMs = 50)]` `ValueTask<int> ReadBatchDeterministicAsync(long startBlock, int count, Memory<byte> destination, IoDeadline deadline, CancellationToken ct)`
  - `DeterministicIoStats GetStats()`
- `DeterministicIoStats` record: `long TotalOperations`, `long DeadlineMisses`, `double P99LatencyMicroseconds`, `double MaxLatencyMicroseconds`, `int ActiveBuffersInUse`, `int TotalBuffersAllocated`
- `SafetyCertificationInfo` record: `string Standard` (e.g., "DO-178C"), `string Level` (e.g., "DAL-A"), `IReadOnlyDictionary<string, string> TraceabilityMatrix` -- maps requirement IDs to method names

**PreAllocatedBufferPool.cs**: Fixed-size buffer pool with zero dynamic allocation on hot path:
- `PooledBuffer` struct implementing IDisposable: `Memory<byte> Memory`, `int Index` (pool slot), returns to pool on Dispose
- `PreAllocatedBufferPool` class:
  - Constructor takes `int bufferCount`, `int bufferSize`; allocates ALL buffers upfront using `GC.AllocateArray<byte>(bufferSize, pinned: true)` for each slot (pinned for P/Invoke safety with io_uring)
  - Uses `ConcurrentQueue<int>` as free-list of available slot indices (lock-free)
  - `bool TryRent(out PooledBuffer buffer)` -- dequeue from free list, return false if exhausted (no allocation, no waiting)
  - `PooledBuffer Rent(TimeSpan timeout)` -- spin-wait up to timeout, then throw `BufferExhaustedException` (for deterministic deadline failure)
  - `void Return(int index)` -- enqueue index back to free list; clear buffer bytes with `Memory.Span.Clear()` for security
  - `int Available` property -- free list count (approximate, ConcurrentQueue.Count)
  - `int Total` property -- total buffer count
  - Implements IDisposable -- unpins and releases all buffers
  - IMPORTANT: No `new byte[]` on hot path. No ArrayPool. No MemoryPool. Only pre-allocated pinned arrays.

Namespace: `DataWarehouse.SDK.IO.DeterministicIo`
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors.
  </verify>
  <done>IDeterministicIoPath contract with WCET annotations and PreAllocatedBufferPool with pinned pre-allocated buffers and lock-free free list exist.</done>
</task>

<task type="auto">
  <name>Task 2: Earliest Deadline First scheduler</name>
  <files>
    DataWarehouse.SDK/IO/DeterministicIo/DeadlineScheduler.cs
  </files>
  <action>
**DeadlineScheduler.cs**: EDF (Earliest Deadline First) I/O scheduler:
- `ScheduledIoOperation` record: `string OperationId` (GUID), `IoDeadline Deadline`, `Func<PooledBuffer, ValueTask> Execute`, `TaskCompletionSource<bool> Completion`, `DateTimeOffset SubmittedAt`
- `DeadlineScheduler` class:
  - Constructor takes `PreAllocatedBufferPool bufferPool`, `DeterministicIoConfig config`, and optional `ILogger`
  - Internal: `PriorityQueue<ScheduledIoOperation, DateTimeOffset>` ordered by deadline (earliest first)
  - `ValueTask<bool> ScheduleAsync(ScheduledIoOperation operation, CancellationToken ct)` -- enqueue to priority queue; if operation deadline already passed, execute immediately or fail based on FailOnDeadlineMiss
  - Processing loop (runs on dedicated thread via `Thread` with `IsBackground = false` and `ThreadPriority.AboveNormal`):
    - Dequeue highest-priority operation
    - TryRent buffer from pool (if exhausted: deadline miss)
    - Execute operation with rented buffer
    - Measure execution time via Stopwatch
    - If execution time exceeds WCET annotation: log warning; if FailOnDeadlineMiss: throw `DeadlineMissException`
    - Return buffer to pool
    - Complete the TaskCompletionSource
  - `DeadlineMissException` : Exception with `string OperationId`, `TimeSpan Actual`, `TimeSpan MaxAllowed`
  - Latency tracking: maintain running min/max/p99 using a circular buffer of last 10_000 latency measurements (pre-allocated long[] array, no List, no allocation)
  - `SchedulerStats GetStats()` -- return total operations, deadline misses, p99/max latency, queue depth, buffer utilization
  - `SchedulerStats` record: `long TotalScheduled`, `long TotalCompleted`, `long DeadlineMisses`, `double P99LatencyUs`, `double MaxLatencyUs`, `int CurrentQueueDepth`, `int BuffersInUse`
  - Graceful shutdown via CancellationToken: drain queue, complete all pending operations

Thread safety: PriorityQueue protected by SemaphoreSlim(1,1) (not lock -- allows async wait); dedicated thread avoids ThreadPool starvation.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors and 0 warnings.
  </verify>
  <done>DeadlineScheduler implements EDF scheduling with pre-allocated latency tracking, dedicated I/O thread, WCET enforcement, and graceful shutdown.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors, 0 warnings
- All three files exist under DataWarehouse.SDK/IO/DeterministicIo/
- PreAllocatedBufferPool uses GC.AllocateArray with pinned=true, no hot-path allocation
- DeadlineScheduler uses PriorityQueue for EDF ordering
- WcetAnnotation attribute exists and is applied to IDeterministicIoPath methods
</verification>

<success_criteria>
- Deterministic I/O contract with WCET annotations and safety certification traceability
- Pre-allocated pinned buffer pool with lock-free ConcurrentQueue free list
- Zero dynamic allocation on hot I/O path
- EDF deadline scheduler on dedicated thread with latency tracking
- Deadline miss detection with configurable response (log, throw, circuit break)
- Full solution builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/85-competitive-edge/85-06-SUMMARY.md`
</output>
