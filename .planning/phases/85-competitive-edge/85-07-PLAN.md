---
phase: 85-competitive-edge
plan: 07
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Format/WideBlockAddress.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/AddressWidthDescriptor.cs
  - DataWarehouse.SDK/AI/MlPipeline/VdeFeatureStore.cs
autonomous: true

must_haves:
  truths:
    - "128-bit block addresses compile and represent yottabyte-scale VDE capacity"
    - "Address width is declared in superblock and all pointers use exactly that width"
    - "ML pipeline stores feature data in VDE Intelligence Cache region"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/WideBlockAddress.cs"
      provides: "Variable-width block address type (32/48/64/128 bits) with arithmetic"
      exports: ["WideBlockAddress", "AddressWidth"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/AddressWidthDescriptor.cs"
      provides: "Superblock address width declaration and width promotion engine"
      exports: ["AddressWidthDescriptor", "AddressWidthPromotionEngine"]
    - path: "DataWarehouse.SDK/AI/MlPipeline/VdeFeatureStore.cs"
      provides: "ML feature store integrated with VDE Intelligence Cache region"
      exports: ["VdeFeatureStore", "FeatureVector", "ModelVersion"]
  key_links:
    - from: "WideBlockAddress"
      to: "SuperblockV2"
      via: "Superblock declares AddressWidth used for all on-disk pointers"
      pattern: "AddressWidth"
    - from: "VdeFeatureStore"
      to: "Intelligence Cache region"
      via: "Stores feature vectors in VDE region for ML pipelines"
      pattern: "IntelligenceCache"
---

<objective>
Implement 128-bit block addressing for yottabyte-scale VDE capacity (forward-compatible, activated by config flag) and an ML pipeline feature store integrated with the VDE Intelligence Cache region for model versioning and training data lineage.

Purpose: 128-bit addressing removes capacity limits that block competitors. ML pipeline integration makes the VDE a first-class citizen for ML workflows, not just storage.
Output: WideBlockAddress type, AddressWidthDescriptor, VdeFeatureStore.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockAddressing.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Regions/
@DataWarehouse.SDK/AI/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Variable-width block addressing (32/48/64/128-bit)</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/WideBlockAddress.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/AddressWidthDescriptor.cs
  </files>
  <action>
**WideBlockAddress.cs**: Variable-width block address type:
- `AddressWidth` enum: Width32 = 4, Width48 = 6, Width64 = 8, Width128 = 16 -- values are byte counts on disk
- `WideBlockAddress` readonly struct implementing IEquatable<WideBlockAddress>, IComparable<WideBlockAddress>:
  - Internal storage: `UInt128 Value` (always 128-bit internally for simplicity)
  - `AddressWidth Width` property -- the on-disk width
  - Constructors: from long (for 32/48/64-bit), from UInt128 (for 128-bit), from ReadOnlySpan<byte> (deserialize from on-disk width)
  - Arithmetic: operator+ (WideBlockAddress, long offset), operator- (WideBlockAddress, WideBlockAddress -> long delta), operator++ , operator--
  - Comparison: <, >, <=, >=, ==, != using UInt128 comparison
  - `void WriteTo(Span<byte> destination)` -- writes exactly `Width` bytes in little-endian
  - `static WideBlockAddress ReadFrom(ReadOnlySpan<byte> source, AddressWidth width)` -- reads exactly `width` bytes
  - `long ToInt64()` -- throws OverflowException if value exceeds long.MaxValue (for backward compat code paths)
  - `bool FitsIn(AddressWidth width)` -- checks if current value can be represented in narrower width
  - `static WideBlockAddress MaxValue(AddressWidth width)` -- returns maximum address for given width
  - `static long MaxBlockCount(AddressWidth width)` -- returns max blocks addressable (2^32, 2^48, 2^64, 2^128)
  - `static string MaxCapacityHuman(AddressWidth width, int blockSize = 4096)` -- returns human-readable capacity ("16 TB", "1 EB", "1 YB", "340 undecillion bytes")
  - ToString: hex representation with width prefix e.g., "32:0x00001000" or "128:0x000000000000000000001000"

**AddressWidthDescriptor.cs**: Superblock integration and width promotion:
- `AddressWidthDescriptor` record: `AddressWidth CurrentWidth`, `AddressWidth MinReaderVersion` (minimum width a reader must support to open this VDE), `bool PromotionInProgress`, `AddressWidth? TargetWidth` (during promotion)
- `AddressWidthPromotionEngine` class:
  - Constructor takes `AddressWidthDescriptor current`, `ILogger`
  - `bool ShouldPromote(long currentBlockCount, AddressWidth currentWidth)` -- returns true if block count exceeds 75% of max for current width (to promote before running out)
  - `AddressWidth RecommendWidth(long currentBlockCount)` -- returns smallest width that fits with 4x headroom
  - `PromotionPlan CreatePromotionPlan(AddressWidth targetWidth)` -- generates plan for online width promotion
  - `PromotionPlan` record: `AddressWidth From`, `AddressWidth To`, `long EstimatedBlocksToRewrite` (all metadata blocks with pointers), `TimeSpan EstimatedDuration`, `bool RequiresMinReaderVersionBump`
  - Width promotion is background-safe: old-width readers can still read data blocks (only metadata pointers change)
  - `static int BytesPerPointer(AddressWidth width)` -- simply returns (int)width enum value
  - Capacity table for reference (4KB block size):
    - 32-bit: 16 TB (2^32 * 4KB)
    - 48-bit: 1 EB (2^48 * 4KB)
    - 64-bit: 64 ZB (2^64 * 4KB)
    - 128-bit: 1.36e27 YB (2^128 * 4KB, effectively unlimited)

Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors. WideBlockAddress arithmetic and serialization methods exist.
  </verify>
  <done>WideBlockAddress supports 32/48/64/128-bit on-disk representation with UInt128 internal storage, and AddressWidthPromotionEngine handles online width upgrades.</done>
</task>

<task type="auto">
  <name>Task 2: ML pipeline VDE feature store</name>
  <files>
    DataWarehouse.SDK/AI/MlPipeline/VdeFeatureStore.cs
  </files>
  <action>
Create the MlPipeline directory under AI.

**VdeFeatureStore.cs**: ML pipeline integrated with VDE Intelligence Cache:
- `FeatureVector` record: `string FeatureSetId`, `string EntityId`, `float[] Values`, `DateTimeOffset ComputedAt`, `string? ModelVersion`, `Dictionary<string, string>? Metadata`
- `ModelVersion` record: `string ModelId`, `int Version`, `string Algorithm`, `DateTimeOffset TrainedAt`, `string DataLineageHash` (SHA-256 of training data), `Dictionary<string, double> Metrics` (e.g., accuracy, f1, loss), `ModelStatus Status`
- `ModelStatus` enum: Training, Validating, Active, Retired, Failed
- `FeatureSetDefinition` record: `string FeatureSetId`, `string[] FeatureNames`, `FeatureType[] FeatureTypes`, `string Description`
- `FeatureType` enum: Numeric, Categorical, Binary, Embedding, Timestamp, Text
- `TrainingDataLineage` record: `string DatasetId`, `string SourceVdePath`, `long RowCount`, `DateTimeOffset ExtractedAt`, `string FilterCriteria`, `string SchemaHash`
- `InferenceResult` record: `string ModelId`, `string EntityId`, `float[] Predictions`, `float Confidence`, `DateTimeOffset InferredAt`, `TimeSpan Latency`

- `VdeFeatureStore` class:
  - Constructor takes optional `ILogger`
  - Feature storage:
    - `ValueTask StoreFeatureVectorAsync(FeatureVector vector, CancellationToken ct)` -- stores in Intelligence Cache region (ConcurrentDictionary keyed by `{FeatureSetId}:{EntityId}`)
    - `ValueTask<FeatureVector?> GetFeatureVectorAsync(string featureSetId, string entityId, CancellationToken ct)`
    - `ValueTask<IReadOnlyList<FeatureVector>> GetFeatureSetAsync(string featureSetId, int limit = 1000, CancellationToken ct = default)`
  - Model versioning:
    - `ValueTask RegisterModelAsync(ModelVersion model, CancellationToken ct)` -- stores model metadata; validates version is monotonically increasing per modelId
    - `ValueTask<ModelVersion?> GetActiveModelAsync(string modelId, CancellationToken ct)` -- returns latest Active version
    - `ValueTask<IReadOnlyList<ModelVersion>> GetModelHistoryAsync(string modelId, CancellationToken ct)` -- all versions for audit
    - `ValueTask PromoteModelAsync(string modelId, int version, CancellationToken ct)` -- sets version to Active, retires previous
  - Training data lineage:
    - `ValueTask RecordLineageAsync(TrainingDataLineage lineage, CancellationToken ct)` -- tracks which data trained which model
    - `ValueTask<IReadOnlyList<TrainingDataLineage>> GetLineageForModelAsync(string modelId, int version, CancellationToken ct)`
  - Inference caching:
    - `ValueTask CacheInferenceResultAsync(InferenceResult result, CancellationToken ct)` -- stores in Intelligence Cache for fast re-use
    - `ValueTask<InferenceResult?> GetCachedInferenceAsync(string modelId, string entityId, CancellationToken ct)`
  - `FeatureStoreStats GetStats()` -- record: `long TotalVectors`, `int FeatureSets`, `int Models`, `int ActiveModels`, `long CachedInferences`

All storage uses ConcurrentDictionary internally (will be backed by VDE region in Phase 87 when ARC cache is available). Thread-safe for concurrent ML pipeline access.

Namespace: `DataWarehouse.SDK.AI.MlPipeline`
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors and 0 warnings.
  </verify>
  <done>VdeFeatureStore provides feature vector storage, model versioning with lineage tracking, inference caching, and model promotion lifecycle.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors, 0 warnings
- WideBlockAddress supports all four widths with correct serialization byte counts
- AddressWidthPromotionEngine detects when promotion is needed and generates migration plans
- VdeFeatureStore stores features, versions models, tracks lineage, and caches inferences
</verification>

<success_criteria>
- 128-bit block addressing compiles and is forward-compatible
- Variable-width on-disk pointer representation (4/6/8/16 bytes)
- Online address width promotion with background safety
- ML feature store with model versioning and lineage
- Inference result caching in Intelligence Cache region
- Full solution builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/85-competitive-edge/85-07-SUMMARY.md`
</output>
