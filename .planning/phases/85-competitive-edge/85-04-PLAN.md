---
phase: 85-competitive-edge
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Security/OsHardening/SeccompProfile.cs
  - DataWarehouse.SDK/Security/OsHardening/PluginSandbox.cs
  - DataWarehouse.SDK/Security/OsHardening/SecurityVerification.cs
autonomous: true

must_haves:
  truths:
    - "Linux processes run under seccomp-bpf with a defined syscall allowlist"
    - "Untrusted plugin code runs in isolated namespaces with minimal privilege"
    - "ASLR and W^X enforcement are verified at startup with clear pass/fail"
  artifacts:
    - path: "DataWarehouse.SDK/Security/OsHardening/SeccompProfile.cs"
      provides: "Seccomp-BPF profile definition and Linux syscall filtering"
      exports: ["SeccompProfile", "SeccompRule", "SyscallAction"]
    - path: "DataWarehouse.SDK/Security/OsHardening/PluginSandbox.cs"
      provides: "Process compartmentalization for untrusted plugins"
      exports: ["PluginSandbox", "SandboxConfig", "SandboxCapabilities"]
    - path: "DataWarehouse.SDK/Security/OsHardening/SecurityVerification.cs"
      provides: "Runtime ASLR, W^X, and security posture verification"
      exports: ["SecurityVerification", "SecurityPosture"]
  key_links:
    - from: "PluginSandbox"
      to: "SeccompProfile"
      via: "Applies seccomp filter to sandboxed plugin process"
      pattern: "SeccompProfile"
    - from: "SecurityVerification"
      to: "SecurityPosture"
      via: "Aggregates all OS-level security checks into posture report"
      pattern: "SecurityPosture"
---

<objective>
Implement OS-level security hardening: seccomp-bpf syscall filtering for Linux, plugin process compartmentalization (Linux namespaces + Windows job objects), W^X enforcement verification, ASLR validation, and AppArmor/SELinux profile generation.

Purpose: Defense-in-depth at the OS level. Even if application-level security is breached, OS-level sandboxing limits blast radius. Competing products rarely provide this level of OS integration.
Output: SeccompProfile, PluginSandbox, SecurityVerification with startup checks.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Security/SecurityContracts.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Seccomp profile and plugin sandbox</name>
  <files>
    DataWarehouse.SDK/Security/OsHardening/SeccompProfile.cs
    DataWarehouse.SDK/Security/OsHardening/PluginSandbox.cs
  </files>
  <action>
Create the OsHardening directory under Security.

**SeccompProfile.cs**: Seccomp-BPF profile definition for Linux syscall filtering:
- `SyscallAction` enum: Allow, Kill, Trap, Errno, Log, Trace
- `SeccompRule` record: `int SyscallNumber`, `SyscallAction Action`, `string? SyscallName` (for readability)
- `SeccompProfile` class:
  - `string Name` property (e.g., "datawarehouse-core", "datawarehouse-plugin")
  - `SyscallAction DefaultAction` (default Kill -- deny all not explicitly allowed)
  - `IReadOnlyList<SeccompRule> Rules` -- the allowlist
  - Static `SeccompProfile CreateCoreProfile()` -- allowlist for core DW process: read, write, open, close, fstat, mmap, mprotect, munmap, brk, rt_sigaction, rt_sigprocmask, ioctl, pread64, pwrite64, access, pipe, select, sched_yield, mremap, msync, madvise, shmget, shmat, socket, connect, sendto, recvfrom, sendmsg, recvmsg, bind, listen, accept, clone, execve, exit, exit_group, wait4, kill, fcntl, flock, fsync, fdatasync, truncate, ftruncate, getdents, getcwd, chdir, mkdir, rename, unlink, readlink, chmod, chown, umask, gettimeofday, getrlimit, getuid, getgid, getpid, gettid, epoll_create, epoll_ctl, epoll_wait, futex, set_robust_list, get_robust_list, clock_gettime, clock_nanosleep, openat, newfstatat, io_uring_setup, io_uring_enter, io_uring_register
  - Static `SeccompProfile CreatePluginProfile()` -- restricted: no execve, no socket (unless network plugin), no clone, no mount/umount, no ptrace
  - `string GenerateBpfAssembly()` -- generate libseccomp-compatible BPF assembly text
  - `string GenerateAppArmorProfile(string binaryPath)` -- generate AppArmor profile text
  - `string GenerateSelinuxPolicy(string moduleNamespace)` -- generate SELinux .te policy module text

**PluginSandbox.cs**: Process compartmentalization:
- `SandboxCapabilities` flags enum: Network, FileSystem, IPC, ProcessCreation, DeviceAccess, SystemAdmin
- `SandboxConfig` record: `SandboxCapabilities AllowedCapabilities`, `string? RootfsPath` (chroot for Linux), `long MemoryLimitBytes`, `int CpuPercent`, `SeccompProfile? SeccompFilter`
- `PluginSandbox` class:
  - Constructor takes `SandboxConfig config` and `ILogger`
  - `SandboxedProcess LaunchPlugin(string pluginAssemblyPath, string[] args)` -- on Linux: clone with CLONE_NEWNS|CLONE_NEWPID|CLONE_NEWNET (if no Network cap), apply seccomp, set cgroup limits. On Windows: create Job Object with JOB_OBJECT_LIMIT_PROCESS_MEMORY, JOB_OBJECT_LIMIT_ACTIVE_PROCESS, assign integrity level (Low for untrusted, Medium for trusted)
  - `SandboxedProcess` record: `int ProcessId`, `SandboxConfig AppliedConfig`, `bool IsIsolated`, `string IsolationMethod` (e.g., "Linux namespaces+seccomp" or "Windows Job Object+Integrity Level")
  - Static `SandboxConfig CreateDefaultForUntrustedPlugin()` -- no Network, no ProcessCreation, no SystemAdmin, 512MB memory, 25% CPU, plugin seccomp profile
  - Static `SandboxConfig CreateDefaultForTrustedPlugin()` -- Network + FileSystem + IPC, 2GB memory, 100% CPU, core seccomp profile
  - On unsupported platforms (macOS, etc.), log warning and return `IsIsolated = false`

Namespace: `DataWarehouse.SDK.Security.OsHardening`
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors.
  </verify>
  <done>SeccompProfile generates BPF/AppArmor/SELinux profiles; PluginSandbox launches plugins in isolated processes with OS-level restrictions.</done>
</task>

<task type="auto">
  <name>Task 2: Security posture verification at startup</name>
  <files>
    DataWarehouse.SDK/Security/OsHardening/SecurityVerification.cs
  </files>
  <action>
**SecurityVerification.cs**: Runtime security posture checks:
- `SecurityCheck` record: `string Name`, `bool Passed`, `string Details`, `SecuritySeverity Severity`
- `SecuritySeverity` enum: Critical, High, Medium, Low, Info
- `SecurityPosture` record: `IReadOnlyList<SecurityCheck> Checks`, `bool AllCriticalPassed`, `bool AllHighPassed`, `int Score` (0-100), `DateTimeOffset CheckedAt`
- `SecurityVerification` static class:
  - `SecurityPosture VerifyAll()` -- runs all checks and returns aggregate posture
  - Individual check methods (all return SecurityCheck):
    - `CheckAslr()` -- Linux: read /proc/sys/kernel/randomize_va_space (expect 2). Windows: check ProcessMitigationPolicy via GetProcessMitigationPolicy (or check IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE). Return Passed/Failed with details.
    - `CheckWxEnforcement()` -- verify no memory region is both writable and executable: Linux: parse /proc/self/maps for regions with "rwx" (should be zero). Windows: VirtualQuery walk checking PAGE_EXECUTE_READWRITE (should be zero).
    - `CheckSeccompActive()` -- Linux only: read /proc/self/status for Seccomp field (expect 2 for filter mode). Non-Linux: return Info severity "Not applicable".
    - `CheckDepEnabled()` -- Windows: verify DEP (Data Execution Prevention) is enabled. Linux: check NX bit support.
    - `CheckStackCanaries()` -- check if compiler stack protection is active (heuristic: presence of __stack_chk_fail in binary, or runtime check)
    - `CheckKernelHardening()` -- Linux: check /proc/sys/kernel/kptr_restrict (expect >=1), /proc/sys/kernel/dmesg_restrict (expect 1), /proc/sys/kernel/perf_event_paranoid (expect >=2)
  - `int CalculateScore(IReadOnlyList<SecurityCheck> checks)` -- weighted: Critical=25pts each, High=15pts, Medium=10pts, Low=5pts; score = passed_weight / total_weight * 100
  - All file reads wrapped in try/catch -- non-Linux returns Info "Not applicable" (not failure)

XML documentation explains each check and its security impact.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors and 0 warnings. SecurityVerification.VerifyAll() is callable.
  </verify>
  <done>SecurityVerification runs ASLR, W^X, seccomp, DEP, stack canary, and kernel hardening checks, producing a scored SecurityPosture report.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors, 0 warnings
- All three files exist under DataWarehouse.SDK/Security/OsHardening/
- SeccompProfile.CreateCoreProfile() and CreatePluginProfile() return profiles with correct syscall allowlists
- PluginSandbox handles both Linux (namespace+seccomp) and Windows (Job Object+Integrity) paths
- SecurityVerification.VerifyAll() produces SecurityPosture with score
</verification>

<success_criteria>
- Seccomp-BPF profiles defined for core process and plugin isolation
- AppArmor and SELinux profile generation from same rule definitions
- Plugin sandbox supports Linux namespaces and Windows job objects
- Runtime ASLR, W^X, DEP verification at startup
- Security posture scoring (0-100) with severity-weighted checks
- Graceful degradation on unsupported platforms
- Full solution builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/85-competitive-edge/85-04-SUMMARY.md`
</output>
