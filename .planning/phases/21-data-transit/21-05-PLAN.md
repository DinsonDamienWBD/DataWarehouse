---
phase: 21-data-transit
plan: 05
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Layers/CompressionInTransitLayer.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Layers/EncryptionInTransitLayer.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Audit/TransitAuditService.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/UltimateDataTransitPlugin.cs
  - DataWarehouse.SDK/Contracts/Transit/TransitAuditTypes.cs
  - Metadata/TODO.md
autonomous: true

must_haves:
  truths:
    - "CompressionInTransitLayer wraps any IDataTransitStrategy as a decorator, compressing data before passing to inner strategy"
    - "EncryptionInTransitLayer wraps any IDataTransitStrategy as a decorator, encrypting data before passing to inner strategy"
    - "Layer ordering is enforced: compress-then-encrypt outbound, decrypt-then-decompress inbound (per research pitfall 4)"
    - "Layers delegate to SDK ITransitCompression and ITransitEncryption via message bus (NOT direct plugin reference)"
    - "TransitAuditService logs all transfer events with strategy used, bytes, duration, source, destination"
    - "Audit entries are published to message bus for cross-plugin consumption"
    - "UltimateDataTransitPlugin integrates layers, QoS, cost router, and audit into transfer pipeline"
    - "Other plugins can delegate transport to UltimateDataTransit via message bus request/response"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/Layers/CompressionInTransitLayer.cs"
      provides: "Decorator wrapping IDataTransitStrategy with compression via message bus"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/Layers/EncryptionInTransitLayer.cs"
      provides: "Decorator wrapping IDataTransitStrategy with encryption via message bus"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/Audit/TransitAuditService.cs"
      provides: "Structured audit trail for all transit operations"
      min_lines: 120
    - path: "DataWarehouse.SDK/Contracts/Transit/TransitAuditTypes.cs"
      provides: "Audit record types for transit operations"
      exports: ["TransitAuditEntry", "TransitAuditEventType"]
  key_links:
    - from: "CompressionInTransitLayer.TransferAsync"
      to: "SDK ITransitCompression"
      via: "message bus request for compression"
      pattern: "MessageBus.*compression|compress.*transit"
    - from: "EncryptionInTransitLayer.TransferAsync"
      to: "SDK ITransitEncryption"
      via: "message bus request for encryption"
      pattern: "MessageBus.*encryption|encrypt.*transit"
    - from: "TransitAuditService"
      to: "message bus"
      via: "publishes transit.audit.entry events"
      pattern: "transit\\.audit\\.entry|PublishAsync"
    - from: "UltimateDataTransitPlugin message handler"
      to: "transit.transfer.request topic"
      via: "handles requests from other plugins (Replication, DataIntegration, etc.)"
      pattern: "transit\\.transfer\\.request|SubscribeAsync|HandleTransferRequest"
---

<objective>
Implement composable decorator layers (compression, encryption), audit trail service, and cross-plugin integration to complete the UltimateDataTransit plugin.

Purpose: Enable pipeline composition (compress then encrypt any strategy), compliance audit logging, and inter-plugin transport delegation
Output: Decorator layers, audit service, cross-plugin message bus handlers, and final integration in orchestrator
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-data-transit/21-RESEARCH.md
@.planning/phases/21-data-transit/21-01-SUMMARY.md

# SDK contracts
@DataWarehouse.SDK/Contracts/Transit/IDataTransitStrategy.cs
@DataWarehouse.SDK/Contracts/Transit/DataTransitTypes.cs
@DataWarehouse.SDK/Contracts/Transit/DataTransitStrategyBase.cs
@DataWarehouse.SDK/Contracts/Transit/ITransitOrchestrator.cs
@DataWarehouse.SDK/Security/Transit/ITransitEncryption.cs
@DataWarehouse.SDK/Security/Transit/ITransitCompression.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs

# Plugin from prior plans
@Plugins/DataWarehouse.Plugins.UltimateDataTransit/UltimateDataTransitPlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateDataTransit/TransitMessageTopics.cs
@Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/QoSThrottlingManager.cs
@Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/CostAwareRouter.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement composable decorator layers (compression and encryption) and SDK audit types</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Layers/CompressionInTransitLayer.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Layers/EncryptionInTransitLayer.cs
    DataWarehouse.SDK/Contracts/Transit/TransitAuditTypes.cs
  </files>
  <action>
**File 1: CompressionInTransitLayer.cs**
Create `internal sealed class CompressionInTransitLayer : IDataTransitStrategy` in namespace `DataWarehouse.Plugins.UltimateDataTransit.Layers`.

This is a **decorator** wrapping any `IDataTransitStrategy` (follows research Pattern 2):
- Constructor: `CompressionInTransitLayer(IDataTransitStrategy inner, IMessageBus messageBus)`
- Private fields: `_inner` (the wrapped strategy), `_messageBus` (for requesting compression from UltimateCompression plugin)
- `StrategyId` => `$"compressed-{_inner.StrategyId}"`
- `Name` => `$"Compressed {_inner.Name}"`
- `Capabilities` => copies inner capabilities with `SupportsCompression = true`

**TransferAsync:**
1. Check `request.Layers?.EnableCompression == true` (if not, pass through to inner directly)
2. **Compress outbound data:** Request compression via message bus:
   - Send `PluginMessage` to topic `"compression.compress"` with payload containing data stream and algorithm preference from `request.Layers.CompressionAlgorithm`
   - Receive compressed stream in response
   - If message bus unavailable or compression plugin not responding, fall back to `System.IO.Compression.GZipStream` wrapping the data stream directly
3. Create modified request with compressed stream: `request with { DataStream = compressedStream, Metadata = metadata + {"compressed": "true", "originalSize": originalSize} }`
4. Call `_inner.TransferAsync(modifiedRequest, progress, ct)`
5. Return result with metadata indicating compression was applied and compression ratio

**Passthrough methods:** `IsAvailableAsync`, `ResumeTransferAsync`, `CancelTransferAsync`, `GetHealthAsync` all delegate to `_inner`.

**File 2: EncryptionInTransitLayer.cs**
Create `internal sealed class EncryptionInTransitLayer : IDataTransitStrategy` in namespace `DataWarehouse.Plugins.UltimateDataTransit.Layers`.

Same decorator pattern:
- Constructor: `EncryptionInTransitLayer(IDataTransitStrategy inner, IMessageBus messageBus)`
- `StrategyId` => `$"encrypted-{_inner.StrategyId}"`
- `Name` => `$"Encrypted {_inner.Name}"`

**TransferAsync:**
1. Check `request.Layers?.EnableEncryption == true` (if not, pass through to inner)
2. **Encrypt outbound data:** Request encryption via message bus:
   - Send `PluginMessage` to topic `"encryption.transit.encrypt"` with payload containing data stream and algorithm preference
   - Receive encrypted stream in response
   - If message bus unavailable, fall back to `System.Security.Cryptography.AesGcm` with a generated key (store key in metadata for receiver)
3. Create modified request with encrypted stream
4. Call `_inner.TransferAsync(modifiedRequest, progress, ct)`
5. Return result with metadata indicating encryption was applied

**Layer ordering enforcement (pitfall 4 from research):**
Both layers check for a metadata marker to prevent double-application:
- CompressionInTransitLayer sets metadata `"transit-compressed" = "true"`. Before compressing, checks if marker exists -- if so, skip (idempotent).
- EncryptionInTransitLayer sets metadata `"transit-encrypted" = "true"`. Same idempotency check.
- The orchestrator plugin applies layers in correct order: `new EncryptionInTransitLayer(new CompressionInTransitLayer(baseStrategy, bus), bus)` -- compress first, then encrypt outbound.

**File 3: TransitAuditTypes.cs**
Create in `DataWarehouse.SDK/Contracts/Transit/` namespace:

`public enum TransitAuditEventType`: TransferStarted, TransferCompleted, TransferFailed, TransferResumed, TransferCancelled, StrategySelected, LayerApplied, QoSEnforced, CostRouteSelected

`public sealed record TransitAuditEntry`:
- `string AuditId` (GUID)
- `string TransferId`
- `TransitAuditEventType EventType`
- `DateTime Timestamp`
- `string StrategyId`
- `string SourceEndpoint`
- `string DestinationEndpoint`
- `long BytesTransferred`
- `TimeSpan Duration`
- `bool Success`
- `string? ErrorMessage`
- `string? UserId`
- `Dictionary<string, object>? Details` (layers applied, cost, QoS tier, etc.)

XML docs on all types and members.
  </action>
  <verify>
Build SDK: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj`
Expect: 0 errors
Build plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj`
Expect: 0 errors
Grep: `rg "TODO|NotImplementedException|simulate|placeholder" Plugins/DataWarehouse.Plugins.UltimateDataTransit/Layers/`
Expect: 0 matches
  </verify>
  <done>
CompressionInTransitLayer and EncryptionInTransitLayer compile as decorators wrapping any IDataTransitStrategy. Compression delegates to UltimateCompression via message bus with GZip fallback. Encryption delegates to UltimateEncryption via message bus with AES-GCM fallback. Layer ordering enforced (compress-then-encrypt). TransitAuditTypes in SDK defines audit entry records.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TransitAuditService, cross-plugin integration, and final orchestrator wiring</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Audit/TransitAuditService.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/UltimateDataTransitPlugin.cs
    Metadata/TODO.md
  </files>
  <action>
**File 1: TransitAuditService.cs**
Create `internal sealed class TransitAuditService` in namespace `DataWarehouse.Plugins.UltimateDataTransit.Audit`.

- Constructor takes `IMessageBus messageBus`
- Private `ConcurrentDictionary<string, List<TransitAuditEntry>> _auditLog` keyed by transferId
- Private `long _totalAuditEntries` with Interlocked tracking

**Methods:**
- `void LogEvent(TransitAuditEntry entry)`:
  1. Add entry to `_auditLog[entry.TransferId]` (create list if not exists, use AddOrUpdate)
  2. Increment `_totalAuditEntries`
  3. Publish entry to message bus on topic `TransitMessageTopics.AuditEntry`:
     - `PluginMessage` with SourcePluginId="com.datawarehouse.transit.ultimate", Type=entry.EventType.ToString(), Payload=dictionary with all entry fields
- `IReadOnlyList<TransitAuditEntry> GetAuditTrail(string transferId)`: return entries for a specific transfer
- `IReadOnlyList<TransitAuditEntry> GetRecentEntries(int count)`: return last N entries across all transfers (flatten, sort by Timestamp descending, take count)
- `long GetTotalEntries()`: return _totalAuditEntries
- `void PurgeOlderThan(DateTime cutoff)`: remove entries older than cutoff from all transfer logs

**File 2: UltimateDataTransitPlugin.cs (UPDATE)**
Update the existing orchestrator to integrate all Plan 02-05 components:

**Add fields:**
- `private TransitAuditService? _auditService;`
- `private QoSThrottlingManager? _qosManager;`
- `private CostAwareRouter? _costRouter;`

**Update StartAsync:**
1. Initialize `_auditService = new TransitAuditService(MessageBus!)`
2. Initialize `_qosManager` with default QoS configuration (total bandwidth: 100MB/s, Critical: 50%/10MB min, High: 30%/5MB min, Normal: 15%/2MB min, Low: 5%/1MB min)
3. Initialize `_costRouter = new CostAwareRouter(RoutingPolicy.Balanced)`
4. Register default cost profiles for each strategy type (HTTP strategies: Free tier, FTP/SFTP: Metered tier, P2P: Free tier, etc.)
5. **Subscribe to cross-plugin transfer requests:** Subscribe to `"transit.transfer.request"` topic on message bus. Handler:
   - Parse request from PluginMessage payload (extract source URI, destination URI, size, preferred strategy)
   - Create TransitRequest from parsed data
   - Call `TransferAsync(request)` (the orchestrator's own method)
   - Reply with TransitResult via message bus response
6. Configure Intelligence on all registered strategies: `foreach strategy in registry.GetAll() => if strategy is DataTransitStrategyBase dsb => dsb.ConfigureIntelligence(MessageBus)`

**Update TransferAsync to integrate pipeline:**
1. Select strategy (existing logic)
2. **Apply QoS:** If `request.QoSPolicy != null`, create throttled stream wrapping request.DataStream using `_qosManager.CreateThrottledStreamAsync(stream, request.QoSPolicy.Priority, ct)`
3. **Apply layers:** If `request.Layers != null`:
   - If compression requested: wrap strategy with `new CompressionInTransitLayer(strategy, MessageBus!)`
   - If encryption requested: wrap with `new EncryptionInTransitLayer(wrappedStrategy, MessageBus!)`
   - Order: compression first (inner), encryption second (outer) -- per research pitfall 4
4. **Audit start:** `_auditService.LogEvent(new TransitAuditEntry { EventType=TransferStarted, ... })`
5. Execute transfer via (possibly wrapped) strategy
6. **Audit complete/failed:** Log TransferCompleted or TransferFailed with result details
7. Return result

**Update SelectStrategyAsync to use cost router:**
If `request.QoSPolicy?.CostLimit != null`, build TransitRoute objects for each candidate strategy, pass to `_costRouter.SelectRoute()` to filter by cost. Otherwise use existing scoring logic.

**File 3: Metadata/TODO.md**
Add UltimateDataTransit task entries if they don't exist. Mark sub-tasks based on what's implemented:
- `- [x] TRANSIT.01: SDK transit contracts (IDataTransitStrategy, types, base class, orchestrator interface)`
- `- [x] TRANSIT.02: Plugin orchestrator with auto-discovery and strategy selection`
- `- [x] TRANSIT.03: Direct strategies (HTTP/2, HTTP/3, gRPC, FTP, SFTP, SCP/rsync)`
- `- [x] TRANSIT.04: Chunked/resumable transfer with manifest tracking`
- `- [x] TRANSIT.05: Delta/differential transfer with rolling hash`
- `- [x] TRANSIT.06: P2P swarm distribution with backpressure`
- `- [x] TRANSIT.07: Multi-path parallel transfer with path scoring`
- `- [x] TRANSIT.08: Store-and-forward offline transfer`
- `- [x] TRANSIT.09: QoS throttling with minimum bandwidth guarantees`
- `- [x] TRANSIT.10: Cost-aware routing with 4 policies`
- `- [x] TRANSIT.11: Compression-in-transit decorator layer`
- `- [x] TRANSIT.12: Encryption-in-transit decorator layer`
- `- [x] TRANSIT.13: Transit audit trail service`
- `- [x] TRANSIT.14: Cross-plugin transport delegation via message bus`

XML docs on all new/updated public/internal members.
  </action>
  <verify>
Build SDK: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj`
Expect: 0 errors
Build plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj`
Expect: 0 errors
Grep for forbidden patterns: `rg "TODO|NotImplementedException|simulate|placeholder|stub" Plugins/DataWarehouse.Plugins.UltimateDataTransit/ --glob "*.cs"`
Expect: 0 matches
Grep for direct plugin references: `rg "UltimateEncryption|UltimateCompression" Plugins/DataWarehouse.Plugins.UltimateDataTransit/ --glob "*.cs"`
Expect: 0 matches (must use message bus, not direct reference per rules)
  </verify>
  <done>
TransitAuditService logs all transfer events and publishes to message bus. UltimateDataTransitPlugin integrates: QoS throttling in transfer pipeline, cost-aware strategy selection, composable layers (compress-then-encrypt), audit logging, cross-plugin request handling via message bus subscription. Metadata/TODO.md updated with all TRANSIT sub-tasks marked complete. Full plugin builds with zero forbidden patterns and zero direct plugin references.
  </done>
</task>

</tasks>

<verification>
- [ ] SDK builds: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- [ ] Plugin builds: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj` passes with 0 errors
- [ ] No direct plugin references (UltimateEncryption, UltimateCompression) in plugin code
- [ ] Layer ordering enforced: compress-then-encrypt outbound
- [ ] Audit entries published to message bus
- [ ] Cross-plugin transport delegation handles transit.transfer.request topic
- [ ] No forbidden patterns (TODO, NotImplementedException, simulate, placeholder, stub)
- [ ] TODO.md updated with TRANSIT task entries
</verification>

<success_criteria>
Phase 21 Plan 05 succeeds when:
1. CompressionInTransitLayer and EncryptionInTransitLayer implement decorator pattern wrapping any strategy
2. Layers delegate to UltimateCompression/UltimateEncryption via message bus (NOT direct reference)
3. TransitAuditService logs all transfer lifecycle events and publishes to message bus
4. UltimateDataTransitPlugin wires QoS, cost router, layers, and audit into unified transfer pipeline
5. Cross-plugin delegation works: other plugins POST to transit.transfer.request, plugin handles and responds
6. Metadata/TODO.md updated with all TRANSIT sub-tasks
7. Full build passes with zero Rule 13 violations
</success_criteria>

<output>
After completion, create `.planning/phases/21-data-transit/21-05-SUMMARY.md`
</output>
