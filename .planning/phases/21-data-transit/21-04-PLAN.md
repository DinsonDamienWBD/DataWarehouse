---
phase: 21-data-transit
plan: 04
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Offline/StoreAndForwardStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/QoSThrottlingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/CostAwareRouter.cs
autonomous: true

must_haves:
  truths:
    - "StoreAndForwardStrategy packages data to removable media with manifest and integrity hashes for air-gap transfer"
    - "Ingest validates manifest checksums against actual data and rejects corrupted packages"
    - "QoSThrottlingManager enforces bandwidth limits using token bucket algorithm with per-priority-tier guarantees"
    - "Low-priority transfers get minimum guaranteed bandwidth (no starvation per research pitfall 5)"
    - "CostAwareRouter selects cheapest or fastest path based on TransitCostProfile and configurable cost models"
    - "All three components integrate via message bus for transit events"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Offline/StoreAndForwardStrategy.cs"
      provides: "Offline/sneakernet transfer with manifest, SHA-256 integrity, package/ingest lifecycle"
      min_lines: 180
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/QoSThrottlingManager.cs"
      provides: "Token bucket rate limiting with weighted fair queueing and minimum bandwidth guarantees"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/CostAwareRouter.cs"
      provides: "Cost-based route selection across multiple strategies/paths"
      min_lines: 150
  key_links:
    - from: "QoSThrottlingManager.AcquireTokensAsync"
      to: "token bucket"
      via: "token bucket refills at configured rate, blocks until tokens available"
      pattern: "token.*bucket|refill|SemaphoreSlim"
    - from: "CostAwareRouter.SelectRoute"
      to: "TransitCostProfile"
      via: "computes total cost per route, selects based on policy (cheapest/fastest/balanced)"
      pattern: "CostPerGB|cost.*route|cheapest|balanced"
    - from: "QoSThrottlingManager"
      to: "UltimateDataTransitPlugin"
      via: "plugin wraps strategy transfers with QoS throttling"
      pattern: "throttl|bandwidth|rate.*limit"
---

<objective>
Implement store-and-forward offline strategy, QoS bandwidth management, and cost-aware routing for constrained and optimized transfers.

Purpose: Enable air-gap transfers, enforce bandwidth policies with starvation prevention, and optimize transfer costs
Output: 3 components (StoreAndForward strategy, QoS manager, cost router) compiled and integrated
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-data-transit/21-RESEARCH.md
@.planning/phases/21-data-transit/21-01-SUMMARY.md

# SDK contracts from Plan 01
@DataWarehouse.SDK/Contracts/Transit/IDataTransitStrategy.cs
@DataWarehouse.SDK/Contracts/Transit/DataTransitTypes.cs
@DataWarehouse.SDK/Contracts/Transit/DataTransitStrategyBase.cs

# Existing plugin
@Plugins/DataWarehouse.Plugins.UltimateDataTransit/UltimateDataTransitPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement StoreAndForwardStrategy for offline/sneakernet transfers</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Offline/StoreAndForwardStrategy.cs
  </files>
  <action>
Create `internal sealed class StoreAndForwardStrategy : DataTransitStrategyBase` in namespace `DataWarehouse.Plugins.UltimateDataTransit.Strategies.Offline`.

**Strategy identity:**
- StrategyId: "transit-store-and-forward"
- Name: "Store-and-Forward Transfer"
- Capabilities: SupportsOffline=true, SupportsResumable=true, SupportsCompression=true, SupportsEncryption=true, MaxTransferSizeBytes=long.MaxValue, SupportedProtocols=["file", "offline", "sneakernet"]

**Internal types:**

`internal sealed record ForwardPackage`:
- `string PackageId` (GUID)
- `string TransferId`
- `DateTime CreatedAt`
- `string SourceDescription`
- `string DestinationDescription`
- `long TotalSizeBytes`
- `List<PackageEntry> Entries`
- `string ManifestHash` (SHA-256 of serialized manifest excluding this field)

`internal sealed record PackageEntry`:
- `string RelativePath`
- `long SizeBytes`
- `string Sha256Hash`
- `DateTime ModifiedAt`

**TransferAsync implementation (Package mode - source side):**
1. Generate transfer ID and package ID
2. Determine output path from `request.Destination.Uri` (expects `file:///path/to/output` or local directory path)
3. Create package directory structure at output path:
   ```
   {packageId}/
     manifest.json       -- ForwardPackage serialized as JSON
     data/
       {entry1.RelativePath}
       {entry2.RelativePath}
       ...
   ```
4. Copy data from `request.DataStream` to `data/` directory. If data is a single stream, write as `data/payload.bin`.
5. For each file in `data/`:
   - Compute SHA-256 hash using `SHA256.HashData()` on file stream (streaming, not loading entire file)
   - Create `PackageEntry` with path, size, hash, modified timestamp
6. Build `ForwardPackage` manifest with all entries
7. Compute manifest hash: serialize ForwardPackage to JSON (excluding ManifestHash field), compute SHA-256 of that JSON, set ManifestHash
8. Write `manifest.json` to package directory
9. Report progress throughout: files processed / total files
10. Return TransitResult with BytesTransferred=total package size, metadata includes packageId and output path

**IngestAsync (destination side, called via TransferAsync when source is a package path):**
If `request.Source.Protocol == "file"` or `request.Source.Uri` points to an existing package directory:
1. Read `manifest.json` from package directory
2. Deserialize `ForwardPackage`
3. **Verify manifest integrity:** Recompute SHA-256 of manifest JSON (excluding ManifestHash), compare with stored ManifestHash. If mismatch, return TransitResult with Success=false, ErrorMessage="Manifest integrity check failed - package may be tampered"
4. **Verify each entry:** For each PackageEntry, compute SHA-256 of the actual file in `data/`, compare with entry hash. If mismatch, return failure with specific corrupted file path.
5. If all hashes match, copy data from package to final destination (from `request.Destination.Uri`)
6. Return TransitResult with Success=true, metadata includes verified entry count

**IsAvailableAsync:** Returns true if endpoint URI scheme is "file" or "offline", or if the path exists as a directory.

XML docs on all members. Use `System.Text.Json.JsonSerializer` for manifest serialization with `JsonSerializerOptions { WriteIndented = true }`. Use streaming SHA-256 computation (`IncrementalHash.CreateHash(HashAlgorithmName.SHA256)`) for large files.
  </action>
  <verify>
Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj`
Expect: 0 errors
Grep: `rg "TODO|NotImplementedException|simulate|placeholder" Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Offline/StoreAndForwardStrategy.cs`
Expect: 0 matches
  </verify>
  <done>
StoreAndForwardStrategy compiles with: package creation at source (directory structure + manifest.json), SHA-256 per-entry integrity hashes, manifest integrity hash, ingest-side verification (recompute all hashes, reject on mismatch), streaming hash computation for large files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement QoS throttling manager and cost-aware router</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/QoSThrottlingManager.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/CostAwareRouter.cs
  </files>
  <action>
**File 1: QoSThrottlingManager.cs**
Create `internal sealed class QoSThrottlingManager : IDisposable` in namespace `DataWarehouse.Plugins.UltimateDataTransit.QoS`.

**Token bucket rate limiter:**
`internal sealed class TokenBucket`:
- `long MaxTokens` (bucket capacity in bytes)
- `long TokensPerSecond` (refill rate = bandwidth limit)
- `long _availableTokens` (current tokens, managed with Interlocked)
- `DateTime _lastRefillTime`
- `SemaphoreSlim _refillLock` for thread-safe refill
- `async Task<bool> TryConsumeAsync(long tokens, CancellationToken ct)`:
  1. Refill tokens: elapsed = now - lastRefill, newTokens = elapsed.TotalSeconds * tokensPerSecond, availableTokens = min(maxTokens, available + newTokens)
  2. If available >= requested: consume and return true
  3. Else: compute wait time = (requested - available) / tokensPerSecond, await Task.Delay(waitTime, ct), refill and retry
- `async Task ConsumeAsync(long tokens, CancellationToken ct)`: blocks until tokens available (calls TryConsumeAsync in loop)

**Weighted fair queueing with minimum guarantees (pitfall 5 from research):**
`internal sealed class QoSThrottlingManager`:
- Constructor takes `QoSConfiguration`:
  - `long TotalBandwidthBytesPerSecond`
  - `Dictionary<TransitPriority, PriorityConfig>` where PriorityConfig has:
    - `double WeightPercent` (e.g., Critical=50%, High=30%, Normal=15%, Low=5%)
    - `long MinBandwidthBytesPerSecond` (floor guarantee, e.g., Low gets at least 1MB/s)
    - `long MaxBandwidthBytesPerSecond` (ceiling)
- Internal `Dictionary<TransitPriority, TokenBucket>` - one bucket per priority tier
- `async Task<Stream> CreateThrottledStreamAsync(Stream inner, TransitPriority priority, CancellationToken ct)`:
  Returns a `ThrottledStream` that wraps the inner stream, calling `_buckets[priority].ConsumeAsync(bytesRead)` on each Read/Write
- `ThrottledStream` (internal sealed class extending `Stream`):
  - Wraps inner stream
  - `ReadAsync` override: reads from inner, then `await bucket.ConsumeAsync(bytesRead, ct)` before returning
  - `WriteAsync` override: `await bucket.ConsumeAsync(count, ct)` then writes to inner
  - Delegates all other Stream members to inner (Length, Position, CanRead, etc.)
- **Starvation prevention:** Each priority tier has a guaranteed minimum bucket that refills independently. Even when Critical uses maximum, Low still gets its MinBandwidth. The total bandwidth is split: guaranteed minimums are reserved first, remaining bandwidth is distributed by weight.
- `void UpdateConfiguration(QoSConfiguration config)`: re-create buckets with new limits. Thread-safe via lock.

**File 2: CostAwareRouter.cs**
Create `internal sealed class CostAwareRouter` in namespace `DataWarehouse.Plugins.UltimateDataTransit.QoS`.

**Route types:**
`internal sealed record TransitRoute`:
- `string RouteId` (GUID)
- `string StrategyId` (which strategy to use)
- `TransitEndpoint Endpoint`
- `TransitCostProfile CostProfile`
- `double EstimatedLatencyMs`
- `double EstimatedThroughputBytesPerSec`

`internal enum RoutingPolicy { Cheapest, Fastest, Balanced, CostCapped }`

**CostAwareRouter:**
- Constructor takes `RoutingPolicy defaultPolicy`
- `ConcurrentDictionary<string, TransitCostProfile> _costProfiles` - maps strategyId to cost profile
- `void RegisterCostProfile(string strategyId, TransitCostProfile profile)`
- `TransitRoute SelectRoute(IReadOnlyList<TransitRoute> candidates, TransitRequest request, RoutingPolicy? overridePolicy = null)`:
  1. Filter candidates by: endpoint reachability (non-null), strategy availability
  2. Compute total cost for each route: `totalCost = profile.FixedCostPerTransfer + (profile.CostPerGB * request.SizeBytes / 1_073_741_824m)` (1GB in bytes)
  3. If policy=CostCapped and `request.QoSPolicy?.CostLimit` is set, filter out routes exceeding cost limit
  4. Score each route based on policy:
     - Cheapest: score = -totalCost (lower cost = higher score)
     - Fastest: score = estimatedThroughput / max(1, estimatedLatency)
     - Balanced: score = 0.4 * normalizedThroughput - 0.3 * normalizedCost - 0.3 * normalizedLatency
     - CostCapped: score = throughput (after filtering by cost cap)
  5. Return route with highest score
- `decimal EstimateTransferCost(string strategyId, long sizeBytes)`:
  Look up cost profile, compute: `profile.FixedCostPerTransfer + profile.CostPerGB * sizeBytes / 1_073_741_824m`
- `IReadOnlyList<(TransitRoute Route, decimal Cost)> RankRoutesByCost(IReadOnlyList<TransitRoute> routes, long sizeBytes)`:
  Compute cost for each route, sort ascending by cost, return as ranked list

XML docs on all members. Both classes are internal sealed. No external dependencies beyond SDK types.
  </action>
  <verify>
Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj`
Expect: 0 errors
Grep: `rg "TODO|NotImplementedException|simulate|placeholder" Plugins/DataWarehouse.Plugins.UltimateDataTransit/QoS/ Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Offline/`
Expect: 0 matches
  </verify>
  <done>
QoSThrottlingManager compiles with token bucket rate limiting, per-priority-tier buckets, minimum bandwidth guarantees preventing starvation, ThrottledStream wrapper. CostAwareRouter compiles with 4 routing policies, cost computation per route, route ranking. StoreAndForwardStrategy handles offline transfer with manifest integrity verification.
  </done>
</task>

</tasks>

<verification>
- [ ] Plugin builds: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj` passes with 0 errors
- [ ] StoreAndForwardStrategy creates packages with SHA-256 manifest and validates on ingest
- [ ] QoSThrottlingManager uses token bucket with minimum bandwidth guarantee per priority tier
- [ ] CostAwareRouter supports 4 routing policies (Cheapest, Fastest, Balanced, CostCapped)
- [ ] No forbidden patterns (TODO, NotImplementedException, simulate, placeholder, stub)
- [ ] ThrottledStream is a proper Stream wrapper (not Task.Run or sync blocking)
</verification>

<success_criteria>
Phase 21 Plan 04 succeeds when:
1. StoreAndForwardStrategy packages data for air-gap transfer with JSON manifest and SHA-256 per-entry integrity
2. QoSThrottlingManager enforces bandwidth limits with token bucket algorithm and guarantees minimum bandwidth per priority tier
3. CostAwareRouter selects optimal routes based on cost/performance tradeoffs across 4 policies
4. All components compile with zero Rule 13 violations
</success_criteria>

<output>
After completion, create `.planning/phases/21-data-transit/21-04-SUMMARY.md`
</output>
