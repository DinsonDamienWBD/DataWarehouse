---
phase: 21-data-transit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Transit/IDataTransitStrategy.cs
  - DataWarehouse.SDK/Contracts/Transit/DataTransitTypes.cs
  - DataWarehouse.SDK/Contracts/Transit/DataTransitStrategyBase.cs
  - DataWarehouse.SDK/Contracts/Transit/ITransitOrchestrator.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/UltimateDataTransitPlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/TransitStrategyRegistry.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/TransitMessageTopics.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/Http2TransitStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/Http3TransitStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/GrpcStreamingTransitStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/FtpTransitStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/SftpTransitStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/ScpRsyncTransitStrategy.cs
autonomous: true

must_haves:
  truths:
    - "SDK defines IDataTransitStrategy interface with TransferAsync, ResumeTransferAsync, CancelTransferAsync, and health check"
    - "DataTransitStrategyBase provides common transfer ID generation, statistics, progress reporting, and cancellation"
    - "UltimateDataTransitPlugin orchestrator auto-discovers and registers all strategies via reflection"
    - "TransitStrategyRegistry provides thread-safe registration, lookup, filtering by protocol/capability"
    - "Plugin selects best strategy automatically based on endpoint protocol, data size, and availability"
    - "HTTP/2 strategy transfers data using System.Net.Http with HttpVersion.Version20 and streaming"
    - "HTTP/3 strategy uses System.Net.Http with HttpVersion.Version30 for QUIC-based transfer"
    - "gRPC strategy uses Grpc.Net.Client for bidirectional streaming transfers"
    - "FTP strategy uses FluentFTP for FTP/FTPS transfers with async API"
    - "SFTP strategy uses SSH.NET for SFTP transfers with async API"
    - "SCP/rsync strategy uses SSH.NET for SCP transfers with rolling-hash incremental sync"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Transit/IDataTransitStrategy.cs"
      provides: "Strategy interface, TransitCapabilities record"
      exports: ["IDataTransitStrategy", "TransitCapabilities"]
    - path: "DataWarehouse.SDK/Contracts/Transit/DataTransitTypes.cs"
      provides: "TransitEndpoint, TransitRequest, TransitResult, TransitProgress, TransitHealthStatus records"
      exports: ["TransitEndpoint", "TransitRequest", "TransitResult", "TransitProgress", "TransitHealthStatus"]
    - path: "DataWarehouse.SDK/Contracts/Transit/DataTransitStrategyBase.cs"
      provides: "Abstract base class with statistics, progress, transfer ID generation, Intelligence integration"
      exports: ["DataTransitStrategyBase"]
    - path: "DataWarehouse.SDK/Contracts/Transit/ITransitOrchestrator.cs"
      provides: "Orchestrator interface for strategy selection and transfer execution"
      exports: ["ITransitOrchestrator"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/UltimateDataTransitPlugin.cs"
      provides: "Plugin orchestrator extending FeaturePluginBase with auto-discovery and strategy selection"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/TransitStrategyRegistry.cs"
      provides: "Thread-safe strategy registry with protocol and capability filtering"
      min_lines: 80
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/Http2TransitStrategy.cs"
      provides: "HTTP/2 direct transfer via System.Net.Http"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/SftpTransitStrategy.cs"
      provides: "SFTP transfer via SSH.NET"
      min_lines: 100
  key_links:
    - from: "UltimateDataTransitPlugin.DiscoverStrategies"
      to: "TransitStrategyRegistry.Register"
      via: "reflection-based auto-discovery of IDataTransitStrategy implementations"
      pattern: "GetTypes.*IsAssignableFrom.*IDataTransitStrategy"
    - from: "UltimateDataTransitPlugin.SelectStrategyAsync"
      to: "TransitStrategyRegistry.GetAll"
      via: "filter by protocol, check availability, score candidates"
      pattern: "IsAvailableAsync.*ScoreStrategy"
    - from: "All strategies"
      to: "DataTransitStrategyBase"
      via: "inheritance providing common transfer tracking"
      pattern: "class.*Strategy.*:.*DataTransitStrategyBase"
---

<objective>
Create the SDK transit contracts and UltimateDataTransit plugin foundation with all 6 direct transfer strategies.

Purpose: Establish the strategy pattern infrastructure and implement the most common point-to-point transfer mechanisms that all other plans depend on
Output: Compilable SDK contracts + plugin with orchestrator, registry, and 6 direct strategies
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-data-transit/21-RESEARCH.md

# SDK patterns to follow
@DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategy.cs
@DataWarehouse.SDK/Contracts/Replication/ReplicationStrategy.cs
@DataWarehouse.SDK/Contracts/Streaming/StreamingStrategy.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Contracts/IPluginCapabilityRegistry.cs
@DataWarehouse.SDK/Primitives/Enums.cs

# Reference Ultimate plugin structure
@Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateReplication/DataWarehouse.Plugins.UltimateReplication.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SDK transit contracts (IDataTransitStrategy, types, base class, orchestrator interface)</name>
  <files>
    DataWarehouse.SDK/Contracts/Transit/IDataTransitStrategy.cs
    DataWarehouse.SDK/Contracts/Transit/DataTransitTypes.cs
    DataWarehouse.SDK/Contracts/Transit/DataTransitStrategyBase.cs
    DataWarehouse.SDK/Contracts/Transit/ITransitOrchestrator.cs
  </files>
  <action>
Create new directory `DataWarehouse.SDK/Contracts/Transit/` with 4 files following the exact pattern from `Contracts/Encryption/EncryptionStrategy.cs` and `Contracts/Replication/ReplicationStrategy.cs`.

**File 1: IDataTransitStrategy.cs**
Namespace: `DataWarehouse.SDK.Contracts.Transit`

Define `IDataTransitStrategy` interface with:
- `string StrategyId { get; }` - unique ID (e.g., "transit-http2", "transit-sftp")
- `string Name { get; }` - human-readable name
- `TransitCapabilities Capabilities { get; }` - capability record
- `Task<bool> IsAvailableAsync(TransitEndpoint endpoint, CancellationToken ct = default)` - check if strategy can reach endpoint
- `Task<TransitResult> TransferAsync(TransitRequest request, IProgress<TransitProgress>? progress = null, CancellationToken ct = default)` - execute transfer
- `Task<TransitResult> ResumeTransferAsync(string transferId, IProgress<TransitProgress>? progress = null, CancellationToken ct = default)` - resume interrupted transfer
- `Task CancelTransferAsync(string transferId, CancellationToken ct = default)` - cancel active transfer
- `Task<TransitHealthStatus> GetHealthAsync(CancellationToken ct = default)` - health check

Define `TransitCapabilities` record with bool properties:
- SupportsResumable, SupportsStreaming, SupportsDelta, SupportsMultiPath, SupportsP2P, SupportsOffline, SupportsCompression, SupportsEncryption
- `long MaxTransferSizeBytes { get; init; }`
- `IReadOnlyList<string> SupportedProtocols { get; init; } = []`

**File 2: DataTransitTypes.cs**
Namespace: `DataWarehouse.SDK.Contracts.Transit`

Define records (follow TransitRequest/TransitResult/TransitProgress/TransitEndpoint/TransitHealthStatus from research exactly):
- `TransitEndpoint` - Uri (required), Protocol, AuthToken, Options dictionary
- `TransitRequest` - TransferId (required), Source (required), Destination (required), DataStream, SizeBytes, ContentHash, QoSPolicy, Layers config, Metadata dictionary
- `TransitResult` - TransferId (required), Success (required), BytesTransferred, Duration, ErrorMessage, ContentHash, StrategyUsed, Metadata
- `TransitProgress` - TransferId, BytesTransferred, TotalBytes, PercentComplete, BytesPerSecond, EstimatedRemaining, CurrentPhase
- `TransitHealthStatus` - StrategyId, IsHealthy, LastCheckTime, ErrorMessage, AvailableEndpoints count, ActiveTransfers count
- `TransitQoSPolicy` - MaxBandwidthBytesPerSecond, Priority (enum: Low/Normal/High/Critical), MinBandwidthGuarantee, CostLimit
- `TransitLayerConfig` - EnableCompression, CompressionAlgorithm, EnableEncryption, EncryptionAlgorithm
- `TransitCostProfile` - CostPerGB, FixedCostPerTransfer, Tier (enum: Free/Metered/Premium), IsMetered
- `TransitPriority` enum - Low=0, Normal=1, High=2, Critical=3
- `TransitCostTier` enum - Free=0, Metered=1, Premium=2

**File 3: DataTransitStrategyBase.cs**
Namespace: `DataWarehouse.SDK.Contracts.Transit`

Abstract base class following `EncryptionStrategyBase` pattern:
- Abstract properties: StrategyId, Name, Capabilities
- Interlocked statistics tracking: transfer count, bytes transferred, failures, active transfers
- `TransitStatistics GetStatistics()` / `void ResetStatistics()`
- Protected `string GenerateTransferId()` using `$"{StrategyId}-{Guid.NewGuid():N}"` (avoids collision per research pitfall 6)
- Protected `ConcurrentDictionary<string, CancellationTokenSource>` for active transfer cancellation tracking
- Intelligence integration region (following EncryptionStrategyBase pattern): `IMessageBus? MessageBus`, `ConfigureIntelligence`, `IsIntelligenceAvailable`, `GetStrategyKnowledge()`, `GetStrategyCapability()` returning `CapabilityCategory.Transport`
- Protected virtual methods: `GetKnowledgeTopic()` returns "transit", `GetCapabilityCategory()` returns `CapabilityCategory.Transport`

**File 4: ITransitOrchestrator.cs**
Namespace: `DataWarehouse.SDK.Contracts.Transit`

Interface `ITransitOrchestrator`:
- `Task<IDataTransitStrategy> SelectStrategyAsync(TransitRequest request, CancellationToken ct = default)`
- `Task<TransitResult> TransferAsync(TransitRequest request, IProgress<TransitProgress>? progress = null, CancellationToken ct = default)`
- `IReadOnlyCollection<IDataTransitStrategy> GetRegisteredStrategies()`
- `Task<IReadOnlyCollection<TransitHealthStatus>> GetHealthAsync(CancellationToken ct = default)`

All types must have XML documentation on every public member. Use `sealed record` for data types. Keep namespace separate from `DataWarehouse.SDK.Security.Transit` (that's for encryption/compression, not transport).
  </action>
  <verify>
Build SDK: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj`
Expect: 0 errors. New types visible in Transit namespace.
  </verify>
  <done>
4 SDK contract files exist in DataWarehouse.SDK/Contracts/Transit/ with IDataTransitStrategy, all type records, DataTransitStrategyBase, and ITransitOrchestrator. SDK builds cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create UltimateDataTransit plugin with orchestrator, registry, and 6 direct strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/UltimateDataTransitPlugin.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/TransitStrategyRegistry.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/TransitMessageTopics.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/Http2TransitStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/Http3TransitStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/GrpcStreamingTransitStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/FtpTransitStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/SftpTransitStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/ScpRsyncTransitStrategy.cs
  </files>
  <action>
**Csproj:** Follow UltimateReplication.csproj pattern:
- TargetFramework: net10.0, ImplicitUsings: enable, Nullable: enable
- GenerateDocumentationFile: true, TreatWarningsAsErrors: true, LangVersion: latest
- ProjectReference to `..\..\DataWarehouse.SDK\DataWarehouse.SDK.csproj` (SDK-only reference per rules)
- PackageReference: `Grpc.Net.Client` Version="2.*", `SSH.NET` Version="*", `FluentFTP` Version="*"
- Description: "Ultimate Data Transit plugin providing user-selectable transport strategies"

**TransitMessageTopics.cs:** Static class with const string topics (from research):
- transit.transfer.started, transit.transfer.progress, transit.transfer.completed, transit.transfer.failed, transit.transfer.resumed, transit.transfer.cancelled
- transit.strategy.registered, transit.strategy.health
- transit.qos.changed, transit.cost.route.changed, transit.audit.entry

**TransitStrategyRegistry.cs:** Internal sealed class:
- `ConcurrentDictionary<string, IDataTransitStrategy>` with case-insensitive comparer
- `Register(IDataTransitStrategy)`, `GetStrategy(string)`, `GetAll()`, `GetByProtocol(string)`, `GetByCapability(Func<TransitCapabilities, bool>)`
- `DiscoverStrategies(params Assembly[])` using reflection (same pattern as EncryptionStrategyRegistry)
- Thread-safe throughout

**UltimateDataTransitPlugin.cs:** Sealed class extending `FeaturePluginBase`, implementing `ITransitOrchestrator`, `IDisposable`:
- Id: "com.datawarehouse.transit.ultimate", Name: "Ultimate Data Transit", Version: "1.0.0"
- Category: `PluginCategory.FeatureProvider`
- Private `TransitStrategyRegistry _registry`
- Private `ConcurrentDictionary<string, ActiveTransfer>` tracking active transfers (ActiveTransfer is internal record with TransferId, StrategyId, StartTime, CancellationTokenSource)
- Constructor: creates registry, calls `DiscoverStrategies()` using own assembly
- `SelectStrategyAsync`: filter strategies by destination protocol, check availability with `IsAvailableAsync`, score by capabilities matching request (resumable for large files, delta for updates, etc.), return highest-scored
- `TransferAsync`: select strategy, create ActiveTransfer record, publish `transit.transfer.started` via message bus, call strategy.TransferAsync, publish completed/failed, remove from active
- `StartAsync`/`StopAsync`: register strategies, configure Intelligence on all strategies
- `ScoreStrategy(IDataTransitStrategy, TransitRequest)`: private method scoring by: protocol match (+100), resumable if size > 100MB (+50), streaming support (+30), encryption support if layers request it (+20)
- Publish message bus events using `PluginMessage` with Type, SourcePluginId, Payload dictionary (follow Phase 6 pattern)

**6 Direct Strategies** (all `internal sealed`, extend `DataTransitStrategyBase`):

1. **Http2TransitStrategy**: StrategyId "transit-http2", protocols ["http", "https", "http2"]
   - Use `HttpClient` with `HttpVersion.Version20` and `HttpVersionPolicy.RequestVersionExact`
   - TransferAsync: POST data stream to destination URI, read response, compute SHA-256 hash of transferred bytes
   - SupportsResumable: true (via Range headers), SupportsStreaming: true, MaxTransferSize: long.MaxValue

2. **Http3TransitStrategy**: StrategyId "transit-http3", protocols ["http3", "quic"]
   - Use `HttpClient` with `HttpVersion.Version30` and `HttpVersionPolicy.RequestVersionExact`
   - Same pattern as HTTP/2 but with HTTP/3. IsAvailableAsync checks `System.Net.Quic.QuicConnection.IsSupported`
   - SupportsResumable: true, SupportsStreaming: true

3. **GrpcStreamingTransitStrategy**: StrategyId "transit-grpc", protocols ["grpc", "grpc-web"]
   - Use `Grpc.Net.Client.GrpcChannel.ForAddress` with `GrpcChannelOptions`
   - TransferAsync: create channel, use raw HTTP/2 streaming (since we don't have proto definitions, use `HttpClient` with gRPC content-type `application/grpc` and binary framing: 1-byte compressed flag + 4-byte message length + message)
   - SupportsStreaming: true, SupportsResumable: false

4. **FtpTransitStrategy**: StrategyId "transit-ftp", protocols ["ftp", "ftps"]
   - Use `FluentFTP.AsyncFtpClient` (NOT synchronous FtpClient)
   - `ConnectAsync` then `UploadStreamAsync`/`DownloadStreamAsync` with `IProgress<FtpProgress>` mapped to `TransitProgress`
   - IsAvailableAsync: attempt `ConnectAsync` with timeout, return success
   - SupportsResumable: true (FTP REST command), SupportsStreaming: true

5. **SftpTransitStrategy**: StrategyId "transit-sftp", protocols ["sftp", "ssh"]
   - Use `Renci.SshNet.SftpClient` (SSH.NET package)
   - Connect with `ConnectionInfo` from endpoint URI (host, port, username from AuthToken or URI userinfo)
   - Use `BeginUploadFile`/`EndUploadFile` for async upload, `BeginDownloadFile`/`EndDownloadFile` for download
   - SupportsResumable: true (SFTP supports append), SupportsStreaming: true

6. **ScpRsyncTransitStrategy**: StrategyId "transit-scp-rsync", protocols ["scp", "rsync"]
   - Use `Renci.SshNet.ScpClient` for SCP transfers
   - Implement rolling-hash based incremental sync: compute Adler-32 rolling checksums on source and destination blocks (using `System.IO.Hashing`), transfer only changed blocks
   - SupportsResumable: false, SupportsDelta: true, SupportsStreaming: false

All strategies: XML docs on every public/internal member. All async methods accept CancellationToken. No Task.Run wrapping sync APIs (use truly async APIs). Generate transfer IDs using base class `GenerateTransferId()`.
  </action>
  <verify>
Build plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj`
Expect: 0 errors, 0 warnings (or only CS1591 suppressed)
Grep for forbidden patterns: `rg "TODO|NotImplementedException|placeholder|stub|simulate" Plugins/DataWarehouse.Plugins.UltimateDataTransit/`
Expect: 0 matches
  </verify>
  <done>
Plugin project compiles. UltimateDataTransitPlugin orchestrator discovers and registers 6 direct strategies. TransitStrategyRegistry provides thread-safe lookup. All strategies use real protocol libraries (System.Net.Http, Grpc.Net.Client, FluentFTP, SSH.NET). Zero forbidden patterns.
  </done>
</task>

</tasks>

<verification>
- [ ] SDK builds: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- [ ] Plugin builds: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataTransit/DataWarehouse.Plugins.UltimateDataTransit.csproj` passes with 0 errors
- [ ] No forbidden patterns (TODO, NotImplementedException, simulate, placeholder, stub)
- [ ] All 6 direct strategies extend DataTransitStrategyBase
- [ ] UltimateDataTransitPlugin extends FeaturePluginBase and implements ITransitOrchestrator
- [ ] Only SDK ProjectReference, no direct plugin references
- [ ] All public types have XML documentation
</verification>

<success_criteria>
Phase 21 Plan 01 succeeds when:
1. SDK Contracts/Transit/ directory contains IDataTransitStrategy, DataTransitTypes, DataTransitStrategyBase, ITransitOrchestrator
2. UltimateDataTransit plugin compiles with orchestrator, registry, message topics, and 6 direct strategies
3. Strategies use real libraries: HttpClient (HTTP/2, HTTP/3), Grpc.Net.Client (gRPC), FluentFTP (FTP), SSH.NET (SFTP, SCP)
4. Plugin follows FeaturePluginBase pattern with auto-discovery via reflection
5. Zero Rule 13 violations
</success_criteria>

<output>
After completion, create `.planning/phases/21-data-transit/21-01-SUMMARY.md`
</output>
