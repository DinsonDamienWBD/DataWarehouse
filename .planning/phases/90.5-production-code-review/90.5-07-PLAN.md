---
phase: 90.5-production-code-review
plan: 07
type: manual
wave: 3
depends_on: ["90.5-04"]
files_modified: [Plugins/DataWarehouse.Plugins.UltimateCompute/]
autonomous: false

must_haves:
  truths:
    - "The 1 throw is replaced with real implementation"
    - "All 12 Task.CompletedTask no-ops are replaced with real compute logic"
    - "Wiring document explains compute strategy dispatch and job execution"
  artifacts:
    - path: ".planning/phases/90.5-production-code-review/wiring/07-compute-wiring.md"
      provides: "Complete wiring documentation for UltimateCompute"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompute/"
      to: "DataWarehouse.SDK/Contracts/Compute/"
      via: "Compute strategy implementations"
---

<objective>
Production Code Review and Gap Closure for UltimateCompute plugin.

Purpose: UltimateCompute handles distributed computation. Known: 1 throw + 12 Task.CompletedTask. Relatively small scope but must be thorough.

Output: Zero-gap UltimateCompute with comprehensive wiring documentation.
</objective>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
</context>

<tasks>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 1: Systematic Scan of UltimateCompute</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompute/</files>
  <action>

    **MANDATORY PER-FILE REPORTING RULE:**
    Every single .cs file in the project directory MUST be individually listed in the findings report. No exceptions, no summarization across files. For each file report:
    - Full file path and total line count
    - Every finding (stub, no-op, gap, fake payload, TODO) with exact line number(s) and code snippet
    - If the file has zero issues, explicitly list it as: "filename.cs (N lines) â€” CLEAN, no issues"
    
    Do NOT skip any file. Do NOT group files together. Do NOT say "similar pattern in X files".
    Go through every line of code in every file. We are closing all gaps once and for all.
    Perform exhaustive scan for:
    1. The known 1 throw (locate and classify)
    2. All 12 Task.CompletedTask no-ops (locate each one)
    3. Any additional stubs, fake payloads, TODO comments
    4. Verify compute job scheduling, execution, and result collection paths

    Present findings table to user.
  </action>
  <verify>User reviews findings and approves fix plan</verify>
  <done>Complete inventory presented to user</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Implement Fixes</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompute/</files>
  <action>
    Implement all fixes:
    1. Replace the 1 throw with real implementation
    2. Replace all 12 Task.CompletedTask with real compute logic
    3. Each compute strategy must actually process input and produce output
    4. Job lifecycle: submit -> schedule -> execute -> collect results must work end-to-end

    Rescan and build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompute/`
  </action>
  <verify>Rescan clean, build succeeds, user confirms</verify>
  <done>All gaps closed, plugin builds clean</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Write Wiring Document</name>
  <files>.planning/phases/90.5-production-code-review/wiring/07-compute-wiring.md</files>
  <action>
    Document: Compute strategy registry, job submission flow, scheduling algorithm, execution backends, result aggregation, integration with message bus, resource management.
  </action>
  <verify>User reviews wiring document</verify>
  <done>Wiring document complete, approved by user</done>
</task>

</tasks>

<verification>
- Zero throws/no-ops remaining
- Plugin builds clean
- Wiring document complete
</verification>

<success_criteria>
UltimateCompute is 100% production-ready. Wiring document complete.
</success_criteria>

<output>
After completion, create `.planning/phases/90.5-production-code-review/90.5-07-SUMMARY.md`
</output>
