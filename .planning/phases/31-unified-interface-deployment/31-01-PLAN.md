---
phase: 31-unified-interface-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.Shared/DynamicCommandRegistry.cs
  - DataWarehouse.Shared/Commands/CommandExecutor.cs
  - DataWarehouse.Shared/CapabilityManager.cs
  - DataWarehouse.Shared/Models/InstanceCapabilities.cs
  - DataWarehouse.Shared/CommandRegistry.cs
autonomous: true

must_haves:
  truths:
    - "DynamicCommandRegistry maintains a live ConcurrentDictionary of commands that updates when capability events arrive"
    - "CommandExecutor reads available commands from DynamicCommandRegistry instead of hardcoded RegisterBuiltInCommands()"
    - "CapabilityManager uses a dynamic HashSet<string> for features instead of hardcoded bool properties"
    - "Initial capability query bootstraps the registry on startup (prevents race condition where events were missed)"
  artifacts:
    - path: "DataWarehouse.Shared/DynamicCommandRegistry.cs"
      provides: "Dynamic command registry with event subscription and ConcurrentDictionary storage"
      min_lines: 80
    - path: "DataWarehouse.Shared/Commands/CommandExecutor.cs"
      provides: "CommandExecutor reading from DynamicCommandRegistry"
      contains: "DynamicCommandRegistry"
    - path: "DataWarehouse.Shared/CapabilityManager.cs"
      provides: "Dynamic feature model using HashSet<string>"
      contains: "HashSet<string>"
  key_links:
    - from: "DataWarehouse.Shared/DynamicCommandRegistry.cs"
      to: "DataWarehouse.Shared/MessageBridge.cs"
      via: "event subscription for capability.changed, plugin.loaded, plugin.unloaded"
      pattern: "capability\\.changed|plugin\\.loaded|plugin\\.unloaded"
    - from: "DataWarehouse.Shared/Commands/CommandExecutor.cs"
      to: "DataWarehouse.Shared/DynamicCommandRegistry.cs"
      via: "reads available commands from registry"
      pattern: "DynamicCommandRegistry"
    - from: "DataWarehouse.Shared/CapabilityManager.cs"
      to: "DataWarehouse.Shared/DynamicCommandRegistry.cs"
      via: "feeds feature changes into command registry"
      pattern: "DynamicCommandRegistry|CommandsChanged"
---

<objective>
Create DynamicCommandRegistry in DataWarehouse.Shared that subscribes to capability change events via MessageBridge and maintains a live registry of available commands based on loaded plugins. Refactor CommandExecutor to read from this dynamic registry instead of hardcoded command lists. Refactor CapabilityManager to use a dynamic feature model.

Purpose: CLI-02, CLI-04, CLI-05 -- commands must appear/disappear dynamically when plugins load/unload at runtime, and both CLI and GUI must read from the same registry for feature parity.
Output: DynamicCommandRegistry.cs, refactored CommandExecutor.cs, refactored CapabilityManager.cs
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-unified-interface-deployment/31-RESEARCH.md

@DataWarehouse.Shared/Commands/CommandExecutor.cs
@DataWarehouse.Shared/CommandRegistry.cs
@DataWarehouse.Shared/CapabilityManager.cs
@DataWarehouse.Shared/Models/InstanceCapabilities.cs
@DataWarehouse.Shared/MessageBridge.cs
@DataWarehouse.Shared/Commands/ICommand.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamicCommandRegistry and refactor CapabilityManager to dynamic model</name>
  <files>
    DataWarehouse.Shared/DynamicCommandRegistry.cs
    DataWarehouse.Shared/CapabilityManager.cs
    DataWarehouse.Shared/Models/InstanceCapabilities.cs
  </files>
  <action>
1. Create `DataWarehouse.Shared/DynamicCommandRegistry.cs`:
   - Class `DynamicCommandRegistry` with `ConcurrentDictionary<string, DynamicCommandDefinition> _commands`
   - `DynamicCommandDefinition` record: Name, Description, Category, RequiredFeatures (List of string), SourcePlugin (string), IsCore (bool)
   - `CommandsChanged` event (EventHandler with CommandsChangedEventArgs containing Added/Removed lists)
   - `StartListeningAsync(MessageBridge bridge, CancellationToken ct)` method that subscribes to message bus events:
     - Subscribe to "capability.changed" topic via MessageBridge.SendOneWayAsync pattern (register a callback)
     - Subscribe to "plugin.loaded" topic
     - Subscribe to "plugin.unloaded" topic
     - After subscribing, do an initial full capability query via bridge.SendAsync with command "system.capabilities" to bootstrap the registry
   - `OnPluginLoaded(string pluginId, List<string> capabilities)` -- adds commands for that plugin's capabilities
   - `OnPluginUnloaded(string pluginId)` -- removes all commands sourced from that plugin
   - `OnCapabilityChanged(string pluginId, string capability, bool available)` -- updates specific command availability
   - `GetAvailableCommands()` returns IEnumerable<DynamicCommandDefinition>
   - `GetCommandsByCategory()` returns Dictionary<string, List<DynamicCommandDefinition>>
   - `IsCommandAvailable(string commandName)` returns bool
   - `RegisterCoreCommand(DynamicCommandDefinition def)` for built-in commands that always exist
   - Thread-safe: all mutations via ConcurrentDictionary operations
   - Handle startup race (Pitfall 6): after subscribing to events, always do initial full query

2. Refactor `DataWarehouse.Shared/Models/InstanceCapabilities.cs`:
   - Add `HashSet<string> DynamicFeatures { get; set; } = new()` property alongside existing bool properties
   - Add `List<string> LoadedPluginCapabilities { get; set; } = new()` for per-plugin capability lists
   - Keep existing bool properties for backward compatibility but mark with comment "Legacy -- prefer DynamicFeatures"
   - Add `bool HasDynamicFeature(string feature) => DynamicFeatures.Contains(feature)` method

3. Refactor `DataWarehouse.Shared/CapabilityManager.cs`:
   - Add `private readonly HashSet<string> _dynamicFeatures = new(StringComparer.OrdinalIgnoreCase)`
   - Modify `HasFeature(string featureName)` to check `_dynamicFeatures` FIRST, fall back to hardcoded switch for backward compat
   - Add `RegisterFeature(string featureName)` / `UnregisterFeature(string featureName)` methods that update _dynamicFeatures and raise CapabilitiesChanged
   - Add `GetAllFeatures()` returning union of dynamic features and legacy hardcoded features
   - Modify `UpdateCapabilities(InstanceCapabilities)` to also populate _dynamicFeatures from the new DynamicFeatures property
   - Add `DynamicCommandRegistry? _dynamicRegistry` field, settable via `SetDynamicRegistry(DynamicCommandRegistry registry)` -- when set, feature changes also notify the registry

All code must have XML documentation comments. Use CancellationToken on all async methods. No mocks, stubs, or placeholders (Rule 13).
  </action>
  <verify>
Run `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` -- zero errors. Verify DynamicCommandRegistry.cs exists with ConcurrentDictionary and event subscription methods. Verify CapabilityManager.cs has dynamic feature model.
  </verify>
  <done>DynamicCommandRegistry exists with event subscription, ConcurrentDictionary storage, initial bootstrap query, and CommandsChanged event. CapabilityManager supports dynamic features via HashSet alongside legacy bools. InstanceCapabilities has DynamicFeatures property.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor CommandExecutor to use DynamicCommandRegistry</name>
  <files>
    DataWarehouse.Shared/Commands/CommandExecutor.cs
    DataWarehouse.Shared/CommandRegistry.cs
  </files>
  <action>
1. Refactor `DataWarehouse.Shared/Commands/CommandExecutor.cs`:
   - Add `private readonly DynamicCommandRegistry? _dynamicRegistry` field
   - Add constructor overload that accepts `DynamicCommandRegistry` parameter
   - Keep `RegisterBuiltInCommands()` but change it to ALSO register each built-in command into the DynamicCommandRegistry as core commands (via `_dynamicRegistry?.RegisterCoreCommand(...)`)
   - Modify `AvailableCommands` property: if `_dynamicRegistry` is set, return commands from both the local _commands dict AND dynamic registry merged. Dynamic registry commands take precedence.
   - Modify `Resolve(string commandName)`: check local _commands first (for built-in ICommand instances), then check dynamic registry for commands that came from plugins
   - Modify `ExecuteAsync`: for dynamically-registered commands (from plugins), route execution through MessageBridge rather than local ICommand.ExecuteAsync -- send a message with the command name and parameters to the connected instance
   - Add `SubscribeToDynamicUpdates()` method that hooks into `_dynamicRegistry.CommandsChanged` to log command additions/removals
   - Preserve ALL existing built-in commands (zero regression per AD-08) -- the 40+ commands in RegisterBuiltInCommands() remain

2. Update `DataWarehouse.Shared/CommandRegistry.cs`:
   - Add `[Obsolete("Use DynamicCommandRegistry for runtime capability reflection. This static registry is retained for backward compatibility.")]` attribute on the class
   - Keep all existing static command definitions intact (zero regression)
   - Add `static IEnumerable<DynamicCommandDefinition> ToDynamicDefinitions()` method that converts the static CommandDefinition list to DynamicCommandDefinition format for initial seeding

Both files must compile cleanly. No removal of existing commands. All existing CommandExecutor public API signatures preserved.
  </action>
  <verify>
Run `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` -- zero errors. Verify CommandExecutor still has all 40+ commands registered. Verify CommandRegistry has [Obsolete] attribute. Verify CommandExecutor has DynamicCommandRegistry integration.
  </verify>
  <done>CommandExecutor reads from DynamicCommandRegistry when available, falls back to built-in commands. CommandRegistry marked obsolete with conversion method. All 40+ built-in commands preserved. CLI-02, CLI-04 requirements addressed.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` passes with zero errors
- DynamicCommandRegistry.cs exists with ConcurrentDictionary, event subscription, CommandsChanged event
- CommandExecutor.cs has DynamicCommandRegistry integration AND all 40+ built-in commands
- CapabilityManager.cs has dynamic HashSet<string> feature model
- CommandRegistry.cs marked [Obsolete] with ToDynamicDefinitions() conversion
- No mock data, no placeholders, no stubs
</verification>

<success_criteria>
- CLI-02: DynamicCommandRegistry subscribes to capability.changed, plugin.loaded, plugin.unloaded events
- CLI-04: CommandExecutor generates commands from DynamicCommandRegistry (no hardcoded-only lists)
- CLI-05: Both CLI and GUI can read from the same DynamicCommandRegistry (single Shared class)
- Zero regression: all 40+ built-in commands still registered and functional
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/31-unified-interface-deployment/31-01-SUMMARY.md`
</output>
