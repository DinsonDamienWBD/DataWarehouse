---
phase: 31-unified-interface-deployment
plan: 08
type: execute
wave: 3
depends_on: ["31-06"]
files_modified:
  - DataWarehouse.Shared/Services/PlatformServiceManager.cs
  - DataWarehouse.Shared/Commands/ServiceManagementCommands.cs
  - DataWarehouse.Shared/Commands/ConnectCommand.cs
  - DataWarehouse.Shared/Commands/CommandExecutor.cs
  - DataWarehouse.CLI/Program.cs
  - DataWarehouse.Launcher/Integration/DataWarehouseHost.cs
autonomous: true

must_haves:
  truths:
    - "PlatformServiceManager provides unified API for Windows sc, Linux systemd, and macOS launchd service operations"
    - "'dw service status' shows whether the DW service is running on the current platform"
    - "'dw service start/stop/restart' controls the DW service"
    - "'dw connect --host <ip> --port <port>' connects to a real running DW instance"
    - "DataWarehouseHost.RegisterServiceAsync delegates to PlatformServiceManager"
    - "GUI reads from the same DynamicCommandRegistry as CLI (feature parity verified)"
  artifacts:
    - path: "DataWarehouse.Shared/Services/PlatformServiceManager.cs"
      provides: "Cross-platform service management abstraction"
      min_lines: 100
    - path: "DataWarehouse.Shared/Commands/ServiceManagementCommands.cs"
      provides: "Service management CLI commands"
      min_lines: 50
    - path: "DataWarehouse.Shared/Commands/ConnectCommand.cs"
      provides: "Real dw connect command"
      min_lines: 40
  key_links:
    - from: "DataWarehouse.Shared/Services/PlatformServiceManager.cs"
      to: "System.Diagnostics.Process"
      via: "invokes platform-specific service management tools"
      pattern: "Process\\.Start|ProcessStartInfo"
    - from: "DataWarehouse.Launcher/Integration/DataWarehouseHost.cs"
      to: "DataWarehouse.Shared/Services/PlatformServiceManager.cs"
      via: "delegates service registration to PlatformServiceManager"
      pattern: "PlatformServiceManager"
---

<objective>
Create a unified PlatformServiceManager for cross-platform service management, add service management CLI commands, implement the real 'dw connect' command, and refactor DataWarehouseHost to use PlatformServiceManager. Verify CLI/GUI feature parity via shared DynamicCommandRegistry.

Purpose: DEPLOY-07 (platform service registration), DEPLOY-08 (autostart), DEPLOY-01 (connect command), CLI-05 (feature parity) -- completes all remaining Phase 31 requirements.
Output: PlatformServiceManager.cs, ServiceManagementCommands.cs, ConnectCommand.cs, CLI/GUI parity
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-unified-interface-deployment/31-RESEARCH.md

@DataWarehouse.Shared/Commands/ICommand.cs
@DataWarehouse.Shared/InstanceManager.cs
@DataWarehouse.Shared/MessageBridge.cs
@DataWarehouse.Launcher/Integration/DataWarehouseHost.cs
@DataWarehouse.CLI/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlatformServiceManager and refactor DataWarehouseHost</name>
  <files>
    DataWarehouse.Shared/Services/PlatformServiceManager.cs
    DataWarehouse.Launcher/Integration/DataWarehouseHost.cs
  </files>
  <action>
1. Create `DataWarehouse.Shared/Services/PlatformServiceManager.cs`:

   Class `PlatformServiceManager` (static class for service management):

   - `static async Task<ServiceStatus> GetServiceStatusAsync(string serviceName, CancellationToken ct)`:
     a. Windows: run `sc query {serviceName}`, parse output for STATE line (RUNNING, STOPPED, etc.)
     b. Linux: run `systemctl is-active {serviceName}`, check output (active, inactive, failed)
     c. macOS: run `launchctl list | grep {serviceName}`, check exit code
     d. Return ServiceStatus record: IsInstalled (bool), IsRunning (bool), State (string), PID (int?)

   - `static async Task StartServiceAsync(string serviceName, CancellationToken ct)`:
     a. Windows: run `sc start {serviceName}`
     b. Linux: run `systemctl start {serviceName}`
     c. macOS: run `launchctl start {serviceName}`
     d. Throw on non-zero exit code with stderr

   - `static async Task StopServiceAsync(string serviceName, CancellationToken ct)`:
     a. Windows: run `sc stop {serviceName}`
     b. Linux: run `systemctl stop {serviceName}`
     c. macOS: run `launchctl stop {serviceName}`

   - `static async Task RestartServiceAsync(string serviceName, CancellationToken ct)`:
     a. Windows: `sc stop` then `sc start`
     b. Linux: `systemctl restart {serviceName}`
     c. macOS: stop then start

   - `static async Task RegisterServiceAsync(ServiceRegistration registration, CancellationToken ct)`:
     a. Windows: `sc create {name} binPath= "{exePath}" DisplayName= "{displayName}" start= {startType}`
     b. Linux: write systemd unit file to /etc/systemd/system/{name}.service, `systemctl daemon-reload`
     c. macOS: write plist to /Library/LaunchDaemons/{name}.plist
     d. If registration.AutoStart: configure autostart per platform

   - `static async Task UnregisterServiceAsync(string serviceName, CancellationToken ct)`:
     a. Stop service first if running
     b. Windows: `sc delete {serviceName}`
     c. Linux: `systemctl disable {serviceName}`, delete unit file, `systemctl daemon-reload`
     d. macOS: `launchctl unload`, delete plist file

   - `static bool HasAdminPrivileges()`:
     a. Windows: check via WindowsIdentity.GetCurrent() and WindowsPrincipal.IsInRole(BuiltinRole.Administrator) -- guard with OperatingSystem.IsWindows()
     b. Linux/macOS: check if getuid() == 0 via Environment.UserName == "root" or geteuid check
     c. Return bool

   - Private helper `RunProcessAsync(string fileName, string arguments, CancellationToken ct)`:
     a. ProcessStartInfo with RedirectStandardOutput, RedirectStandardError, CreateNoWindow
     b. Start, await WaitForExitAsync
     c. Return (ExitCode, StdOut, StdErr)

   Supporting records:
   - `ServiceStatus`: IsInstalled, IsRunning, State, PID
   - `ServiceRegistration`: Name, DisplayName, ExecutablePath, WorkingDirectory, AutoStart, Description

2. Modify `DataWarehouse.Launcher/Integration/DataWarehouseHost.cs`:
   - Refactor `RegisterServiceAsync` to delegate to `PlatformServiceManager.RegisterServiceAsync`:
     a. Create ServiceRegistration from InstallConfiguration
     b. Call PlatformServiceManager.RegisterServiceAsync
     c. Remove the inline platform-specific code (it is now in PlatformServiceManager)
   - This ensures DW has ONE place for service management code (in Shared, accessible to both CLI and Launcher)

NOTE: PlatformServiceManager is in Shared (not Launcher) because CLI commands need access to it too (for `dw service status/start/stop`).
  </action>
  <verify>
Run `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` -- zero errors. Run `dotnet build DataWarehouse.Launcher/DataWarehouse.Launcher.csproj` -- zero errors. Verify PlatformServiceManager.cs has all platform-specific methods. Verify DataWarehouseHost.RegisterServiceAsync delegates to PlatformServiceManager.
  </verify>
  <done>PlatformServiceManager provides unified cross-platform service management. DataWarehouseHost delegates to it. Service status, start, stop, restart, register, unregister all implemented for Windows/Linux/macOS.</done>
</task>

<task type="auto">
  <name>Task 2: Create ServiceManagementCommands, ConnectCommand, and finalize CLI/GUI parity</name>
  <files>
    DataWarehouse.Shared/Commands/ServiceManagementCommands.cs
    DataWarehouse.Shared/Commands/ConnectCommand.cs
    DataWarehouse.Shared/Commands/CommandExecutor.cs
    DataWarehouse.CLI/Program.cs
  </files>
  <action>
1. Create `DataWarehouse.Shared/Commands/ServiceManagementCommands.cs`:
   - `ServiceStatusCommand : ICommand`:
     - Name = "service.status", Category = "deployment"
     - ExecuteAsync: call PlatformServiceManager.GetServiceStatusAsync("DataWarehouse"), return status
   - `ServiceStartCommand : ICommand`:
     - Name = "service.start", Category = "deployment"
     - ExecuteAsync: check admin privileges, start service, return result
   - `ServiceStopCommand : ICommand`:
     - Name = "service.stop", Category = "deployment"
     - ExecuteAsync: check admin privileges, stop service, return result
   - `ServiceRestartCommand : ICommand`:
     - Name = "service.restart", Category = "deployment"
     - ExecuteAsync: check admin privileges, restart service, return result
   - `ServiceUninstallCommand : ICommand`:
     - Name = "service.uninstall", Category = "deployment"
     - ExecuteAsync: check admin privileges, unregister service, return result

2. Create `DataWarehouse.Shared/Commands/ConnectCommand.cs`:
   - `ConnectCommand : ICommand`:
     - Name = "connect", Category = "core"
     - RequiredFeatures = empty
     - ExecuteAsync:
       a. Extract: host (string, required), port (int, default 8080), useTls (bool, default false), authToken (string, optional)
       b. Create ConnectionTarget with Type=Remote, Host=host, Port=port, UseTls=useTls, AuthToken=authToken
       c. Call context.InstanceManager.ConnectAsync(target)
       d. If success: discover capabilities, return connected status with instance ID and capability count
       e. If failure: return error with connection details
   - `DisconnectCommand : ICommand`:
     - Name = "disconnect", Category = "core"
     - ExecuteAsync: call context.InstanceManager.DisconnectAsync(), return success

3. Modify `DataWarehouse.Shared/Commands/CommandExecutor.cs`:
   - In RegisterBuiltInCommands(), add all new commands:
     ```csharp
     // Service management
     Register(new ServiceStatusCommand());
     Register(new ServiceStartCommand());
     Register(new ServiceStopCommand());
     Register(new ServiceRestartCommand());
     Register(new ServiceUninstallCommand());

     // Connection
     Register(new ConnectCommand());
     Register(new DisconnectCommand());
     ```

4. Modify `DataWarehouse.CLI/Program.cs`:
   - Add `service` command group with subcommands: status, start, stop, restart, uninstall
   - Add/update `connect` command with options: --host (required), --port (default 8080), --tls (flag), --auth-token
   - Add `disconnect` command (no options)
   - Wire all handlers via SetAction

5. CLI/GUI feature parity verification (CLI-05):
   - Both CLI and GUI reference DataWarehouse.Shared
   - Both use CommandExecutor which reads from DynamicCommandRegistry
   - No CLI-only or GUI-only commands -- everything goes through Shared
   - Add a comment block at the top of CommandExecutor.cs documenting the parity guarantee:
     ```csharp
     // CLI-05: Feature Parity Guarantee
     // CLI and GUI both use this CommandExecutor which reads from DynamicCommandRegistry.
     // Any command registered here (or dynamically via DynamicCommandRegistry) is available
     // to both CLI and GUI. No CLI-specific or GUI-specific command registration paths exist.
     ```

All commands: XML docs, CancellationToken, proper error handling.
  </action>
  <verify>
Run `dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj` -- zero errors. Verify ServiceManagementCommands.cs, ConnectCommand.cs exist. Verify CLI has `dw service status/start/stop/restart`, `dw connect --host --port`, `dw disconnect`.
  </verify>
  <done>Platform service management commands (status/start/stop/restart/uninstall) wired for CLI. Connect/disconnect commands implemented for real instance connection. CLI/GUI feature parity documented and guaranteed via shared CommandExecutor + DynamicCommandRegistry.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj` passes with zero errors
- `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` passes with zero errors
- `dotnet build DataWarehouse.Launcher/DataWarehouse.Launcher.csproj` passes with zero errors
- PlatformServiceManager works on Windows (sc), Linux (systemd), macOS (launchd)
- CLI has service, connect, disconnect commands
- CommandExecutor has feature parity comment block
- DataWarehouseHost delegates to PlatformServiceManager
</verification>

<success_criteria>
- DEPLOY-01: `dw connect --host <ip> --port <port>` connects to real running DW instance
- DEPLOY-07: Platform-specific service registration centralized in PlatformServiceManager
- DEPLOY-08: Platform-specific autostart configuration
- CLI-05: CLI and GUI both read from same DynamicCommandRegistry -- 100% feature parity
- All Phase 31 requirements (CLI-02 through CLI-05, DEPLOY-01 through DEPLOY-09) addressed
</success_criteria>

<output>
After completion, create `.planning/phases/31-unified-interface-deployment/31-08-SUMMARY.md`
</output>
