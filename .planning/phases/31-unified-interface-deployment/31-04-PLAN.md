---
phase: 31-unified-interface-deployment
plan: 04
type: execute
wave: 2
depends_on: ["31-03"]
files_modified:
  - DataWarehouse.Launcher/Integration/LauncherHttpServer.cs
  - DataWarehouse.Launcher/Integration/ServiceHost.cs
  - DataWarehouse.Launcher/DataWarehouse.Launcher.csproj
autonomous: true

must_haves:
  truths:
    - "Launcher exposes GET /api/v1/info returning instance ID, version, and mode"
    - "Launcher exposes GET /api/v1/capabilities returning live capabilities from loaded plugins"
    - "Launcher exposes POST /api/v1/message accepting message dispatch to the kernel"
    - "Launcher exposes POST /api/v1/execute accepting command execution"
    - "RemoteInstanceConnection can successfully connect to the Launcher HTTP endpoints"
  artifacts:
    - path: "DataWarehouse.Launcher/Integration/LauncherHttpServer.cs"
      provides: "ASP.NET Core minimal API server exposing /api/v1/* endpoints"
      min_lines: 80
    - path: "DataWarehouse.Launcher/Integration/ServiceHost.cs"
      provides: "ServiceHost that optionally starts HTTP server alongside kernel"
      contains: "LauncherHttpServer"
  key_links:
    - from: "DataWarehouse.Launcher/Integration/LauncherHttpServer.cs"
      to: "DataWarehouse.Launcher/Integration/AdapterRunner.cs"
      via: "queries kernel for capabilities, dispatches messages to kernel"
      pattern: "AdapterRunner|IKernelAdapter"
    - from: "DataWarehouse.Launcher/Integration/InstanceConnection.cs (RemoteInstanceConnection)"
      to: "DataWarehouse.Launcher/Integration/LauncherHttpServer.cs"
      via: "HTTP protocol /api/v1/* endpoints"
      pattern: "/api/v1/"
---

<objective>
Add HTTP listener endpoints to the Launcher so that RemoteInstanceConnection (which already expects /api/v1/* REST endpoints) can connect to a running DW instance. Use ASP.NET Core minimal APIs since the project targets .NET 10.

Purpose: DEPLOY-02 -- Launcher must expose an HTTP/REST listener compatible with RemoteInstanceConnection's protocol for capability discovery, message dispatch, and command execution.
Output: LauncherHttpServer.cs with 4 endpoints, ServiceHost integration
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-unified-interface-deployment/31-RESEARCH.md

@DataWarehouse.Launcher/Integration/ServiceHost.cs
@DataWarehouse.Launcher/Integration/InstanceConnection.cs
@DataWarehouse.Launcher/Integration/AdapterRunner.cs
@DataWarehouse.Launcher/Integration/IKernelAdapter.cs
@DataWarehouse.Launcher/DataWarehouse.Launcher.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LauncherHttpServer with /api/v1/* endpoints</name>
  <files>
    DataWarehouse.Launcher/Integration/LauncherHttpServer.cs
    DataWarehouse.Launcher/DataWarehouse.Launcher.csproj
  </files>
  <action>
1. Add NuGet package reference to DataWarehouse.Launcher.csproj:
   `<PackageReference Include="Microsoft.AspNetCore.App" />` -- actually, for .NET 10 console apps, use the framework reference:
   `<ItemGroup><FrameworkReference Include="Microsoft.AspNetCore.App" /></ItemGroup>`
   This enables Kestrel and minimal APIs without a separate package.

2. Create `DataWarehouse.Launcher/Integration/LauncherHttpServer.cs`:

```csharp
public sealed class LauncherHttpServer : IAsyncDisposable
{
    private readonly ILoggerFactory _loggerFactory;
    private readonly ILogger<LauncherHttpServer> _logger;
    private WebApplication? _app;
    private readonly AdapterRunner _runner;
    private bool _disposed;

    // Constructor takes AdapterRunner (to access kernel) and ILoggerFactory
    public LauncherHttpServer(AdapterRunner runner, ILoggerFactory loggerFactory);

    // Port the server is listening on
    public int Port { get; private set; }

    // Whether the server is running
    public bool IsRunning { get; private set; }

    // Starts the HTTP server on the given port
    public async Task StartAsync(int port, CancellationToken ct)
    {
        var builder = WebApplication.CreateSlimBuilder();
        builder.WebHost.UseUrls($"http://0.0.0.0:{port}");
        builder.Logging.ClearProviders(); // Use existing Serilog

        _app = builder.Build();

        // Map endpoints
        MapEndpoints(_app);

        await _app.StartAsync(ct);
        Port = port;
        IsRunning = true;
        _logger.LogInformation("HTTP server started on port {Port}", port);
    }

    private void MapEndpoints(WebApplication app)
    {
        // GET /api/v1/info -- instance information
        app.MapGet("/api/v1/info", () => {
            return Results.Ok(new {
                instanceId = _runner.CurrentKernelId ?? "unknown",
                version = "2.0.0",
                mode = _runner.CurrentMode ?? "Unknown",
                uptime = _runner.Uptime?.TotalSeconds ?? 0
            });
        });

        // GET /api/v1/capabilities -- capability discovery
        app.MapGet("/api/v1/capabilities", async (CancellationToken ct) => {
            // Query the kernel adapter for loaded plugins and their capabilities
            var capabilities = await _runner.GetCapabilitiesAsync(ct);
            return Results.Ok(capabilities);
        });

        // POST /api/v1/message -- message dispatch to kernel
        app.MapPost("/api/v1/message", async (HttpContext ctx, CancellationToken ct) => {
            var body = await ctx.Request.ReadFromJsonAsync<MessageRequest>(ct);
            if (body == null)
                return Results.BadRequest("Invalid message body");

            var response = await _runner.DispatchMessageAsync(body.Type, body.Payload, ct);
            return Results.Ok(new { success = response.Success, payload = response.Payload, error = response.Error });
        });

        // POST /api/v1/execute -- command execution
        app.MapPost("/api/v1/execute", async (HttpContext ctx, CancellationToken ct) => {
            var body = await ctx.Request.ReadFromJsonAsync<ExecuteRequest>(ct);
            if (body == null)
                return Results.BadRequest("Invalid execute body");

            var result = await _runner.ExecuteCommandAsync(body.Command, body.Arguments ?? Array.Empty<string>(), ct);
            return Results.Ok(new { success = result.Success, exitCode = result.ExitCode, output = result.Output, error = result.Error });
        });
    }

    // Stops the HTTP server
    public async Task StopAsync()
    {
        if (_app != null) {
            await _app.StopAsync();
            await _app.DisposeAsync();
            _app = null;
        }
        IsRunning = false;
    }

    public async ValueTask DisposeAsync() { ... }
}

// Request DTOs
internal sealed record MessageRequest(string Type, Dictionary<string, object>? Payload);
internal sealed record ExecuteRequest(string Command, string[]? Arguments);
```

IMPORTANT: The AdapterRunner needs additional methods for the HTTP server to call: GetCapabilitiesAsync, DispatchMessageAsync, ExecuteCommandAsync, CurrentKernelId, CurrentMode, Uptime. If AdapterRunner does not have these methods, add them. Check AdapterRunner.cs first. These methods should delegate to the active IKernelAdapter.

NOTE: If WebApplication/WebApplicationBuilder are not available because the project is a console app, the FrameworkReference to Microsoft.AspNetCore.App is the correct approach for .NET 10. DO NOT add a PackageReference to Microsoft.AspNetCore.App.
  </action>
  <verify>
Run `dotnet build DataWarehouse.Launcher/DataWarehouse.Launcher.csproj` -- zero errors. Verify LauncherHttpServer.cs exists with all 4 endpoints mapped. Verify FrameworkReference to Microsoft.AspNetCore.App added.
  </verify>
  <done>LauncherHttpServer exposes GET /api/v1/info, GET /api/v1/capabilities, POST /api/v1/message, POST /api/v1/execute using ASP.NET Core minimal APIs. Endpoints delegate to AdapterRunner/kernel.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate LauncherHttpServer into ServiceHost</name>
  <files>
    DataWarehouse.Launcher/Integration/ServiceHost.cs
    DataWarehouse.Launcher/Integration/AdapterRunner.cs
  </files>
  <action>
1. Read `DataWarehouse.Launcher/Integration/ServiceHost.cs` and `AdapterRunner.cs` first.

2. Modify `ServiceHost.cs`:
   - Add `private LauncherHttpServer? _httpServer;` field
   - In the startup path (wherever the kernel/adapter is started):
     a. After kernel startup succeeds, create a LauncherHttpServer(_runner, _loggerFactory)
     b. Start the HTTP server on a configurable port (default 8080, from config or command-line)
     c. Log the HTTP endpoint URL
   - In the shutdown path:
     a. Stop the HTTP server before stopping the kernel
     b. Dispose the HTTP server

3. Modify `AdapterRunner.cs` if needed:
   - Add `string? CurrentKernelId` property (return the current adapter's kernel ID)
   - Add `string? CurrentMode` property (return the operating mode)
   - Add `TimeSpan? Uptime` property (track start time, return elapsed)
   - Add `async Task<InstanceCapabilities> GetCapabilitiesAsync(CancellationToken ct)`:
     - Delegates to the active IKernelAdapter if it exposes capabilities
     - If not, returns a default InstanceCapabilities with basic info
   - Add `async Task<MessageResponse> DispatchMessageAsync(string type, Dictionary<string, object>? payload, CancellationToken ct)`:
     - Delegates to the active IKernelAdapter
     - Returns MessageResponse with success/error
   - Add `async Task<CommandResult> ExecuteCommandAsync(string command, string[] args, CancellationToken ct)`:
     - Delegates to the active IKernelAdapter
     - Returns CommandResult with exit code and output

   Check IKernelAdapter interface for what methods are available. If IKernelAdapter does not have capability/message/execute methods, add them to the interface and provide default implementations.

4. Ensure the HTTP server port is configurable:
   - Via appsettings.json: `"Http": { "Port": 8080, "Enabled": true }`
   - Via command-line: `--http-port 8080`
   - Via environment variable: `DW_HTTP_PORT`

All code: XML docs, CancellationToken, proper error handling. No mocks or stubs.
  </action>
  <verify>
Run `dotnet build DataWarehouse.Launcher/DataWarehouse.Launcher.csproj` -- zero errors. Verify ServiceHost creates and starts LauncherHttpServer. Verify AdapterRunner has GetCapabilitiesAsync, DispatchMessageAsync, ExecuteCommandAsync methods.
  </verify>
  <done>ServiceHost starts LauncherHttpServer alongside the kernel. AdapterRunner exposes capability query, message dispatch, and command execution methods. DEPLOY-02 fully implemented -- RemoteInstanceConnection can connect to Launcher.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.Launcher/DataWarehouse.Launcher.csproj` passes with zero errors
- LauncherHttpServer.cs exists with 4 mapped endpoints
- ServiceHost integrates HTTP server startup/shutdown
- AdapterRunner has capability, message, and execute delegation methods
- FrameworkReference to Microsoft.AspNetCore.App present (not PackageReference)
</verification>

<success_criteria>
- DEPLOY-02: Launcher exposes /api/v1/info, /api/v1/capabilities, /api/v1/message, /api/v1/execute
- DEPLOY-02: Endpoints are compatible with RemoteInstanceConnection's HTTP protocol
- HTTP port is configurable via appsettings.json / command-line / environment
- No mocks, stubs, or placeholders
</success_criteria>

<output>
After completion, create `.planning/phases/31-unified-interface-deployment/31-04-SUMMARY.md`
</output>
