---
phase: 31-unified-interface-deployment
plan: 06
type: execute
wave: 2
depends_on: ["31-03"]
files_modified:
  - DataWarehouse.Launcher/Integration/DataWarehouseHost.cs
  - DataWarehouse.Shared/Commands/InstallCommands.cs
  - DataWarehouse.CLI/Program.cs
autonomous: true

must_haves:
  truths:
    - "CopyFilesAsync copies actual binaries, DLLs, and configs from source to install path"
    - "InitializePluginsAsync copies plugin DLLs from source to plugins/ directory"
    - "CreateAdminUserAsync creates a real user record (not just a log message)"
    - "RegisterServiceAsync calls sc create on Windows, writes systemd unit on Linux, writes launchd plist on macOS"
    - "'dw install --path C:/DW --service --autostart' runs the full install pipeline"
  artifacts:
    - path: "DataWarehouse.Launcher/Integration/DataWarehouseHost.cs"
      provides: "Real implementations of CopyFilesAsync, InitializePluginsAsync, CreateAdminUserAsync, RegisterServiceAsync"
      contains: "File.Copy|Directory.CreateDirectory|Process.Start"
    - path: "DataWarehouse.Shared/Commands/InstallCommands.cs"
      provides: "InstallCommand with full parameter support"
      min_lines: 60
  key_links:
    - from: "DataWarehouse.Shared/Commands/InstallCommands.cs"
      to: "DataWarehouse.Launcher/Integration/DataWarehouseHost.cs"
      via: "calls InstallAsync with InstallConfiguration"
      pattern: "InstallAsync|InstallConfiguration"
    - from: "DataWarehouse.Launcher/Integration/DataWarehouseHost.cs"
      to: "System.Diagnostics.Process"
      via: "platform service registration"
      pattern: "Process\\.Start|ProcessStartInfo"
---

<objective>
Replace all stub implementations in DataWarehouseHost (CopyFilesAsync, InitializePluginsAsync, CreateAdminUserAsync, RegisterServiceAsync) with real production code. Create the 'dw install' CLI command with full parameter support.

Purpose: DEPLOY-05 (install pipeline), DEPLOY-07 (platform service registration), DEPLOY-08 (autostart configuration) -- the install mode must actually install DataWarehouse, not just log messages.
Output: Real DataWarehouseHost install methods, InstallCommands.cs, CLI wiring
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-unified-interface-deployment/31-RESEARCH.md

@DataWarehouse.Launcher/Integration/DataWarehouseHost.cs
@DataWarehouse.SDK/Hosting/InstallConfiguration.cs
@DataWarehouse.Shared/Commands/ICommand.cs
@DataWarehouse.CLI/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement real DataWarehouseHost install methods</name>
  <files>
    DataWarehouse.Launcher/Integration/DataWarehouseHost.cs
  </files>
  <action>
Modify `DataWarehouse.Launcher/Integration/DataWarehouseHost.cs`:

1. Replace `CopyFilesAsync` stub (currently returns Task.CompletedTask):
   - Determine source directory: AppContext.BaseDirectory (where the Launcher is running from)
   - Copy all files from source to config.InstallPath:
     a. Copy *.exe, *.dll, *.json, *.pdb files to install root
     b. Copy appsettings*.json to config/ subdirectory
     c. Use File.Copy with overwrite=true
     d. Preserve directory structure for subdirectories
     e. Skip obj/, bin/, .git/ directories
   - Log each file copied at Debug level, summary at Info level
   - Throw IOException on failure with descriptive message

2. Replace `InitializePluginsAsync` stub (currently creates dirs only):
   - Keep directory creation
   - ALSO: search for plugin DLLs in source's plugins/ subdirectory
   - For each plugin in config.IncludedPlugins:
     a. Find the plugin's DLL in the source plugins directory (match by name pattern)
     b. Copy the entire plugin directory (DLL + deps) to target plugins/ directory
   - If a requested plugin is not found in source, log a warning but continue
   - Log summary: "Initialized {N} plugins, {M} skipped (not found in source)"

3. Replace `CreateAdminUserAsync` stub (currently just logs):
   - Create a security configuration file at {installPath}/config/security.json
   - Generate a unique user ID
   - Hash the admin password using SHA256 (with salt) -- use System.Security.Cryptography.SHA256 and RandomNumberGenerator for salt
   - Write user record: { users: [{ id, username, passwordHash, salt, role: "admin", createdAt }] }
   - Use System.Text.Json for serialization (project standard)
   - Log: "Created admin user: {username}"
   - IMPORTANT: Use CryptographicOperations.ZeroMemory to wipe the password from memory after hashing (per Phase 23 MEM-01)

4. Replace `RegisterServiceAsync` stub (currently just logs):
   - Platform-specific implementation using OperatingSystem.IsWindows/IsLinux/IsMacOS:

   **Windows (sc create):**
   - Exe path: Path.Combine(config.InstallPath, "DataWarehouse.Launcher.exe")
   - Service name: "DataWarehouse"
   - Use ProcessStartInfo with FileName="sc", Arguments = $"create DataWarehouse binPath= \"{exePath}\" DisplayName= \"DataWarehouse Service\" start= auto"
   - Process.Start, await WaitForExitAsync
   - Check exit code: 0 = success, non-zero = throw with stderr
   - If config.AutoStart: also run `sc config DataWarehouse start= auto`

   **Linux (systemd):**
   - Write unit file to /etc/systemd/system/datawarehouse.service (see research Example 3)
   - Run `systemctl daemon-reload` via Process.Start
   - If config.AutoStart: run `systemctl enable datawarehouse`
   - Handle permission errors: if EACCES, throw with "Root privileges required. Run with sudo."

   **macOS (launchd):**
   - Write plist file to /Library/LaunchDaemons/com.datawarehouse.plist
   - Include ProgramArguments, RunAtLoad (if autostart), WorkingDirectory
   - Run `launchctl load /Library/LaunchDaemons/com.datawarehouse.plist`

   - Add helper method: `private async Task RunProcessAsync(string fileName, string arguments, CancellationToken ct)` that starts a process, waits for exit, and throws on non-zero exit code with stderr content.
   - Detect privilege level before attempting service registration. If insufficient privileges, throw descriptive error (Pitfall 4).

All methods: XML docs, CancellationToken, real file I/O and process execution. Zero stubs remaining.
  </action>
  <verify>
Run `dotnet build DataWarehouse.Launcher/DataWarehouse.Launcher.csproj` -- zero errors. Verify CopyFilesAsync has File.Copy calls. Verify RegisterServiceAsync has platform-specific Process.Start calls. Verify CreateAdminUserAsync has SHA256 hashing.
  </verify>
  <done>All 4 stub methods in DataWarehouseHost replaced with real implementations: file copy, plugin initialization, admin user creation with hashed password, platform-specific service registration (sc create / systemd / launchd).</done>
</task>

<task type="auto">
  <name>Task 2: Create InstallCommands and wire CLI 'dw install' command</name>
  <files>
    DataWarehouse.Shared/Commands/InstallCommands.cs
    DataWarehouse.Shared/Commands/CommandExecutor.cs
    DataWarehouse.CLI/Program.cs
  </files>
  <action>
1. Create `DataWarehouse.Shared/Commands/InstallCommands.cs`:
   - `InstallCommand : ICommand`:
     - Name = "install"
     - Description = "Install DataWarehouse to a local path"
     - Category = "deployment"
     - RequiredFeatures = empty (always available, runs locally)
     - ExecuteAsync:
       a. Extract parameters: path (string, required), service (bool, default false), autostart (bool, default false), adminPassword (string, optional), adminUsername (string, default "admin"), plugins (string list, optional), dataPath (string, optional), fromUsb (string, optional -- handled in plan 31-07)
       b. Validate: path must be provided and writable, if service=true then check admin privileges
       c. Create InstallConfiguration from parameters:
          - InstallPath = path
          - CreateService = service
          - AutoStart = autostart
          - CreateDefaultAdmin = true (always)
          - AdminUsername = adminUsername
          - AdminPassword = adminPassword (prompt if not provided? -- for CLI, use parameter; if missing, generate a random one and display it)
          - IncludedPlugins = plugins ?? default list
          - DataPath = dataPath
       d. Get IServerHost from CommandContext (IServerHost must expose InstallAsync or route to DataWarehouseHost)
       e. Call install with progress callback that logs each step
       f. Return success with install path, service status, admin credentials

   - `InstallStatusCommand : ICommand`:
     - Name = "install.verify"
     - Description = "Verify a DataWarehouse installation"
     - Category = "deployment"
     - ExecuteAsync:
       a. Extract path parameter
       b. Check: directories exist (data, config, plugins, logs)
       c. Check: config file exists and is valid JSON
       d. Check: at least one plugin DLL exists
       e. If service: check service is registered (sc query on Windows, systemctl status on Linux)
       f. Return verification report

2. Modify `DataWarehouse.Shared/Commands/CommandExecutor.cs`:
   - In RegisterBuiltInCommands(), add:
     ```csharp
     // Install commands
     Register(new InstallCommand());
     Register(new InstallStatusCommand());
     ```

3. Modify `DataWarehouse.CLI/Program.cs`:
   - Add `install` command group:
     ```
     var installCommand = new Command("install", "Install DataWarehouse locally");
     ```
   - Add options:
     - `--path` (string, required, "Installation directory")
     - `--service` (bool flag, "Register as system service")
     - `--autostart` (bool flag, "Enable autostart on boot")
     - `--admin-password` (string, "Admin password (generated if not provided)")
     - `--from-usb` (string, "Source path for USB installation" -- wired in plan 31-07)
   - Wire SetAction handler that delegates to CommandExecutor
   - Add `install verify` subcommand with `--path` option

Follow exact same System.CommandLine patterns as existing commands (SetAction, not NamingConventionBinder).
  </action>
  <verify>
Run `dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj` -- zero errors. Verify InstallCommands.cs has InstallCommand and InstallStatusCommand. Verify CLI has `dw install --path ... --service --autostart` command.
  </verify>
  <done>'dw install' command fully wired: --path, --service, --autostart, --admin-password parameters. Install verification subcommand available. DEPLOY-05 requirement met.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.Launcher/DataWarehouse.Launcher.csproj` passes with zero errors
- `dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj` passes with zero errors
- DataWarehouseHost.CopyFilesAsync copies real files
- DataWarehouseHost.RegisterServiceAsync uses sc/systemctl/launchctl
- DataWarehouseHost.CreateAdminUserAsync hashes password and writes security.json
- CLI has `dw install --path --service --autostart --admin-password` command
- CLI has `dw install verify --path` command
</verification>

<success_criteria>
- DEPLOY-05: `dw install --path <path> [--autostart] [--service] [--admin-password <pwd>]` runs full pipeline
- DEPLOY-07: Platform-specific service registration (sc create, systemd, launchd) -- production-ready
- DEPLOY-08: Platform-specific autostart (sc config, systemctl enable, launchctl load)
- Rule 13: No stubs, mocks, or placeholders remain in install pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/31-unified-interface-deployment/31-06-SUMMARY.md`
</output>
