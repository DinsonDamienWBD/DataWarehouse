---
phase: 31-unified-interface-deployment
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.Shared/MessageBridge.cs
  - DataWarehouse.Shared/InstanceManager.cs
  - DataWarehouse.Shared/Commands/ServerCommands.cs
autonomous: true

must_haves:
  truths:
    - "MessageBridge.SendInProcessAsync uses a real Channel<T>-based message queue instead of returning mock data"
    - "InstanceManager.ExecuteAsync throws InvalidOperationException when disconnected instead of returning mock response"
    - "ServerStartCommand starts the kernel via DataWarehouseHost.RunEmbeddedAsync instead of Task.Delay(100)"
    - "ServerStopCommand triggers real kernel shutdown instead of Task.Delay(500)"
  artifacts:
    - path: "DataWarehouse.Shared/MessageBridge.cs"
      provides: "Real in-process message dispatch via Channel<T>"
      contains: "Channel<"
    - path: "DataWarehouse.Shared/InstanceManager.cs"
      provides: "Proper error handling when disconnected"
      contains: "InvalidOperationException"
    - path: "DataWarehouse.Shared/Commands/ServerCommands.cs"
      provides: "Real kernel startup/shutdown"
      contains: "DataWarehouseHost"
  key_links:
    - from: "DataWarehouse.Shared/MessageBridge.cs"
      to: "System.Threading.Channels"
      via: "Channel-based producer-consumer for in-process messaging"
      pattern: "Channel<.*Message"
    - from: "DataWarehouse.Shared/Commands/ServerCommands.cs"
      to: "DataWarehouse.Launcher.Integration.DataWarehouseHost"
      via: "real kernel startup/shutdown"
      pattern: "DataWarehouseHost|RunEmbeddedAsync|RunServiceAsync"
---

<objective>
Replace all mocks, stubs, and Task.Delay placeholders in DataWarehouse.Shared with real implementations. MessageBridge gets a Channel-based in-process queue, InstanceManager gets proper disconnect error handling, and ServerCommands get real kernel startup/shutdown.

Purpose: DEPLOY-09 -- ServerStartCommand/ServerStopCommand must use real kernel startup/shutdown. MessageBridge.SendInProcessAsync must use real in-memory message queue. This plan is the FOUNDATION that plans 04, 05, 06, 07, and 08 all depend on.
Output: Real MessageBridge, real InstanceManager errors, real ServerCommands
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-unified-interface-deployment/31-RESEARCH.md

@DataWarehouse.Shared/MessageBridge.cs
@DataWarehouse.Shared/InstanceManager.cs
@DataWarehouse.Shared/Commands/ServerCommands.cs
@DataWarehouse.Launcher/Integration/DataWarehouseHost.cs
@DataWarehouse.SDK/Hosting/EmbeddedConfiguration.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace MessageBridge mock with Channel-based in-process queue</name>
  <files>
    DataWarehouse.Shared/MessageBridge.cs
  </files>
  <action>
Modify `DataWarehouse.Shared/MessageBridge.cs`:

1. Add using: `using System.Threading.Channels;`

2. Add fields:
   - `private Channel<(Message request, TaskCompletionSource<Message?> response)>? _inProcessChannel;`
   - `private CancellationTokenSource? _inProcessCts;`
   - `private Task? _inProcessConsumerTask;`
   - `private Func<Message, CancellationToken, Task<Message?>>? _inProcessHandler;`

3. Add method `ConfigureInProcessHandler(Func<Message, CancellationToken, Task<Message?>> handler)`:
   - Stores the handler function that will process messages when in in-process mode
   - This handler will be set by the DataWarehouseHost/kernel when starting embedded mode
   - The handler receives a Message and returns a response Message

4. Modify `ConnectAsync` for InProcess case:
   - Create a bounded channel: `Channel.CreateBounded<...>(new BoundedChannelOptions(100) { FullMode = BoundedChannelFullMode.Wait })`
   - Create CancellationTokenSource
   - Start a consumer task that reads from the channel, invokes _inProcessHandler, and sets the TCS result
   - Set _isConnected = true

5. Replace `SendInProcessAsync(Message message)` entirely:
   - Remove the mock response (the entire "return new Message { ... placeholder }" block)
   - If _inProcessChannel is null: throw InvalidOperationException("In-process channel not initialized. Call ConfigureInProcessHandler first.")
   - Create a TaskCompletionSource<Message?>
   - Write (message, tcs) to _inProcessChannel.Writer
   - Await tcs.Task with timeout of 30 seconds via Task.WaitAsync(TimeSpan.FromSeconds(30))
   - Return the result
   - On timeout: throw TimeoutException("In-process message processing timed out after 30 seconds")

6. Add private method `RunInProcessConsumerAsync(CancellationToken ct)`:
   - Reads from _inProcessChannel.Reader in a loop
   - For each (request, tcs): invokes _inProcessHandler(request, ct)
   - Sets tcs.SetResult(response) or tcs.SetException on error
   - Exits cleanly on cancellation

7. Modify `DisconnectAsync`:
   - If _inProcessChannel is not null: cancel _inProcessCts, complete the channel writer, await _inProcessConsumerTask
   - Dispose _inProcessCts
   - Set all in-process fields to null

8. Add `SubscribeToTopic(string topic, Func<Message, Task> handler)` method:
   - Maintains a ConcurrentDictionary<string, List<Func<Message, Task>>> _topicSubscriptions
   - Used by DynamicCommandRegistry (Plan 31-01) to subscribe to capability events
   - When a message arrives with matching topic in its Command field, invoke all subscribed handlers

All code: XML documentation, production-ready, no mocks/stubs/placeholders.
  </action>
  <verify>
Run `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` -- zero errors. Verify SendInProcessAsync no longer returns mock data. Verify Channel<T> usage. Verify ConfigureInProcessHandler method exists.
  </verify>
  <done>MessageBridge.SendInProcessAsync uses Channel<T>-based queue with real handler invocation, 30s timeout, proper cleanup on disconnect. Topic subscription support added. Zero mock data remains.</done>
</task>

<task type="auto">
  <name>Task 2: Fix InstanceManager mock and ServerCommands placeholders</name>
  <files>
    DataWarehouse.Shared/InstanceManager.cs
    DataWarehouse.Shared/Commands/ServerCommands.cs
  </files>
  <action>
1. Modify `DataWarehouse.Shared/InstanceManager.cs`:
   - Replace the mock response block in `ExecuteAsync` (lines 125-139):
     OLD: when `!_isConnected`, returns mock Message with "Command '{command}' executed (development mode)"
     NEW: when `!_isConnected`, throw `InvalidOperationException("Not connected to a DataWarehouse instance. Use 'dw connect' to connect to an instance first.")`
   - This is a simple, clean fix -- disconnected state is an error, not a silent mock

2. Modify `DataWarehouse.Shared/Commands/ServerCommands.cs`:
   - **ServerStartCommand.ExecuteAsync**: Replace `await Task.Delay(100, cancellationToken)` with real kernel startup:
     a. Add `private static DataWarehouseHost? _runningHost;` static field to track the running host
     b. If _runningHost is not null and running, return error "Server is already running"
     c. Create a new DataWarehouseHost (using Microsoft.Extensions.Logging.Abstractions.NullLoggerFactory.Instance)
     d. Create EmbeddedConfiguration with:
        - PersistData = true
        - ExposeHttp = true
        - HttpPort = port (from parameters)
        - DataPath = dataPath (from parameters or default)
     e. Start host in background: `_ = Task.Run(() => _runningHost.RunEmbeddedAsync(config, cancellationToken))`
     f. Wait briefly (up to 2 seconds) for startup confirmation
     g. Return ServerStatus with IsRunning = true, actual port, mode

   - **ServerStopCommand.ExecuteAsync**: Replace `await Task.Delay(500, cancellationToken)` with real shutdown:
     a. If ServerStartCommand._runningHost is null, return error "Server is not running"
     b. Call `_runningHost.RequestShutdown()`
     c. Wait for graceful shutdown (up to 10 seconds)
     d. Dispose the host: `await _runningHost.DisposeAsync()`
     e. Set `_runningHost = null`
     f. Return success with shutdown timestamp

   - **ServerStatusCommand.ExecuteAsync**: Remove hardcoded `Port = 5000` and `StartTime = DateTime.UtcNow.AddDays(-15)` mock values. Query actual status from _runningHost if available. If not running, return not-running status.

   - **ServerInfoCommand.ExecuteAsync**: Remove hardcoded mock values (ActiveConnections = 45, DataPath = "/var/lib/..."). Query real info from running host or connected instance.

NOTE: ServerCommands.cs needs a reference to DataWarehouse.Launcher for DataWarehouseHost. Check if DataWarehouse.Shared.csproj already references Launcher -- if NOT, do NOT add the reference (would create circular dependency since Launcher references Shared). Instead:
   - Define an `IServerHost` interface in DataWarehouse.Shared/Commands/IServerHost.cs with: StartAsync, StopAsync, IsRunning, Status
   - ServerStartCommand uses IServerHost (injected or set statically)
   - DataWarehouseHost implements IServerHost (in Launcher project, registered at startup)
   - This maintains the Shared -> SDK dependency direction

IMPORTANT: Check csproj references. Shared references SDK only. Launcher references both SDK and Shared. So Shared CANNOT reference Launcher. Use the interface approach described above.
  </action>
  <verify>
Run `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` -- zero errors. Verify InstanceManager.ExecuteAsync throws when disconnected. Verify ServerStartCommand no longer has Task.Delay(100). Verify ServerStopCommand no longer has Task.Delay(500). Verify IServerHost interface exists.
  </verify>
  <done>InstanceManager throws on disconnected ExecuteAsync (no mock). ServerCommands use IServerHost interface for real kernel startup/shutdown (no Task.Delay placeholders). DEPLOY-09 requirement met for Shared layer.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` passes with zero errors
- MessageBridge.SendInProcessAsync uses Channel<T>, no mock response
- InstanceManager.ExecuteAsync throws InvalidOperationException when disconnected
- ServerStartCommand uses IServerHost (not Task.Delay)
- ServerStopCommand uses IServerHost (not Task.Delay)
- No circular dependencies introduced
- Zero mocks/stubs/placeholders remain in these files
</verification>

<success_criteria>
- DEPLOY-09: MessageBridge.SendInProcessAsync uses real in-memory message queue
- DEPLOY-09: ServerStartCommand/ServerStopCommand use real kernel startup/shutdown
- Rule 13: No simulations, mocks, stubs, or placeholders
- No circular dependency between Shared and Launcher
- Foundation is solid for plans 04-08 to build upon
</success_criteria>

<output>
After completion, create `.planning/phases/31-unified-interface-deployment/31-03-SUMMARY.md`
</output>
