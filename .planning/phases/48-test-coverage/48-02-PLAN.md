---
phase: 48
plan: 48-02
title: "Integration Tests"
depends_on: []
---

# Plan 48-02: Integration Tests

## Goal
Verify end-to-end integration across plugins, message bus, kernel, and external systems. Test plugin-to-plugin communication, write/read pipeline, AEDS server→client distribution, and dashboard→kernel→plugin→storage round-trip.

## Approach
1. **Test Environment Setup**:
   - Create integration test environment:
     - In-memory database (SQLite, LiteDB)
     - In-memory storage (MemoryStream)
     - Mock external services (S3, Azure Blob, MQTT broker)
   - Start kernel with test configuration
   - Load required plugins (UltimateCompression, UltimateEncryption, UltimateStorage, etc.)

2. **Plugin-to-Plugin Communication via Message Bus**:
   - Test scenario: Plugin A publishes message, Plugin B subscribes and processes
   - Example: `UltimateDataLineage` publishes lineage event, `UltimateDataCatalog` subscribes and updates catalog
   - Test steps:
     - Load both plugins
     - Publish lineage event via message bus
     - Verify `UltimateDataCatalog` receives event
     - Verify catalog updated with lineage metadata
   - Test multiple subscribers (fan-out):
     - Publish event
     - Verify multiple plugins receive event
     - Verify each processes independently
   - Test request-response pattern:
     - Plugin A requests capability from Plugin B
     - Plugin B responds with result
     - Verify Plugin A receives result

3. **Write/Read Pipeline E2E**:
   - Test scenario: Write data → compress → encrypt → store → replicate → read → decrypt → decompress
   - Test steps:
     - **Write**: client writes data via API (`POST /api/data`)
     - **Compress**: `UltimateCompression` compresses data (gzip)
     - **Encrypt**: `UltimateEncryption` encrypts compressed data (AES-256-GCM)
     - **Store**: `UltimateStorage` stores encrypted data (S3 backend)
     - **Replicate**: `UltimateReplication` replicates to secondary storage
     - **Read**: client reads data via API (`GET /api/data/{id}`)
     - **Retrieve**: `UltimateStorage` retrieves encrypted data from storage
     - **Decrypt**: `UltimateEncryption` decrypts data
     - **Decompress**: `UltimateCompression` decompresses data
     - **Return**: API returns original data to client
   - Verify: data read == data written (byte-for-byte match)
   - Verify: intermediate data encrypted (cannot read without decryption key)
   - Verify: replication successful (data exists on secondary storage)

4. **AEDS Server→Client Distribution**:
   - Test scenario: Server distributes data to client via AEDS protocol
   - Test steps:
     - Start server in Server profile (AEDS service running)
     - Start client in Client profile (connects to server)
     - Server writes data to local storage
     - Server publishes update notification via message bus
     - `AedsCore` receives notification, sends to client via gRPC/MQTT/WebSocket
     - Client receives data, stores locally
     - Verify: client storage contains data from server
   - Test offline sync:
     - Client disconnects
     - Server writes data while client offline
     - Client reconnects
     - Verify: client receives missed updates (sync from last known state)

5. **Dashboard→Kernel→Plugin→Storage Round-Trip**:
   - Test scenario: Dashboard queries kernel, kernel queries plugin, plugin queries storage, results returned to dashboard
   - Test steps:
     - **Dashboard**: user clicks "Storage Usage" in dashboard
     - **API**: dashboard sends `GET /api/dashboard/storage`
     - **Kernel**: API handler publishes `GetStorageUsage` message on bus
     - **Plugin**: `UltimateStorage` subscribes to message, queries all backends
     - **Backend**: each backend returns usage stats (bytes, objects)
     - **Plugin**: aggregates results, publishes response
     - **Kernel**: receives response, sends to API handler
     - **API**: returns JSON response to dashboard
     - **Dashboard**: updates UI with usage stats
   - Verify: dashboard displays real data (not mock values)
   - Verify: data updates in real-time (refresh → new values)
   - Test error handling:
     - Backend unavailable → verify graceful degradation (show partial data + error)
     - Plugin not loaded → verify error message in dashboard

6. **Multi-Plugin Workflow Integration**:
   - Test scenario: Complex workflow involving multiple plugins
   - Example: Data ingestion → format detection → transcoding → compression → encryption → storage → lineage → catalog → compliance
   - Test steps:
     - Ingest media file (video.mp4)
     - `UltimateDataFormat` detects format (MP4, H.264 codec)
     - `Transcoding.Media` transcodes to H.265
     - `UltimateCompression` compresses (zstd)
     - `UltimateEncryption` encrypts (AES-256-GCM)
     - `UltimateStorage` stores (S3)
     - `UltimateDataLineage` records lineage (video.mp4 → transcode → compress → encrypt → S3)
     - `UltimateDataCatalog` updates catalog (new entry with metadata)
     - `UltimateCompliance` checks compliance (GDPR retention policy applied)
   - Verify: all steps execute successfully
   - Verify: lineage captured E2E (can trace from original file to stored object)
   - Verify: catalog entry exists with all metadata

7. **Concurrency and Race Condition Testing**:
   - Test concurrent writes:
     - 10 threads write data simultaneously
     - Verify: all writes succeed
     - Verify: no data loss (read all 10 objects)
     - Verify: no data corruption (each object matches original)
   - Test concurrent reads:
     - 10 threads read same data simultaneously
     - Verify: all reads succeed
     - Verify: correct data returned (matches original)
   - Test concurrent plugin operations:
     - Multiple plugins processing same message
     - Verify: no race conditions (thread-safe message handling)

## Scope
**In Scope:**
- Plugin-to-plugin communication via message bus
- Write/read pipeline E2E (compress → encrypt → store → replicate → retrieve → decrypt → decompress)
- AEDS server→client distribution
- Dashboard→kernel→plugin→storage round-trip
- Multi-plugin workflow integration
- Concurrency and race condition testing

**Out of Scope:**
- Unit tests (Plan 48-01)
- Edge case/failure mode tests (Plan 48-03)
- Cross-platform tests (Plan 48-04)

## Success Criteria
- [ ] Test environment setup (in-memory database, storage, mock services)
- [ ] Plugin-to-plugin communication verified (publish → subscribe → process)
- [ ] Fan-out verified (multiple subscribers receive event)
- [ ] Request-response pattern verified (request → response)
- [ ] Write/read pipeline verified E2E (data written == data read)
- [ ] Intermediate data encrypted verified (cannot read without key)
- [ ] Replication verified (data on secondary storage)
- [ ] AEDS server→client distribution verified (server writes → client receives)
- [ ] Offline sync verified (client reconnects → receives missed updates)
- [ ] Dashboard round-trip verified (dashboard → kernel → plugin → storage → response)
- [ ] Real-time updates verified (refresh → new values)
- [ ] Multi-plugin workflow verified (data ingestion → lineage → catalog → compliance)
- [ ] Concurrent writes verified (10 threads, no data loss, no corruption)
- [ ] Concurrent reads verified (10 threads, correct data)
- [ ] All tests pass (green)

## Output
- `TEST-COVERAGE-integration.md`: Integration test results
  - Plugin-to-plugin communication test results
  - Write/read pipeline E2E test results
  - AEDS server→client distribution test results
  - Dashboard round-trip test results
  - Multi-plugin workflow test results
  - Concurrency test results
  - All failures documented (expected vs actual)
- Test projects:
  - `DataWarehouse.IntegrationTests/` with integration tests
  - Test fixtures for environment setup
  - Helper classes for common test scenarios
