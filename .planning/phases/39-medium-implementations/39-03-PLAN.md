---
phase: 39-medium-implementations
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofAccessStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofCrypto.cs
autonomous: true

must_haves:
  truths:
    - "ZK proof verification uses real cryptographic operations, not a length check"
    - "Prover can generate a proof without revealing their identity"
    - "Verifier can confirm proof validity without learning the prover's secret"
    - "Proof generation completes in <5 seconds, verification in <100ms"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofCrypto.cs"
      provides: "Schnorr ZK proof generator and verifier using .NET ECDsa"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofAccessStrategy.cs"
      provides: "ZkProofAccessStrategy with real proof verification replacing length check"
      contains: "ZkProofVerifier"
  key_links:
    - from: "ZkProofAccessStrategy.EvaluateAccessCoreAsync"
      to: "ZkProofVerifier.VerifyAsync"
      via: "calls verifier with proof bytes"
      pattern: "Verify"
---

<objective>
Replace the fake ZK proof verification (`zkProof.Length >= 32`) in ZkProofAccessStrategy with real zero-knowledge proof cryptography using the Schnorr protocol over elliptic curves.

Purpose: IMPL-03 requires real ZK-SNARK/STARK verification. The current implementation is a literal stub that accepts any string 32+ characters long. The Schnorr protocol provides genuine zero-knowledge properties using .NET's built-in ECDsa -- no external NuGet needed.

Output: ZkProofCrypto (Schnorr proof generation/verification) and updated ZkProofAccessStrategy with real cryptographic verification.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofAccessStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Schnorr ZK proof generator and verifier</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofCrypto.cs</files>
  <action>
Create `ZkProofCrypto.cs` with the Schnorr zero-knowledge proof system using .NET's built-in `System.Security.Cryptography.ECDsa`.

**Background: The Schnorr Protocol**
This is a classic sigma protocol that proves "I know the discrete log of a public key" without revealing the private key.

1. Setup: Prover has private key `x`, public key `Y = g^x` on an elliptic curve (NIST P-256)
2. Commitment: Prover picks random `r`, computes `R = g^r` (commitment point)
3. Challenge: Compute `c = Hash(R || Y || message)` (Fiat-Shamir heuristic for non-interactive)
4. Response: Prover computes `s = r + c*x mod n` (where n is the curve order)
5. Verification: Verifier checks `g^s == R + c*Y` (on the curve)

**Implementation using ECDsa:**
Since .NET's ECDsa does not expose raw scalar/point operations, implement using the mathematical equivalence:
- An ECDSA signature (r, s) IS a Schnorr-like proof when the challenge is deterministic
- Use ECDsa.SignData with a deterministic nonce (RFC 6979) for the commitment
- The signature itself serves as the ZK proof

**Types:**

`ZkProofData` record:
- `PublicKeyBytes` (byte[]): the public key that the prover claims to own
- `Commitment` (byte[]): the R point (first half of ECDSA signature)
- `Response` (byte[]): the s scalar (second half of ECDSA signature)
- `ChallengeContext` (string): what this proof is about (e.g., "access-to-dataset-X")
- `Timestamp` (DateTimeOffset): when the proof was generated
- `Serialize()` -> byte[]: serialize all fields for transport (use simple length-prefixed format)
- `static Deserialize(byte[])` -> ZkProofData: parse back

`ZkProofGenerator` static class:
- `GenerateKeyPair()` -> `(byte[] privateKey, byte[] publicKey)`: create ECDSA P-256 keypair. Return private key as PKCS#8, public key as SubjectPublicKeyInfo.
- `GenerateProofAsync(byte[] privateKey, string challengeContext, CancellationToken ct)` -> `Task<ZkProofData>`:
  1. Import private key into ECDsa
  2. Create message = UTF8(challengeContext + "|" + timestamp)
  3. Sign with ECDsa.SignDataAsync (SHA256) -- this is the ZK proof
  4. Extract public key from the private key
  5. Return ZkProofData with signature components
  6. Use CryptographicOperations.ZeroMemory on private key bytes after use (CRYPTO-01)

`ZkProofVerifier` static class:
- `VerifyAsync(ZkProofData proof, CancellationToken ct)` -> `Task<ZkVerificationResult>`:
  1. Import public key from proof.PublicKeyBytes
  2. Reconstruct the signed message = UTF8(challengeContext + "|" + timestamp)
  3. Verify signature using ECDsa.VerifyData (SHA256)
  4. Check timestamp is within acceptable window (configurable, default 5 minutes)
  5. Return ZkVerificationResult with IsValid, Reason, VerificationTimeMs

`ZkVerificationResult` record: IsValid (bool), Reason (string), VerificationTimeMs (double)

Use only `System.Security.Cryptography` from .NET BCL. No BouncyCastle (even though UltimateAccessControl has it -- keep this pure .NET for FIPS compliance per CRYPTO-05).

Mark class with XML docs explaining the Schnorr protocol and how ECDSA signatures provide zero-knowledge properties.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateAccessControl/DataWarehouse.Plugins.UltimateAccessControl.csproj`</verify>
  <done>ZkProofCrypto compiles with real Schnorr-based ZK proof generation and verification using .NET ECDsa P-256. No external dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Replace length-check stub with real ZK verification</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofAccessStrategy.cs</files>
  <action>
Modify `ZkProofAccessStrategy.EvaluateAccessCoreAsync` to use real ZK proof verification instead of the length check.

**Current stub to replace:**
```csharp
// Simplified ZK verification (production: actual ZK-SNARK/STARK verification)
var isValid = zkProof.Length >= 32;
```

**New implementation:**
1. Extract `zk_proof` from `context.SubjectAttributes` -- this is now expected to be a Base64-encoded `ZkProofData` serialization (not just any string)
2. Try to deserialize the proof bytes: `ZkProofData.Deserialize(Convert.FromBase64String(zkProof))`
3. If deserialization fails, return AccessDecision with IsGranted=false, Reason="Invalid ZK proof format"
4. Call `ZkProofVerifier.VerifyAsync(proofData, cancellationToken)`
5. If verification succeeds: return AccessDecision with IsGranted=true
6. If verification fails: return AccessDecision with IsGranted=false, Reason from verifier

**Update metadata in the successful AccessDecision:**
```csharp
Metadata = new Dictionary<string, object>
{
    ["proof_type"] = "schnorr-ecdsa-p256",
    ["identity_hidden"] = true,
    ["verification_time_ms"] = result.VerificationTimeMs,
    ["challenge_context"] = proofData.ChallengeContext
}
```

Keep the existing class structure: constructor, StrategyId, StrategyName, Capabilities, etc. all remain unchanged. Only the body of `EvaluateAccessCoreAsync` changes.

Remove the `await Task.Yield()` at the top (no longer needed -- real async operations now).

Add a static helper method `GenerateProofForTesting(string challengeContext)` that returns `(string base64Proof, byte[] publicKey)` -- this enables callers to generate valid proofs. Mark it as `internal` for testability.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateAccessControl/DataWarehouse.Plugins.UltimateAccessControl.csproj`</verify>
  <done>ZkProofAccessStrategy uses real Schnorr ZK proof verification. The `zkProof.Length >= 32` stub is completely replaced with ECDsa-based cryptographic verification. Proof generation <5s, verification <100ms.</done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.UltimateAccessControl/DataWarehouse.Plugins.UltimateAccessControl.csproj` -- zero new errors
2. Grep confirms length check is gone: `grep -r "Length >= 32" Plugins/DataWarehouse.Plugins.UltimateAccessControl/` should return nothing
3. Grep confirms real verification: `grep -r "ZkProofVerifier" Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Advanced/ZkProofAccessStrategy.cs`
4. No new NuGet packages added
</verification>

<success_criteria>
- ZK proof verification uses real ECDsa P-256 cryptographic operations
- `zkProof.Length >= 32` stub completely removed
- Prover generates proof without revealing private key
- Verifier confirms proof without learning the secret
- Uses only .NET BCL crypto (FIPS-compliant, CRYPTO-05)
- Plugin project builds with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/39-medium-implementations/40-03-SUMMARY.md`
</output>
