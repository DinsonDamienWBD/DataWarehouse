---
phase: 39-medium-implementations
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/ContinuousSyncService.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/DeviceManagementStrategies.cs
autonomous: true

must_haves:
  truths:
    - "Physical sensor data updates are reflected in digital twin within 100ms"
    - "State projection can predict future twin state based on historical trend"
    - "What-if simulation projects the effect of parameter changes on twin state"
    - "DeviceTwin model is extended with sync/projection/simulation capabilities"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/ContinuousSyncService.cs"
      provides: "ContinuousSyncService, StateProjectionEngine, WhatIfSimulator"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/DeviceManagementStrategies.cs"
      provides: "DeviceTwinStrategy extended with SyncAsync, ProjectAsync, SimulateAsync methods"
      contains: "SyncAsync"
  key_links:
    - from: "DeviceTwinStrategy"
      to: "ContinuousSyncService"
      via: "delegates continuous sync to ContinuousSyncService"
      pattern: "ContinuousSyncService"
    - from: "ContinuousSyncService"
      to: "DeviceTwin"
      via: "updates ReportedProperties and tracks history"
      pattern: "ReportedProperties"
---

<objective>
Extend the existing DeviceTwin model with continuous real-time synchronization from physical sensors, state projection (predict future state), and what-if simulation capability.

Purpose: IMPL-06 requires digital twin continuous sync within 100ms, state projection using historical data, and what-if simulation. The DeviceTwinStrategy already manages desired/reported properties but lacks real-time sync, trend analysis, and simulation.

Output: ContinuousSyncService (real-time sync + history), StateProjectionEngine (trend extrapolation), WhatIfSimulator (parameter change projection), integrated into DeviceTwinStrategy.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/DeviceManagementStrategies.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build ContinuousSyncService, StateProjectionEngine, and WhatIfSimulator</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/ContinuousSyncService.cs</files>
  <action>
Create `ContinuousSyncService.cs` in the DeviceManagement directory with three main classes:

**1. ContinuousSyncService**

Manages real-time synchronization from sensor data to digital twin state.

Constructor: `(ContinuousSyncOptions? options = null)`

`ContinuousSyncOptions` record: MaxHistoryPerProperty (default 1000), SyncTimeoutMs (default 100), MaxDevices (default 10_000)

Core data structures:
- `ConcurrentDictionary<string, DeviceSyncState>` -- per-device sync state
- `DeviceSyncState`: DeviceTwin reference, PropertyHistory (ConcurrentDictionary of string to BoundedList of TimestampedValue), LastSyncAt, SyncCount

Methods:
- `RegisterTwin(string deviceId, DeviceTwin twin)`: register a twin for continuous sync
- `UnregisterTwin(string deviceId)`: stop syncing
- `SyncSensorDataAsync(string deviceId, Dictionary<string, object> sensorReadings, CancellationToken ct)` -> `Task<SyncResult>`:
  1. Look up DeviceSyncState for the device
  2. Update twin.ReportedProperties with new sensor values
  3. Record each value with timestamp in PropertyHistory
  4. Update twin.LastUpdated to DateTimeOffset.UtcNow
  5. Increment twin.Version
  6. Return SyncResult with SyncLatencyMs (measure from entry to completion)
  7. Target: complete within 100ms (the method itself is fast -- it is an in-memory update)

- `GetPropertyHistoryAsync(string deviceId, string propertyName, TimeSpan window, CancellationToken ct)` -> `Task<IReadOnlyList<TimestampedValue>>`:
  Return historical values within the specified time window.

Supporting types:
- `TimestampedValue` record: Timestamp (DateTimeOffset), Value (object)
- `SyncResult` record: Success (bool), SyncLatencyMs (double), PropertiesUpdated (int)
- `BoundedList<T>`: simple circular buffer with configurable max size (evicts oldest when full)

**2. StateProjectionEngine**

Predicts future twin state using linear extrapolation on historical data.

Methods:
- `ProjectAsync(ContinuousSyncService syncService, string deviceId, string propertyName, TimeSpan horizon, CancellationToken ct)` -> `Task<StateProjection>`:
  1. Get property history for the last N minutes (configurable, default 10 min)
  2. Filter to numeric values (double, int, float, decimal -- skip non-numeric)
  3. Calculate linear regression: y = mx + b using least-squares fit
     - m = (N * sum(xy) - sum(x) * sum(y)) / (N * sum(x^2) - (sum(x))^2)
     - b = (sum(y) - m * sum(x)) / N
     - Where x = seconds since first reading, y = numeric value
  4. Project value at current_time + horizon
  5. Calculate R-squared for confidence measure
  6. Return StateProjection with ProjectedValue, Confidence (R-squared), Trend (Increasing/Decreasing/Stable), TimeToThreshold (if threshold provided)

- `ProjectMultipleAsync(ContinuousSyncService syncService, string deviceId, string[] propertyNames, TimeSpan horizon, CancellationToken ct)` -> `Task<Dictionary<string, StateProjection>>`:
  Project multiple properties at once.

Supporting types:
- `StateProjection` record: PropertyName, CurrentValue (double), ProjectedValue (double), Confidence (double 0-1), Trend (enum: Increasing/Decreasing/Stable), ProjectionHorizon (TimeSpan), TimeToThreshold (TimeSpan? -- null if no threshold)
- `TrendDirection` enum: Increasing, Decreasing, Stable

**3. WhatIfSimulator**

Projects the effect of parameter changes on twin state.

Methods:
- `SimulateAsync(ContinuousSyncService syncService, string deviceId, Dictionary<string, object> proposedChanges, TimeSpan simulationHorizon, CancellationToken ct)` -> `Task<WhatIfResult>`:
  1. Take current twin state and property history
  2. For each proposed change:
     - Find the current trend for that property (from StateProjectionEngine)
     - Apply the change as a step function overlay
     - For correlated properties (e.g., if "airflow" increases, "temperature" decreases): use simple correlation coefficients from historical co-occurrence
  3. Project all properties forward with the proposed changes applied
  4. Return WhatIfResult with before/after projections

- `GetCorrelationsAsync(ContinuousSyncService syncService, string deviceId, CancellationToken ct)` -> `Task<Dictionary<(string, string), double>>`:
  Calculate Pearson correlation coefficients between all pairs of numeric properties from history.

Supporting types:
- `WhatIfResult` record: DeviceId, ProposedChanges (Dictionary), Projections (Dictionary of string to WhatIfPropertyProjection), CorrelatedEffects (List of CorrelatedEffect)
- `WhatIfPropertyProjection` record: PropertyName, CurrentValue, ProjectedWithoutChange, ProjectedWithChange, Delta
- `CorrelatedEffect` record: TriggerProperty, AffectedProperty, CorrelationCoefficient, ExpectedDelta

All collections bounded per MEM-03. Use ConcurrentDictionary for thread safety. No NuGet packages needed.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/DataWarehouse.Plugins.UltimateIoTIntegration.csproj`</verify>
  <done>ContinuousSyncService syncs sensor data to twin within 100ms. StateProjectionEngine predicts future state via linear regression. WhatIfSimulator projects parameter change effects with correlation analysis.</done>
</task>

<task type="auto">
  <name>Task 2: Extend DeviceTwinStrategy with sync/project/simulate methods</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/DeviceManagementStrategies.cs</files>
  <action>
Extend the existing `DeviceTwinStrategy` class with new methods that wire to ContinuousSyncService, StateProjectionEngine, and WhatIfSimulator. Do NOT modify any existing methods -- only ADD new ones.

Add private field to DeviceTwinStrategy:
```csharp
private readonly ContinuousSyncService _syncService = new();
private readonly StateProjectionEngine _projectionEngine = new();
private readonly WhatIfSimulator _simulator = new();
```

Add new methods to DeviceTwinStrategy:

1. `public async Task<SyncResult> SyncSensorDataAsync(string deviceId, Dictionary<string, object> sensorReadings, CancellationToken ct = default)`:
   - Ensure twin is registered with sync service (lazy registration)
   - Call `_syncService.SyncSensorDataAsync(deviceId, sensorReadings, ct)`
   - Return SyncResult

2. `public async Task<SyncResult> StartContinuousSyncAsync(string deviceId, CancellationToken ct = default)`:
   - Get or create twin for deviceId
   - Register with sync service
   - Return success result

3. `public async Task<StateProjection> ProjectStateAsync(string deviceId, string propertyName, TimeSpan horizon, CancellationToken ct = default)`:
   - Call `_projectionEngine.ProjectAsync(_syncService, deviceId, propertyName, horizon, ct)`
   - Return StateProjection

4. `public async Task<WhatIfResult> SimulateAsync(string deviceId, Dictionary<string, object> proposedChanges, TimeSpan horizon, CancellationToken ct = default)`:
   - Call `_simulator.SimulateAsync(_syncService, deviceId, proposedChanges, horizon, ct)`
   - Return WhatIfResult

5. `public async Task<IReadOnlyList<TimestampedValue>> GetPropertyHistoryAsync(string deviceId, string propertyName, TimeSpan window, CancellationToken ct = default)`:
   - Call `_syncService.GetPropertyHistoryAsync(deviceId, propertyName, window, ct)`
   - Return history

Do NOT modify:
- RegisterDeviceAsync (existing)
- GetDeviceTwinAsync (existing)
- UpdateDeviceTwinAsync (existing)
- ListDevicesAsync (existing)
- UpdateFirmwareAsync (existing)
- DeleteDeviceAsync (existing)
- GetDeviceAsync (existing)

Also do NOT modify any other strategy class in the file (DeviceRegistryStrategy, FleetManagementStrategy, FirmwareOtaStrategy, DeviceLifecycleStrategy) -- they remain exactly as they are.

Modify the override of `RegisterDeviceAsync` in DeviceTwinStrategy to also auto-register the twin with the sync service after creating it (add one line after the twin is created: `_syncService.RegisterTwin(deviceId, twin)`). This is a minimal, additive change.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/DataWarehouse.Plugins.UltimateIoTIntegration.csproj`</verify>
  <done>DeviceTwinStrategy has SyncSensorDataAsync, ProjectStateAsync, SimulateAsync, GetPropertyHistoryAsync methods. Twin auto-registers with sync service on creation. All existing methods unchanged. Other strategy classes in the file untouched.</done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/DataWarehouse.Plugins.UltimateIoTIntegration.csproj` -- zero new errors
2. Grep confirms sync method: `grep -r "SyncSensorDataAsync" Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/`
3. Grep confirms projection: `grep -r "ProjectStateAsync" Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/`
4. Grep confirms simulation: `grep -r "SimulateAsync" Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/`
5. Other strategy classes in DeviceManagementStrategies.cs unchanged (diff check)
</verification>

<success_criteria>
- ContinuousSyncService updates twin ReportedProperties within 100ms of sensor data arrival
- StateProjectionEngine predicts future state using linear regression on historical data
- WhatIfSimulator projects parameter change effects with correlation analysis
- DeviceTwinStrategy has SyncSensorDataAsync, ProjectStateAsync, SimulateAsync methods
- All existing DeviceTwinStrategy methods unchanged
- All other strategies in DeviceManagementStrategies.cs unchanged
- No NuGet packages added
- Plugin project builds with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/39-medium-implementations/40-06-SUMMARY.md`
</output>
