---
phase: 73-vde-regions-operations
plan: 05
type: execute
wave: 4
depends_on: ["73-01", "73-03", "73-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/VdeSeparationManager.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/VdeFederationRegion.cs
autonomous: true

must_haves:
  truths:
    - "VDE separation manager allows configuring data on VDE1, index on VDE2, metadata on VDE3"
    - "Separation routing is user-configurable per data object via role-based VDE assignment"
    - "VDE federation resolves cross-region dw:// namespaces with geo-aware routing"
    - "Federation supports geo-region awareness with latency-based routing preferences"
    - "Both components use CrossVdeReferenceRegion for persisting cross-VDE links"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/VdeSeparationManager.cs"
      provides: "VDE index/metadata separation with user-configurable routing"
      contains: "VdeSeparationManager"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/VdeFederationRegion.cs"
      provides: "VDE federation with geo-aware namespace resolution"
      contains: "VdeFederationRegion"
  key_links:
    - from: "VdeSeparationManager"
      to: "CrossVdeReferenceRegion"
      via: "uses VdeReference with ReferenceType DataLink/IndexLink/MetadataLink"
      pattern: "ReferenceType"
    - from: "VdeFederationRegion"
      to: "BlockTypeTags.XREF"
      via: "federation namespace entries serialized with XREF"
      pattern: "BlockTypeTags\\.XREF"
---

<objective>
Implement VDE index/metadata separation (cross-VDE data/index/metadata split with user-configurable routing) and VDE federation (geo-aware cross-region namespace resolution).

Purpose: Separation manager enables spreading a logical dataset across multiple VDEs (data on VDE1, index on VDE2, metadata on VDE3) for performance and isolation. Federation enables resolving dw:// namespaces across geographic regions with latency-aware routing.
Output: Two new files in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/73-vde-regions-operations/73-01-SUMMARY.md

These components build on CrossVdeReferenceRegion from 73-01:
- VdeReference.ReferenceType values: 0=DataLink, 1=IndexLink, 2=MetadataLink, 3=FabricLink
- CrossVdeReferenceRegion stores and queries cross-VDE references
- DetectBrokenLinks validates target VDE existence

@DataWarehouse.SDK/VirtualDiskEngine/Regions/CrossVdeReferenceRegion.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: VDE Separation Manager</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/VdeSeparationManager.cs</files>
  <action>
Create `VdeSeparationManager.cs` with:

1. `VdeRole` enum (`[SdkCompatibility("6.0.0")]`):
   - `Data = 0` -- stores raw data blocks
   - `Index = 1` -- stores index structures (B-tree nodes, tag index)
   - `Metadata = 2` -- stores metadata (inodes, region directory, policies)
   - `Combined = 3` -- single VDE holds all roles (default, no separation)

2. `VdeRoleAssignment` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `Guid VdeId` -- the VDE being assigned a role
   - `VdeRole Role` -- what this VDE stores
   - `byte Priority` -- routing priority (0=primary, 1=secondary, 2=tertiary)
   - `long CapacityBlocks` -- total blocks available on this VDE for this role
   - `long UsedBlocks` -- blocks currently used
   - `bool IsReadOnly` -- whether this VDE is read-only for this role
   - `const int SerializedSize = 36` (16+1+1+8+8+1+1padding = 36) -- recalculate: Guid(16)+Role as byte(1)+Priority(1)+CapacityBlocks(8)+UsedBlocks(8)+IsReadOnly as byte(1)+padding(1) = 36
   - `internal void WriteTo(Span<byte>, int offset)` / `internal static VdeRoleAssignment ReadFrom(ReadOnlySpan<byte>, int offset)`

3. `VdeSeparationManager` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- VDE Separation (VADV-01)")]`):
   - Internal: `List<VdeRoleAssignment>` + `Dictionary<Guid, List<int>>` grouping by VdeId
   - `uint Generation { get; set; }`
   - `int AssignmentCount` property

   Configuration methods:
   - `void AssignRole(VdeRoleAssignment assignment)` -- assigns a VDE to a role. Multiple VDEs can have the same role (for redundancy). One VDE can have multiple roles.
   - `void RemoveAssignment(Guid vdeId, VdeRole role)` -- removes specific role from VDE
   - `IReadOnlyList<VdeRoleAssignment> GetAssignmentsByRole(VdeRole role)` -- all VDEs assigned to this role, ordered by priority
   - `IReadOnlyList<VdeRoleAssignment> GetAssignmentsByVde(Guid vdeId)` -- all roles for this VDE

   Routing methods:
   - `Guid? ResolveVdeForRole(VdeRole role)` -- returns the primary (lowest priority number) non-readonly VDE for this role. Returns null if no VDE assigned.
   - `IReadOnlyList<Guid> ResolveAllVdesForRole(VdeRole role)` -- all VDEs for role, ordered by priority
   - `bool IsSeparated` -- true if any assignments exist with different roles on different VDEs (false if all Combined or empty)

   Cross-VDE reference integration:
   - `IReadOnlyList<VdeReference> GenerateCrossReferences()` -- generates VdeReference entries for all cross-VDE relationships. For each pair of VDEs with different roles, creates a VdeReference with ReferenceType matching the role (DataLink for Data, IndexLink for Index, MetadataLink for Metadata). These can be added to a CrossVdeReferenceRegion.

   Serialization:
   - Header: `[AssignmentCount:4 LE][Reserved:12][VdeRoleAssignment entries...]`
   - `int RequiredBlocks(int blockSize)` / `void Serialize(Span<byte>, int blockSize)` / `static VdeSeparationManager Deserialize(ReadOnlySpan<byte>, int blockSize, int blockCount)`
   - Use BlockTypeTags.XREF (shares tag with CrossVdeReferenceRegion -- differentiated by RegionDirectory slot assignment).
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles clean. Verify ResolveVdeForRole and GenerateCrossReferences exist.
  </verify>
  <done>
VdeSeparationManager.cs exists with role-based VDE assignment, priority-based routing, and cross-reference generation. Builds clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: VDE Federation Region</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/VdeFederationRegion.cs</files>
  <action>
Create `VdeFederationRegion.cs` with:

1. `GeoRegion` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `ushort RegionId` -- numeric ID for the geographic region
   - `byte[] RegionName` -- UTF-8 name (max 32 bytes, e.g., "us-east-1", "eu-west-1")
   - `double Latitude` -- region center latitude
   - `double Longitude` -- region center longitude
   - Serialized: `[RegionId:2][NameLength:2][RegionName:variable max 32][Latitude:8][Longitude:8]`
   - `int SerializedSize => 20 + (RegionName?.Length ?? 0)`
   - `internal int WriteTo(Span<byte>, int offset)` / `internal static GeoRegion ReadFrom(ReadOnlySpan<byte>, int offset, out int bytesRead)`

2. `FederationEntry` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `Guid VdeId` -- the VDE in the federation
   - `ushort GeoRegionId` -- which geographic region this VDE is in
   - `byte[] NamespacePath` -- UTF-8 dw:// namespace path this VDE serves (max 256 bytes)
   - `long LastSeenUtcTicks` -- last heartbeat/contact from this VDE
   - `ushort LatencyMs` -- estimated latency to reach this VDE from the local region
   - `byte ReplicaCount` -- number of replicas of this VDE in this region
   - `byte Status` -- 0=Online, 1=Degraded, 2=Offline, 3=Migrating
   - Serialized: `[VdeId:16][GeoRegionId:2][NamespacePathLength:2][NamespacePath:variable max 256][LastSeenUtcTicks:8][LatencyMs:2][ReplicaCount:1][Status:1]`
   - `int SerializedSize => 32 + (NamespacePath?.Length ?? 0)`
   - `internal int WriteTo(Span<byte>, int offset)` / `internal static FederationEntry ReadFrom(ReadOnlySpan<byte>, int offset, out int bytesRead)`

3. `VdeFederationRegion` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- VDE Federation (VADV-03)")]`):
   - Internal: `List<GeoRegion>` for region definitions + `List<FederationEntry>` for VDE registrations + `Dictionary<Guid, int>` index by VdeId
   - `uint Generation { get; set; }`
   - `ushort LocalRegionId { get; set; }` -- the geographic region of the local VDE
   - `int GeoRegionCount` / `int FederationEntryCount` properties

   Geo region management:
   - `void AddGeoRegion(GeoRegion region)` -- add geographic region definition
   - `GeoRegion? GetGeoRegion(ushort regionId)` -- lookup by ID
   - `IReadOnlyList<GeoRegion> GetAllGeoRegions()`

   Federation management:
   - `void RegisterVde(FederationEntry entry)` -- register or update VDE in federation
   - `bool UnregisterVde(Guid vdeId)` -- remove VDE from federation
   - `FederationEntry? GetVde(Guid vdeId)` -- lookup by VDE ID

   Namespace resolution (geo-aware):
   - `IReadOnlyList<FederationEntry> ResolveNamespace(byte[] namespacePath)` -- finds all VDEs serving a dw:// namespace path (prefix match). Results ordered by: (1) local region first, (2) lowest latency, (3) online status preferred over degraded.
   - `FederationEntry? ResolveNamespacePreferred(byte[] namespacePath)` -- returns single best VDE for the namespace (first result from ResolveNamespace)
   - `IReadOnlyList<FederationEntry> GetVdesByRegion(ushort geoRegionId)` -- all VDEs in a geographic region
   - `IReadOnlyList<FederationEntry> GetOnlineVdes()` -- all VDEs with Status == Online

   Geo-routing helpers:
   - `double CalculateDistance(ushort regionId1, ushort regionId2)` -- Haversine distance between two regions in km
   - `IReadOnlyList<GeoRegion> GetNearestRegions(ushort fromRegionId, int count)` -- nearest N regions by Haversine distance

   Serialization:
   - Two-section layout: GeoRegions then FederationEntries
   - Header: `[GeoRegionCount:4 LE][FederationEntryCount:4 LE][LocalRegionId:2 LE][Reserved:6][GeoRegion entries...][FederationEntry entries...]`
   - `int RequiredBlocks(int blockSize)` / `void Serialize(Span<byte>, int blockSize)` / `static VdeFederationRegion Deserialize(ReadOnlySpan<byte>, int blockSize, int blockCount)`
   - Use BlockTypeTags.XREF (federation is cross-VDE linking). Differentiated from CrossVdeReferenceRegion by RegionDirectory slot.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles clean. Verify ResolveNamespace and CalculateDistance exist. Verify Haversine formula is implemented (not stubbed).
  </verify>
  <done>
VdeFederationRegion.cs exists with geo-aware namespace resolution, Haversine distance routing, and federation VDE management. Builds clean.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. VdeSeparationManager.ResolveVdeForRole returns primary VDE by priority
3. VdeSeparationManager.GenerateCrossReferences creates VdeReference with correct ReferenceType values
4. VdeFederationRegion.ResolveNamespace orders results by local region, then latency, then status
5. VdeFederationRegion.CalculateDistance uses Haversine formula (not placeholder)
6. Both files integrate with CrossVdeReferenceRegion concepts
</verification>

<success_criteria>
- VDE separation allows data/index/metadata on different VDEs with user-configurable routing
- VDE federation resolves dw:// namespaces with geo-aware routing (local region preferred, latency-ordered)
- Haversine distance calculation is production-ready
- Both serialize/deserialize with trailer verification
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/73-vde-regions-operations/73-05-SUMMARY.md`
</output>
