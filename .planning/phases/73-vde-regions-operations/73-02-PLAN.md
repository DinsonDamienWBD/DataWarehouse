---
phase: 73-vde-regions-operations
plan: 02
type: execute
wave: 2
depends_on: ["73-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/ComputeCodeCacheRegion.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/SnapshotTableRegion.cs
autonomous: true

must_haves:
  truths:
    - "Compute Code Cache stores WASM module directory entries with module hash, size, and entry point"
    - "Modules are retrievable by SHA-256 hash in O(1) via dictionary lookup"
    - "Snapshot Table implements CoW snapshot registry with parent-child relationships"
    - "Snapshot creation records only metadata -- no data block copying occurs"
    - "Both regions round-trip through Serialize/Deserialize with UniversalBlockTrailer verification"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/ComputeCodeCacheRegion.cs"
      provides: "Compute Code Cache region with CODE block type"
      contains: "ComputeCodeCacheRegion"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/SnapshotTableRegion.cs"
      provides: "Snapshot Table region with SNAP block type"
      contains: "SnapshotTableRegion"
  key_links:
    - from: "ComputeCodeCacheRegion"
      to: "BlockTypeTags.CODE"
      via: "UniversalBlockTrailer.Write"
      pattern: "BlockTypeTags\\.CODE"
    - from: "SnapshotTableRegion"
      to: "BlockTypeTags.SNAP"
      via: "UniversalBlockTrailer.Write"
      pattern: "BlockTypeTags\\.SNAP"
---

<objective>
Implement the Compute Code Cache region (WASM module directory with hash-based retrieval) and Snapshot Table region (CoW snapshot registry with zero-copy creation).

Purpose: Compute Code Cache enables WASM module storage and retrieval by content hash. Snapshot Table enables copy-on-write snapshots where creation is metadata-only (no data block duplication).
Output: Two new region files in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/73-vde-regions-operations/73-01-SUMMARY.md

Key patterns (same as 73-01):
- BinaryPrimitives LE serialization, UniversalBlockTrailer on every block
- Block types: BlockTypeTags.CODE (0x434F4445), BlockTypeTags.SNAP (0x534E4150)
- Multi-block overflow pattern from ComplianceVaultRegion
- Record struct for entries, sealed class for region

@DataWarehouse.SDK/VirtualDiskEngine/Regions/ComplianceVaultRegion.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Compute Code Cache Region</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/ComputeCodeCacheRegion.cs</files>
  <action>
Create `ComputeCodeCacheRegion.cs` with:

1. `ComputeModuleEntry` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `byte[] ModuleHash` -- 32-byte SHA-256 hash of the WASM module content (the lookup key)
   - `Guid ModuleId` -- unique module identifier
   - `long BlockOffset` -- starting block where module data is stored in the VDE
   - `int BlockCount` -- number of blocks the module occupies
   - `int ModuleSizeBytes` -- exact byte size of the WASM binary
   - `ushort AbiVersion` -- WASI ABI version (0=preview1, 1=preview2, 2=stable)
   - `long RegisteredUtcTicks` -- when the module was registered
   - `byte[] EntryPointName` -- UTF-8 entry point function name (max 128 bytes, variable length)
   - Serialized layout: `[ModuleHash:32][ModuleId:16][BlockOffset:8][BlockCount:4][ModuleSizeBytes:4][AbiVersion:2][RegisteredUtcTicks:8][EntryPointNameLength:2][EntryPointName:variable]`
   - `int SerializedSize => 76 + (EntryPointName?.Length ?? 0)` (32+16+8+4+4+2+8+2 = 76 fixed)
   - `internal int WriteTo(Span<byte>, int offset)` returns bytes written
   - `internal static ComputeModuleEntry ReadFrom(ReadOnlySpan<byte>, int offset, out int bytesRead)`

2. `ComputeCodeCacheRegion` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- Compute Code Cache (VREG-12)")]`):
   - Internal: `List<ComputeModuleEntry>` + `Dictionary<string, int>` keyed by hex-encoded hash for O(1) lookup
   - Helper: private static `string HashToHex(byte[] hash)` using Convert.ToHexString
   - `uint Generation { get; set; }`
   - `int ModuleCount` property
   - `void RegisterModule(ComputeModuleEntry entry)` -- validates hash is 32 bytes, entry point <= 128 bytes, rejects duplicate hash
   - `ComputeModuleEntry? GetByHash(byte[] moduleHash)` -- O(1) lookup by SHA-256 hash
   - `ComputeModuleEntry? GetByModuleId(Guid moduleId)` -- linear scan (secondary lookup)
   - `bool RemoveModule(byte[] moduleHash)` -- remove by hash
   - `IReadOnlyList<ComputeModuleEntry> GetAllModules()`
   - `int RequiredBlocks(int blockSize)` / `void Serialize(Span<byte>, int blockSize)` / `static ComputeCodeCacheRegion Deserialize(ReadOnlySpan<byte>, int blockSize, int blockCount)`

   Header: `[ModuleCount:4 LE][Reserved:12][entries...]`. Use BlockTypeTags.CODE. Multi-block overflow.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles clean. Grep for `GetByHash` and `ComputeModuleEntry` to confirm hash-based retrieval.
  </verify>
  <done>
ComputeCodeCacheRegion.cs exists with WASM module directory entries and O(1) hash-based retrieval. Builds clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Snapshot Table Region</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/SnapshotTableRegion.cs</files>
  <action>
Create `SnapshotTableRegion.cs` with:

1. `SnapshotEntry` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `Guid SnapshotId` -- unique snapshot identifier
   - `Guid ParentSnapshotId` -- parent snapshot (Guid.Empty for root/first snapshot)
   - `long CreatedUtcTicks` -- creation timestamp
   - `long InodeTableBlockOffset` -- block offset of the inode table snapshot (CoW: points to shared blocks)
   - `long InodeTableBlockCount` -- block count of inode table at snapshot time
   - `long DataBlockCount` -- total data blocks referenced at snapshot time (metadata only -- NOT copied)
   - `ushort Flags` -- bit 0: readonly, bit 1: deleted (tombstone), bit 2: base snapshot
   - `byte[] Label` -- UTF-8 label (max 64 bytes, variable)
   - Serialized: `[SnapshotId:16][ParentSnapshotId:16][CreatedUtcTicks:8][InodeTableBlockOffset:8][InodeTableBlockCount:8][DataBlockCount:8][Flags:2][LabelLength:2][Label:variable]`
   - `int SerializedSize => 68 + (Label?.Length ?? 0)` (16+16+8+8+8+8+2+2 = 68 fixed)
   - `internal int WriteTo(Span<byte>, int offset)` / `internal static SnapshotEntry ReadFrom(ReadOnlySpan<byte>, int offset, out int bytesRead)`

2. `SnapshotTableRegion` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- Snapshot Table (VREG-13)")]`):
   - Internal: `List<SnapshotEntry>` + `Dictionary<Guid, int>` index by SnapshotId
   - `uint Generation { get; set; }`
   - `int SnapshotCount` property
   - `void CreateSnapshot(SnapshotEntry entry)` -- validates label <= 64 bytes, rejects duplicate SnapshotId. IMPORTANT: This is metadata-only -- it records the inode table offset and block counts but does NOT copy any data blocks (CoW semantics). Add XML doc comment explicitly stating "No data blocks are copied; this method records metadata pointers only."
   - `SnapshotEntry? GetSnapshot(Guid snapshotId)` -- O(1) lookup
   - `bool DeleteSnapshot(Guid snapshotId)` -- sets deleted flag (tombstone), does not remove from list
   - `IReadOnlyList<SnapshotEntry> GetChildSnapshots(Guid parentId)` -- all direct children
   - `IReadOnlyList<SnapshotEntry> GetAllSnapshots()` -- excludes tombstoned
   - `IReadOnlyList<SnapshotEntry> GetSnapshotChain(Guid snapshotId)` -- walks ParentSnapshotId chain from given snapshot to root
   - `int RequiredBlocks(int blockSize)` / `void Serialize(Span<byte>, int blockSize)` / `static SnapshotTableRegion Deserialize(ReadOnlySpan<byte>, int blockSize, int blockCount)`

   Header: `[SnapshotCount:4 LE][Reserved:12][entries...]`. Use BlockTypeTags.SNAP. Multi-block overflow.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles clean. Grep for `CreateSnapshot` and confirm XML doc contains "No data blocks are copied".
  </verify>
  <done>
SnapshotTableRegion.cs exists with CoW snapshot registry (metadata-only creation, parent-child chain walking, tombstone deletion). Builds clean.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. ComputeCodeCacheRegion has Dictionary-backed hash lookup
3. SnapshotTableRegion.CreateSnapshot XML doc explicitly states no data block copying
4. Both use correct BlockTypeTags (CODE, SNAP)
</verification>

<success_criteria>
- Compute Code Cache stores WASM modules and retrieves by SHA-256 hash in O(1)
- Snapshot Table records CoW metadata without copying data blocks
- Both serialize/deserialize with trailer verification
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/73-vde-regions-operations/73-02-SUMMARY.md`
</output>
