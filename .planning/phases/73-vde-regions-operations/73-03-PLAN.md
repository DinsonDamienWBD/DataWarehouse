---
phase: 73-vde-regions-operations
plan: 03
type: execute
wave: 3
depends_on: ["73-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/AuditLogRegion.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/ConsensusLogRegion.cs
autonomous: true

must_haves:
  truths:
    - "Audit Log is append-only and hash-chained -- each entry includes SHA-256 of the previous entry"
    - "Audit Log has no truncation method -- no API exists that can remove or overwrite entries"
    - "Audit Log chain integrity is verifiable by walking entries and recomputing hashes"
    - "Consensus Log stores per-Raft-group term and committed index metadata"
    - "Consensus Log supports multiple concurrent Raft groups each with independent term/index tracking"
    - "Both regions round-trip through Serialize/Deserialize with UniversalBlockTrailer verification"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/AuditLogRegion.cs"
      provides: "Audit Log region with ALOG block type"
      contains: "AuditLogRegion"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/ConsensusLogRegion.cs"
      provides: "Consensus Log region with CLOG block type"
      contains: "ConsensusLogRegion"
  key_links:
    - from: "AuditLogRegion"
      to: "BlockTypeTags.ALOG"
      via: "UniversalBlockTrailer.Write"
      pattern: "BlockTypeTags\\.ALOG"
    - from: "AuditLogEntry"
      to: "SHA256"
      via: "PreviousEntryHash field"
      pattern: "PreviousEntryHash"
    - from: "ConsensusLogRegion"
      to: "BlockTypeTags.CLOG"
      via: "UniversalBlockTrailer.Write"
      pattern: "BlockTypeTags\\.CLOG"
---

<objective>
Implement the Audit Log region (append-only, hash-chained, truncation-proof) and Consensus Log region (per-Raft-group term/index metadata).

Purpose: Audit Log provides an immutable, hash-chained record of all operations for compliance and forensics -- no API exists to truncate or delete entries, even for privileged processes. Consensus Log tracks Raft consensus state per group for distributed coordination.
Output: Two new region files in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key patterns:
- Block types: BlockTypeTags.ALOG (0x414C4F47), BlockTypeTags.CLOG (0x434C4F47)
- WormImmutableRegion pattern for append-only with high-water mark (reference for Audit Log)
- ReplicationStateRegion pattern for multi-entry state tracking
- Multi-block overflow for large entry counts

@DataWarehouse.SDK/VirtualDiskEngine/Regions/WormImmutableRegion.cs (append-only pattern)
@DataWarehouse.SDK/VirtualDiskEngine/Regions/ReplicationStateRegion.cs (state tracking)
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit Log Region (append-only, hash-chained)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/AuditLogRegion.cs</files>
  <action>
Create `AuditLogRegion.cs` with:

1. `AuditLogEntry` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `long SequenceNumber` -- monotonically increasing, gapless
   - `long TimestampUtcTicks` -- when the event occurred
   - `Guid ActorId` -- who performed the action
   - `ushort EventType` -- operation type (0=Read, 1=Write, 2=Delete, 3=Create, 4=Modify, 5=Access, 6=PolicyChange, 7=AuthEvent, 8=SystemEvent)
   - `Guid TargetObjectId` -- object the action was performed on
   - `byte[] PreviousEntryHash` -- 32-byte SHA-256 hash of the preceding entry's serialized bytes (all-zero for first entry)
   - `byte[] Details` -- variable-length event details (max 256 bytes)
   - Serialized: `[SequenceNumber:8][TimestampUtcTicks:8][ActorId:16][EventType:2][TargetObjectId:16][PreviousEntryHash:32][DetailsLength:4][Details:variable]`
   - `int SerializedSize => 86 + (Details?.Length ?? 0)` (8+8+16+2+16+32+4 = 86 fixed)
   - `internal int WriteTo(Span<byte>, int offset)` returns bytes written
   - `internal static AuditLogEntry ReadFrom(ReadOnlySpan<byte>, int offset, out int bytesRead)`

2. `AuditLogRegion` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- Audit Log (VREG-14)")]`):
   - Internal: `List<AuditLogEntry>` (append-only list -- no removal methods)
   - `uint Generation { get; set; }`
   - `long EntryCount` property (returns list count as long)
   - `long NextSequenceNumber` -- next expected sequence number

   CRITICAL DESIGN CONSTRAINTS (enforce via API design):
   - NO Remove, Delete, Clear, Truncate, or any mutation method except Append
   - NO setter on the internal list; it is readonly after construction
   - The class is deliberately designed to prevent truncation even by privileged callers

   Methods:
   - `AuditLogEntry Append(Guid actorId, ushort eventType, Guid targetObjectId, byte[] details)`:
     * Validates details <= 256 bytes
     * Computes PreviousEntryHash: if list is empty, use 32 zero bytes; otherwise SHA-256 hash of the previous entry's serialized bytes (serialize the last entry into a temp buffer, then SHA256.HashData)
     * Assigns next SequenceNumber (list count) and current UTC ticks
     * Appends to list and returns the created entry
   - `AuditLogEntry GetEntry(long sequenceNumber)` -- O(1) by index
   - `IReadOnlyList<AuditLogEntry> GetEntries(long fromSequence, int count)` -- range query
   - `IReadOnlyList<AuditLogEntry> GetAllEntries()` -- full snapshot
   - `bool VerifyChainIntegrity()` -- walks all entries, recomputes each PreviousEntryHash from the preceding entry, returns false if any mismatch. First entry must have all-zero PreviousEntryHash.
   - `bool VerifyEntryIntegrity(long sequenceNumber)` -- verifies single entry's hash chain link

   Serialization:
   - `int RequiredBlocks(int blockSize)` -- header + overflow
   - `void Serialize(Span<byte>, int blockSize)` -- header: `[EntryCount:8 LE][NextSequenceNumber:8 LE][entries...]`, BlockTypeTags.ALOG
   - `static AuditLogRegion Deserialize(ReadOnlySpan<byte>, int blockSize, int blockCount)` -- verify trailers, rebuild

   Add XML doc on the class: "This region is deliberately designed with no truncation, deletion, or modification API. The append-only constraint is enforced at the API level to ensure audit integrity even against privileged processes."
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles clean. Verify no Remove/Delete/Clear/Truncate methods exist via grep. Verify VerifyChainIntegrity method exists.
  </verify>
  <done>
AuditLogRegion.cs exists with append-only, hash-chained audit log. No truncation API. Chain integrity verification. Builds clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Consensus Log Region</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/ConsensusLogRegion.cs</files>
  <action>
Create `ConsensusLogRegion.cs` with:

1. `ConsensusGroupState` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `Guid GroupId` -- Raft group identifier
   - `long CurrentTerm` -- current Raft term number
   - `long CommittedIndex` -- highest committed log index
   - `long AppliedIndex` -- highest applied log index
   - `Guid VotedFor` -- candidate voted for in current term (Guid.Empty if none)
   - `Guid LeaderId` -- current known leader (Guid.Empty if unknown)
   - `byte MemberCount` -- number of members in the group (for quorum calculation)
   - `long LastHeartbeatUtcTicks` -- last heartbeat received from leader
   - `const int SerializedSize = 89` (16+8+8+8+16+16+1+8+8 = 89) -- include LastUpdatedUtcTicks:8
   - `long LastUpdatedUtcTicks` -- when this state was last persisted
   - Actually recalculate: 16+8+8+8+16+16+1+8+8 = 89
   - `internal void WriteTo(Span<byte>, int offset)` / `internal static ConsensusGroupState ReadFrom(ReadOnlySpan<byte>, int offset)`

2. `ConsensusLogRegion` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- Consensus Log (VREG-15)")]`):
   - Internal: `Dictionary<Guid, ConsensusGroupState>` for O(1) lookup by GroupId
   - `uint Generation { get; set; }`
   - `int GroupCount` property
   - `void UpdateGroupState(ConsensusGroupState state)` -- upsert by GroupId
   - `ConsensusGroupState? GetGroupState(Guid groupId)` -- O(1) lookup
   - `bool RemoveGroup(Guid groupId)` -- remove group tracking
   - `IReadOnlyList<ConsensusGroupState> GetAllGroups()` -- snapshot of all groups
   - `IReadOnlyList<ConsensusGroupState> GetGroupsByLeader(Guid leaderId)` -- groups where this node is leader
   - `long GetHighestTerm()` -- max term across all groups (useful for staleness detection)

   Serialization:
   - `int RequiredBlocks(int blockSize)` -- 1 header block + overflow as needed (groups are fixed-size so simpler)
   - `void Serialize(Span<byte>, int blockSize)` -- header: `[GroupCount:4 LE][Reserved:12][ConsensusGroupState entries...]`, BlockTypeTags.CLOG
   - `static ConsensusLogRegion Deserialize(ReadOnlySpan<byte>, int blockSize, int blockCount)` -- verify trailers, rebuild dictionary
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles clean. Grep for `ConsensusGroupState` and `UpdateGroupState` to confirm per-Raft-group tracking.
  </verify>
  <done>
ConsensusLogRegion.cs exists with per-Raft-group term/index tracking, O(1) group lookup, multi-group support. Builds clean.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. AuditLogRegion has NO Remove/Delete/Clear/Truncate methods
3. AuditLogRegion.Append computes SHA-256 chain hash from previous entry
4. AuditLogRegion.VerifyChainIntegrity walks and validates the full chain
5. ConsensusLogRegion supports multiple concurrent Raft groups
</verification>

<success_criteria>
- Audit Log is append-only with SHA-256 hash chaining and no truncation API
- Audit Log chain integrity is verifiable end-to-end
- Consensus Log tracks per-Raft-group term/index with O(1) lookup
- Both serialize/deserialize with trailer verification
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/73-vde-regions-operations/73-03-SUMMARY.md`
</output>
