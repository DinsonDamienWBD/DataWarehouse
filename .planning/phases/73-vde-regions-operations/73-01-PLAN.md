---
phase: 73-vde-regions-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/IntelligenceCacheRegion.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/CrossVdeReferenceRegion.cs
autonomous: true

must_haves:
  truths:
    - "Intelligence Cache stores classification results with confidence, heat score, and tier assignment per data object"
    - "Intelligence Cache entries are retrievable by object ID in O(1) via dictionary lookup"
    - "Cross-VDE Reference Table persists dw:// fabric links with source and target VDE identifiers"
    - "Broken dw:// links are detectable by scanning the reference table for unresolvable targets"
    - "Both regions round-trip through Serialize/Deserialize with UniversalBlockTrailer verification"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/IntelligenceCacheRegion.cs"
      provides: "Intelligence Cache region with INTE block type"
      contains: "IntelligenceCacheRegion"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/CrossVdeReferenceRegion.cs"
      provides: "Cross-VDE Reference Table with XREF block type"
      contains: "CrossVdeReferenceRegion"
  key_links:
    - from: "IntelligenceCacheRegion"
      to: "BlockTypeTags.INTE"
      via: "UniversalBlockTrailer.Write"
      pattern: "BlockTypeTags\\.INTE"
    - from: "CrossVdeReferenceRegion"
      to: "BlockTypeTags.XREF"
      via: "UniversalBlockTrailer.Write"
      pattern: "BlockTypeTags\\.XREF"
---

<objective>
Implement the Intelligence Cache region and Cross-VDE Reference Table -- the two foundational operational regions that other plans in this phase depend on for patterns and cross-VDE linking.

Purpose: Intelligence Cache stores AI classification results per data object (classification, confidence, heat score, tier). Cross-VDE Reference Table persists dw:// fabric links and enables broken-link detection -- this is the foundation for VDE index/metadata separation in plan 73-05.
Output: Two new region files in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key patterns from Phase 72 regions:
- All regions use `System.Buffers.Binary.BinaryPrimitives` for LE serialization
- All regions use `UniversalBlockTrailer.Write/Verify/Read` for block integrity
- All regions use `FormatConstants.MinBlockSize` validation
- Block types already defined: `BlockTypeTags.INTE` (0x494E5445), `BlockTypeTags.XREF` (0x58524546)
- Pattern: record struct for entries with `WriteTo`/`ReadFrom`, sealed class for region with `Serialize`/`Deserialize`
- `[SdkCompatibility("6.0.0")]` attribute on all public types
- Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Regions`

Reference files:
@DataWarehouse.SDK/VirtualDiskEngine/Regions/PolicyVaultRegion.cs (2-block HMAC pattern)
@DataWarehouse.SDK/VirtualDiskEngine/Regions/ComplianceVaultRegion.cs (multi-block overflow pattern)
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs (INTE, XREF tags)
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Intelligence Cache Region</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/IntelligenceCacheRegion.cs</files>
  <action>
Create `IntelligenceCacheRegion.cs` in `DataWarehouse.SDK/VirtualDiskEngine/Regions/` with these types:

1. `IntelligenceCacheEntry` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `Guid ObjectId` -- data object this classification covers
   - `ushort ClassificationId` -- AI classification category (user-defined enum range)
   - `float ConfidenceScore` -- 0.0 to 1.0 confidence in the classification
   - `float HeatScore` -- 0.0 to 1.0 access heat (recency-weighted frequency)
   - `byte TierAssignment` -- storage tier (0=Hot, 1=Warm, 2=Cold, 3=Frozen, 4=Archive)
   - `long LastClassifiedUtcTicks` -- when the AI last classified this object
   - `long LastAccessedUtcTicks` -- when the object was last accessed (for heat calculation)
   - `const int SerializedSize = 43` (16+2+4+4+1+8+8)
   - `internal void WriteTo(Span<byte> buffer, int offset)` -- BinaryPrimitives LE
   - `internal static IntelligenceCacheEntry ReadFrom(ReadOnlySpan<byte> buffer, int offset)` -- BinaryPrimitives LE

2. `IntelligenceCacheRegion` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- Intelligence Cache (VREG-10)")]`):
   - Internal storage: `Dictionary<Guid, int>` for O(1) lookup by ObjectId mapping to list index, plus `List<IntelligenceCacheEntry>` for ordered storage
   - `uint Generation { get; set; }` for torn-write detection
   - `int EntryCount` property
   - `void AddOrUpdate(IntelligenceCacheEntry entry)` -- upserts by ObjectId
   - `IntelligenceCacheEntry? GetByObjectId(Guid objectId)` -- O(1) lookup
   - `bool Remove(Guid objectId)` -- removes entry
   - `IReadOnlyList<IntelligenceCacheEntry> GetByTier(byte tier)` -- filter by tier
   - `IReadOnlyList<IntelligenceCacheEntry> GetHotEntries(float heatThreshold)` -- entries above heat threshold
   - `IReadOnlyList<IntelligenceCacheEntry> GetAllEntries()` -- snapshot
   - `int RequiredBlocks(int blockSize)` -- header block + data blocks
   - `void Serialize(Span<byte> buffer, int blockSize)` -- follow ComplianceVaultRegion multi-block overflow pattern with BlockTypeTags.INTE
   - `static IntelligenceCacheRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize, int blockCount)` -- verify all trailers, rebuild dictionary index

   Header block layout: `[EntryCount:4 LE][Reserved:12][IntelligenceCacheEntry entries...]`
   Each block ends with UniversalBlockTrailer. Entries overflow to subsequent blocks following the ComplianceVaultRegion pattern.

   Use `using DataWarehouse.SDK.Contracts;` for SdkCompatibility, `using DataWarehouse.SDK.VirtualDiskEngine.Format;` for block types.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors. Grep for `IntelligenceCacheRegion` and `IntelligenceCacheEntry` in the output file to confirm all members present.
  </verify>
  <done>
IntelligenceCacheRegion.cs exists with IntelligenceCacheEntry (43-byte serialized) and IntelligenceCacheRegion (Dictionary-backed O(1) lookup, multi-block Serialize/Deserialize with INTE tag, tier/heat queries). Builds clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Cross-VDE Reference Table Region</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/CrossVdeReferenceRegion.cs</files>
  <action>
Create `CrossVdeReferenceRegion.cs` in `DataWarehouse.SDK/VirtualDiskEngine/Regions/` with these types:

1. `VdeReference` (readonly record struct, `[SdkCompatibility("6.0.0")]`):
   - `Guid ReferenceId` -- unique ID for this link
   - `Guid SourceVdeId` -- VDE containing the referencing object
   - `Guid TargetVdeId` -- VDE being referenced
   - `long SourceInodeNumber` -- inode in source VDE
   - `long TargetInodeNumber` -- inode in target VDE (0 if VDE-level reference)
   - `ushort ReferenceType` -- 0=DataLink, 1=IndexLink, 2=MetadataLink, 3=FabricLink
   - `long CreatedUtcTicks` -- when the reference was created
   - `const int SerializedSize = 74` (16+16+16+8+8+2+8)
   - `internal void WriteTo(Span<byte>, int offset)` / `internal static VdeReference ReadFrom(ReadOnlySpan<byte>, int offset)`

2. `CrossVdeReferenceRegion` (sealed class, `[SdkCompatibility("6.0.0", Notes = "Phase 73: VDE regions -- Cross-VDE Reference Table (VREG-11)")]`):
   - Internal: `List<VdeReference>` + `Dictionary<Guid, int>` index by ReferenceId
   - `uint Generation { get; set; }`
   - `int ReferenceCount` property
   - `void AddReference(VdeReference reference)` -- add (reject duplicate ReferenceId)
   - `bool RemoveReference(Guid referenceId)` -- remove by ID
   - `VdeReference? GetReference(Guid referenceId)` -- lookup by ID
   - `IReadOnlyList<VdeReference> GetReferencesBySource(Guid sourceVdeId)` -- all outgoing refs from a VDE
   - `IReadOnlyList<VdeReference> GetReferencesByTarget(Guid targetVdeId)` -- all incoming refs to a VDE
   - `IReadOnlyList<VdeReference> GetReferencesByType(ushort referenceType)` -- filter by type
   - `IReadOnlyList<Guid> DetectBrokenLinks(IReadOnlySet<Guid> knownVdeIds)` -- returns ReferenceIds whose TargetVdeId is NOT in the known set. This is the broken-link detection method.
   - `int RequiredBlocks(int blockSize)` / `void Serialize(Span<byte>, int blockSize)` / `static CrossVdeReferenceRegion Deserialize(ReadOnlySpan<byte>, int blockSize, int blockCount)`

   Same multi-block overflow pattern as ComplianceVaultRegion. Use BlockTypeTags.XREF.
   Header: `[ReferenceCount:4 LE][Reserved:12][VdeReference entries...]`
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors. Grep for `DetectBrokenLinks` and `VdeReference` to confirm broken-link detection is present.
  </verify>
  <done>
CrossVdeReferenceRegion.cs exists with VdeReference (74-byte serialized, 4 reference types) and CrossVdeReferenceRegion (Dictionary-backed lookup, broken-link detection via DetectBrokenLinks, multi-block Serialize/Deserialize with XREF tag). Builds clean.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. Both files exist in DataWarehouse.SDK/VirtualDiskEngine/Regions/
3. BlockTypeTags.INTE and BlockTypeTags.XREF are used in Serialize methods
4. IntelligenceCacheRegion has Dictionary-backed O(1) lookup
5. CrossVdeReferenceRegion has DetectBrokenLinks method accepting IReadOnlySet<Guid>
</verification>

<success_criteria>
- IntelligenceCacheRegion stores classification, confidence, heat, tier per object with O(1) lookup
- CrossVdeReferenceRegion persists dw:// links with source/target VDE IDs and broken-link detection
- Both serialize/deserialize with UniversalBlockTrailer verification using correct block type tags
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/73-vde-regions-operations/73-01-SUMMARY.md`
</output>
