---
phase: 65.3-strategy-aware-plugin-base-infrastructure
plan: "03"
subsystem: sdk-strategy-dispatch
tags: [strategy-registry, encryption, compression, dispatch, domain-operations, ai-hooks]

requires:
  - phase: 65.3-01
    provides: StrategyRegistry<TStrategy>, PluginBase dispatch infrastructure (RegisterStrategy, ResolveStrategy, ExecuteWithStrategyAsync, DiscoverStrategiesFromAssembly, GetDefaultStrategyId virtual)

provides:
  - DispatchWithOptimalStrategyAsync<TStrategy,TResult> in DataTransformationPluginBase that calls SelectOptimalAlgorithmAsync as fallback (no longer dead code)
  - EncryptionPluginBase.EncryptAsync/DecryptAsync domain operations via typed StrategyRegistry<IEncryptionStrategy>
  - CompressionPluginBase.CompressAsync/DecompressAsync domain operations via typed StrategyRegistry<ICompressionStrategy>
  - EncryptionPluginBase.DispatchEncryptionStrategyAsync with CommandIdentity ACL + SelectOptimalAlgorithmAsync fallback
  - CompressionPluginBase.DispatchCompressionStrategyAsync with CommandIdentity ACL + SelectOptimalAlgorithmAsync fallback

affects:
  - Ultimate encryption plugins inheriting EncryptionPluginBase
  - Ultimate compression plugins inheriting CompressionPluginBase
  - Any plugin using DataTransformationPluginBase dispatch

tech-stack:
  added: []
  patterns:
    - "Typed strategy registry per domain (IEncryptionStrategy, ICompressionStrategy have their own StrategyRegistry<T> separate from PluginBase IStrategy registry)"
    - "Domain dispatch with AI fallback: explicit strategyId -> SelectOptimalAlgorithmAsync -> ACL check -> execute"
    - "GetDefaultStrategyId() override chain: EncryptionPluginBase returns AlgorithmId, CompressionPluginBase returns CompressionAlgorithm, DataTransformationPluginBase returns SubCategory"

key-files:
  created: []
  modified:
    - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/DataTransformationPluginBase.cs
    - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
    - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/CompressionPluginBase.cs

key-decisions:
  - "Use StrategyRegistry<IEncryptionStrategy> and StrategyRegistry<ICompressionStrategy> as dedicated typed registries since IEncryptionStrategy/ICompressionStrategy do NOT inherit IStrategy and cannot use PluginBase's IStrategy registry"
  - "Key selector for ICompressionStrategy uses Characteristics.AlgorithmName.ToLowerInvariant().Replace(' ', '-') to match CompressionStrategyBase.StrategyId convention"
  - "DispatchWithOptimalStrategyAsync in DataTransformationPluginBase handles IStrategy-based types; domain-specific dispatchers (DispatchEncryptionStrategyAsync, DispatchCompressionStrategyAsync) handle their typed registries"
  - "GetDefaultStrategyId() override returns AlgorithmId/CompressionAlgorithm/SubCategory for domain-specific routing"

patterns-established:
  - "Domain dispatch pattern: DispatchXxxStrategyAsync<TResult>(explicitId, identity, context, operation, ct)"
  - "Typed registry per domain interface not implementing IStrategy"

duration: 25min
completed: 2026-02-21
---

# Phase 65.3 Plan 03: Wire Domain Dispatch and AI Algorithm Selection Summary

**EncryptionPluginBase and CompressionPluginBase now provide EncryptAsync/DecryptAsync and CompressAsync/DecompressAsync domain operations via typed strategy registries with CommandIdentity ACL and AI-driven SelectOptimalAlgorithmAsync fallback - Ultimate plugins get these for free.**

## Performance

- **Duration:** ~25 min
- **Started:** 2026-02-21T03:00:00Z
- **Completed:** 2026-02-21T03:23:14Z
- **Tasks:** 2
- **Files modified:** 3

## Accomplishments

- SelectOptimalAlgorithmAsync wired into `DispatchWithOptimalStrategyAsync` in `DataTransformationPluginBase` (no longer dead code - used as AI fallback when no explicit strategyId provided)
- `EncryptionPluginBase` gains `EncryptAsync`/`DecryptAsync` using `StrategyRegistry<IEncryptionStrategy>` with ACL and AI selection
- `CompressionPluginBase` gains `CompressAsync`/`DecompressAsync` using `StrategyRegistry<ICompressionStrategy>` with ACL and AI selection
- Domain plugins get `GetDefaultStrategyId()` overrides that return `AlgorithmId`/`CompressionAlgorithm` for accurate fallback routing

## Task Commits

Each task was committed atomically:

1. **Task 1: Wire SelectOptimalAlgorithmAsync into DataTransformationPluginBase dispatch** - `db7e92b8` (feat)
2. **Task 2: Add domain operations to EncryptionPluginBase and CompressionPluginBase** - `981ea2ee` (feat)

## Files Created/Modified

- `DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/DataTransformationPluginBase.cs` - Added `DispatchWithOptimalStrategyAsync<TStrategy,TResult>` that calls `SelectOptimalAlgorithmAsync` as AI fallback; overrides `GetDefaultStrategyId()` to return `SubCategory`
- `DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs` - Added `StrategyRegistry<IEncryptionStrategy>`, `DispatchEncryptionStrategyAsync`, `EncryptAsync`/`DecryptAsync`, `GetDefaultStrategyId()` returning `AlgorithmId`
- `DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/CompressionPluginBase.cs` - Added `StrategyRegistry<ICompressionStrategy>`, `DispatchCompressionStrategyAsync`, `CompressAsync`/`DecompressAsync`, `GetDefaultStrategyId()` returning `CompressionAlgorithm`

## Decisions Made

- **Separate typed registries per domain**: `IEncryptionStrategy` and `ICompressionStrategy` do not extend `IStrategy`, so they cannot use PluginBase's `StrategyRegistry<IStrategy>`. Each domain base gets its own `StrategyRegistry<IDomainStrategy>` with a domain-appropriate key selector.
- **Key selector for compression**: Uses `s.Characteristics.AlgorithmName.ToLowerInvariant().Replace(" ", "-")` to mirror the `CompressionStrategyBase.StrategyId` convention so callers can look up by algorithm name string.
- **Dispatch separation**: `DispatchWithOptimalStrategyAsync` (in DataTransformationPluginBase) handles `IStrategy`-constrained types and delegates to `ExecuteWithStrategyAsync`. Domain-specific dispatchers handle their own typed registries.
- **Existing methods preserved**: `EncryptCoreAsync`/`DecryptCoreAsync`/`OnWriteAsync`/`OnReadAsync` in EncryptionPluginBase are completely untouched - new byte[] domain operations coexist alongside Stream-level methods.

## Deviations from Plan

### Auto-fixed Issues

**1. [Rule 1 - Bug] IEncryptionStrategy ACL check used wrong method signature**
- **Found during:** Task 2 (EncryptionPluginBase domain operations)
- **Issue:** Plan draft showed `StrategyAclProvider.IsAllowedAsync(identity, strategyId, ct)` but the actual `IStrategyAclProvider` interface has `IsStrategyAllowed(strategyId, identity)` (synchronous, different parameter order)
- **Fix:** Used `StrategyAclProvider.IsStrategyAllowed(strategyId, identity)` (synchronous) matching the actual interface contract
- **Files modified:** EncryptionPluginBase.cs, CompressionPluginBase.cs
- **Verification:** Build passes, interface contract honored
- **Committed in:** 981ea2ee (Task 2 commit)

---

**Total deviations:** 1 auto-fixed (Rule 1 - wrong API signature from plan draft)
**Impact on plan:** Minimal - same semantics, correct interface used.

## Issues Encountered

- Full solution build revealed `CS0108` on `IngestPipelineConsciousnessStrategy.MessageBus` hiding `StrategyBase.MessageBus`. Investigation showed the linter had already applied the fix (`public new IMessageBus?` with `get => base.MessageBus; set => base.ConfigureIntelligence(value)`) in a prior operation, so no additional action was needed.

## Next Phase Readiness

- Ultimate encryption plugins can now call `EncryptAsync`/`DecryptAsync` using registered strategies without reimplementing ~300 lines of registry+dispatch
- Ultimate compression plugins can now call `CompressAsync`/`DecompressAsync` similarly
- Plan 65.3-04 and later can build on this domain dispatch foundation
- Full solution builds with 0 errors, 0 warnings

---
*Phase: 65.3-strategy-aware-plugin-base-infrastructure*
*Completed: 2026-02-21*
