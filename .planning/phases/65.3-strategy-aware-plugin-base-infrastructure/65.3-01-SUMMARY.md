---
phase: 65.3-strategy-aware-plugin-base-infrastructure
plan: "01"
subsystem: SDK-Core
tags: [strategy-registry, plugin-base, acl, dispatch, foundation]
dependency_graph:
  requires: []
  provides:
    - StrategyRegistry<TStrategy> generic registry
    - IStrategyAclProvider ACL interface
    - PluginBase strategy dispatch infrastructure
  affects:
    - All strategy-using plugins (opt-in)
    - Plans 65.3-02 through 65.3-06 (consume this foundation)
tech_stack:
  added:
    - StrategyRegistry<TStrategy> (DataWarehouse.SDK/Contracts/StrategyRegistry.cs)
    - IStrategyAclProvider (DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs)
  patterns:
    - Key selector pattern for generic strategy registration
    - Lazy initialization for zero-overhead non-strategy plugins
    - CommandIdentity ACL integration for strategy access control
key_files:
  created:
    - DataWarehouse.SDK/Contracts/StrategyRegistry.cs
    - DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs
  modified:
    - DataWarehouse.SDK/Contracts/PluginBase.cs
decisions:
  - "Use Func<TStrategy, string> key selector instead of IStrategy constraint to support independent strategy interfaces (IEncryptionStrategy, IConsciousnessStrategy) that do not inherit IStrategy"
  - "Lazy initialize _strategyRegistry in PluginBase — null by default — so non-strategy plugins pay zero overhead"
  - "GetStrategyKnowledge() auto-populates from registry rather than requiring override; domain bases still can override to supplement"
  - "Used new keyword on plugin members that shadow base class members rather than override (different return types)"
metrics:
  duration: "~45 minutes"
  completed: "2026-02-21"
  tasks_completed: 2
  files_modified: 9
---

# Phase 65.3 Plan 01: Generic StrategyRegistry and PluginBase Dispatch Infrastructure Summary

One-liner: Generic StrategyRegistry<TStrategy> with key selector pattern replaces 3 bespoke typed registries; PluginBase gains opt-in CommandIdentity-ACL strategy dispatch.

## What Was Built

### Task 1: StrategyRegistry<TStrategy> and IStrategyAclProvider

Created `DataWarehouse.SDK/Contracts/StrategyRegistry.cs`:
- Generic `StrategyRegistry<TStrategy> where TStrategy : class` using key selector `Func<TStrategy, string>`
- Internally backed by `BoundedDictionary<string, TStrategy>` (capacity 1000, LRU eviction)
- Full API: `Register`, `Unregister`, `Get`, `GetAll`, `GetByPredicate`, `ContainsStrategy`, `Count`
- Default strategy management: `SetDefault` (validates before setting), `GetDefault`, `DefaultStrategyId`
- Assembly discovery: `DiscoverFromAssembly(params Assembly[])` scans for non-abstract implementors, silently skips on failure
- Thread-safe throughout (BoundedDictionary uses ReaderWriterLockSlim; DefaultStrategyId is volatile)

Created `DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs`:
- Interface with single method: `bool IsStrategyAllowed(string strategyId, CommandIdentity identity)`
- Doc comment mandates use of `EffectivePrincipalId`, never `ActorId`

### Task 2: PluginBase Strategy Dispatch Infrastructure

Added `#region Strategy Registry and Dispatch` to `DataWarehouse.SDK/Contracts/PluginBase.cs`:

| Member | Purpose |
|---|---|
| `StrategyRegistry` (protected property) | Lazy-initialized `StrategyRegistry<IStrategy>` — null until first use |
| `StrategyAclProvider` (protected property) | Optional injectable ACL; null = allow all |
| `RegisterStrategy(IStrategy)` | Delegates to registry |
| `ResolveStrategy<TStrategy>(id, identity?)` | Gets + casts + ACL checks; returns null if not found |
| `ResolveStrategyOrDefault<TStrategy>(id?, identity?)` | Falls back to `GetDefaultStrategyId()` then registry default; throws if none found |
| `GetDefaultStrategyId()` | Virtual hook returning null; override in domain bases |
| `ExecuteWithStrategyAsync<TStrategy,TResult>(id?, identity, op, ct)` | Primary dispatch pattern |
| `DiscoverStrategiesFromAssembly(Assembly[])` | Delegates to registry |

Modified `GetStrategyKnowledge()` to auto-populate from registry when strategies are registered, providing `strategies[]` list with `strategyId`, `name`, `description` fields plus `count` and optional `defaultStrategyId`.

Modified `DisposeAsyncCore()` and `Dispose(bool)` to async-shutdown and dispose all registered strategies during plugin cleanup.

## Deviations from Plan

### Auto-fixed Issues

**1. [Rule 1 - Bug] Pre-existing "hides inherited member" warnings in UltimateResilience**

- **Found during:** Task 2 full-solution build
- **Issue:** `ResilienceStrategyBase.Characteristics` returns `ResilienceCharacteristics` (not `IReadOnlyDictionary<string,object>`) hiding `StrategyBase.Characteristics` without `new` keyword; `BulkheadStrategies` and `LeakyBucketRateLimitingStrategy` implement `Dispose()` that hides `StrategyBase.Dispose()` without `new` keyword
- **Fix:** Added `new` keyword to all shadowing members
- **Files modified:** `ResilienceStrategyBase.cs`, `BulkheadStrategies.cs`, `RateLimitingStrategies.cs`
- **Commit:** 0212deed

**2. [Rule 1 - Bug] DataQualityStrategyBase.DisposeAsync() return type mismatch**

- **Found during:** Task 2 full-solution build
- **Issue:** `DataQualityStrategyBase.DisposeAsync()` returns `Task` (not `ValueTask`) hiding `StrategyBase.DisposeAsync()` without `new` keyword
- **Fix:** Added `new` keyword
- **Files modified:** `DataQualityStrategyBase.cs`
- **Commit:** 0212deed

**3. [Rule 1 - Bug] CA2215 false positive in DatabaseProtocolStrategyBase**

- **Found during:** Task 2 full-solution build
- **Issue:** Roslyn analyzer CA2215 incorrectly reports `DisposeAsyncCore()` doesn't call `base.DisposeCoreAsync(bool)` — but `base.DisposeAsyncCore()` IS called in the implementation. The analyzer misreports the method name.
- **Fix:** Added `#pragma warning disable/restore CA2215` with explanation comment
- **Files modified:** `DatabaseProtocolStrategyBase.cs`
- **Commit:** 0212deed

**4. [Rule 1 - Bug] UltimateDatabaseStoragePlugin.StrategyRegistry naming conflict**

- **Found during:** Task 2 full-solution build (caused by adding StrategyRegistry property to PluginBase)
- **Issue:** The plugin had its own `StrategyRegistry` property returning `IDatabaseStorageStrategyRegistry` which now conflicts with the new `PluginBase.StrategyRegistry` returning `StrategyRegistry<IStrategy>`
- **Fix:** Added `new` keyword to the plugin's property with updated doc comment explaining the shadowing intent
- **Files modified:** `UltimateDatabaseStoragePlugin.cs`
- **Commit:** 0212deed

## Commits

| Task | Commit | Files |
|---|---|---|
| Task 1: StrategyRegistry + IStrategyAclProvider | 62227c73 | StrategyRegistry.cs, IStrategyAclProvider.cs |
| Task 2: PluginBase dispatch + bug fixes | 0212deed | PluginBase.cs + 6 plugin files |

## Self-Check: PASSED

- FOUND: DataWarehouse.SDK/Contracts/StrategyRegistry.cs
- FOUND: DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs
- FOUND: commit 62227c73 (Task 1)
- FOUND: commit 0212deed (Task 2)
- StrategyRegistry class: 1 definition
- IStrategyAclProvider interface: 1 definition
- PluginBase strategy methods: 6 (RegisterStrategy, 2x ResolveStrategy, ExecuteWithStrategyAsync, 2x references)
- Full solution build: 0 errors, 0 warnings (dotnet build DataWarehouse.slnx --no-incremental)
