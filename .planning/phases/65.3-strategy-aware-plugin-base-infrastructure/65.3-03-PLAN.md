---
phase: 65.3-strategy-aware-plugin-base-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["65.3-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/DataTransformationPluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/CompressionPluginBase.cs
autonomous: true

must_haves:
  truths:
    - "SelectOptimalAlgorithmAsync is called during strategy dispatch (no longer dead code)"
    - "EncryptionPluginBase provides EncryptAsync/DecryptAsync domain operations that resolve strategy from registry"
    - "CompressionPluginBase provides CompressAsync/DecompressAsync domain operations that resolve strategy from registry"
    - "Ultimate plugins inheriting these bases get domain operations for free without reimplementing"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/DataTransformationPluginBase.cs"
      provides: "SelectOptimalAlgorithmAsync wired into dispatch"
      contains: "SelectOptimalAlgorithmAsync"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs"
      provides: "Encrypt/Decrypt domain operations using strategy registry"
      contains: "EncryptAsync"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/CompressionPluginBase.cs"
      provides: "Compress/Decompress domain operations using strategy registry"
      contains: "CompressAsync"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs"
      to: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      via: "Uses inherited ResolveStrategy/ExecuteWithStrategyAsync from PluginBase"
      pattern: "ResolveStrategy|ExecuteWithStrategyAsync"
    - from: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/DataTransformationPluginBase.cs"
      to: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      via: "SelectOptimalAlgorithmAsync used in dispatch chain"
      pattern: "SelectOptimalAlgorithmAsync"
---

<objective>
Wire SelectOptimalAlgorithmAsync into the dispatch chain and implement domain operations (Encrypt/Decrypt, Compress/Decompress) in the plugin bases so Ultimate plugins get them for free.

Purpose: SelectOptimalAlgorithmAsync is currently dead code. Domain operations currently require each Ultimate plugin to reimplement ~300 lines of registry+dispatch. By implementing these in the base classes, Ultimate plugins inherit them automatically.

Output: DataTransformationPluginBase, EncryptionPluginBase, and CompressionPluginBase modified with domain dispatch operations
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/65.3-strategy-aware-plugin-base-infrastructure/65.3-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/DataTransformationPluginBase.cs
@DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
@DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/CompressionPluginBase.cs
@DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategy.cs (for IEncryptionStrategy interface)
@DataWarehouse.SDK/Contracts/Compression/CompressionStrategy.cs (for ICompressionStrategy interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire SelectOptimalAlgorithmAsync into DataTransformationPluginBase dispatch</name>
  <files>DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/DataTransformationPluginBase.cs</files>
  <action>
Add a protected dispatch method to DataTransformationPluginBase that integrates SelectOptimalAlgorithmAsync:

```csharp
/// <summary>
/// Dispatches an operation to the optimal strategy, using AI-driven algorithm selection
/// when no explicit strategy is specified. This is the primary dispatch entry point
/// for all data transformation operations.
/// </summary>
/// <typeparam name="TStrategy">The strategy interface type.</typeparam>
/// <typeparam name="TResult">The operation result type.</typeparam>
/// <param name="explicitStrategyId">Explicit strategy ID (null = use AI selection).</param>
/// <param name="identity">CommandIdentity for ACL checks.</param>
/// <param name="dataContext">Context about the data for AI algorithm selection.</param>
/// <param name="operation">The operation to execute on the resolved strategy.</param>
/// <param name="ct">Cancellation token.</param>
/// <returns>The operation result.</returns>
protected async Task<TResult> DispatchWithOptimalStrategyAsync<TStrategy, TResult>(
    string? explicitStrategyId,
    CommandIdentity? identity,
    Dictionary<string, object>? dataContext,
    Func<TStrategy, Task<TResult>> operation,
    CancellationToken ct = default) where TStrategy : class, IStrategy
{
    string strategyId;
    if (!string.IsNullOrEmpty(explicitStrategyId))
    {
        strategyId = explicitStrategyId;
    }
    else
    {
        // Use AI-driven selection (no longer dead code!)
        strategyId = await SelectOptimalAlgorithmAsync(
            dataContext ?? new Dictionary<string, object>(), ct).ConfigureAwait(false);
    }

    return await ExecuteWithStrategyAsync<TStrategy, TResult>(
        strategyId, identity, operation, ct).ConfigureAwait(false);
}
```

This makes SelectOptimalAlgorithmAsync the fallback when no explicit strategy is provided, wiring the previously dead-code AI hook into the live dispatch path. The method is protected so domain plugin bases (EncryptionPluginBase, CompressionPluginBase) can use it.

Also add an overload of `GetDefaultStrategyId()` that delegates to SubCategory as the fallback:
```csharp
protected override string? GetDefaultStrategyId()
    => SubCategory; // "Encryption", "Compression", etc.
```
  </action>
  <verify>Build SDK: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors, 0 warnings.</verify>
  <done>DataTransformationPluginBase has DispatchWithOptimalStrategyAsync that calls SelectOptimalAlgorithmAsync when no explicit strategy is provided. SelectOptimalAlgorithmAsync is no longer dead code.</done>
</task>

<task type="auto">
  <name>Task 2: Add domain operations to EncryptionPluginBase and CompressionPluginBase</name>
  <files>
    DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/CompressionPluginBase.cs
  </files>
  <action>
**EncryptionPluginBase** -- add these domain operation methods that use the inherited PluginBase strategy registry + DataTransformationPluginBase dispatch:

```csharp
#region Domain Operations (Strategy-Dispatched)

/// <summary>
/// Encrypts data using the specified or default encryption strategy.
/// Resolves the strategy from the registry with CommandIdentity ACL,
/// falls back to SelectOptimalAlgorithmAsync for AI-driven selection.
/// </summary>
protected async Task<byte[]> EncryptAsync(
    byte[] plaintext,
    byte[] key,
    string? strategyId = null,
    CommandIdentity? identity = null,
    byte[]? associatedData = null,
    CancellationToken ct = default)
{
    return await DispatchWithOptimalStrategyAsync<IEncryptionStrategy, byte[]>(
        strategyId,
        identity,
        new Dictionary<string, object>
        {
            ["operation"] = "encrypt",
            ["dataSize"] = plaintext.Length,
            ["hasAssociatedData"] = associatedData != null
        },
        async strategy =>
        {
            var result = await strategy.EncryptAsync(plaintext, key, associatedData, ct)
                .ConfigureAwait(false);
            UpdateEncryptionStats(plaintext.Length);
            return result;
        },
        ct).ConfigureAwait(false);
}

/// <summary>
/// Decrypts data using the specified or default encryption strategy.
/// </summary>
protected async Task<byte[]> DecryptAsync(
    byte[] ciphertext,
    byte[] key,
    string? strategyId = null,
    CommandIdentity? identity = null,
    byte[]? associatedData = null,
    CancellationToken ct = default)
{
    return await DispatchWithOptimalStrategyAsync<IEncryptionStrategy, byte[]>(
        strategyId,
        identity,
        new Dictionary<string, object>
        {
            ["operation"] = "decrypt",
            ["dataSize"] = ciphertext.Length
        },
        async strategy =>
        {
            var result = await strategy.DecryptAsync(ciphertext, key, associatedData, ct)
                .ConfigureAwait(false);
            UpdateDecryptionStats(result.Length);
            return result;
        },
        ct).ConfigureAwait(false);
}

/// <summary>
/// Override to provide encryption-specific default strategy.
/// Returns AlgorithmId (e.g., "aes-256-gcm").
/// </summary>
protected override string? GetDefaultStrategyId() => AlgorithmId;

#endregion
```

Note: The IEncryptionStrategy does NOT extend IStrategy. If DispatchWithOptimalStrategyAsync requires `TStrategy : IStrategy`, these methods need to use a different dispatch path. In that case, create a parallel dispatch method that works with any type having StrategyId:

```csharp
protected async Task<TResult> DispatchEncryptionStrategyAsync<TResult>(
    string? explicitStrategyId,
    CommandIdentity? identity,
    Dictionary<string, object>? dataContext,
    Func<IEncryptionStrategy, Task<TResult>> operation,
    CancellationToken ct = default)
```

This method resolves from a `StrategyRegistry<IEncryptionStrategy>` field on EncryptionPluginBase (not from PluginBase's IStrategy registry). Add `protected StrategyRegistry<IEncryptionStrategy>? EncryptionStrategyRegistry { get; set; }` as a dedicated typed registry. The dispatchers know the right type. If the generic StrategyRegistry constraint allows this, use it directly.

**CompressionPluginBase** -- add analogous domain operations:

```csharp
#region Domain Operations (Strategy-Dispatched)

/// <summary>
/// Compresses data using the specified or default compression strategy.
/// </summary>
protected async Task<byte[]> CompressAsync(
    byte[] data,
    string? strategyId = null,
    CommandIdentity? identity = null,
    int? compressionLevel = null,
    CancellationToken ct = default)
{
    // Similar pattern to EncryptAsync using DispatchWithOptimalStrategyAsync
    // or a CompressionPluginBase-specific dispatch
}

/// <summary>
/// Decompresses data using the specified or default compression strategy.
/// </summary>
protected async Task<byte[]> DecompressAsync(
    byte[] compressedData,
    string? strategyId = null,
    CommandIdentity? identity = null,
    CancellationToken ct = default)
{
    // Similar pattern
}

protected override string? GetDefaultStrategyId() => CompressionAlgorithm;

#endregion
```

Look at `DataWarehouse.SDK/Contracts/Compression/CompressionStrategy.cs` for the ICompressionStrategy interface to determine the exact method signatures for compress/decompress operations. Match those signatures.

IMPORTANT: Do NOT break existing EncryptionPluginBase functionality. The new EncryptAsync/DecryptAsync are ADDITIONAL methods alongside the existing EncryptCoreAsync/DecryptCoreAsync and OnWriteAsync/OnReadAsync. The existing methods work at the Stream level; the new methods work at the byte[] level using strategy dispatch.
  </action>
  <verify>Build full solution: `dotnet build DataWarehouse.sln --no-restore` -- 0 errors, 0 warnings.</verify>
  <done>EncryptionPluginBase has EncryptAsync/DecryptAsync domain operations. CompressionPluginBase has CompressAsync/DecompressAsync domain operations. Both use strategy dispatch with CommandIdentity ACL and SelectOptimalAlgorithmAsync fallback. All existing functionality preserved.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore` -- 0 errors, 0 warnings
2. Grep for SelectOptimalAlgorithmAsync being called (not just defined) in dispatch path
3. Grep for EncryptAsync in EncryptionPluginBase.cs (new domain operation)
4. Grep for CompressAsync in CompressionPluginBase.cs (new domain operation)
5. Grep for DispatchWithOptimalStrategyAsync in DataTransformationPluginBase.cs
</verification>

<success_criteria>
- SelectOptimalAlgorithmAsync wired into live dispatch chain (no longer dead code)
- EncryptionPluginBase provides EncryptAsync/DecryptAsync using strategy dispatch
- CompressionPluginBase provides CompressAsync/DecompressAsync using strategy dispatch
- CommandIdentity ACL enforced in all dispatch paths
- Full solution builds with 0 errors, 0 warnings
- Existing EncryptCoreAsync/DecryptCoreAsync/OnWriteAsync/OnReadAsync untouched
</success_criteria>

<output>
After completion, create `.planning/phases/65.3-strategy-aware-plugin-base-infrastructure/65.3-03-SUMMARY.md`
</output>
