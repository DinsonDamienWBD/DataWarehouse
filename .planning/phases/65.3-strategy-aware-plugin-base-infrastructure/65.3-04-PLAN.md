---
phase: 65.3-strategy-aware-plugin-base-infrastructure
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateRAID/RaidStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataGovernanceStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateResilience/ResilienceStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataPrivacy/DataPrivacyStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataQuality/DataQualityStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataCatalogStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateDeployment/DeploymentStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UniversalDashboards/DashboardStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateRTOSBridge/IRtosStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateResourceManager/ResourceStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateSustainability/SustainabilityStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/FilesystemStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateMultiCloud/MultiCloudStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/LineageStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataIntegration/UltimateDataIntegrationPlugin.cs
autonomous: true

must_haves:
  truths:
    - "All 15 Tier 2 plugin-local strategy bases in this batch extend StrategyBase"
    - "All concrete strategies inheriting these bases still compile without changes"
    - "Duplicated infrastructure (counters, health, init, dispose) removed in favor of StrategyBase inherited members"
    - "Domain-specific members (interfaces, properties, methods) preserved exactly"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/RaidStrategyBase.cs"
      provides: "RaidStrategyBase extending StrategyBase"
      contains: "RaidStrategyBase : StrategyBase"
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataGovernanceStrategyBase.cs"
      provides: "DataGovernanceStrategyBase extending StrategyBase"
      contains: "DataGovernanceStrategyBase : StrategyBase"
    - path: "Plugins/DataWarehouse.Plugins.UltimateResilience/ResilienceStrategyBase.cs"
      provides: "ResilienceStrategyBase extending StrategyBase"
      contains: "ResilienceStrategyBase : StrategyBase"
  key_links:
    - from: "All 15 strategy bases in this plan"
      to: "DataWarehouse.SDK/Contracts/StrategyBase.cs"
      via: "class inheritance"
      pattern: ": StrategyBase"
---

<objective>
Migrate 15 Tier 2 plugin-local strategy bases to extend SDK StrategyBase, eliminating duplicated lifecycle/counter/health infrastructure.

Purpose: These strategy bases currently implement domain interfaces directly (e.g., `RaidStrategyBase : IRaidStrategy`) with their own counters, init/shutdown, and health check infrastructure that duplicates StrategyBase. By extending StrategyBase, they get lifecycle, counters, retry, health caching, and dispose for free.

Output: 15 modified strategy base files, all extending StrategyBase
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@DataWarehouse.SDK/Contracts/StrategyBase.cs
@DataWarehouse.SDK/Contracts/IStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate batch 1 strategy bases (RAID, DataGovernance, Resilience, DataPrivacy, DataQuality, DataCatalog, Deployment, Dashboard)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateRAID/RaidStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataGovernanceStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateResilience/ResilienceStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateDataPrivacy/DataPrivacyStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateDataQuality/DataQualityStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataCatalogStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateDeployment/DeploymentStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UniversalDashboards/DashboardStrategyBase.cs
  </files>
  <action>
For each of the 8 strategy bases, apply this migration pattern:

1. **Read the file** -- understand what members it has (StrategyId, Name/DisplayName, counters, health, init/shutdown, dispose, domain-specific members)

2. **Change declaration** from `class XxxStrategyBase : IXxxStrategy` to `class XxxStrategyBase : StrategyBase, IXxxStrategy`
   - Add `using DataWarehouse.SDK.Contracts;` if not present
   - The plugin's .csproj already references DataWarehouse.SDK (all plugins do)

3. **Remove duplicated members** that StrategyBase already provides:
   - `_counters` / BoundedDictionary counters -> use `IncrementCounter(name)` / `GetCounter(name)`
   - `_initialized` bool -> use inherited `_initialized` / `IsInitialized`
   - `InitializeAsync` / `ShutdownAsync` -> rename to `InitializeAsyncCore` / `ShutdownAsyncCore` (protected override)
   - `_disposed` / `Dispose(bool)` / `DisposeAsync` -> use inherited pattern, override `Dispose(bool disposing)` and call `base.Dispose(disposing)`
   - Health cache (`_cachedHealth`, `_healthCacheExpiry`) -> use inherited `GetCachedHealthAsync`
   - `EnsureNotDisposed()` -> inherited from StrategyBase
   - `ThrowIfNotInitialized()` -> inherited from StrategyBase

4. **Map name properties**:
   - If base has `DisplayName` (abstract string) and the domain interface requires it: keep DisplayName, implement `public override string Name => DisplayName;`
   - If base has `Name` already: just make it `override`
   - `StrategyId` -> make it `override` (already abstract in StrategyBase)
   - `Description` -> make it `override` if present

5. **Preserve domain-specific members** -- anything unique to the domain (e.g., RAID parity calculations, governance scoring, resilience circuit breaking) stays exactly as-is.

6. **Handle IDisposable conflicts** -- StrategyBase implements IDisposable and IAsyncDisposable. If the strategy base also declares `: IDisposable`, remove it from the declaration (inherited). If it has its own `Dispose()` method (non-virtual), change to `protected override void Dispose(bool disposing)`.

7. **Handle name collisions** -- If both the domain interface and StrategyBase define `StrategyId`, the override satisfies both. If the domain interface has a different name (e.g., `Id` instead of `StrategyId`), add an explicit interface implementation.

For each file, after modification, ensure the plugin project compiles:
```
dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/ --no-restore
dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/ --no-restore
# ... etc
```

Fix any compilation errors before moving to the next file.
  </action>
  <verify>
Build all 8 plugin projects individually with `dotnet build Plugins/DataWarehouse.Plugins.{PluginName}/ --no-restore` -- each produces 0 errors, 0 warnings.
  </verify>
  <done>8 strategy bases extend StrategyBase. All concrete strategies compile. Duplicated infrastructure removed.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate batch 2 strategy bases (RTOS, Resource, Sustainability, Filesystem, MultiCloud, DataLineage, DataIntegration)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateRTOSBridge/IRtosStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateResourceManager/ResourceStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateSustainability/SustainabilityStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/FilesystemStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateMultiCloud/MultiCloudStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateDataLineage/LineageStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateDataIntegration/UltimateDataIntegrationPlugin.cs
  </files>
  <action>
Apply the same migration pattern as Task 1 to these 7 strategy bases.

Special cases:
- **IRtosStrategy.cs** contains RtosStrategyBase in the same file as the interface. Only modify the class, not the interface.
- **UltimateDataIntegrationPlugin.cs** contains DataIntegrationStrategyBase in the same file as the plugin. Only modify the strategy base class.
- **ResourceStrategyBase** is in its own file -- straightforward migration.

Same steps: change declaration -> remove duplicates -> map names -> preserve domain -> handle IDisposable -> handle collisions.

Build each plugin project after modification to catch errors early.
  </action>
  <verify>
Build all 7 plugin projects individually with `dotnet build Plugins/DataWarehouse.Plugins.{PluginName}/ --no-restore` -- each produces 0 errors, 0 warnings.
Then build full solution: `dotnet build DataWarehouse.sln --no-restore` -- 0 errors, 0 warnings.
  </verify>
  <done>7 more strategy bases extend StrategyBase. All 15 Tier 2 bases in this plan now extend StrategyBase. Full solution builds cleanly.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore` -- 0 errors, 0 warnings
2. Grep for `: StrategyBase` in all 15 modified files confirms migration
3. Grep for `_counters = new BoundedDictionary` in modified files returns 0 results (duplicates removed)
4. All concrete strategy classes inheriting these bases still compile
</verification>

<success_criteria>
- 15 Tier 2 strategy bases now extend StrategyBase
- Duplicated lifecycle/counter/health/dispose code removed
- Domain-specific behavior preserved exactly
- All concrete strategies compile without changes
- Full solution builds with 0 errors, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/65.3-strategy-aware-plugin-base-infrastructure/65.3-04-SUMMARY.md`
</output>
