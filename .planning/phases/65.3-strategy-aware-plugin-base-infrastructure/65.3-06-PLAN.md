---
phase: 65.3-strategy-aware-plugin-base-infrastructure
plan: 06
type: execute
wave: 3
depends_on: ["65.3-01", "65.3-02", "65.3-03", "65.3-04", "65.3-05"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs
autonomous: true

must_haves:
  truths:
    - "UltimateEncryptionPlugin uses inherited EncryptionPluginBase strategy dispatch instead of its own registry/dispatch code"
    - "UltimateCompressionPlugin uses inherited CompressionPluginBase strategy dispatch instead of its own registry/dispatch code"
    - "Duplicated strategy registry/dispatch/discovery code removed from both plugins (~300 lines each)"
    - "All existing message handlers still work (encryption.encrypt, encryption.decrypt, etc.)"
    - "OnWriteAsync/OnReadAsync still function correctly using the inherited infrastructure"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs"
      provides: "UltimateEncryption using inherited dispatch"
      contains: "EncryptionPluginBase"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs"
      provides: "UltimateCompression using inherited dispatch"
      contains: "CompressionPluginBase"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs"
      to: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs"
      via: "Uses inherited EncryptAsync/DecryptAsync and strategy registry"
      pattern: "EncryptAsync|DecryptAsync|StrategyRegistry"
---

<objective>
Migrate UltimateEncryptionPlugin and UltimateCompressionPlugin to use the inherited strategy dispatch infrastructure, removing duplicated registry/dispatch code.

Purpose: Each Ultimate plugin currently reimplements ~300 lines of strategy registry, assembly scanning, and dispatch logic. With Plans 01-03 complete, this code is now provided by PluginBase/EncryptionPluginBase/CompressionPluginBase. Removing the duplication simplifies the plugins and ensures consistent behavior.

Output: Two plugin files modified with duplicated code removed, delegating to inherited infrastructure
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/65.3-strategy-aware-plugin-base-infrastructure/65.3-01-SUMMARY.md
@.planning/phases/65.3-strategy-aware-plugin-base-infrastructure/65.3-03-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs
@DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/EncryptionPluginBase.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate UltimateEncryptionPlugin to inherited dispatch</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs</files>
  <action>
Read the full UltimateEncryptionPlugin.cs. Identify the duplicated code that can be replaced with inherited infrastructure:

1. **EncryptionStrategyRegistry _registry** -- This is the bespoke typed registry. After Plan 02, EncryptionStrategyRegistry delegates to StrategyRegistry<T> internally. The plugin can continue to use _registry for type-safe encryption operations, OR switch to the inherited PluginBase.StrategyRegistry.

   DECISION: Keep the typed `_registry` (EncryptionStrategyRegistry) since it provides encryption-specific query methods (GetFipsCompliantStrategies, GetStrategiesBySecurityLevel). BUT wire it INTO the inherited PluginBase strategy registry so the generic dispatch path also works. Do this by:
   - In OnHandshakeAsync or InitializeAsync: for each strategy in _registry.GetAllStrategies(), also call `RegisterStrategy(strategy)` (if IEncryptionStrategy also implements IStrategy; if not, register in a type-specific sub-registry on EncryptionPluginBase).
   - If IEncryptionStrategy does NOT extend IStrategy (which is the current state), the PluginBase generic registry won't help for encryption strategies. In that case, the migration is about making the message handlers use the base class domain operations instead.

2. **DiscoverAndRegisterStrategies()** -- the private method that scans assemblies with Activator.CreateInstance. This can be replaced with `_registry.DiscoverStrategies(GetType().Assembly)` which already exists. Verify it already does this -- if so, no change needed.

3. **HandleEncryptAsync / HandleDecryptAsync** -- These handlers resolve a strategy from _registry and call EncryptAsync/DecryptAsync. If EncryptionPluginBase now provides EncryptAsync/DecryptAsync domain methods (from Plan 03), the handlers can delegate to those. But they also need to handle encryption-specific concerns (key management, envelope mode, audit).

   APPROACH: Rather than a wholesale rewrite, surgically remove the duplicated strategy resolution code and replace it with calls to the base class. The encryption-specific logic (key management, envelope, FIPS validation) stays in the plugin.

4. **OnWriteAsync/OnReadAsync** -- Currently resolves strategy from _registry and calls strategy.EncryptAsync/DecryptAsync directly. Update to use the base class EncryptAsync/DecryptAsync methods where possible, but keep the stream-level operations as-is since the base class domain operations work at the byte[] level.

5. **Remove duplicated stats tracking** -- _totalEncryptions, _totalDecryptions, _totalBytesEncrypted, _totalBytesDecrypted duplicate EncryptionPluginBase.EncryptionCount etc. Remove and use inherited counters.

6. **Remove duplicated _usageStats** BoundedDictionary -- use inherited counter infrastructure.

KEY RULE: Do NOT break existing functionality. If any migration step is risky, keep the existing code and add a comment: `// TODO(65.3): Migrate to base class dispatch when IEncryptionStrategy extends IStrategy`. The migration may be partial depending on the IEncryptionStrategy/IStrategy relationship.

After modification, verify all message handlers still work by examining the code flow. Run the build to confirm compilation.
  </action>
  <verify>
```
dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/ --no-restore
dotnet build DataWarehouse.sln --no-restore
```
0 errors, 0 warnings.
  </verify>
  <done>UltimateEncryptionPlugin uses inherited dispatch infrastructure where possible. Duplicated stats/counters removed. All message handlers compile and delegate to base class operations.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate UltimateCompressionPlugin to inherited dispatch</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs</files>
  <action>
First, find the UltimateCompressionPlugin file:
```
find Plugins/ -name "*Compression*Plugin*.cs" -type f
```

If it doesn't exist as a separate plugin, check if compression is handled by a different plugin name (e.g., UltimateDataTransformation or similar). Search for:
```
grep -r "CompressionPluginBase" Plugins/ --include="*.cs" -l
```

Once found, apply the same migration pattern as Task 1:
1. Identify duplicated registry/dispatch code
2. Replace with calls to inherited CompressionPluginBase.CompressAsync/DecompressAsync
3. Remove duplicated stats tracking
4. Keep domain-specific logic (compression level selection, algorithm-specific parameters)
5. Ensure all message handlers still work

If UltimateCompressionPlugin does not exist or is very different from UltimateEncryption's pattern, document what was found and what migration was done.

Build the plugin project and full solution after modification.
  </action>
  <verify>
```
dotnet build DataWarehouse.sln --no-restore
```
0 errors, 0 warnings.
  </verify>
  <done>UltimateCompressionPlugin (or equivalent) uses inherited dispatch infrastructure. Duplicated code removed. Full solution builds cleanly.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore` -- 0 errors, 0 warnings
2. Grep for duplicated registry/dispatch patterns in the migrated plugins -- should be significantly reduced
3. Verify message handlers still reference appropriate operations
4. `dotnet test DataWarehouse.Tests/ --no-build` -- all existing tests pass
</verification>

<success_criteria>
- UltimateEncryption and UltimateCompression use inherited dispatch infrastructure
- Duplicated stats, registry, and dispatch code removed or delegated
- All message handlers still work
- All existing tests pass
- Full solution builds with 0 errors, 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/65.3-strategy-aware-plugin-base-infrastructure/65.3-06-SUMMARY.md`
</output>
