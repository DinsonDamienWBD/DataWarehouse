---
phase: 65.3-strategy-aware-plugin-base-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/StrategyRegistry.cs
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs
autonomous: true
must_haves:
  truths:
    - "Generic StrategyRegistry provides Register/Get/GetAll/Discover for any IStrategy-derived type"
    - "PluginBase has protected strategy dispatch methods that any plugin can use without reimplementing"
    - "ResolveStrategy checks CommandIdentity.EffectivePrincipalId via IStrategyAclProvider before returning a strategy"
    - "Non-strategy plugins are unaffected (zero impact if they never call strategy methods)"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/StrategyRegistry.cs"
      provides: "Generic strategy registry replacing 3 bespoke registries"
      contains: "class StrategyRegistry"
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "Strategy dispatch infrastructure in PluginBase"
      contains: "RegisterStrategy"
    - path: "DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs"
      provides: "ACL interface for strategy access control"
      contains: "interface IStrategyAclProvider"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      to: "DataWarehouse.SDK/Contracts/StrategyRegistry.cs"
      via: "PluginBase owns a StrategyRegistry instance"
      pattern: "StrategyRegistry"
    - from: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      to: "DataWarehouse.SDK/Security/CommandIdentity.cs"
      via: "ResolveStrategy accepts CommandIdentity for ACL check"
      pattern: "CommandIdentity"
---

<objective>
Create the generic StrategyRegistry<TStrategy> and add strategy dispatch infrastructure to PluginBase with CommandIdentity ACL integration.

Purpose: This is the foundation for all subsequent plans. The generic registry replaces 3 duplicate bespoke registries. The PluginBase dispatch methods eliminate ~300 lines of duplicated code per Ultimate plugin.

Output: StrategyRegistry.cs (new), IStrategyAclProvider.cs (new), PluginBase.cs (modified with strategy dispatch methods)
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/StrategyBase.cs
@DataWarehouse.SDK/Contracts/IStrategy.cs
@DataWarehouse.SDK/Security/CommandIdentity.cs
@DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategy.cs (reference: EncryptionStrategyRegistry pattern to generalize)
@DataWarehouse.SDK/Connectors/ConnectionStrategyRegistry.cs (reference: ConnectionStrategyRegistry pattern to generalize)
@DataWarehouse.SDK/Utilities/BoundedDictionary.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generic StrategyRegistry and IStrategyAclProvider</name>
  <files>
    DataWarehouse.SDK/Contracts/StrategyRegistry.cs
    DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Contracts/StrategyRegistry.cs` with a generic `StrategyRegistry<TStrategy>` class where `TStrategy : class`. Use a `Func<TStrategy, string>` key selector for extracting the strategy ID. Provide a convenience constructor for IStrategy types that uses `s => s.StrategyId`. This replaces the pattern duplicated in EncryptionStrategyRegistry, ConnectionStrategyRegistry, and ConsciousnessStrategyRegistry.

NOTE: The constraint is `where TStrategy : class` (not `where TStrategy : IStrategy`) because IEncryptionStrategy and IConsciousnessStrategy do NOT extend IStrategy. They independently define StrategyId. The key selector pattern accommodates all of them.

The class must:
1. Use `BoundedDictionary<string, TStrategy>` internally (capacity 1000, matching existing registries)
2. `void Register(TStrategy strategy)` - register by keySelector(strategy), overwrites existing
3. `bool Unregister(string strategyId)` - remove by ID
4. `TStrategy? Get(string strategyId)` - lookup by ID
5. `IReadOnlyCollection<TStrategy> GetAll()` - all registered
6. `IReadOnlyCollection<TStrategy> GetByPredicate(Func<TStrategy, bool> predicate)` - filtered query
7. `int Count` property
8. `string? DefaultStrategyId { get; set; }` - default strategy ID (volatile for thread safety)
9. `TStrategy GetDefault()` - returns strategy for DefaultStrategyId, throws if not found
10. `void SetDefault(string strategyId)` - validates strategy exists before setting
11. `int DiscoverFromAssembly(params Assembly[] assemblies)` - scan assemblies for non-abstract types implementing TStrategy, instantiate via Activator.CreateInstance, register. Silent skip on instantiation failures (matching existing pattern).
12. `bool ContainsStrategy(string strategyId)` - check existence

Constructors:
- `public StrategyRegistry(Func<TStrategy, string> keySelector)` - explicit key selector
- For IStrategy convenience, add a static factory: `public static StrategyRegistry<TStrategy> ForStrategyInterface() where TStrategy is constrained differently...` Actually, just use the lambda: `new StrategyRegistry<IStrategy>(s => s.StrategyId)`.

Thread-safe. Namespace: `DataWarehouse.SDK.Contracts`. Mark with `[SdkCompatibility("5.0.0", Notes = "Generic strategy registry replacing bespoke typed registries")]`.

Create `DataWarehouse.SDK/Contracts/IStrategyAclProvider.cs`:
```csharp
namespace DataWarehouse.SDK.Contracts;

/// <summary>
/// Provides access control checks for strategy resolution.
/// Plugins can inject this to enforce per-strategy ACL based on CommandIdentity.
/// Default: all strategies accessible (no restrictions).
/// </summary>
[SdkCompatibility("5.0.0", Notes = "Strategy-level ACL via CommandIdentity")]
public interface IStrategyAclProvider
{
    /// <summary>
    /// Checks whether the given identity is allowed to use the specified strategy.
    /// Implementations MUST evaluate identity.EffectivePrincipalId, NEVER identity.ActorId.
    /// </summary>
    /// <param name="strategyId">The strategy being accessed.</param>
    /// <param name="identity">The command identity requesting access.</param>
    /// <returns>True if access is allowed, false if denied.</returns>
    bool IsStrategyAllowed(string strategyId, CommandIdentity identity);
}
```

Use `DataWarehouse.SDK.Security` namespace import for CommandIdentity. Do NOT define a default implementation here -- PluginBase will handle the "allow all" default path.
  </action>
  <verify>
Build the SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` should compile with 0 errors, 0 warnings.
  </verify>
  <done>Generic StrategyRegistry exists with all 12 methods and key selector pattern. IStrategyAclProvider interface exists. Both compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add strategy dispatch infrastructure to PluginBase</name>
  <files>DataWarehouse.SDK/Contracts/PluginBase.cs</files>
  <action>
Add strategy dispatch methods to PluginBase. These are opt-in: plugins that don't use strategies are unaffected (the registry is lazily initialized).

Add these protected members and methods to PluginBase (in a new `#region Strategy Registry and Dispatch` section):

1. **Private field**: `private StrategyRegistry<IStrategy>? _strategyRegistry;` (lazy -- null until first use)

2. **Protected property**: `protected StrategyRegistry<IStrategy> StrategyRegistry` -- lazy-initializes `_strategyRegistry` on first access using `new StrategyRegistry<IStrategy>(s => s.StrategyId)`. Thread-safe (lock on a new `_strategyRegistryLock` object).

3. **Protected property**: `protected IStrategyAclProvider? StrategyAclProvider { get; set; }` -- optional ACL provider, null means "allow all".

4. **`protected void RegisterStrategy(IStrategy strategy)`** -- delegates to StrategyRegistry.Register(strategy). Also calls strategy.InitializeAsync if the plugin is already initialized.

5. **`protected TStrategy? ResolveStrategy<TStrategy>(string strategyId, CommandIdentity? identity = null) where TStrategy : class, IStrategy`** -- Gets strategy from registry, casts to TStrategy. If identity is provided AND StrategyAclProvider is set, checks `StrategyAclProvider.IsStrategyAllowed(strategyId, identity)`. If denied, throws `UnauthorizedAccessException` with message including identity.EffectivePrincipalId and strategyId. Returns null if strategy not found (not an error -- caller decides).

6. **`protected TStrategy ResolveStrategyOrDefault<TStrategy>(string? strategyId, CommandIdentity? identity = null) where TStrategy : class, IStrategy`** -- If strategyId is null/empty, uses GetDefaultStrategyId() first, then registry's DefaultStrategyId. Then delegates to ResolveStrategy. Throws InvalidOperationException if no strategy found.

7. **`protected virtual string? GetDefaultStrategyId()`** -- Returns null by default. Override in domain bases to provide domain-specific defaults (e.g., EncryptionPluginBase returns "aes-256-gcm").

8. **`protected async Task<TResult> ExecuteWithStrategyAsync<TStrategy, TResult>(string? strategyId, CommandIdentity? identity, Func<TStrategy, Task<TResult>> operation, CancellationToken ct = default) where TStrategy : class, IStrategy`** -- Resolves strategy via ResolveStrategyOrDefault, executes the operation function, returns result. This is the main dispatch pattern.

9. **`protected int DiscoverStrategiesFromAssembly(params Assembly[] assemblies)`** -- delegates to StrategyRegistry.DiscoverFromAssembly. Returns count of discovered strategies.

10. Modify `GetStrategyKnowledge()` (line 447) -- if `_strategyRegistry` is not null and has strategies, return a dictionary with "strategies" as a list of {strategyId, name, description} from the registry. This wires strategy knowledge into the existing knowledge bank infrastructure.

11. During `DisposeAsync`/`Dispose` -- if `_strategyRegistry` is not null, iterate all strategies and call ShutdownAsync/Dispose on each.

IMPORTANT: Do NOT break any existing PluginBase functionality. All new members are protected and opt-in. The `_strategyRegistry` being null by default ensures zero overhead for non-strategy plugins. Use System.Reflection for Assembly parameter.
  </action>
  <verify>
Build the full solution: `dotnet build DataWarehouse.sln --no-restore` should compile with 0 errors, 0 warnings. Existing plugins must not be affected.
  </verify>
  <done>PluginBase has RegisterStrategy, ResolveStrategy (with CommandIdentity ACL), ExecuteWithStrategyAsync, DiscoverStrategiesFromAssembly, GetDefaultStrategyId. Non-strategy plugins compile without changes.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.sln --no-restore` -- 0 errors, 0 warnings
2. Grep for StrategyRegistry class definition exists
3. Grep for RegisterStrategy, ResolveStrategy, ExecuteWithStrategyAsync in PluginBase.cs
4. Grep for IStrategyAclProvider interface definition exists
5. Grep for CommandIdentity in PluginBase.cs (confirms ACL integration)
</verification>

<success_criteria>
- Generic StrategyRegistry compiles and provides Register/Get/GetAll/Discover/Default
- PluginBase has opt-in strategy dispatch with CommandIdentity ACL
- IStrategyAclProvider interface defined for injectable ACL
- Full solution builds with 0 errors, 0 warnings
- No existing plugin behavior changes
</success_criteria>

<output>
After completion, create `.planning/phases/65.3-strategy-aware-plugin-base-infrastructure/65.3-01-SUMMARY.md`
</output>
