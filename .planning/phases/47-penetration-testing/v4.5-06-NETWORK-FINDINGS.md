# v4.5-06 Network & Transport Layer Attack Findings

**Pentest Phase:** 47-v4.5-06
**Date:** 2026-02-19
**Tester:** Automated adversarial analysis (Opus 4.6)
**Scope:** All network protocols and transport layers across DataWarehouse codebase
**Methodology:** Static code analysis of every TLS callback, protocol handler, and transport strategy

---

## Executive Summary

This assessment identified **9 findings** across the network and transport layer. The most critical class of vulnerability remains **TLS certificate validation bypass**, which persists in **2 unconditional bypass** locations and **15 configurable bypass** locations (all defaulting to secure). Additionally, the **gRPC control plane uses hardcoded insecure credentials**, and several application-layer protocols lack defense-in-depth controls.

**Bounty-eligible findings: 6** (FINDING-06 through FINDING-11)

| Severity | Count |
|----------|-------|
| Critical (9.0+) | 2 |
| High (7.0-8.9) | 3 |
| Medium (4.0-6.9) | 3 |
| Low (1.0-3.9) | 1 |

---

## ATTACK 1: Complete TLS Bypass Audit (Census)

### Methodology
Searched all .cs files for: `RemoteCertificateValidationCallback`, `ServerCertificateCustomValidationCallback`, `DangerousAcceptAnyServerCertificateValidator`, `SslClientAuthenticationOptions` with cert callbacks, and `ValidateAnyCertificate`.

### Complete TLS Certificate Validation Census

#### Category A: UNCONDITIONAL BYPASS (always returns true, no config toggle)

| # | File | Pattern | Status |
|---|------|---------|--------|
| 1 | `UltimateStorage/Strategies/Specialized/GrpcStorageStrategy.cs:160-163` | `RemoteCertificateValidationCallback = ... return true;` with comment "In production, implement proper certificate validation" | **BYPASS** |
| 2 | `UltimateDataTransit/Strategies/Direct/FtpTransitStrategy.cs:280` | `ValidateAnyCertificate = true` -- hardcoded for ALL FTPS connections, no configuration toggle | **BYPASS** |

#### Category B: CONFIGURABLE BYPASS (toggle exists, defaults to SECURE - validation ON)

| # | File | Config Field | Default |
|---|------|-------------|---------|
| 3 | `AedsCore/DataPlane/QuicDataPlanePlugin.cs:488-498` | `VerifySslCertificates` (Options dict) | `true` |
| 4 | `AdaptiveTransport/AdaptiveTransportPlugin.cs:553-563` | `_config.VerifySslCertificates` | `true` |
| 5 | `UniversalObservability/Strategies/Health/IcingaStrategy.cs:47` | `_verifySsl` | `true` |
| 6 | `UniversalDashboards/DashboardStrategyBase.cs:452` | `Config.VerifySsl` | `true` |
| 7 | `UltimateDatabaseProtocol/Strategies/Search/ElasticsearchProtocolStrategy.cs:82` | `_verifySsl` | `true` |
| 8 | `UltimateDatabaseProtocol/Strategies/Search/ElasticsearchProtocolStrategy.cs:750` | `_verifySsl` (2nd instance) | `true` |
| 9 | `UltimateDatabaseProtocol/Strategies/Search/AdditionalSearchStrategies.cs:73` | `_verifySsl` | `true` |
| 10 | `UltimateStorage/Strategies/Specialized/RestStorageStrategy.cs:247` | `_validateServerCertificate` | `true` |
| 11 | `UltimateStorage/Strategies/Network/WebDavStrategy.cs:164` | `_validateServerCertificate` | `true` |
| 12 | `UltimateStorage/Strategies/Network/FtpStrategy.cs:170,190` | `_validateCertificate` | `true` |
| 13 | `UltimateStorage/Strategies/Enterprise/WekaIoStrategy.cs:173` | `_validateCertificate` | `true` |
| 14 | `UltimateStorage/Strategies/Enterprise/VastDataStrategy.cs:224` | `_validateCertificate` | `true` |
| 15 | `UltimateStorage/Strategies/Enterprise/PureStorageStrategy.cs:163` | `_validateCertificate` | `true` |
| 16 | `UltimateStorage/Strategies/Enterprise/NetAppOntapStrategy.cs:156` | `_validateCertificate` | `true` |
| 17 | `UltimateStorage/Strategies/Enterprise/HpeStoreOnceStrategy.cs:166` | `_validateCertificate` | `true` |
| 18 | `UltimateConnector/Strategies/NoSql/DynamoDbConnectionStrategy.cs:46` | `_verifySsl` | `true` |
| 19 | `UltimateConnector/Strategies/NoSql/CosmosDbConnectionStrategy.cs:46` | `_verifySsl` | `true` |
| 20 | `UltimateIntelligence/Federation/FederationSystem.cs:608` | `config.ValidateServerCertificate` | `true` |

#### Category C: CONFIGURABLE BYPASS (toggle exists, behavior depends on TLS mode)

| # | File | Condition | Notes |
|---|------|-----------|-------|
| 21 | `UltimateStorage/Strategies/Connectors/GrpcConnectorStrategy.cs:74-76` | Bypasses when `!_useTls` | Correct: disables validation when TLS is disabled (plaintext mode). When TLS enabled, callback is null (default .NET validation). |

#### Category D: SECURE (proper validation)

| # | File | Validation Quality |
|---|------|-------------------|
| 22 | `SDK/Infrastructure/Distributed/TcpP2PNetwork.cs:236` (ValidateServerCertificate) | **SECURE**: Rejects null certs, supports cert pinning via thumbprints, proper SslPolicyErrors check, optional self-signed for dev (default: off) |
| 23 | `SDK/Infrastructure/Distributed/TcpP2PNetwork.cs:303` (ValidateClientCertificate) | **SECURE**: Same as above, server-side mTLS validation |
| 24 | `UltimateConnector/Strategies/Innovations/ZeroTrustConnectionMeshStrategy.cs:233` | **SECURE**: `errors == SslPolicyErrors.None` (strict) |
| 25 | `UltimateConnector/Strategies/Innovations/QuantumSafeConnectionStrategy.cs:97` | **SECURE**: `errors == SslPolicyErrors.None` + TLS 1.3 only |
| 26 | `UltimateDatabaseProtocol/DatabaseProtocolStrategyBase.cs:608` | **SECURE**: `sslPolicyErrors == SslPolicyErrors.None` |
| 27 | `UltimateKeyManagement/Strategies/Hsm/AwsCloudHsmStrategy.cs:216` | **PARTIAL**: Validates against customer CA cert when path configured; falls back to accepting `RemoteCertificateChainErrors` when no CA cert path -- see FINDING-09 |

### Regression Tracking

| Version | Total Bypass | Unconditional | Configurable (default insecure) | Configurable (default secure) |
|---------|-------------|---------------|--------------------------------|-------------------------------|
| v4.3 | 15 | 15 | 0 | 0 |
| v4.4 | 2 | 2 | 0 | 13 fixed |
| v4.5 (current) | 2 | 2 | 0 | 18 (configurable, all default secure) |

**Progress:** 13 of 15 original unconditional bypasses have been fixed. 2 remain (GrpcStorageStrategy, FtpTransitStrategy).

---

## ATTACK 2: TLS Version Downgrade

### Findings

Searched for `SslProtocols`, `SecurityProtocolType` across all source files.

**Locations that explicitly enforce TLS 1.2+ minimum:**

| File | Enforcement |
|------|-------------|
| `TcpP2PNetwork.cs:234,301` | `SslProtocols.Tls12 \| SslProtocols.Tls13` (excellent) |
| `QuantumSafeConnectionStrategy.cs:99` | `SslProtocols.Tls13` only (strict) |
| `DatabaseProtocolStrategyBase.cs:591` | `SslProtocols.Tls12 \| SslProtocols.Tls13` (excellent) |
| `TlsBridgeTransitStrategy.cs:196` | Runtime check rejects `< Tls12` (excellent) |
| `FederationSystem.cs:2656` | Config property defaults to `Tls12` minimum |
| Compliance tests (ComplianceTestSuites.cs:131-138) | Assert TLS 1.2 minimum, reject SSL3/TLS1.0/TLS1.1 |

**Locations that DO NOT specify TLS version (rely on OS/framework defaults):**

All `HttpClientHandler`-based strategies (IcingaStrategy, DashboardStrategyBase, ElasticsearchProtocolStrategy, all enterprise storage strategies, FederationSystem HttpClient, etc.) use default `HttpClient` which inherits the OS-level TLS settings. On modern .NET 8+, this defaults to TLS 1.2+, but:

- **Risk**: On .NET 8 the default `SslProtocols.None` means "let OS decide", which on modern Windows/Linux defaults to TLS 1.2+. This is acceptable but not defense-in-depth.
- **No explicit downgrade protection** in any `HttpClientHandler` configuration across ~20 strategies.

**Assessment: LOW risk.** .NET 8+ defaults are secure. No explicit `SslProtocols.Ssl3` or `SslProtocols.Tls` (1.0) found anywhere in production code.

---

## ATTACK 3: Weak Cipher Suite Negotiation

### Findings

No `CipherSuitesPolicy` configuration found anywhere in the codebase.

**Assessment:** The codebase relies entirely on OS/framework cipher suite defaults. On .NET 8+ with modern Windows/Linux, this is acceptable (RC4, 3DES, NULL, EXPORT ciphers are disabled by default). However:

- No explicit cipher suite ordering or restriction
- No enforcement of forward secrecy (ECDHE/DHE)
- Server cipher preference not configured (relies on OS defaults)

**Risk: LOW.** Modern .NET 8 defaults are secure, but there is no defense-in-depth cipher configuration.

---

## ATTACK 4: Certificate Pinning Assessment

### Findings

Certificate pinning is implemented in **exactly one location**: `TcpP2PNetwork.cs` (lines 352-355, 377-380).

| Component | Pinning? | Details |
|-----------|----------|---------|
| TcpP2PNetwork (SDK) | **YES** | Thumbprint-based pinning via `PinnedCertificateThumbprints` HashSet |
| ZeroTrustConnectionMeshStrategy | **NO** | Standard CA validation only |
| QuantumSafeConnectionStrategy | **NO** | Standard CA validation only |
| All HttpClient strategies | **NO** | Standard CA validation only |
| GrpcStorageStrategy | **NO** | No validation at all (bypass) |
| AwsCloudHsmStrategy | **PARTIAL** | Validates against customer CA cert (quasi-pinning) |

**Assessment:** An attacker with a rogue CA certificate (e.g., compromised enterprise CA, state-sponsored CA) can MITM **all connections except TcpP2PNetwork** when pinning is configured. This is typical for most software but notable given DataWarehouse's claim to support air-gapped and zero-trust environments.

---

## ATTACK 5: mTLS Client Certificate Attacks

### Findings

**mTLS is implemented in:**
1. `TcpP2PNetwork.cs` -- Full mTLS with `ClientCertificateRequired = true`, proper validation
2. `GrpcStorageStrategy.cs` -- Client cert loading but server validation is bypassed (FINDING-06)
3. `FederationSystem.cs` -- mTLS when `AuthMethod == MutualTls`
4. `MtlsStrategy.cs` (UltimateAccessControl) -- Full mTLS authentication strategy
5. `DatabaseProtocolStrategyBase.cs` -- Client cert support

**TcpP2PNetwork ValidateClientCertificate analysis (line 340-360):**
- Rejects null certificates (good)
- `AllowSelfSignedCertificates` defaults to `false` (good)
- When `AllowSelfSignedCertificates = true`, accepts ANY self-signed cert (only checks `RemoteCertificateChainErrors`, not identity)
- Certificate pinning supported via `PinnedCertificateThumbprints`

**Assessment:** mTLS is NOT universally enforced. Many strategies (all HTTP-based) only support bearer token or API key auth. The mTLS implementations that exist are properly done in TcpP2PNetwork but the `AllowSelfSignedCertificates` flag creates risk if enabled.

---

## ATTACK 6: TLS Session Resumption

No explicit TLS session ticket configuration found. The codebase relies entirely on .NET's default session management. No 0-RTT replay protection is configured for QUIC connections (QUIC `ClientAuthenticationOptions` does not set `AllowTlsResume` or early data policies).

**Assessment: LOW risk.** .NET's defaults handle session tickets securely.

---

## Findings

### FINDING-06: GrpcStorageStrategy Unconditional TLS Certificate Bypass (Confirmed from v4.3)

**CVSS 3.1:** 9.1 (Critical)
**Vector:** `AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N`
**Status:** CONFIRMED -- still present from v4.3 FINDING-01

**Location:** `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Specialized/GrpcStorageStrategy.cs` lines 160-163

**Evidence:**
```csharp
RemoteCertificateValidationCallback = (sender, certificate, chain, errors) =>
{
    // In production, implement proper certificate validation
    return true;
}
```

**Attack Narrative:** An attacker in a MITM position between DataWarehouse and a gRPC storage backend can present ANY certificate (self-signed, expired, wrong hostname) and it will be accepted. The attacker can then intercept, modify, or inject all data flowing to/from gRPC storage. The comment "In production, implement proper certificate validation" indicates this was intended as temporary code that was never replaced.

**Impact:** Complete compromise of data confidentiality and integrity for all gRPC storage operations. This strategy handles potentially the most sensitive data in the system (stored objects).

**Remediation:** Replace with `errors == SslPolicyErrors.None` or add a configurable toggle defaulting to secure (matching the pattern in other strategies).

---

### FINDING-07: GrpcControlPlanePlugin Hardcoded Insecure Channel Credentials

**CVSS 3.1:** 8.7 (High)
**Vector:** `AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N` (adjusted for control plane impact)

**Location:** `Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/GrpcControlPlanePlugin.cs` line 108

**Evidence:**
```csharp
_channel = GrpcChannel.ForAddress(config.ServerUrl, new GrpcChannelOptions
{
    Credentials = Grpc.Core.ChannelCredentials.Insecure,
    MaxReceiveMessageSize = 10 * 1024 * 1024,
    MaxSendMessageSize = 10 * 1024 * 1024
});
```

**Attack Narrative:** The AEDS gRPC control plane -- which carries intent manifests, heartbeats, and channel subscriptions -- uses `ChannelCredentials.Insecure` unconditionally. This means:
1. All control plane traffic is sent in cleartext (no TLS)
2. An attacker on the network can read all control plane messages (manifest contents, client IDs, subscription patterns)
3. An attacker can inject forged manifests, hijack channels, or impersonate clients
4. The `AuthToken` sent via metadata header is transmitted in cleartext

This is the AEDS command-and-control channel. Compromising it allows an attacker to redirect data flows, inject malicious manifests, or perform denial-of-service.

**Impact:** Complete compromise of the AEDS control plane. All control signaling is unprotected.

**Remediation:** Use `ChannelCredentials.SecureSsl` when `config.ServerUrl` starts with `https://`. Add TLS certificate validation. Never send auth tokens over insecure channels.

---

### FINDING-08: FtpTransitStrategy Unconditional Certificate Bypass

**CVSS 3.1:** 7.4 (High)
**Vector:** `AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N`

**Location:** `Plugins/DataWarehouse.Plugins.UltimateDataTransit/Strategies/Direct/FtpTransitStrategy.cs` line 280

**Evidence:**
```csharp
if (protocol.Equals("ftps", StringComparison.OrdinalIgnoreCase))
{
    client.Config.EncryptionMode = FtpEncryptionMode.Explicit;
    client.Config.ValidateAnyCertificate = true;  // UNCONDITIONAL BYPASS
}
```

**Attack Narrative:** When the FTP transit strategy connects to an FTPS endpoint, it enables encryption but unconditionally accepts ANY server certificate. An attacker performing MITM on the FTP data transit path can present a rogue certificate and intercept all data being transferred. Unlike FtpStrategy (which has a configurable toggle), FtpTransitStrategy has NO configuration option to enable validation.

**Impact:** All FTPS data transit operations are vulnerable to MITM. Data in transit (potentially large dataset transfers) can be intercepted or modified.

**Remediation:** Add a configurable `_validateCertificate` flag defaulting to `true`, matching the pattern in `FtpStrategy.cs`.

---

### FINDING-09: AwsCloudHsmStrategy Certificate Validation Fallback

**CVSS 3.1:** 6.5 (Medium)
**Vector:** `AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N`

**Location:** `Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hsm/AwsCloudHsmStrategy.cs` lines 229-231

**Evidence:**
```csharp
// For development/testing, accept if no errors other than untrusted root
return errors == SslPolicyErrors.None ||
       errors == SslPolicyErrors.RemoteCertificateChainErrors;
```

**Attack Narrative:** When no `CustomerCaCertPath` is configured (the default), the HSM strategy accepts any certificate with chain errors -- including self-signed certificates from an attacker. Since this is a Hardware Security Module strategy (protecting the most sensitive cryptographic keys), a MITM attacker could intercept key management operations.

**Impact:** Cryptographic key management operations could be intercepted if the customer CA cert path is not configured. This is particularly dangerous because HSM operations involve the most sensitive secrets in the system.

**Remediation:** When `CustomerCaCertPath` is not configured, only accept `SslPolicyErrors.None` (strict validation). Log a warning that customer CA should be configured for production.

---

### FINDING-10: MQTT Control Plane Lacks Topic-Level Authorization

**CVSS 3.1:** 7.5 (High)
**Vector:** `AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N`

**Location:** `Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/MqttControlPlanePlugin.cs`

**Evidence:**
The MQTT control plane plugin subscribes to topics based on `clientId`:
```csharp
var personalTopic = $"aeds/client/{config.ClientId}/manifests";
await SubscribeToTopicAsync(personalTopic, MqttQualityOfServiceLevel.AtLeastOnce, ct);
```

There is **no server-side topic authorization** in the codebase. The MQTT client:
1. Uses username/password OR token auth (lines 107-118) -- authentication only
2. Any authenticated client can subscribe to ANY topic pattern
3. No ACL check on topic subscriptions
4. MQTT wildcard subscriptions (`#`, `+`) are not restricted

**Attack Narrative:** An authenticated MQTT client can:
1. Subscribe to `aeds/client/#` to receive ALL manifests for ALL clients
2. Subscribe to `aeds/channel/#` to monitor ALL channels
3. Subscribe to `aeds/heartbeat/#` to map all active clients and their status
4. Publish to `aeds/client/{victim-id}/manifests` to inject forged manifests to specific clients

The authentication is connection-level only (MQTT broker auth). There is no topic-level authorization code in the DataWarehouse codebase. Topic ACLs would need to be configured on the external MQTT broker, but this is not enforced or documented.

**Impact:** Any authenticated MQTT client can eavesdrop on all control plane traffic and inject forged manifests to any other client.

**Remediation:** Implement topic-level authorization: either client-side validation before processing messages from foreign topics, or server-side MQTT ACL configuration (documented and enforced). At minimum, validate that received manifests on personal topics match the expected sender.

---

### FINDING-11: WebSocket Control Plane Missing Origin Validation

**CVSS 3.1:** 6.1 (Medium)
**Vector:** `AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N`

**Location:** `Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/WebSocketControlPlanePlugin.cs` lines 108-117

**Evidence:**
```csharp
_webSocket = new ClientWebSocket();

if (!string.IsNullOrEmpty(config.AuthToken))
{
    _webSocket.Options.SetRequestHeader("Authorization", $"Bearer {config.AuthToken}");
}

var uri = new Uri(config.ServerUrl);
await _webSocket.ConnectAsync(uri, ct);
```

No `Origin` header validation is performed. No `AllowedOrigins` check exists in the WebSocket control plane.

**Attack Narrative:** This is a client-side WebSocket implementation (connects to server), so the traditional cross-origin WebSocket attack surface applies to the server side. However, the **server side of the WebSocket control plane** is not implemented in this codebase -- it is expected to be provided externally. The client-side code:
1. Does not validate the server's identity beyond TLS (which inherits OS defaults)
2. Sends the Bearer token to any URL configured in `config.ServerUrl`
3. Does not implement WebSocket subprotocol negotiation for authentication

For the server-side WebSocket endpoints (Dashboard, SignalR, SocketIO strategies), Origin validation depends on the framework defaults. No explicit Origin restriction was found in the AEDS control plane code.

**Impact:** If an attacker can manipulate the WebSocket server URL configuration, they can steal the Bearer auth token. Server-side WebSocket endpoints may accept cross-origin connections.

**Remediation:** Add Origin validation on any server-side WebSocket endpoints. Consider adding server certificate pinning for the control plane connection.

---

### FINDING-12: GraphQL Introspection Enabled by Default

**CVSS 3.1:** 5.3 (Medium)
**Vector:** `AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N`

**Location:**
- `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Connectors/GraphQlConnectorStrategy.cs` lines 88-94
- `Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/Protocol/GraphQlConnectionStrategy.cs` lines 56-58

**Evidence:**
```csharp
// GraphQlConnectorStrategy - test connection uses introspection
var introspectionQuery = new { query = "{ __schema { queryType { name } } }" };
var response = await _httpClient!.PostAsJsonAsync("", introspectionQuery, ct);

// GraphQlConnectionStrategy - connectivity test uses introspection
var introspectionQuery = @"{""query"":""{__schema { queryType { name } }}""}";
```

**Attack Narrative:** Both GraphQL strategies use introspection queries as connectivity tests, confirming that the connected GraphQL endpoints support introspection. While DataWarehouse is a client of external GraphQL services (not a server), the code demonstrates:
1. **No query depth limiting** -- GraphQL queries are forwarded without complexity analysis
2. **No query complexity limiting** -- Deeply nested queries could cause exponential processing on the target
3. **No persisted query enforcement** -- Any arbitrary query string is accepted
4. **Introspection assumed available** -- No option to disable introspection queries

For any GraphQL server endpoints DataWarehouse might expose (e.g., via PluginMarketplace, DataCatalog), there is no depth/complexity limiter found in the codebase.

**Impact:** Information disclosure via schema introspection. Potential DoS via deeply nested queries against DataWarehouse-hosted or proxied GraphQL endpoints.

**Remediation:** Add query depth and complexity limits for any GraphQL endpoints. Disable introspection in production. Implement persisted queries.

---

### FINDING-13: CoAP Client Has No DTLS Security

**CVSS 3.1:** 7.5 (High)
**Vector:** `AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N`

**Location:** `DataWarehouse.SDK/Edge/Protocols/CoApClient.cs` (entire file)

**Evidence:**
```csharp
// From file documentation (lines 28-29):
// DTLS security: Not implemented. UseDtls flag is ignored.

// Line 38: Uses raw UdpClient
private UdpClient? _udpClient;

// Line 70-71: No DTLS wrapping
_udpClient = new UdpClient();
```

Also, `CoApConnectionStrategy.cs` (line 46-47):
```csharp
var client = new UdpClient();
client.Connect(host, port);
```

**Attack Narrative:** CoAP is used for IoT/constrained device communication. The implementation:
1. Uses raw UDP with NO encryption (DTLS not implemented)
2. The `UseDtls` configuration flag is ignored (documented as stub)
3. No authentication on CoAP requests
4. Message IDs are sequential (`_nextMessageId++` from random start) -- predictable after observing one message
5. No replay protection beyond the 5-second timeout
6. CoAP observe tokens are stub-implemented

An attacker on the same network segment as IoT devices can:
- Read all CoAP messages (sensor data, commands) in cleartext
- Inject forged CoAP responses (spoofing sensor readings)
- Replay captured requests (re-triggering actuator commands)
- Predict message IDs after seeing one exchange

**Impact:** Complete compromise of IoT device communication. Sensor data exposed, actuator commands can be injected or replayed.

**Remediation:** Implement DTLS support for `coaps://` URIs. Do not ignore the `UseDtls` flag. Add message authentication (e.g., HMAC-based tokens). Randomize message IDs.

---

### FINDING-14: gRPC Storage Strategy Accepts 100MB Messages

**CVSS 3.1:** 3.1 (Low)
**Vector:** `AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L`

**Location:** `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Specialized/GrpcStorageStrategy.cs` lines 90-91

**Evidence:**
```csharp
_maxReceiveMessageSize = GetConfiguration("MaxReceiveMessageSize", 100 * 1024 * 1024); // 100MB
_maxSendMessageSize = GetConfiguration("MaxSendMessageSize", 100 * 1024 * 1024);       // 100MB
```

Compared to `GrpcControlPlanePlugin.cs` which limits to 10MB:
```csharp
MaxReceiveMessageSize = 10 * 1024 * 1024,
MaxSendMessageSize = 10 * 1024 * 1024
```

**Attack Narrative:** The default 100MB message size for gRPC storage can be exploited by a malicious client or MITM attacker to send oversized messages that consume server memory. While configurable, the default is generous.

**Impact:** Potential memory pressure from oversized gRPC messages. Mitigated by being configurable.

**Remediation:** Consider reducing default to 16MB (standard gRPC default is 4MB) and requiring explicit opt-in for larger sizes.

---

## Summary of All Findings

| ID | Title | CVSS | Severity | Protocol |
|----|-------|------|----------|----------|
| FINDING-06 | GrpcStorageStrategy unconditional TLS bypass | 9.1 | Critical | gRPC/TLS |
| FINDING-07 | GrpcControlPlanePlugin hardcoded insecure credentials | 8.7 | Critical | gRPC |
| FINDING-08 | FtpTransitStrategy unconditional cert bypass | 7.4 | High | FTPS |
| FINDING-09 | AwsCloudHsmStrategy cert validation fallback | 6.5 | Medium | HTTPS/TLS |
| FINDING-10 | MQTT control plane lacks topic authorization | 7.5 | High | MQTT |
| FINDING-11 | WebSocket control plane missing Origin validation | 6.1 | Medium | WebSocket |
| FINDING-12 | GraphQL introspection enabled, no depth limiting | 5.3 | Medium | GraphQL |
| FINDING-13 | CoAP client has no DTLS security | 7.5 | High | CoAP/UDP |
| FINDING-14 | gRPC Storage 100MB default message size | 3.1 | Low | gRPC |

---

## Protocol Security Summary

| Protocol | TLS | Auth | Injection Protection | DoS Protection | Overall |
|----------|-----|------|---------------------|----------------|---------|
| TCP P2P | Excellent (TLS 1.2+, mTLS, pinning) | mTLS | Length-prefixed framing | N/A | **Strong** |
| gRPC Storage | CRITICAL BYPASS | Token | N/A | 100MB limit | **Weak** |
| gRPC Control | INSECURE (cleartext) | Token (exposed) | N/A | 10MB limit | **Critical** |
| QUIC/HTTP3 | Good (configurable, default secure) | N/A | N/A | N/A | **Good** |
| MQTT | TLS only for mqtts:// | Password/token | No topic ACL | Unbounded channel | **Weak** |
| WebSocket | Inherits from URL scheme | Bearer token | No Origin check | 90s heartbeat timeout | **Fair** |
| REST/HTTP | Configurable (default secure) | Bearer/API key | Standard | N/A | **Good** |
| GraphQL | Via HTTP client | Bearer/API key | No depth/complexity limit | No rate limiting | **Fair** |
| CoAP | NONE (DTLS not implemented) | None | Sequential message IDs | 5s timeout only | **Critical** |
| FTP Storage | Configurable (default secure) | Password | N/A | N/A | **Good** |
| FTP Transit | BYPASS (unconditional) | Password | N/A | N/A | **Weak** |
| Database Protocol | Good (TLS 1.2+, CRL checking) | Protocol-specific | N/A | N/A | **Good** |

---

## Recommendations Priority

1. **Immediate (Critical):** Fix FINDING-06 (GrpcStorageStrategy) and FINDING-07 (GrpcControlPlane insecure) -- these represent complete compromise of gRPC data and control paths
2. **High Priority:** Fix FINDING-08 (FtpTransit), FINDING-10 (MQTT topic auth), FINDING-13 (CoAP DTLS)
3. **Medium Priority:** Fix FINDING-09 (HSM cert fallback), FINDING-11 (WebSocket origin), FINDING-12 (GraphQL depth)
4. **Low Priority:** FINDING-14 (gRPC message size default)
