---
phase: 47-penetration-testing
plan: 47-v4.5-04
title: "Data Path Exploitation & Cryptographic Attacks"
type: execute
wave: 2
depends_on: ["47-v4.5-01"]
files_modified: [".planning/phases/47-penetration-testing/47-v4.5-04-DATA-FINDINGS.md"]
autonomous: true
must_haves:
  truths:
    - "Storage path traversal tested on all storage strategy types"
    - "VDE block device corruption attacks tested for code execution and info disclosure"
    - "Key material extraction tested via memory dumps, logs, error messages, and crash dumps"
    - "Cryptographic implementation tested for padding oracle, downgrade, and mode confusion"
  artifacts:
    - path: ".planning/phases/47-penetration-testing/47-v4.5-04-DATA-FINDINGS.md"
      provides: "Data path and cryptographic vulnerability findings"
  key_links:
    - from: "data findings"
      to: "encryption plugin base"
      via: "all encryption flows through EncryptionPluginBase"
      pattern: "path.*traversal|key.*extract|crypto.*attack"
---

# Plan 47-v4.5-04: Data Path Exploitation & Cryptographic Attacks

<objective>
Attack the data storage and encryption pipeline. DataWarehouse stores data across 100+ storage backends with multiple encryption strategies. The goal: read data you shouldn't, corrupt data silently, or extract cryptographic key material.

Purpose: Data confidentiality and integrity are the core value proposition. An attacker who can read unauthorized data or extract keys has effectively compromised the entire system. These attacks target the heart of what DataWarehouse protects.
Output: Data path and cryptographic vulnerability report with key extraction PoCs.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/47-penetration-testing/47-CONTEXT.md
@.planning/phases/47-penetration-testing/47-v4.5-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Storage Path & Address Exploitation</name>
  <files>.planning/phases/47-penetration-testing/47-v4.5-04-DATA-FINDINGS.md</files>
  <action>
Attack storage addressing and path resolution to access unauthorized data.

**Attack 1: Storage Address Confusion**
- Read StorageStrategy, StorageRequest, UuidObjectAddress, PathStorageAdapter, PatternBasedClassifier
- StorageAddress variants (UUID, path, URI) can address different backends. Can an address designed for Backend A be manipulated to reach Backend B?
- Can a UUID address be crafted to collide with an existing object's address?
- Can path-based addresses escape their intended directory via `../` traversal?
- Check: How does PatternBasedClassifier route requests? Can the routing be confused?

**Attack 2: Path Traversal on Every Storage Type**
- For LocalFileStorage: Can `../../../etc/passwd` or `..\..\Windows\System32\config\SAM` escape the storage root?
- For cloud storage (S3, Azure Blob): Can bucket/container boundaries be crossed via path manipulation?
- For network storage (SMB, NFS, WebDAV): Can share boundaries be escaped?
- For each storage strategy: Search for path sanitization. Is it `Path.GetFullPath` + prefix check? Or just string replacement?
- Check: Are there TOCTOU (time-of-check-time-of-use) races between path validation and file access?

**Attack 3: VDE Block Device Corruption**
- The Virtual Disk Engine manages block devices with inode tables, journals, copy-on-write snapshots
- Can a crafted VDE image (malicious inode table entries) cause:
  - Buffer overflow when reading inodes?
  - Infinite loops in journal replay?
  - Code execution via crafted metadata?
- Check: InodeTable.cs, JournalEntry.cs, SnapshotManager.cs for input validation on disk-read data
- Attack: What happens if inode size field is negative? If block count is MAX_INT? If journal checksum is wrong but entry is replayed anyway?

**Attack 4: Data Exfiltration via Error Messages**
- Can crafted requests trigger error messages that leak:
  - Internal file paths?
  - Configuration values?
  - Other users' data fragments?
  - Stack traces with sensitive variable values?
- Search for: `catch` blocks that include `ex.Message` or `ex.ToString()` in user-visible responses
- Check: Are error messages sanitized for production mode?

**Attack 5: Symlink/Junction Attack (Filesystem)**
- If DataWarehouse follows symlinks, can an attacker:
  - Create a symlink pointing outside the storage root?
  - Replace a file with a symlink between validation and access (TOCTOU)?
  - Use NTFS junction points (Windows) to redirect writes?
- Check: Does the filesystem plugin resolve symlinks? Does it check after resolution?

**Attack 6: Race Condition in Multi-Step Writes**
- DataWarehouse uses atomic writes (rename pattern) for local storage. But:
  - Can a TOCTOU race between "write temp file" and "rename to final" be exploited?
  - If two concurrent writes target the same key, can data corruption occur?
  - Are temp files written with restricted permissions, or can another process read them?
  - Check: What happens during copy-on-write snapshot if the source changes mid-copy?
  </action>
  <verify>
Report must contain:
1. Path traversal test results for at least 5 storage types (local, S3, Azure, SMB, WebDAV)
2. VDE corruption attack analysis with specific validation gaps
3. Error message data leakage assessment
4. Symlink/junction attack feasibility for local filesystem
5. Race condition analysis for concurrent access patterns
  </verify>
  <done>All 6 storage path attack vectors tested. Path traversal defenses verified for each storage type. VDE input validation assessed. Race conditions analyzed.</done>
</task>

<task type="auto">
  <name>Task 2: Cryptographic Implementation Attacks</name>
  <files>.planning/phases/47-penetration-testing/47-v4.5-04-DATA-FINDINGS.md</files>
  <action>
Attack the cryptographic implementation, not the algorithms (algorithms are standard). Focus on implementation flaws that render strong crypto useless.

**Attack 7: Key Material Extraction**
- Trace every path where cryptographic keys exist in plaintext memory:
  - Key generation: Where is the key first materialized? How long does it stay in memory?
  - Key use: During encryption/decryption, is the key pinned in memory or can it be GC'd and survive in heap?
  - Key disposal: Search for `ZeroMemory`, `CryptographicOperations.ZeroMemory`, `Array.Clear` on key material
  - NativeKeyHandle: Read its implementation. Does it actually protect keys or just wrap byte[]?
- Check: v4.3 LOW-05 noted CLI key management doesn't wipe process output. Is this fixed?
- Attack: Can keys be extracted from:
  - /proc/[pid]/mem (Linux) or process memory dump (Windows)?
  - Core dump / crash dump files?
  - Swap file (is mlock used)?
  - Log files (search for logger.Log near key/password/secret variables)?

**Attack 8: Padding Oracle & CBC Attacks**
- If any encryption uses CBC mode: Is padding validated before decryption output is returned?
- Can different error messages distinguish "bad padding" from "bad MAC"? (Classic padding oracle)
- Check: All EncryptionStrategy implementations that use CBC
- Check: Is GCM (authenticated encryption) used consistently, or is there CBC fallback?

**Attack 9: IV/Nonce Reuse**
- For AES-GCM: Is the nonce guaranteed unique? (Nonce reuse = catastrophic for GCM)
- How are nonces generated? `RandomNumberGenerator.GetBytes`? Counter? Timestamp?
- For AES-CTR: Same question -- counter reuse breaks CTR completely
- Search for: Nonce/IV generation in all encryption strategies
- Attack: If encryption is performed concurrently, can two threads get the same nonce?

**Attack 10: Downgrade Attack**
- Can an attacker force the system to use a weaker encryption algorithm?
- If algorithm negotiation exists (e.g., between nodes), is the negotiation authenticated?
- Can config injection change `EncryptionAlgorithm` from AES-256-GCM to AES-128-ECB?
- Check: Is there a minimum algorithm strength enforcement?
- Check: v4.3 found ECB mode in ZigBee/SMPC -- is there a way to force ECB for other data?

**Attack 11: Key Rotation Vulnerabilities**
- During key rotation, is there a window where:
  - The old key is still accessible AND the new key is active? (Key coexistence window)
  - Data encrypted with the old key becomes unreadable? (Availability attack)
  - The rotation process can be interrupted, leaving the system in an inconsistent state?
- Check: UltimateKeyManagement key rotation logic for atomicity

**Attack 12: Envelope Encryption Unwrap**
- Envelope encryption uses DEK (Data Encryption Key) wrapped by KEK (Key Encryption Key)
- Can the KEK be extracted from the HSM or software key store?
- If the KEK is in software (not HSM), how is it protected?
- Can the DEK be unwrapped without proper authorization? (Check access control on unwrap operations)
- Attack: Is the wrapped DEK stored adjacent to the encrypted data? (If both stolen, easy offline attack)
  </action>
  <verify>
Report must contain:
1. Key material lifecycle diagram showing where keys exist in plaintext
2. Padding oracle assessment for all CBC implementations
3. Nonce uniqueness guarantee analysis for GCM/CTR
4. Downgrade attack feasibility assessment
5. Key rotation atomicity analysis
6. All findings with CVSS scores
  </verify>
  <done>All 6 cryptographic attack vectors tested. Key material exposure windows documented. Nonce/IV generation verified. Algorithm downgrade paths assessed. Envelope encryption wrapping analyzed.</done>
</task>

</tasks>

<verification>
- All 12 attack vectors tested with evidence
- Path traversal tested on 5+ storage types
- Key material lifecycle fully traced
- Cryptographic implementation flaws documented with PoCs
</verification>

<success_criteria>
- Clear determination: Can paths escape storage roots? (per storage type)
- Clear determination: Are keys wipeable from memory? (yes/no per key type)
- Clear determination: Is nonce reuse possible under concurrency? (yes/no with evidence)
- All findings include CVSS scores and attack narratives
</success_criteria>

<output>
After completion, create `.planning/phases/47-penetration-testing/47-v4.5-04-SUMMARY.md`
</output>
