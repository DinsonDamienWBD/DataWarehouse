# v4.5-04: Data Path Exploitation & Cryptographic Attacks - Findings

**Date:** 2026-02-19
**Tester:** Ethical Hacker (Claude Opus 4.6)
**Scope:** Storage paths, VDE, encryption pipeline, key management
**Methodology:** Static code analysis of storage, encryption, and VDE subsystems

---

## Executive Summary

12 attack vectors tested across data path and cryptographic domains. Found **4 genuine vulnerabilities** (1 HIGH, 2 MEDIUM, 1 LOW) plus **3 informational findings**. The most critical finding is a **path traversal vulnerability in the SMB storage strategy** (FINDING-D01) that lacks the `Path.GetFullPath` + prefix check present in other local strategies. The VDE symlink resolution has an **infinite loop DoS** potential (FINDING-D02). WebDAV strategy also lacks path traversal checks (FINDING-D03). PBKDF2 iteration count confirmed at 100K (below NIST 600K recommendation, reaffirming Wave 1 FINDING-09).

---

## FINDING-D01: SMB Storage Strategy Path Traversal (HIGH)

**CVSS 3.1:** 7.5 (AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)
**Status:** CONFIRMED VULNERABILITY
**File:** `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Network/SmbStrategy.cs` (line 769-781)

### Description

The SMB storage strategy's `GetFilePath` method constructs file paths by combining a base path with a user-supplied key, but **does not validate that the resulting path stays within the base directory**. Compare with the LocalFileStrategy (line 397-405), NvmeDiskStrategy (line 864-878), ScmStrategy (line 941-955), and NfsStrategy (line 935-950) which all use the pattern:

```csharp
// SECURE (LocalFile, NVMe, SCM, NFS):
var fullPath = Path.GetFullPath(Path.Combine(_basePath, relativePath));
var normalizedBasePath = Path.GetFullPath(_basePath);
if (!fullPath.StartsWith(normalizedBasePath, StringComparison.OrdinalIgnoreCase))
    throw new UnauthorizedAccessException("Path traversal attempt detected");
```

The SMB strategy does:

```csharp
// VULNERABLE (SmbStrategy line 769-781):
private string GetFilePath(string key)
{
    var relativePath = NormalizePath(key);
    if (string.IsNullOrEmpty(_basePath))
        return relativePath;
    return string.IsNullOrEmpty(relativePath)
        ? _basePath
        : Path.Combine(_basePath, relativePath).Replace('/', '\\');
}
```

No `Path.GetFullPath` canonicalization, no prefix check. A key like `../../etc/passwd` or `..\..\Windows\System32\config\SAM` would escape the base directory.

### Attack Narrative

An attacker with access to the storage API sends a StoreAsync/RetrieveAsync request with key `../../sensitive/data`. The SMB strategy combines this with `_basePath` using `Path.Combine`, which on Windows with UNC paths (\\server\share) would allow escaping to sibling shares or parent directories. The `ValidateKey` base method only checks for null chars, newlines, and length -- it does NOT check for `../` sequences.

### Evidence

- `SmbStrategy.GetFilePath` (line 769): No `GetFullPath` canonicalization
- `SmbStrategy.GetFilePath` (line 780): `Path.Combine(_basePath, relativePath)` without prefix validation
- `UltimateStorageStrategyBase.ValidateKey` (line 474): Only checks null/whitespace, control chars, length -- NOT traversal sequences
- All 4 other local strategies (LocalFile, NVMe, SCM, NFS) implement the traversal check correctly

### Impact

- Read arbitrary files on the SMB server/share accessible by the service account
- Potential write to arbitrary paths if StoreAsync is used
- Cross-share access on Windows file servers

### Remediation

Add `Path.GetFullPath` canonicalization and prefix check to `SmbStrategy.GetFilePath`, matching the pattern used by LocalFileStrategy.

---

## FINDING-D02: VDE NamespaceTree Symlink Infinite Loop DoS (MEDIUM)

**CVSS 3.1:** 5.3 (AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H)
**Status:** CONFIRMED VULNERABILITY
**File:** `DataWarehouse.SDK/VirtualDiskEngine/Metadata/NamespaceTree.cs` (line 74-87)

### Description

The `ResolvePathAsync` method follows symlinks recursively with **no depth limit**. If two symlinks point to each other (circular reference), the resolution will recurse infinitely until a `StackOverflowException` crashes the process.

```csharp
// NamespaceTree.cs line 74-87:
if (nextInode.Type == InodeType.SymLink)
{
    if (string.IsNullOrEmpty(nextInode.SymLinkTarget))
        return null;

    // Resolve symlink recursively -- NO DEPTH LIMIT
    nextInode = await ResolvePathAsync(nextInode.SymLinkTarget, ct);
    if (nextInode == null)
        return null;
}
```

### Attack Narrative

An attacker creates two symlinks:
1. `/data/link-a` -> `/data/link-b`
2. `/data/link-b` -> `/data/link-a`

Any operation that resolves either path (read, write, stat, list) triggers infinite recursion. Since `StackOverflowException` cannot be caught in .NET, this crashes the entire process.

### Evidence

- `NamespaceTree.SymLinkAsync` (line 338-380): No validation that target path doesn't create a cycle
- `NamespaceTree.ResolvePathAsync` (line 74-87): No recursion depth counter
- Linux/POSIX standard: `ELOOP` error returned after `SYMLOOP_MAX` (typically 40) hops

### Impact

- Process crash (denial of service)
- Any user who can create symlinks can crash the VDE
- Crash during inode table scan could leave VDE in inconsistent state

### Remediation

Add a `maxSymlinkDepth` parameter (default 40, matching POSIX SYMLOOP_MAX) to `ResolvePathAsync`. Return null or throw when limit is exceeded.

---

## FINDING-D03: WebDAV Storage Strategy Missing Path Traversal Protection (MEDIUM)

**CVSS 3.1:** 5.4 (AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)
**Status:** CONFIRMED VULNERABILITY
**File:** `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Network/WebDavStrategy.cs` (line 1086-1091)

### Description

The WebDAV strategy's `NormalizePath` method (line 1086) only trims slashes and replaces backslashes -- it does NOT check for `../` path traversal sequences. The `GetResourceUrl` method (line 1051) constructs URLs by concatenating the base URL with the normalized path, allowing traversal above the base path:

```csharp
// WebDavStrategy line 1086-1091:
private string NormalizePath(string path)
{
    if (string.IsNullOrEmpty(path))
        return string.Empty;
    return path.Trim('/').Replace('\\', '/');
}
```

A key like `../../../etc/passwd` passes through `NormalizePath` unchanged (after trim), then gets appended to `_baseUrl`, creating a URL that traverses above the intended WebDAV collection.

### Impact

- Read files outside the intended WebDAV collection path
- URL-encoded variants (`%2e%2e%2f`) may bypass naive string checks at the server level

### Remediation

Add `../` and `..` sequence detection (matching `PathStorageAdapter.NormalizePath` pattern) or resolve the path and verify it stays under the base URL.

---

## FINDING-D04: PBKDF2 Iteration Count Below NIST Recommendation (LOW)

**CVSS 3.1:** 3.7 (AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N)
**Status:** CONFIRMED (reaffirms Wave 1 FINDING-09)
**Files:** Multiple locations

### Description

Three locations use PBKDF2 with 100,000 iterations:

1. `DataWarehouse.Shared/Services/UserAuthenticationService.cs` (line 518, 530): Password hashing for user authentication
2. `Plugins/DataWarehouse.Plugins.AirGapBridge/Security/SecurityManager.cs` (line 807): Key derivation
3. `Plugins/DataWarehouse.Plugins.AirGapBridge/Management/SetupWizard.cs` (line 573): Setup key derivation
4. `DataWarehouse.Launcher/Integration/DataWarehouseHost.cs` (line 622): Password hashing

NIST SP 800-132 (2023 update) recommends minimum 600,000 iterations for PBKDF2-SHA256. OWASP recommends 600,000 for SHA256, 210,000 for SHA512.

### Impact

Offline brute-force attacks against password hashes are 6x faster than they should be with NIST-compliant iteration counts.

### Remediation

Increase iteration count to 600,000 for SHA256 or switch to Argon2id (which the AirGapBridge types already support as an option -- see `AirGapTypes.cs` line 404).

---

## Attack Vector Results

### Attack 1: Storage Address Confusion

**Result:** LOW RISK (by design)

The StorageAddress discriminated union (9 variants) uses strong typing via sealed records. Each variant has a distinct `Kind` enum discriminator. The `PatternBasedClassifier` routes based on `Kind` first, then heuristics.

**Confusion potential analyzed:**
- Can a `FilePathAddress` be confused with a `BlockDeviceAddress`? **No.** `BlockDeviceAddress.ToPath()` returns `DevicePath` but the `Kind` discriminator prevents misrouting.
- Can the implicit `string -> StorageAddress` conversion be abused? The heuristic at `StorageAddress.IsObjectKey` (line 226-231) checks `Path.IsPathRooted` and directory separator presence. A string like `../../../etc/passwd` would be classified as `FilePathAddress` (it contains `/`), NOT `ObjectKeyAddress`. This is correct behavior.
- Can a UUID address collide? UUIDs use `ObjectKeyAddress` which is opaque string -- collision requires guessing a 128-bit random value. **Not practical.**

**Verdict:** Address confusion is not exploitable due to strong typing. The implicit conversion heuristic is reasonable.

### Attack 2: Path Traversal on Storage Types

**Result:** 2 VULNERABILITIES FOUND (SMB, WebDAV), 4 types SECURE

| Storage Type | Path Traversal Check | Verdict |
|---|---|---|
| LocalFileStrategy | `Path.GetFullPath` + `StartsWith` check (line 397-407) | SECURE |
| NvmeDiskStrategy | `Path.GetFullPath` + `StartsWith` check (line 864-878) | SECURE |
| ScmStrategy | `Path.GetFullPath` + `StartsWith` check (line 941-955) | SECURE |
| NfsStrategy | `Path.GetFullPath` + `StartsWith` check (line 935-950) | SECURE |
| SmbStrategy | NO CHECK - only `Path.Combine` (line 769-781) | **VULNERABLE** (FINDING-D01) |
| WebDavStrategy | NO CHECK - only trim/replace (line 1086-1091) | **VULNERABLE** (FINDING-D03) |
| S3Strategy | Object key-based (no filesystem paths) | N/A (cloud-native key validation) |
| AzureBlobStrategy | Object key-based (no filesystem paths) | N/A |
| PathStorageAdapter | Explicit `../` check (line 144-149) + normalization | SECURE |

### Attack 3: VDE Block Device Corruption

**Result:** PARTIALLY MITIGATED

**Journal checksum validation:** The `JournalEntry.Deserialize` method (line 173-265) validates XxHash64 checksums. Entries with bad checksums return `false` and are rejected. **This is correct.**

**Negative data length attack:** `Deserialize` (line 209) validates `beforeLen < 0`, `afterLen < 0`, and `totalDataLength < 0`. **Mitigated.**

**Integer overflow in stackalloc:** `Serialize` (line 134) uses `stackalloc` with `offset + beforeLen + afterLen`. If `beforeLen` and `afterLen` are both `int.MaxValue`, this could overflow to a small value causing stack corruption. However, the `GetSerializedSize()` check at line 105 would catch buffer-too-small first. **Low risk but worth noting.**

**Inode table boundary check:** `ReadInodeAsync` (line 496-498) checks `blockNumber >= _inodeTableStartBlock + _inodeTableBlockCount` and returns null for out-of-bounds. **Secure.**

**InodeTable catch-all:** `ReadInodeAsync` (line 507-509) has a bare `catch` block that silently returns null. This could mask corruption detection. An attacker who corrupts inode data would get a silent failure rather than an alert. **Informational.**

### Attack 4: Error Message Information Disclosure

**Result:** INFORMATIONAL (systemic pattern)

Extensive use of `ex.Message` in error responses across plugins. Key examples:

- **AppPlatformPlugin**: 30+ endpoints return `MessageResponse.Error($"...failed: {ex.Message}")`. While `ex.Message` is less dangerous than `ex.ToString()`, exception messages can contain internal paths, connection strings, SQL errors, and stack frame information depending on the underlying exception type.
- **AdaptiveTransportPlugin**: Returns `ex.Message` in transport error metrics.
- **EncryptionStrategyBase** (line 521): Error message includes expected vs actual key size: `$"Invalid key size. Expected {CipherInfo.KeySizeBits / 8} bytes, got {key.Length} bytes"` -- this leaks the encryption algorithm's expected key size. While not secret per se, it aids cryptanalysis.

**No key material found in error messages.** The exception handling does not log or expose actual key bytes, passwords, or nonces.

### Attack 5: Symlink/Junction Attack

**Result:** VULNERABILITY FOUND (FINDING-D02)

**VDE NamespaceTree:** Symlink resolution follows links recursively with no depth limit (line 74-87). Circular symlinks cause infinite recursion -> `StackOverflowException` -> process crash.

**Symlink target validation:** `SymLinkAsync` (line 338-380) does NOT validate that the target path is within the VDE filesystem. A symlink could target any absolute path, potentially including paths that would be resolved through the host filesystem if the VDE is mounted via FUSE. However, since the VDE has its own inode space, external paths would simply not resolve (returning null).

**LocalFileStrategy:** Uses `Path.GetFullPath` + prefix check, which resolves symlinks at the OS level. A symlink at `{basePath}/link -> /etc/passwd` would resolve via `GetFullPath` to `/etc/passwd`, fail the `StartsWith` check, and be rejected. **SECURE against symlink escape.**

### Attack 6: Race Conditions

**Result:** LOW RISK (by design)

**InodeTable locking:** Uses per-inode `SemaphoreSlim` locks (line 779-782) via `ConcurrentDictionary`. Write operations (UpdateInodeAsync, AddDirectoryEntryAsync, RemoveDirectoryEntryAsync) all acquire the inode lock. **Read-Modify-Write is atomic within an inode.**

**Cross-inode races:** Renaming across directories acquires locks for both old and new parent inodes, but NOT in a consistent order. Two concurrent renames in opposite directions could deadlock. However, since `SemaphoreSlim.WaitAsync` is used (not `lock`), cancellation tokens provide a deadlock escape.

**Snapshot Manager:** `CreateSnapshotAsync` (line 99-141) wraps the entire operation in a WAL transaction. **Atomic.**

**AllocateInodeAsync:** Uses `_tableMetadataLock` for `_nextInodeNumber` increment. **Thread-safe.**

### Attack 7: Key Material Extraction

**Result:** WELL-PROTECTED

**NativeKeyHandle** (`DataWarehouse.SDK/Security/NativeKeyHandle.cs`): Uses `NativeMemory.AllocZeroed` (unmanaged allocation outside GC heap), `NativeMemory.Clear` on dispose, finalizer as safety net. **Industry best practice.** Key material is NOT subject to GC compaction/copying.

**EncryptionPluginBase envelope encryption** (line 257-313): `CryptographicOperations.ZeroMemory(dek)` in `finally` block after use. **Correct.**

**EncryptionPluginBase decryption** (line 324-372): `CryptographicOperations.ZeroMemory(dek)` in `finally` block. `ArrayPool` returned with `clearArray: true`. **Correct.**

**Key generation** (EncryptionStrategyBase line 437): Uses `RandomNumberGenerator.GetBytes` (CSPRNG). **Correct.**

**Remaining exposure:** The `EncryptAsync`/`DecryptAsync` methods on `EncryptionStrategyBase` (line 508-592) accept `byte[] key` as a parameter on the managed heap. While key stores can return `NativeKeyHandle`, the `IEncryptionStrategy` interface itself deals in `byte[]` keys. These managed arrays are subject to GC compaction until explicitly zeroed by the caller. The **caller** is responsible for zeroing after use, but the interface doesn't enforce this.

### Attack 8: Padding Oracle / CBC Attacks

**Result:** NOT APPLICABLE

No CBC-mode encryption was found in the standard encryption pipeline. All AEAD strategies use authenticated encryption (GCM, Poly1305, ASCON, AEGIS). The ECB mode usage found is **intentional and correct** -- used as building blocks for:
- XTS mode (disk encryption) - ECB of AES used for tweak computation
- Adiantum mode - ECB for hash function
- FPE (Format-Preserving Encryption) - ECB required by NIST SP 800-38G
- Chaff padding - ECB for CTR mode construction

All ECB uses are properly annotated with `// SECURITY NOTE: ECB mode is intentionally used here as a building block for...`.

**FIPS validator** correctly rejects standalone ECB: `FipsComplianceValidator.IsFipsApprovedMode` returns `false` for algorithm names containing "ECB" (line 1297-1304).

### Attack 9: IV/Nonce Reuse

**Result:** SECURE (by design)

All nonce generation uses `RandomNumberGenerator.GetBytes` (CSPRNG) or BouncyCastle `SecureRandom`. No counter-based or timestamp-based nonce generation was found.

For AES-GCM with 12-byte (96-bit) random nonces, the birthday bound collision probability is:
- After 2^32 messages: ~2^-33 (~1 in 8.6 billion)
- After 2^48 messages: ~1 (catastrophic)

With random nonces, this is acceptable for normal workloads but would be a concern for extremely high-volume encryption (>4 billion operations per key). The `EncryptionStatistics.EncryptionCount` tracking provides visibility into this.

**No thread-local nonce state** was found -- each encryption generates an independent random nonce via CSPRNG. Two concurrent threads cannot get the same nonce (barring CSPRNG failure).

### Attack 10: Encryption Downgrade

**Result:** LOW RISK

The `EncryptionStrategyRegistry` (line 1034-1161) allows setting the default strategy via `SetDefaultStrategy`. The `EncryptedPayload` format (line 856-997) includes `AlgorithmId` in the header, so decryption uses whatever algorithm was specified during encryption.

**Downgrade scenarios:**
- **Config injection:** If an attacker can modify the strategy registry (e.g., via config file or message bus), they could set `_defaultStrategyId` to a weak algorithm. However, this requires already-compromised access.
- **Payload manipulation:** An attacker could modify the `AlgorithmId` field in an `EncryptedPayload`, but the decryption would then fail (wrong algorithm + wrong key/nonce format).
- **ECB availability:** ECB is available as a building block but is NOT registered as a standalone encryption strategy.
- **FipsComplianceValidator:** Provides runtime validation against weak algorithms. Not enforced automatically but available for deployment-time checks.

**No minimum algorithm strength enforcement exists** at the registry level. The registry will accept and serve any registered strategy, including weak ones.

### Attack 11: Key Rotation Vulnerabilities

**Result:** INFORMATIONAL

The `KeyRotationScheduler` (line 181-201) calls `strategy.CreateKeyAsync(keyId, systemContext)` for each key to rotate. This creates a **new key version** rather than replacing the old key. The old key remains accessible for decrypting existing data.

**Window analysis:**
- Old key + new key coexist: **Yes, by design** (required for decrypting existing data)
- Interruption during rotation: If `PerformRotationAsync` fails mid-way through the key list, some keys are rotated and others are not. The retry logic (line 138-178) will retry the entire batch.
- No atomicity across multiple keys: Keys are rotated sequentially, not in a transaction. A crash between key 3 and key 4 of a batch leaves a partial rotation. However, this is not a security vulnerability -- it's an availability concern.

### Attack 12: Envelope Encryption Unwrap

**Result:** SECURE (when HSM-backed)

Envelope encryption in `EncryptionPluginBase` (line 257-372):
- DEK is generated via CSPRNG, used for data encryption, then zeroed
- DEK is wrapped by KEK via `IEnvelopeKeyStore.WrapKeyAsync`
- Wrapped DEK is stored in the `EnvelopeHeader` alongside ciphertext

**If KEK is HSM-backed:** Unwrap requires HSM access + proper ACL. **Secure.**
**If KEK is software-backed:** KEK protection depends on the key store implementation. The SDK interface (`IEnvelopeKeyStore`) doesn't mandate HSM.

**Wrapped DEK stored adjacent to ciphertext:** Yes (in `EnvelopeHeader`). If both the wrapped DEK and ciphertext are stolen, the attacker still needs the KEK to unwrap. This is standard envelope encryption design.

---

## Summary Table

| ID | Finding | CVSS | Severity | Status |
|---|---|---|---|---|
| D01 | SMB Strategy Path Traversal | 7.5 | HIGH | Confirmed |
| D02 | VDE Symlink Infinite Loop DoS | 5.3 | MEDIUM | Confirmed |
| D03 | WebDAV Strategy Missing Path Traversal Check | 5.4 | MEDIUM | Confirmed |
| D04 | PBKDF2 at 100K iterations (below NIST 600K) | 3.7 | LOW | Confirmed (reaffirms FINDING-09) |

### Positive Findings (Defenses That Work)

1. **Path traversal protection on 4/6 local strategies**: LocalFile, NVMe, SCM, NFS all implement correct `GetFullPath` + prefix check
2. **PathStorageAdapter**: Explicitly rejects `../` sequences in `NormalizePath`
3. **NativeKeyHandle**: Industry-leading key material protection (unmanaged memory, secure wipe, finalizer safety net)
4. **Envelope encryption DEK lifecycle**: Proper CSPRNG generation, ZeroMemory in finally blocks
5. **Journal entry checksums**: XxHash64 with proper validation prevents corrupt journal replay
6. **Nonce generation**: All CSPRNG-based, no counter reuse risk
7. **No padding oracle surface**: All encryption uses AEAD modes
8. **Strong typing in StorageAddress**: Prevents address confusion attacks

---

## Methodology Notes

- All findings are based on static code analysis of the source code
- No runtime exploitation was performed
- Cloud storage strategies (S3, Azure, GCS) use opaque object keys -- path traversal is not applicable (server-side validation by cloud provider)
- The SMB and WebDAV strategies were identified as vulnerable because they construct host filesystem paths or URLs from user-supplied keys without traversal checks
