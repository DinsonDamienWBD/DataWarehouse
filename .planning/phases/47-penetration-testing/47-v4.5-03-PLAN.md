---
phase: 47-penetration-testing
plan: 47-v4.5-03
title: "Message Bus Poisoning & Plugin Isolation Escape"
type: execute
wave: 2
depends_on: ["47-v4.5-01"]
files_modified: [".planning/phases/47-penetration-testing/47-v4.5-03-BUS-FINDINGS.md"]
autonomous: true
must_haves:
  truths:
    - "Message bus tested for injection, replay, spoofing, and flooding attacks"
    - "Plugin isolation boundaries tested for escape via reflection, assembly loading, and shared state"
    - "Message bus topic authorization tested (can plugin X publish to plugin Y's topics?)"
    - "Race conditions in message handling tested for TOCTOU vulnerabilities"
  artifacts:
    - path: ".planning/phases/47-penetration-testing/47-v4.5-03-BUS-FINDINGS.md"
      provides: "Message bus and plugin isolation vulnerability findings"
  key_links:
    - from: "bus findings"
      to: "plugin catalog"
      via: "63 plugins all communicate via message bus"
      pattern: "bus.*poison|plugin.*escape|topic.*inject"
---

# Plan 47-v4.5-03: Message Bus Poisoning & Plugin Isolation Escape

<objective>
Attack the internal message bus and plugin isolation system. The DataWarehouse has 63 plugins communicating via a shared message bus with ~100+ topics. This is a MASSIVE internal attack surface. A single poisoned message or escaped plugin can compromise the entire system.

Purpose: The message bus is the nervous system of DataWarehouse. If an attacker can inject, replay, or spoof messages, they can make any plugin do anything. If a plugin can escape isolation, the entire trust model collapses. These are the attacks automated scanners NEVER find.
Output: Message bus and plugin isolation vulnerability report.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/47-penetration-testing/47-CONTEXT.md
@.planning/phases/47-penetration-testing/47-v4.5-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Message Bus Attack Surface</name>
  <files>.planning/phases/47-penetration-testing/47-v4.5-03-BUS-FINDINGS.md</files>
  <action>
Attack the message bus as if you're a compromised plugin trying to take over the system.

**Attack 1: Message Injection / Topic Spoofing**
- Read IMessageBus interface and InMemoryFederatedMessageBus implementation
- Can ANY plugin publish to ANY topic? Or is there topic-level authorization?
- Can a storage plugin publish to `security.*` topics? Can it publish to `kernel.*` topics?
- Search for: Does AccessEnforcementInterceptor validate the PUBLISHER's identity, or just the message content?
- Craft attack: Plugin "UltimateStorage" publishes `security.access.grant {user: "attacker", role: "admin"}` -- is this possible?
- Check: Is there message signing? Can messages be tampered with in transit (in-memory bus probably not, but federated bus?)

**Attack 2: Message Replay**
- Are messages timestamped and nonce-protected?
- Can a captured message be replayed to trigger the same operation again?
- Attack scenario: Capture a `data.write` message, replay it 1000 times = data corruption / storage exhaustion
- Check: Is there idempotency enforcement on message handlers?

**Attack 3: Message Bus Flooding (DoS)**
- Is there rate limiting on message publishing?
- Can a malicious plugin flood the bus with millions of messages, starving other plugins?
- Can a plugin subscribe to a wildcard topic and intercept ALL messages?
- Check: What happens when the bus is full? Does it drop messages silently? Block? Crash?

**Attack 4: Federated Message Bus Attacks**
- FederatedMessageBusBase extends the bus across nodes. How are remote messages authenticated?
- Can a rogue node inject messages into the federated bus?
- Is there message origin verification (which node sent this)?
- Check: InMemoryFederatedMessageBus -- does it validate message origin on receive?

**Attack 5: Topic Pattern Injection**
- If topics use patterns/wildcards, can a malicious topic string inject:
  - `storage.write.#` (subscribe to all storage writes)
  - `..` or `../` path traversal in topic names
  - Unicode/null bytes in topic names to bypass filters
- Check: How are topic strings validated? Is there a topic whitelist or schema?

**Attack 6: Dead Letter / Error Queue Exploitation**
- If failed messages go to a dead letter queue, can an attacker:
  - Read the dead letter queue to see failed sensitive messages?
  - Cause messages to fail strategically to extract data via error queues?
  - Poison the error handler itself?
  </action>
  <verify>
Report must contain:
1. Message bus architecture analysis (how topics work, how auth works)
2. For each of 6 attacks: VULNERABLE, PARTIALLY VULNERABLE, or RESISTANT
3. Any finding must include: attack narrative, code evidence, CVSS score
4. Topic authorization matrix: which plugins can publish/subscribe to which topics
  </verify>
  <done>All 6 message bus attack vectors tested. Topic authorization gaps identified. Federated bus authentication verified. DoS resilience assessed.</done>
</task>

<task type="auto">
  <name>Task 2: Plugin Isolation Escape Attacks</name>
  <files>.planning/phases/47-penetration-testing/47-v4.5-03-BUS-FINDINGS.md</files>
  <action>
Attempt to break out of plugin isolation. Plugins are supposed to reference ONLY the SDK, but are they truly sandboxed?

**Attack 7: Reflection-Based Escape**
- Can a plugin use reflection to:
  - Access private fields/methods of the kernel?
  - Modify the IServiceProvider to inject malicious services?
  - Access other plugins' internal state?
- Search: Is `System.Reflection` restricted in any way? Are there any `ReflectionPermission` constraints?
- Check: Do plugins run in the same AppDomain as the kernel? (If yes, reflection escape is trivial)

**Attack 8: Assembly Loading Attack**
- DataWarehouseKernel.cs and PluginMarketplacePlugin.cs use Assembly.Load
- Can a plugin trigger loading of a malicious assembly?
- Is there assembly integrity verification (signatures, hashes)?
- v4.3 LOW-03 noted "Plugin assembly integrity not verified" -- is this still true?
- Attack: Place a malicious DLL named `System.Security.dll` in the plugin directory -- does it get loaded?
- Check: Are assembly loading paths restricted? Can a plugin influence the assembly resolution path?

**Attack 9: Shared State Exploitation**
- Do plugins share any mutable state? (static fields, singletons, shared dictionaries)
- Can a plugin modify shared state that another plugin trusts?
- Search for: `static` mutable fields in SDK base classes that plugins inherit
- Check: ConcurrentDictionary or shared caches -- can one plugin poison another plugin's cache?

**Attack 10: Resource Exhaustion by Plugin**
- Can a malicious plugin:
  - Allocate unbounded memory until the host process OOMs?
  - Spawn unlimited threads?
  - Open unlimited file handles?
  - Consume all available disk space?
- Check: Are there resource limits (memory, CPU, disk) per plugin?
- Check: Plugin lifecycle -- can a plugin refuse to stop? What happens on Dispose timeout?

**Attack 11: Plugin Marketplace Supply Chain**
- PluginMarketplacePlugin enables downloading and installing plugins
- Is the download channel authenticated (TLS with cert validation)?
- Are downloaded plugins signed? Hash-verified?
- Can a MITM inject a malicious plugin during download?
- Can a plugin name collision (e.g., "UltimateStorage" clone) hijack the real plugin?
- Check: How does the marketplace resolve plugin identity? Name only? Publisher signature?

**Attack 12: Type Confusion via Plugin Interface**
- Plugins implement SDK interfaces. Can a malicious plugin:
  - Return unexpected types from interface methods?
  - Throw unexpected exceptions to crash the kernel?
  - Return objects that implement IDisposable with malicious Dispose?
  - Abuse generic type parameters to cause type confusion?
- Check: Does the kernel validate return types from plugin method calls?
  </action>
  <verify>
Report must contain:
1. Plugin isolation model analysis (what boundaries exist, what doesn't)
2. For each of 6 escape attacks: VULNERABLE, PARTIALLY VULNERABLE, or RESISTANT
3. Assembly loading security assessment with specific file path analysis
4. Resource exhaustion risk matrix
  </verify>
  <done>All 6 plugin isolation escape vectors tested. Assembly loading attack surface documented. Shared state exploitation potential assessed. Plugin marketplace supply chain reviewed.</done>
</task>

</tasks>

<verification>
- All 12 attack vectors tested with evidence
- Message bus authorization model fully analyzed
- Plugin isolation boundaries comprehensively tested
- Supply chain risks documented
</verification>

<success_criteria>
- Clear determination: Can a plugin publish to any topic? (yes/no with evidence)
- Clear determination: Can a plugin escape isolation via reflection? (yes/no with evidence)
- Clear determination: Are plugin assemblies integrity-verified? (yes/no with evidence)
- All findings include CVSS scores and attack narratives
</success_criteria>

<output>
After completion, create `.planning/phases/47-penetration-testing/47-v4.5-03-SUMMARY.md`
</output>
