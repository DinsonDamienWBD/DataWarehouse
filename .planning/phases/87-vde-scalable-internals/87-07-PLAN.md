---
phase: 87-vde-scalable-internals
plan: 07
type: execute
wave: 3
depends_on: ["87-06"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccGarbageCollector.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccIsolationEnforcer.cs
autonomous: true

must_haves:
  truths:
    - "Background vacuum removes versions older than oldest active snapshot plus retention window"
    - "GC is incremental (processes N versions per cycle) and concurrent with normal operations"
    - "Serializable isolation uses predicate locks to detect write-write conflicts"
    - "All three isolation levels (ReadCommitted, Snapshot, Serializable) are configurable per VDE and per query"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccGarbageCollector.cs"
      provides: "Background vacuum for old MVCC versions"
      contains: "class MvccGarbageCollector"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccIsolationEnforcer.cs"
      provides: "Isolation level enforcement including predicate locks for Serializable"
      contains: "class MvccIsolationEnforcer"
  key_links:
    - from: "MvccGarbageCollector.cs"
      to: "MvccManager"
      via: "reads OldestActiveSnapshot to determine safe-to-vacuum threshold"
      pattern: "OldestActiveSnapshot"
    - from: "MvccIsolationEnforcer.cs"
      to: "MvccTransaction"
      via: "validates read/write sets for conflict detection"
      pattern: "MvccTransaction"
---

<objective>
Implement MVCC garbage collection (VOPT-13) and isolation level enforcement (VOPT-14). GC reclaims space from old versions no longer needed by any active snapshot. Isolation enforcement adds predicate locks for Serializable mode.

Purpose: Prevents unbounded MVCC region growth and ensures correct transaction isolation semantics.
Output: Two files in `DataWarehouse.SDK/VirtualDiskEngine/Mvcc/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/87-vde-scalable-internals/87-06-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: MvccGarbageCollector</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccGarbageCollector.cs
  </files>
  <action>
Create `MvccGarbageCollector` class with `[SdkCompatibility("6.0.0")]`:
- Constructor: `MvccManager mvccManager, MvccVersionStore versionStore, TimeSpan retentionWindow = default` (default 5 minutes retention after last snapshot reference)
- `int MaxVersionsPerCycle { get; set; } = 1000` -- incremental: process at most N versions per GC cycle
- `Task<GcResult> RunCycleAsync(CancellationToken ct)`:
  - Compute vacuum threshold: `min(mvccManager.OldestActiveSnapshot, currentSequence) - retentionWindowSequences`
  - Scan version chains starting from known head blocks
  - For each version with TransactionId < threshold:
    1. Unlink from version chain (update previous version's NextVersionBlock)
    2. Free the version block back to MVCC region free list
    3. If inode's VersionChainHead pointed to this version, update it
  - Stop after MaxVersionsPerCycle versions processed
  - Return `GcResult(int VersionsReclaimed, long BlocksFreed, bool MoreWorkRemaining)`
- `GcResult` readonly struct: `int VersionsReclaimed, long BlocksFreed, bool MoreWorkRemaining`
- `Task RunContinuousAsync(TimeSpan interval, CancellationToken ct)`:
  - Background loop: run GC cycle, sleep interval, repeat until cancelled
  - Uses `Task.Delay` for interval, respects cancellation
- Thread-safe: GC acquires write locks only on individual version chain entries, not globally
- Handles concurrent modifications: if a version chain is modified during GC, skip and retry next cycle
- `long TotalVersionsReclaimed` / `long TotalBlocksFreed` -- cumulative stats
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>MvccGarbageCollector incrementally vacuums old versions older than oldest active snapshot plus retention window, freeing MVCC region blocks.</done>
</task>

<task type="auto">
  <name>Task 2: MvccIsolationEnforcer</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccIsolationEnforcer.cs
  </files>
  <action>
Create `MvccIsolationEnforcer` class with `[SdkCompatibility("6.0.0")]`:
- Enforces isolation level semantics for each transaction:

ReadCommitted enforcement:
- `Task<byte[]?> ReadForCommittedAsync(MvccTransaction tx, long inodeNumber, MvccVersionStore store, IBlockDevice device, int blockSize, CancellationToken ct)`:
  - Always reads the latest committed version (no snapshot constraint)
  - Each read gets a fresh snapshot of committed data

SnapshotIsolation enforcement:
- `Task<byte[]?> ReadForSnapshotAsync(MvccTransaction tx, long inodeNumber, MvccVersionStore store, IBlockDevice device, int blockSize, CancellationToken ct)`:
  - Reads the version committed at or before tx.SnapshotSequence
  - Walks version chain to find correct version
  - Write-write conflict detection: if two concurrent snapshot txns write the same inode, second to commit aborts

Serializable enforcement:
- `Task<byte[]?> ReadForSerializableAsync(MvccTransaction tx, long inodeNumber, MvccVersionStore store, IBlockDevice device, int blockSize, CancellationToken ct)`:
  - Same as snapshot reads, plus predicate lock recording
- `PredicateLockSet` inner class: tracks range predicates (inode number ranges) acquired during reads
- `Task ValidateSerializableAsync(MvccTransaction tx, CancellationToken ct)`:
  - At commit time, checks if any inode in tx.ReadSet was modified by any transaction that committed after tx.SnapshotSequence
  - If conflict detected: throws `MvccSerializationException` (tx must abort and retry)
- `ConcurrentDictionary<long, HashSet<(long Start, long End)>> _predicateLocks` for range lock tracking

Common:
- `Task ValidateCommitAsync(MvccTransaction tx, CancellationToken ct)` -- dispatches to correct validation based on tx.IsolationLevel
- `[SdkCompatibility("6.0.0")]`
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>MvccIsolationEnforcer provides ReadCommitted, SnapshotIsolation, and Serializable enforcement with predicate locks and conflict detection.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- GC correctly identifies versions safe to reclaim
- Serializable isolation detects write-write conflicts
</verification>

<success_criteria>
- VOPT-13 satisfied: Background vacuum with incremental processing and configurable retention
- VOPT-14 satisfied: All three isolation levels implemented and configurable per VDE/query
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-07-SUMMARY.md`
</output>
