---
phase: 87-vde-scalable-internals
plan: 13
type: execute
wave: 5
depends_on: ["87-04", "87-12"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Integrity/HierarchicalChecksumTree.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Integrity/MerkleIntegrityVerifier.cs
autonomous: true

must_haves:
  truths:
    - "Per-block XxHash64 provides fast integrity checks"
    - "Per-extent CRC32C provides medium-strength integrity"
    - "Per-object Merkle root provides strong integrity with binary-search corruption localization"
    - "Merkle tree stored in Integrity Tree region enables pinpointing corrupt blocks"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Integrity/HierarchicalChecksumTree.cs"
      provides: "3-level checksum hierarchy (block, extent, Merkle root)"
      contains: "class HierarchicalChecksumTree"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Integrity/MerkleIntegrityVerifier.cs"
      provides: "Merkle tree verification with binary-search corruption localization"
      contains: "class MerkleIntegrityVerifier"
  key_links:
    - from: "HierarchicalChecksumTree.cs"
      to: "UniversalBlockTrailer"
      via: "per-block XxHash64 stored in block trailers"
      pattern: "UniversalBlockTrailer"
    - from: "MerkleIntegrityVerifier.cs"
      to: "IntegrityTreeRegion"
      via: "Merkle tree stored in integrity tree region"
      pattern: "IntegrityTreeRegion"
---

<objective>
Implement hierarchical checksums (VOPT-25) with three integrity tiers: per-block XxHash64 (fast, in block trailer), per-extent CRC32C (medium), and per-object Merkle root (strong). The Merkle tree enables binary-search localization of corrupt blocks.

Purpose: Layered integrity checking allows fast validation for routine reads and deep verification for scrubs and repair. Merkle trees pinpoint exact corrupt blocks without reading all data.
Output: Two files in `DataWarehouse.SDK/VirtualDiskEngine/Integrity/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@DataWarehouse.SDK/VirtualDiskEngine/Integrity/BlockChecksummer.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
@DataWarehouse.SDK/VirtualDiskEngine/Regions/IntegrityTreeRegion.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: HierarchicalChecksumTree</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Integrity/HierarchicalChecksumTree.cs
  </files>
  <action>
Create `HierarchicalChecksumTree` class with `[SdkCompatibility("6.0.0")]`:
- Three checksum levels:

Level 1 -- Per-block XxHash64 (fast, already in UniversalBlockTrailer):
- `ulong ComputeBlockChecksum(ReadOnlySpan<byte> blockData, int blockSize)` -- XxHash64 of block payload (excluding trailer)
- `bool VerifyBlockChecksum(ReadOnlySpan<byte> blockData, int blockSize)` -- compares computed vs stored trailer checksum
- Leverages existing `UniversalBlockTrailer.Verify()`

Level 2 -- Per-extent CRC32C (medium strength):
- `uint ComputeExtentChecksum(IBlockDevice device, InodeExtent extent, int blockSize, CancellationToken ct)` -- CRC32C across all blocks in extent using `System.IO.Hashing.Crc32`
- `ExtentChecksumRecord` struct: `long ExtentStartBlock, int ExtentBlockCount, uint Crc32c`
- Stored as metadata alongside zone maps in extent headers

Level 3 -- Per-object Merkle root (strong):
- `byte[] ComputeMerkleRoot(IBlockDevice device, InodeExtent[] extents, int blockSize, CancellationToken ct)` -- builds Merkle tree from block checksums
- Merkle tree construction: leaf = XxHash64 of each block, internal = SHA256(left || right), root = 32-byte hash
- Tree stored in Integrity Tree region (one tree per object with >1 block)
- `MerkleNode` struct: `byte[] Hash (32 bytes), long LeftChild, long RightChild`

Verification:
- `ChecksumVerificationResult VerifyObject(IBlockDevice device, long inodeNumber, InodeV2 inode, int blockSize, CancellationToken ct)`:
  - Level 1: verify each block's trailer checksum
  - Level 2: verify each extent's CRC32C
  - Level 3: verify Merkle root matches stored root
  - Returns which level(s) passed/failed
- `ChecksumVerificationResult` class: `bool Level1Ok, bool Level2Ok, bool Level3Ok, List<long> CorruptBlocks`
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>HierarchicalChecksumTree provides 3-tier integrity: per-block XxHash64, per-extent CRC32C, per-object Merkle root.</done>
</task>

<task type="auto">
  <name>Task 2: MerkleIntegrityVerifier with binary-search corruption localization</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Integrity/MerkleIntegrityVerifier.cs
  </files>
  <action>
Create `MerkleIntegrityVerifier` class with `[SdkCompatibility("6.0.0")]`:
- Constructor: `IBlockDevice device, long integrityTreeRegionStart, int blockSize`

Merkle tree persistence:
- `Task StoreMerkleTreeAsync(long objectInodeNumber, byte[][] blockChecksums, CancellationToken ct)`:
  - Builds complete Merkle tree from block checksums
  - Serializes tree nodes to Integrity Tree region blocks
  - Tree layout: level-order (BFS) serialization for cache-friendly reads
  - Each node: 32 bytes (hash) + 8 bytes (left ptr) + 8 bytes (right ptr) = 48 bytes
  - For 4KB blocks: ~85 nodes per block
- `Task<byte[]> GetMerkleRootAsync(long objectInodeNumber, CancellationToken ct)` -- reads stored root hash

Binary-search corruption localization:
- `Task<IReadOnlyList<long>> LocalizeCorruptionAsync(long objectInodeNumber, byte[][] currentBlockChecksums, CancellationToken ct)`:
  - Compares stored Merkle root with computed root
  - If mismatch: binary search down the tree
    1. Check root: if match, object is clean. If mismatch, continue.
    2. Check left subtree hash vs stored: if mismatch, recurse left; check right subtree: if mismatch, recurse right
    3. At leaf level: identify exact corrupt block numbers
  - Returns list of corrupt block numbers
  - Complexity: O(log n) block reads to find corruption vs O(n) for full scan

Incremental updates:
- `Task UpdateBlockAsync(long objectInodeNumber, long blockNumber, byte[] newBlockChecksum, CancellationToken ct)`:
  - Updates leaf hash and recomputes path from leaf to root
  - Only touches O(log n) nodes
  - Used after writes to keep Merkle tree current

Scrub support:
- `Task<ScrubResult> ScrubObjectAsync(long objectInodeNumber, InodeV2 inode, CancellationToken ct)`:
  - Full verification: computes all block checksums, verifies Merkle tree, reports corrupt blocks
  - `ScrubResult` struct: `bool IsClean, long BlocksVerified, IReadOnlyList<long> CorruptBlocks, TimeSpan Duration`
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>MerkleIntegrityVerifier provides binary-search corruption localization in O(log n) reads, incremental updates after writes, and full scrub support.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- Merkle tree correctly identifies corrupt blocks via binary search
- Incremental update maintains correct root hash after single-block modifications
</verification>

<success_criteria>
- VOPT-25 satisfied: Per-block XxHash64, per-extent CRC32C, per-object Merkle root
- Binary-search corruption localization in O(log n)
- Merkle tree persisted in Integrity Tree region
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-13-SUMMARY.md`
</output>
