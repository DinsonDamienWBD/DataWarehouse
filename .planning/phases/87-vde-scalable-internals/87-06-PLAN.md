---
phase: 87-vde-scalable-internals
plan: 06
type: execute
wave: 2
depends_on: ["87-02"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccTransaction.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccVersionStore.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccManager.cs
autonomous: true

must_haves:
  truths:
    - "Writers append WAL records with transaction ID"
    - "Readers acquire snapshot (WAL sequence number) and see only versions <= snapshot"
    - "Version chain via inode VersionChainHead pointer links old versions"
    - "Dedicated MVCC Region stores old version data"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccTransaction.cs"
      provides: "Transaction handle with snapshot ID and read/write sets"
      contains: "class MvccTransaction"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccVersionStore.cs"
      provides: "On-disk storage for old versions in MVCC region"
      contains: "class MvccVersionStore"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccManager.cs"
      provides: "Transaction lifecycle, snapshot management, version visibility"
      contains: "class MvccManager"
  key_links:
    - from: "MvccManager.cs"
      to: "IWriteAheadLog"
      via: "WAL-based version tracking"
      pattern: "IWriteAheadLog"
    - from: "MvccVersionStore.cs"
      to: "IBlockDevice"
      via: "reads/writes old versions to MVCC region"
      pattern: "IBlockDevice"
---

<objective>
Implement WAL-based MVCC core (VOPT-12) for the VDE. Multi-version concurrency control enables concurrent readers and writers without locking by maintaining version chains and snapshot-based visibility.

Purpose: Foundation for SQL query isolation, concurrent object access, and snapshot-based operations.
Output: Three files in `DataWarehouse.SDK/VirtualDiskEngine/Mvcc/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@DataWarehouse.SDK/VirtualDiskEngine/Journal/IWriteAheadLog.cs
@DataWarehouse.SDK/VirtualDiskEngine/Journal/JournalEntry.cs
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MvccTransaction and MvccVersionStore</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccTransaction.cs
    DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccVersionStore.cs
  </files>
  <action>
Create `MvccTransaction` class with `[SdkCompatibility("6.0.0")]`:
- Properties: `long TransactionId` (monotonically increasing), `long SnapshotSequence` (WAL sequence at begin), `MvccIsolationLevel IsolationLevel`, `DateTimeOffset StartedUtc`, `TransactionState State` (Active/Committed/Aborted/RolledBack)
- `HashSet<long> ReadSet` -- inode numbers read during transaction
- `Dictionary<long, byte[]> WriteSet` -- inode numbers -> modified data (buffered writes)
- `List<(long InodeNumber, long OldVersionBlock)> VersionChainEntries` -- old versions to chain
- `void MarkRead(long inodeNumber)` -- adds to read set
- `void BufferWrite(long inodeNumber, byte[] data)` -- adds to write set
- `bool IsVisibleTo(long versionTransactionId)` -- true if versionTransactionId <= SnapshotSequence (for ReadCommitted/Snapshot)
- `enum TransactionState { Active, Committed, Aborted, RolledBack }`

Create `MvccVersionStore` class with `[SdkCompatibility("6.0.0")]`:
- Manages the dedicated MVCC VDE region for storing old versions
- Constructor: `IBlockDevice device, long mvccRegionStartBlock, long mvccRegionBlockCount, int blockSize`
- `Task<long> StoreOldVersionAsync(long inodeNumber, long transactionId, ReadOnlyMemory<byte> data, CancellationToken ct)`:
  - Writes old version data to next available block in MVCC region
  - Returns block number where version was stored
- `Task<(long TransactionId, byte[] Data)?> ReadVersionAsync(long versionBlockNumber, CancellationToken ct)`:
  - Reads a stored version including its transaction ID
- Version record format per block: TransactionId(8) + InodeNumber(8) + PreviousVersionBlock(8) + DataLength(4) + Data(variable) + XxHash64(8)
- `Task<IReadOnlyList<(long TransactionId, long VersionBlock)>> GetVersionChainAsync(long headBlock, CancellationToken ct)`:
  - Follows PreviousVersionBlock pointers to build full version chain
- `long UsedBlocks` / `long FreeBlocks` properties
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>MvccTransaction tracks read/write sets with snapshot visibility. MvccVersionStore persists old versions in a dedicated MVCC region with version chain linking.</done>
</task>

<task type="auto">
  <name>Task 2: MvccManager transaction lifecycle</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Mvcc/MvccManager.cs
  </files>
  <action>
Create `MvccManager` class with `[SdkCompatibility("6.0.0")]`:
- Constructor: `IWriteAheadLog wal, MvccVersionStore versionStore, IBlockDevice device, int blockSize`
- `MvccIsolationLevel DefaultIsolationLevel { get; set; }` = ReadCommitted
- `enum MvccIsolationLevel { ReadCommitted, SnapshotIsolation, Serializable }`
- Transaction lifecycle:
  - `Task<MvccTransaction> BeginAsync(MvccIsolationLevel? level = null, CancellationToken ct = default)`:
    - Assigns monotonic TransactionId via Interlocked.Increment
    - Takes snapshot of current WAL sequence number
    - Registers transaction in active transaction set
    - Returns new MvccTransaction
  - `Task CommitAsync(MvccTransaction tx, CancellationToken ct)`:
    - For each write in tx.WriteSet:
      1. Store current data as old version in MvccVersionStore
      2. Update inode's VersionChainHead to point to old version block
      3. Write new data to inode's data blocks
      4. Append WAL commit record with tx.TransactionId
    - Flush WAL for durability
    - Remove from active transaction set
    - Set tx.State = Committed
  - `Task AbortAsync(MvccTransaction tx, CancellationToken ct)`:
    - Discard write set, remove from active set, set State = Aborted
  - `Task<byte[]?> ReadAsync(MvccTransaction tx, long inodeNumber, CancellationToken ct)`:
    - Reads data visible to this transaction's snapshot
    - For ReadCommitted: read latest committed version
    - For SnapshotIsolation: read version <= tx.SnapshotSequence
    - Marks inode in tx.ReadSet
- `long OldestActiveSnapshot` -- minimum SnapshotSequence across active transactions (used by GC)
- Active transaction tracking: `ConcurrentDictionary<long, MvccTransaction> _activeTransactions`
- Conflict detection for Serializable: check if any inode in ReadSet was modified by a concurrent committed transaction
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>MvccManager provides full transaction lifecycle with begin/commit/abort, WAL integration, snapshot visibility, and conflict detection for Serializable isolation.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- MVCC snapshot isolation correctly filters versions by transaction ID
- Version chain properly links through VersionChainHead pointers
</verification>

<success_criteria>
- VOPT-12 satisfied: WAL-based MVCC with version chains, snapshot visibility, dedicated MVCC region
- Writers append WAL records, readers see only versions <= their snapshot
- ReadCommitted and SnapshotIsolation correctly implemented
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-06-SUMMARY.md`
</output>
