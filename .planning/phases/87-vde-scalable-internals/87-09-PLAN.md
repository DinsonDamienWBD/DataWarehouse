---
phase: 87-vde-scalable-internals
plan: 09
type: execute
wave: 3
depends_on: ["87-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/ColumnarRegionEngine.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/ZoneMapIndex.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/ColumnarEncoding.cs
autonomous: true

must_haves:
  truths:
    - "Columnar VDE regions store data column-wise with RLE and dictionary encoding"
    - "Zone maps store per-extent min/max/null_count metadata for predicate pushdown"
    - "Query planner uses zone maps to skip entire extents without reading data"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/ColumnarRegionEngine.cs"
      provides: "Column-oriented storage engine with dedicated VDE region"
      contains: "class ColumnarRegionEngine"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/ZoneMapIndex.cs"
      provides: "Per-extent zone map metadata index"
      contains: "class ZoneMapIndex"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/ColumnarEncoding.cs"
      provides: "RLE and dictionary encoding for columnar data"
      contains: "class ColumnarEncoding"
  key_links:
    - from: "ColumnarRegionEngine.cs"
      to: "RegionDirectory"
      via: "registers columnar region in VDE region directory"
      pattern: "RegionDirectory"
    - from: "ZoneMapIndex.cs"
      to: "InodeExtent"
      via: "zone maps attached to extent headers"
      pattern: "InodeExtent"
---

<objective>
Implement columnar VDE regions (VOPT-16) and zone maps (VOPT-17) for analytical query acceleration. Columnar storage enables compression and vectorized execution; zone maps enable extent-level predicate pushdown to skip irrelevant data.

Purpose: Analytics workloads (OLAP) benefit from column-oriented storage with 5-10x compression and orders of magnitude faster aggregations.
Output: Three files in `DataWarehouse.SDK/VirtualDiskEngine/Sql/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionDirectory.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ColumnarEncoding and ColumnarRegionEngine</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Sql/ColumnarEncoding.cs
    DataWarehouse.SDK/VirtualDiskEngine/Sql/ColumnarRegionEngine.cs
  </files>
  <action>
Create `ColumnarEncoding` static class with `[SdkCompatibility("6.0.0")]`:
- `enum EncodingType { Plain, RunLength, Dictionary, BitPacked }`
- RLE encoding: `byte[] EncodeRunLength(ReadOnlySpan<byte> values, int valueWidth)` -- encodes consecutive equal values as (value, count) pairs. `byte[] DecodeRunLength(ReadOnlySpan<byte> encoded, int valueWidth, int rowCount)`
- Dictionary encoding: `(byte[] DictionaryData, byte[] IndexData) EncodeDictionary(ReadOnlySpan<byte> values, int valueWidth)` -- builds dictionary of unique values, replaces each value with its dictionary index (1/2/4 byte index depending on cardinality). `byte[] DecodeDictionary(ReadOnlySpan<byte> dictionaryData, ReadOnlySpan<byte> indexData, int valueWidth, int rowCount)`
- `EncodingType SelectBestEncoding(ReadOnlySpan<byte> values, int valueWidth)` -- heuristic: if distinct values < 256, use Dictionary; if >50% runs, use RLE; else Plain
- Bit-packing for booleans and small integers

Create `ColumnarRegionEngine` class with `[SdkCompatibility("6.0.0")]`:
- Manages a dedicated VDE region for columnar table storage
- Constructor: `IBlockDevice device, RegionDirectory regionDir, int blockSize`
- `Task CreateColumnarTableAsync(string tableName, ColumnDefinition[] columns, CancellationToken ct)`:
  - Registers new region in RegionDirectory with a custom block type tag "COLR" (add to BlockTypeTags)
  - Creates column metadata header: column names, types, encoding hints
- `ColumnDefinition` readonly struct: `string Name, ColumnType Type, EncodingType PreferredEncoding, bool Nullable`
- `enum ColumnType { Int32, Int64, Float32, Float64, String, Binary, Boolean, DateTime }`
- `Task AppendRowGroupAsync(string tableName, byte[][] columnData, int rowCount, CancellationToken ct)`:
  - Encodes each column using best encoding
  - Writes encoded columns as a row group (set of column chunks)
  - Creates zone map entry for each column in the row group
  - Row group size: configurable, default 65536 rows
- `Task<byte[][]> ReadColumnAsync(string tableName, string columnName, int rowGroupIndex, CancellationToken ct)` -- reads and decodes a single column from a row group
- `IAsyncEnumerable<byte[][]> ScanColumnsAsync(string tableName, string[] columns, Predicate<ZoneMapEntry>[]? filters, CancellationToken ct)` -- scans selected columns with zone map filtering
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>ColumnarRegionEngine stores tables column-wise with RLE/dictionary encoding in dedicated VDE regions.</done>
</task>

<task type="auto">
  <name>Task 2: ZoneMapIndex</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Sql/ZoneMapIndex.cs
  </files>
  <action>
Create `ZoneMapIndex` class with `[SdkCompatibility("6.0.0")]`:
- Per-extent min/max/null_count metadata for O(1) predicate evaluation at extent granularity
- `ZoneMapEntry` readonly struct (32 bytes on disk):
  - `long MinValue` (or hash for strings)
  - `long MaxValue`
  - `int NullCount`
  - `int RowCount`
  - `long ExtentStartBlock`
  - `int ExtentBlockCount` (reuse remaining 4 bytes)
- Constructor: `IBlockDevice device, long zoneMapRegionStart, int blockSize`
- `Task AddEntryAsync(long extentStartBlock, int extentBlockCount, ZoneMapEntry entry, CancellationToken ct)` -- writes zone map entry for an extent
- `Task<ZoneMapEntry?> GetEntryAsync(long extentStartBlock, CancellationToken ct)` -- reads zone map for an extent
- `bool CanSkipExtent(ZoneMapEntry entry, ComparisonPredicate predicate)`:
  - For `value > entry.MaxValue` -> skip (no rows can match)
  - For `value < entry.MinValue` -> skip
  - For `value == X` and `(X < entry.MinValue || X > entry.MaxValue)` -> skip
  - For `IS NULL` and `entry.NullCount == 0` -> skip
  - For `IS NOT NULL` and `entry.NullCount == entry.RowCount` -> skip
- `ComparisonPredicate` readonly struct: `ComparisonOp Op, long Value`
- `enum ComparisonOp { Equal, NotEqual, LessThan, LessOrEqual, GreaterThan, GreaterOrEqual, IsNull, IsNotNull }`
- `IAsyncEnumerable<long> FilterExtentsAsync(IReadOnlyList<(long StartBlock, int BlockCount)> extents, ComparisonPredicate predicate, CancellationToken ct)` -- returns only extent start blocks that might contain matching rows (zone maps that don't exclude the predicate)
- Serialization: zone map entries stored in a dedicated index block per table, packed sequentially
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>ZoneMapIndex provides per-extent min/max/null_count metadata enabling query planner to skip entire extents during predicate evaluation.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- Columnar encoding correctly round-trips through encode/decode for all encoding types
- Zone map filtering correctly identifies skippable extents
</verification>

<success_criteria>
- VOPT-16 satisfied: Columnar VDE regions with RLE and dictionary encoding
- VOPT-17 satisfied: Zone maps with per-extent min/max/null_count for predicate pushdown
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-09-SUMMARY.md`
</output>
