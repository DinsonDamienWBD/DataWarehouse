---
phase: 87-vde-scalable-internals
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Format/CompactInode64.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/ExtendedInode512.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/MixedInodeAllocator.cs
autonomous: true

must_haves:
  truths:
    - "Compact 64-byte inodes store objects up to 48 bytes inline with zero block allocation"
    - "Extended 512-byte inodes support inline xattrs, nanosecond timestamps, compression dict ref, per-object encryption IV, MVCC version chain"
    - "Mixed inode layout auto-selects Compact64/Standard256/Extended512 per object at write time"
    - "Standard 256-byte inodes support files up to 64GB with 4KB blocks via indirect pointers"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/CompactInode64.cs"
      provides: "64-byte inode with 48 bytes inline data"
      contains: "struct CompactInode64"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/ExtendedInode512.cs"
      provides: "512-byte inode with extended metadata fields"
      contains: "class ExtendedInode512"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/MixedInodeAllocator.cs"
      provides: "Auto-selection of inode format in Mixed layout mode"
      contains: "class MixedInodeAllocator"
  key_links:
    - from: "MixedInodeAllocator.cs"
      to: "InodeLayoutDescriptor"
      via: "reads layout from superblock to determine available formats"
      pattern: "InodeLayoutDescriptor"
    - from: "CompactInode64.cs"
      to: "FormatConstants"
      via: "uses InodeCoreSize and alignment constants"
      pattern: "FormatConstants"
---

<objective>
Implement variable-width inode types (VOPT-06, VOPT-07, VOPT-08, VOPT-10) for the VDE. This adds Compact64 for tiny objects (config files, tags), Extended512 for metadata-rich objects, fixes Standard256 indirect block support, and enables Mixed layout auto-selection.

Purpose: Dramatically reduces storage overhead for small objects (zero block allocation for <=48B) while enabling rich metadata for large objects.
Output: Three files in `DataWarehouse.SDK/VirtualDiskEngine/Format/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeLayoutDescriptor.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CompactInode64 and ExtendedInode512</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/CompactInode64.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/ExtendedInode512.cs
  </files>
  <action>
Create `CompactInode64` readonly struct (64 bytes total, `[SdkCompatibility("6.0.0")]`):
- Layout: InodeNumber(8) + Type(1) + Flags(1) + Permissions(2) + LinkCount(4) = 16 bytes header
- InlineDataLength(2) + InlineData(48-2=46 bytes effective) -- objects <=46 bytes stored entirely inline
- Wait, recalculate: 64 total - 16 header = 48 bytes for inline data area. InlineDataLength stored as first 2 bytes of inline area, so 46 bytes max inline data.
- Actually use: InodeNumber(8) + Type(1) + Flags(1) + InlineDataSize(2) + OwnerId(4, truncated hash) = 16 bytes, leaving 48 bytes for inline data
- Serialize/Deserialize methods matching InodeV2 pattern (static methods, Span-based)
- `bool CanFitInline(long objectSize)` static method returning true if size <= 48
- No extent pointers, no timestamps (compact = minimal overhead)
- Conversion: `InodeV2 ToStandardInode()` for when object grows beyond inline capacity

Create `ExtendedInode512` class (512 bytes, `[SdkCompatibility("6.0.0")]`):
- Inherits all InodeV2 core fields (304 bytes)
- Extended fields (208 bytes): NanosecondTimestamps (CreatedNs(8) + ModifiedNs(8) + AccessedNs(8) = 24 bytes), InlineXattrArea(64 bytes), CompressionDictionaryRef(8 bytes -- block number of dict), PerObjectEncryptionIV(16 bytes -- AES-256 IV), MvccVersionChainHead(8 bytes -- block number of version chain), MvccTransactionId(8 bytes), SnapshotRefCount(4 bytes), ReplicationVector(16 bytes -- vector clock), Reserved(60 bytes for future modules)
- Serialize/Deserialize extending InodeV2 pattern
- `ReadOnlySpan<byte> GetInlineXattrs()` for reading extended attributes
- `void SetInlineXattrs(ReadOnlySpan<byte> data)` (max 64 bytes)
- Conversion: `static ExtendedInode512 FromStandard(InodeV2 standard)` upgrades standard inode
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>CompactInode64 stores tiny objects inline. ExtendedInode512 provides nanosecond timestamps, inline xattrs, compression dict ref, encryption IV, and MVCC version chain pointer.</done>
</task>

<task type="auto">
  <name>Task 2: MixedInodeAllocator for auto-selection</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/MixedInodeAllocator.cs
  </files>
  <action>
Create `MixedInodeAllocator` class with `[SdkCompatibility("6.0.0")]`:
- Constructor takes `InodeLayoutDescriptor descriptor` from the superblock
- `InodeFormat SelectFormat(long objectSize, bool hasExtendedMetadata, bool hasMvcc)`:
  - objectSize <= 48 and no extended metadata and no MVCC -> `InodeFormat.Compact64`
  - objectSize <= 64GB (with 4KB blocks, 8 direct extents + indirect) and no extended metadata -> `InodeFormat.Standard256`
  - Otherwise -> `InodeFormat.Extended512`
- `enum InodeFormat { Compact64 = 64, Standard256 = 256, Extended512 = 512 }`
- `byte[] AllocateInode(InodeFormat format)` -- returns zero-initialized buffer of correct size
- `InodeFormat DetectFormat(ReadOnlySpan<byte> inodeBuffer)` -- inspects first bytes to determine which format was used (uses size field from InodeLayoutDescriptor or a format marker byte)
- Handles superblock `InodeLayout: Mixed` mode where each inode region block contains mixed-size inodes
- Tracks per-block inode packing: how many of each format fit in one block
  - 4KB block: 64 Compact64 inodes, or 16 Standard256, or 8 Extended512
- `InodePackingInfo GetPackingInfo(int blockSize)` -- returns counts per format per block
- `InodePackingInfo` readonly struct with `int Compact64PerBlock, Standard256PerBlock, Extended512PerBlock`
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>MixedInodeAllocator auto-selects Compact64/Standard256/Extended512 based on object characteristics at write time.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- CompactInode64 fits in exactly 64 bytes with inline data
- ExtendedInode512 fits in exactly 512 bytes with all extended fields
- MixedInodeAllocator correctly selects format based on object size and metadata needs
</verification>

<success_criteria>
- VOPT-06 satisfied: Compact64 inodes with inline storage for objects <=48 bytes
- VOPT-07 satisfied: Standard256 supports files up to 64GB via indirect pointers (InodeV2 already implements this)
- VOPT-08 satisfied: Extended512 with xattrs, nanosecond timestamps, compression dict, encryption IV, MVCC chain
- VOPT-10 satisfied: Mixed layout auto-selects per object at write time
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-03-SUMMARY.md`
</output>
