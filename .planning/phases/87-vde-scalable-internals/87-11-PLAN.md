---
phase: 87-vde-scalable-internals
plan: 11
type: execute
wave: 4
depends_on: ["87-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Index/RoaringBitmapTagIndex.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Index/TagBloomFilter.cs
autonomous: true

must_haves:
  truths:
    - "Persistent inverted tag index uses roaring bitmaps stored in VDE Tag Index region"
    - "Roaring bitmaps provide O(1) AND/OR/NOT set operations at ~2 bytes per element"
    - "Per-allocation-group bloom filter enables O(1) 'does group contain tag=X?' check"
    - "Bloom filter is 1KB per group with configurable false positive rate ~1%"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Index/RoaringBitmapTagIndex.cs"
      provides: "Persistent tag index with roaring bitmap set operations"
      contains: "class RoaringBitmapTagIndex"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Index/TagBloomFilter.cs"
      provides: "Per-allocation-group bloom filter for tag existence check"
      contains: "class TagBloomFilter"
  key_links:
    - from: "RoaringBitmapTagIndex.cs"
      to: "TagIndexRegion"
      via: "persists bitmaps to the TAGI region"
      pattern: "BlockTypeTags\\.TAGI"
    - from: "TagBloomFilter.cs"
      to: "AllocationGroup"
      via: "one bloom filter per allocation group"
      pattern: "AllocationGroup"
---

<objective>
Implement persistent tag index with roaring bitmaps (VOPT-21) and per-allocation-group tag bloom filters (VOPT-22). Replaces the in-memory ConcurrentDictionary+HashSet tag index with a persistent, space-efficient inverted index supporting fast set operations.

Purpose: Tags are a core VDE feature. Persistent roaring bitmaps reduce memory from O(n) to ~2 bytes/element while enabling O(1) AND/OR/NOT. Bloom filters enable group-level skip during tag queries.
Output: Two files in `DataWarehouse.SDK/VirtualDiskEngine/Index/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@DataWarehouse.SDK/VirtualDiskEngine/Regions/TagIndexRegion.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: RoaringBitmapTagIndex</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Index/RoaringBitmapTagIndex.cs
  </files>
  <action>
Create `RoaringBitmapTagIndex` class with `[SdkCompatibility("6.0.0")]`:
- Persistent inverted index: tag key+value -> RoaringBitmap of inode numbers

Roaring bitmap implementation (embedded, no external dependency):
- `RoaringBitmap` inner class:
  - Container-based: divides 64-bit space into 65536-entry chunks (high 48 bits = chunk key, low 16 bits = position within chunk)
  - Each chunk is either: ArrayContainer (sorted ushort[] for sparse, <4096 entries), BitmapContainer (8KB bitmap for dense, >=4096 entries), or RunContainer (RLE of ranges)
  - `void Add(long inodeNumber)` -- inserts into correct container, promotes Array->Bitmap at threshold
  - `void Remove(long inodeNumber)` -- removes, demotes Bitmap->Array if sparse
  - `bool Contains(long inodeNumber)` -- O(1) lookup
  - `static RoaringBitmap And(RoaringBitmap a, RoaringBitmap b)` -- intersection
  - `static RoaringBitmap Or(RoaringBitmap a, RoaringBitmap b)` -- union
  - `static RoaringBitmap Not(RoaringBitmap a, long universeSize)` -- complement
  - `long Cardinality` -- number of set bits
  - `IEnumerable<long> Enumerate()` -- iterate all set positions

Index operations:
- Constructor: `IBlockDevice device, long tagIndexRegionStart, long tagIndexRegionBlockCount, int blockSize`
- `Task AddTagAsync(string tagKey, string tagValue, long inodeNumber, CancellationToken ct)` -- adds inode to the bitmap for (key, value)
- `Task RemoveTagAsync(string tagKey, string tagValue, long inodeNumber, CancellationToken ct)` -- removes inode from bitmap
- `Task<RoaringBitmap> QueryAsync(string tagKey, string tagValue, CancellationToken ct)` -- returns bitmap of all inodes with this tag
- `Task<RoaringBitmap> QueryAndAsync(IReadOnlyList<(string Key, string Value)> tags, CancellationToken ct)` -- AND across multiple tag bitmaps
- `Task<RoaringBitmap> QueryOrAsync(IReadOnlyList<(string Key, string Value)> tags, CancellationToken ct)` -- OR across multiple tag bitmaps
- Persistence: bitmaps serialized to TAGI region blocks. Index header maps tag keys to block ranges. Uses XxHash64 of (key+value) as the lookup key in a hash table stored in the first N blocks of the region.
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>RoaringBitmapTagIndex provides persistent inverted tag index with O(1) AND/OR/NOT via roaring bitmaps at ~2 bytes/element.</done>
</task>

<task type="auto">
  <name>Task 2: TagBloomFilter per allocation group</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Index/TagBloomFilter.cs
  </files>
  <action>
Create `TagBloomFilter` class with `[SdkCompatibility("6.0.0")]`:
- 1KB bloom filter per allocation group for O(1) "does this group contain tag=X?" check
- Constructor: `int filterSizeBytes = 1024, int hashFunctionCount = 7` (7 hashes for 1KB filter gives ~1% FPR at ~600 elements)
- `void Add(string tagKey, string tagValue)` -- hashes (key+value) with K hash functions, sets K bits
- `bool MayContain(string tagKey, string tagValue)` -- returns true if all K bits are set (may be false positive); false means definitely not present
- `void Clear()` -- resets all bits to zero
- Hash functions: use XxHash64 with K different seeds (seed = hashIndex * 0x9E3779B9)
- Bit index calculation: `hash(seed, tagKey + tagValue) % (filterSizeBytes * 8)`

Per-group management:
- `TagBloomFilterSet` class managing one bloom filter per allocation group:
  - Constructor: `int groupCount, int filterSizeBytes = 1024`
  - `void AddToGroup(int groupId, string tagKey, string tagValue)`
  - `bool GroupMayContainTag(int groupId, string tagKey, string tagValue)`
  - `IReadOnlyList<int> FilterGroups(string tagKey, string tagValue)` -- returns only group IDs where tag might exist (skips groups where bloom says NO)
  - Serialization: `byte[] Serialize()` / `static TagBloomFilterSet Deserialize(ReadOnlySpan<byte> data, int groupCount, int filterSizeBytes)` -- all filters concatenated: groupCount * filterSizeBytes bytes
  - Stored alongside allocation group descriptor table

- `[SdkCompatibility("6.0.0")]` on both classes
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>TagBloomFilter provides 1KB bloom filter per allocation group for O(1) tag existence checks enabling group-level skip during tag queries.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- Roaring bitmap correctly promotes Array->Bitmap at 4096 threshold
- Bloom filter false positive rate is ~1% for expected element counts
</verification>

<success_criteria>
- VOPT-21 satisfied: Persistent roaring bitmap tag index replacing in-memory ConcurrentDictionary+HashSet
- VOPT-22 satisfied: 1KB bloom filter per allocation group for O(1) tag group skip
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-11-SUMMARY.md`
</output>
