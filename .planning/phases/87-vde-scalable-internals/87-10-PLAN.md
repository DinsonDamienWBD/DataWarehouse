---
phase: 87-vde-scalable-internals
plan: 10
type: execute
wave: 4
depends_on: ["87-08", "87-09"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/SimdAggregator.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/SpillToDiskOperator.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/PredicatePushdownPlanner.cs
autonomous: true

must_haves:
  truths:
    - "SIMD vectorized execution uses Vector256 and Avx2 for SUM/COUNT/MIN/MAX/AVG processing 8 values per instruction"
    - "Aggregations exceeding memory budget spill to temp VDE region with hash partitioning"
    - "WHERE clauses are pushed into storage scan layer combining with zone maps"
    - "Runtime Avx2.IsSupported check with scalar fallback"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/SimdAggregator.cs"
      provides: "SIMD-accelerated aggregation functions"
      contains: "class SimdAggregator"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/SpillToDiskOperator.cs"
      provides: "Hash-partitioned spill to temp VDE region for large aggregations"
      contains: "class SpillToDiskOperator"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/PredicatePushdownPlanner.cs"
      provides: "Pushes WHERE predicates into storage scan layer"
      contains: "class PredicatePushdownPlanner"
  key_links:
    - from: "SimdAggregator.cs"
      to: "ColumnarRegionEngine"
      via: "operates on columnar data arrays"
      pattern: "ColumnarRegionEngine"
    - from: "PredicatePushdownPlanner.cs"
      to: "ZoneMapIndex"
      via: "combines zone map filtering with predicate evaluation"
      pattern: "ZoneMapIndex"
---

<objective>
Implement SIMD vectorized SQL execution (VOPT-18), spill-to-disk for large aggregations (VOPT-19), and predicate pushdown into storage scans (VOPT-20). These complete the SQL optimization stack.

Purpose: SIMD processes 8 values per instruction for 4-8x aggregation speedup. Spill-to-disk prevents OOM on large datasets. Predicate pushdown skips >90% of data for selective queries.
Output: Three files in `DataWarehouse.SDK/VirtualDiskEngine/Sql/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/87-vde-scalable-internals/87-09-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SimdAggregator with Avx2 and scalar fallback</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Sql/SimdAggregator.cs
  </files>
  <action>
Create `SimdAggregator` class with `[SdkCompatibility("6.0.0")]`:
- Uses `System.Runtime.Intrinsics` and `System.Runtime.Intrinsics.X86`
- Runtime check: `static bool SimdSupported => Avx2.IsSupported`

Aggregation methods (all with SIMD + scalar fallback):

`long SumInt32(ReadOnlySpan<int> values)`:
- SIMD path: process 8 int32 values per iteration using `Vector256<int>`, accumulate with `Avx2.Add`, horizontal sum at end
- Scalar fallback: simple loop

`long Count(ReadOnlySpan<int> values, int? filterValue = null)`:
- SIMD path: use `Avx2.CompareEqual` to create mask, `Avx2.MoveMask` to popcount matches
- Scalar fallback: simple loop with conditional

`int MinInt32(ReadOnlySpan<int> values)` / `int MaxInt32(ReadOnlySpan<int> values)`:
- SIMD path: `Avx2.Min` / `Avx2.Max` across 8-wide vectors, horizontal reduction at end
- Scalar fallback: simple loop

`double Average(ReadOnlySpan<int> values)`:
- Uses SumInt32 + Count for efficiency

`double SumFloat(ReadOnlySpan<float> values)`:
- SIMD path: `Vector256<float>` with `Avx.Add`
- Scalar fallback: Kahan summation for accuracy

Comparison predicates (for WHERE filtering):
`int[] FilterGreaterThan(ReadOnlySpan<int> values, int threshold)`:
- SIMD path: `Avx2.CompareGreaterThan`, extract indices via movemask
- Returns array of indices where values[i] > threshold

`int[] FilterEquals(ReadOnlySpan<int> values, int target)`:
- SIMD path: `Avx2.CompareEqual`

All methods handle tail elements (when count is not multiple of 8) via scalar loop on remainder.
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>SimdAggregator provides SIMD-accelerated SUM/COUNT/MIN/MAX/AVG with runtime Avx2 detection and scalar fallback.</done>
</task>

<task type="auto">
  <name>Task 2: SpillToDiskOperator and PredicatePushdownPlanner</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Sql/SpillToDiskOperator.cs
    DataWarehouse.SDK/VirtualDiskEngine/Sql/PredicatePushdownPlanner.cs
  </files>
  <action>
Create `SpillToDiskOperator` class with `[SdkCompatibility("6.0.0")]`:
- Constructor: `IBlockDevice device, IBlockAllocator allocator, int blockSize, long memoryBudgetBytes = 64 * 1024 * 1024`
- `Task<IAsyncEnumerable<(byte[] Key, byte[] AggregateState)>> AggregateWithSpillAsync(IAsyncEnumerable<(byte[] Key, byte[] Row)> input, AggregateFunction[] aggregates, CancellationToken ct)`:
  - Phase 1: Hash-partition input rows into in-memory hash table
  - When memory budget exceeded: spill current partition to temp blocks (hash partitioned into N partitions)
  - Phase 2: Process each spilled partition one at a time (fits in memory since partitioned)
  - Merge results from all partitions
- `AggregateFunction` abstract class: `void Accumulate(ReadOnlySpan<byte> value)`, `byte[] GetResult()`, `void Merge(byte[] other)`
- Concrete: `SumAggregate`, `CountAggregate`, `MinAggregate`, `MaxAggregate`, `AvgAggregate`
- Temp block cleanup: `Task CleanupAsync(CancellationToken ct)` -- frees all temp blocks after query completion
- `SpillStats` struct: `long RowsProcessed, long RowsSpilled, int PartitionsCreated, long TempBlocksUsed`

Create `PredicatePushdownPlanner` class with `[SdkCompatibility("6.0.0")]`:
- Takes query predicates and pushes them into the storage scan layer
- `PushdownResult AnalyzePushdown(QueryPredicate[] predicates, ZoneMapIndex zoneMapIndex)`:
  - For each predicate, determines if it can be evaluated at zone map level (extent skip), block level, or must be post-filter
  - Returns `PushdownResult` with: `zoneMappable` (evaluated at extent level), `blockFilterable` (evaluated per block), `postFilter` (evaluated per row)
- `QueryPredicate` class: `string ColumnName, ComparisonOp Op, object Value, LogicalOp? Connector` (AND/OR)
- `enum LogicalOp { And, Or }`
- `IAsyncEnumerable<byte[]> ScanWithPushdownAsync(ColumnarRegionEngine engine, string tableName, string[] columns, QueryPredicate[] predicates, CancellationToken ct)`:
  - Step 1: Use zone maps to eliminate extents (VOPT-17 integration)
  - Step 2: For remaining extents, apply block-level filters
  - Step 3: Apply post-filters on individual rows
  - Works for both row and columnar formats
- Logs pushdown decisions for query explain plans
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>SpillToDiskOperator handles large aggregations with hash-partitioned spill. PredicatePushdownPlanner pushes WHERE clauses into storage scans combining zone maps at extent/block/row levels.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- SIMD methods produce correct results for arrays not aligned to 8-element boundary
- Spill-to-disk correctly partitions and merges aggregation results
</verification>

<success_criteria>
- VOPT-18 satisfied: SIMD vectorized SUM/COUNT/MIN/MAX/AVG with Avx2 and scalar fallback
- VOPT-19 satisfied: Spill-to-disk with hash partitioning and configurable memory budget
- VOPT-20 satisfied: Predicate pushdown combining zone maps for >90% data skip on selective queries
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-10-SUMMARY.md`
</output>
