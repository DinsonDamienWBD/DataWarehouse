---
phase: 87-vde-scalable-internals
plan: 12
type: execute
wave: 4
depends_on: ["87-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Encryption/PerExtentEncryptor.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Compression/PerExtentCompressor.cs
autonomous: true

must_haves:
  truths:
    - "Encryption operates on contiguous extent ranges as one unit with one IV per extent"
    - "Bulk AES-NI processing reduces crypto overhead by up to 256x vs per-block"
    - "Compression operates on extent ranges with one dictionary per extent"
    - "Better compression ratio than per-block for small block sizes"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Encryption/PerExtentEncryptor.cs"
      provides: "Extent-granularity encryption with bulk AES-NI"
      contains: "class PerExtentEncryptor"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Compression/PerExtentCompressor.cs"
      provides: "Extent-granularity compression with shared dictionary"
      contains: "class PerExtentCompressor"
  key_links:
    - from: "PerExtentEncryptor.cs"
      to: "InodeExtent"
      via: "operates on extent ranges defined by InodeExtent"
      pattern: "InodeExtent"
    - from: "PerExtentCompressor.cs"
      to: "ExtentFlags"
      via: "sets Compressed flag on processed extents"
      pattern: "ExtentFlags"
---

<objective>
Implement per-extent encryption (VOPT-23) and per-extent compression (VOPT-24). Operating on extent-sized units instead of individual blocks dramatically reduces overhead while improving compression ratios.

Purpose: Per-block encryption requires one IV per block (256x overhead for a 256-block extent). Per-block compression misses cross-block patterns. Extent-level processing is both faster and more effective.
Output: Two files in `DataWarehouse.SDK/VirtualDiskEngine/Encryption/` and `Compression/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PerExtentEncryptor and PerExtentCompressor</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Encryption/PerExtentEncryptor.cs
    DataWarehouse.SDK/VirtualDiskEngine/Compression/PerExtentCompressor.cs
  </files>
  <action>
Create `PerExtentEncryptor` class with `[SdkCompatibility("6.0.0")]`:
- Constructor: `byte[] key, int blockSize`
- `Task<byte[]> EncryptExtentAsync(ReadOnlyMemory<byte> extentData, InodeExtent extent, CancellationToken ct)`:
  - Generates one 16-byte IV per extent (derived from extent.StartBlock + extent.LogicalOffset via HKDF)
  - Encrypts entire extent data as one AES-256-GCM operation using `System.Security.Cryptography.AesGcm`
  - Appends 16-byte authentication tag
  - Returns: IV(16) + EncryptedData(extentData.Length) + Tag(16)
  - Sets `ExtentFlags.Encrypted` on the extent
- `Task<byte[]> DecryptExtentAsync(ReadOnlyMemory<byte> encryptedData, InodeExtent extent, CancellationToken ct)`:
  - Extracts IV (first 16 bytes) and tag (last 16 bytes)
  - Decrypts and authenticates using AES-256-GCM
  - Throws `CryptographicException` if authentication fails (tamper detected)
- `static byte[] DeriveIV(long startBlock, long logicalOffset)` -- deterministic IV from extent position (enables random-access decryption of individual extents without stored IV table)
- Overhead calculation: 32 bytes per extent (IV + tag) vs 32 bytes per block in per-block mode = 256x reduction for 256-block extents
- `EncryptionStats` struct: `long ExtentsEncrypted, long BytesProcessed, TimeSpan TotalEncryptTime`

Create `PerExtentCompressor` class with `[SdkCompatibility("6.0.0")]`:
- Constructor: `int blockSize, CompressionLevel level = CompressionLevel.Optimal`
- `Task<CompressedExtent> CompressExtentAsync(ReadOnlyMemory<byte> extentData, InodeExtent extent, CancellationToken ct)`:
  - Compresses entire extent as one unit using `System.IO.Compression.BrotliEncoder` (or ZstdSharp if available)
  - Optionally builds a dictionary from the first N blocks of the extent for better ratio
  - Returns `CompressedExtent` with: compressed data, original size, compressed size, dictionary (if built), ratio
  - Sets `ExtentFlags.Compressed` on the extent
  - If compressed size >= original size * 0.95, returns uncompressed (not worth the overhead)
- `Task<byte[]> DecompressExtentAsync(CompressedExtent compressed, CancellationToken ct)`:
  - Decompresses using stored dictionary if present
- `CompressedExtent` readonly struct: `byte[] Data, int OriginalSize, int CompressedSize, byte[]? Dictionary, double Ratio`
- `CompressionLevel` enum: `Fastest, Optimal, SmallestSize`
- Dictionary handling: for extents with repeated patterns (e.g., columnar data), pre-train dictionary on first 8KB of extent data
- `CompressionStats` struct: `long ExtentsCompressed, double AverageRatio, long BytesSaved`
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>PerExtentEncryptor provides one-IV-per-extent AES-256-GCM encryption (256x overhead reduction). PerExtentCompressor provides extent-level compression with optional dictionary for better ratios.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- Encryption round-trips correctly (encrypt then decrypt returns original data)
- IV derivation is deterministic from extent position
</verification>

<success_criteria>
- VOPT-23 satisfied: Per-extent encryption with one IV, bulk AES-NI, 256x overhead reduction
- VOPT-24 satisfied: Per-extent compression with shared dictionary, better ratio than per-block
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-12-SUMMARY.md`
</output>
