---
phase: 87-vde-scalable-internals
plan: 08
type: execute
wave: 3
depends_on: ["87-02", "87-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/PreparedQueryCache.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/MergeJoinExecutor.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Sql/IndexOnlyScan.cs
autonomous: true

must_haves:
  truths:
    - "Prepared query cache stores parsed+planned queries by fingerprint for reuse"
    - "Merge join operates on sorted Bε-tree range scans for efficient joins"
    - "Index-only scans use zone maps to return results without reading data blocks"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/PreparedQueryCache.cs"
      provides: "LRU cache of parsed/planned queries keyed by SQL fingerprint"
      contains: "class PreparedQueryCache"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/MergeJoinExecutor.cs"
      provides: "Merge join on pre-sorted range scans"
      contains: "class MergeJoinExecutor"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Sql/IndexOnlyScan.cs"
      provides: "Index-only scan using zone map metadata"
      contains: "class IndexOnlyScan"
  key_links:
    - from: "PreparedQueryCache.cs"
      to: "AdaptiveReplacementCache"
      via: "uses ARC cache pattern for query plan caching"
      pattern: "IArcCache"
    - from: "MergeJoinExecutor.cs"
      to: "AdaptiveIndexEngine"
      via: "uses sorted range queries from the adaptive index"
      pattern: "RangeQueryAsync"
---

<objective>
Implement SQL OLTP optimizations (VOPT-15): prepared query cache, merge join for sorted range scans, and index-only scans using zone maps. These are the foundational SQL execution components that later plans build upon.

Purpose: Critical for SQL query performance -- prepared queries avoid re-parsing, merge joins exploit sorted data, index-only scans skip data blocks entirely.
Output: Three files in `DataWarehouse.SDK/VirtualDiskEngine/Sql/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/AdaptiveIndexEngine.cs
@DataWarehouse.SDK/VirtualDiskEngine/Cache/IArcCache.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PreparedQueryCache</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Sql/PreparedQueryCache.cs
  </files>
  <action>
Create `PreparedQueryCache` class with `[SdkCompatibility("6.0.0")]`:
- LRU cache storing compiled query plans keyed by SQL fingerprint (normalized SQL text with literal values replaced by placeholders)
- Constructor: `int maxEntries = 1024`
- `string Fingerprint(string sql)` -- normalizes SQL: strips whitespace, replaces numeric/string literals with `?`, lowercases keywords. Example: `SELECT * FROM t WHERE id = 42` -> `select * from t where id = ?`
- `PreparedQuery? TryGet(string sql)` -- computes fingerprint, returns cached plan or null
- `void Put(string sql, PreparedQuery plan)` -- caches plan, evicts LRU if at capacity
- `void Invalidate(string tableName)` -- removes all plans referencing the table (for DDL changes)
- `void Clear()` -- removes all cached plans
- `PreparedQueryCacheStats GetStats()` -- hits, misses, evictions, entry count

Create `PreparedQuery` class with `[SdkCompatibility("6.0.0")]`:
- `string Fingerprint` -- normalized SQL fingerprint
- `string OriginalSql` -- original SQL text
- `QueryPlanNode RootNode` -- execution plan tree root
- `DateTimeOffset CachedUtc` -- when this plan was created
- `long ExecutionCount` -- how many times this plan has been used
- `TimeSpan AverageExecutionTime` -- rolling average

Create `QueryPlanNode` abstract class:
- `string NodeType` (TableScan, IndexScan, MergeJoin, Filter, Project, Sort, Aggregate)
- `QueryPlanNode[]? Children`
- `long EstimatedRows`
- `abstract IAsyncEnumerable<byte[]> ExecuteAsync(QueryContext ctx, CancellationToken ct)`

Internal storage: `LinkedList<(string Fingerprint, PreparedQuery Plan)>` for LRU + `Dictionary<string, LinkedListNode>` for O(1) lookup
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>PreparedQueryCache stores parsed+planned queries by SQL fingerprint with LRU eviction and table-based invalidation.</done>
</task>

<task type="auto">
  <name>Task 2: MergeJoinExecutor and IndexOnlyScan</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Sql/MergeJoinExecutor.cs
    DataWarehouse.SDK/VirtualDiskEngine/Sql/IndexOnlyScan.cs
  </files>
  <action>
Create `MergeJoinExecutor` class with `[SdkCompatibility("6.0.0")]`:
- Performs merge join on two pre-sorted input streams (from Bε-tree / adaptive index range scans)
- Constructor: `IAsyncEnumerable<(byte[] Key, byte[] Row)> leftInput, IAsyncEnumerable<(byte[] Key, byte[] Row)> rightInput, Func<byte[], byte[], int> keyComparer`
- `IAsyncEnumerable<(byte[] LeftRow, byte[] RightRow)> ExecuteAsync(CancellationToken ct)`:
  - Standard merge join algorithm: advance both streams in lock-step
  - When keys match: emit joined pair, advance both
  - When left < right: advance left
  - When left > right: advance right
  - Handles duplicate keys (many-to-many join) by buffering duplicates from one side
- `JoinType` enum: Inner, LeftOuter, RightOuter, FullOuter
- `MergeJoinStats` struct: `long RowsScannedLeft, RowsScannedRight, RowsEmitted, TimeSpan Elapsed`
- Optimized for sorted Bε-tree range scans where both inputs are already sorted by join key

Create `IndexOnlyScan` class with `[SdkCompatibility("6.0.0")]`:
- Returns query results using only index metadata (zone maps) without reading actual data blocks
- Constructor: `IAdaptiveIndex index, int blockSize`
- `IAsyncEnumerable<(byte[] Key, long Value)> ScanAsync(byte[]? startKey, byte[]? endKey, Predicate<ZoneMapEntry>? zoneMapFilter, CancellationToken ct)`:
  - Uses zone map (min/max per extent) to skip extents that cannot contain matching rows
  - Only reads extent headers for zone map check, then reads matching extents
  - Falls back to full scan if no zone map available
- `ZoneMapEntry` readonly struct: `long MinValue, long MaxValue, int NullCount, int RowCount`
- `bool CanSatisfyFromIndexOnly(string[] requestedColumns, string[] indexColumns)` -- returns true if all requested columns are covered by the index
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>MergeJoinExecutor performs efficient sorted-merge joins on index range scans. IndexOnlyScan uses zone maps to skip non-matching extents.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- Query fingerprint normalization is deterministic
- Merge join handles duplicate keys and all join types
</verification>

<success_criteria>
- VOPT-15 satisfied: Prepared query cache, merge join on sorted scans, index-only scans with zone maps
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-08-SUMMARY.md`
</output>
