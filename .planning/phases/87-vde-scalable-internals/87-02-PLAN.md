---
phase: 87-vde-scalable-internals
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Cache/AdaptiveReplacementCache.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Cache/ArcCacheL2Mmap.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Cache/ArcCacheL3NVMe.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Cache/IArcCache.cs
autonomous: true

must_haves:
  truths:
    - "L1 ARC cache provides self-tuning in-process caching with T1/T2/B1/B2 lists"
    - "L2 cache uses memory-mapped VDE regions for zero-copy read when VDE exceeds RAM"
    - "L3 cache offloads warm blocks to a dedicated NVMe device path"
    - "Cache auto-sizes from available system RAM"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Cache/IArcCache.cs"
      provides: "Cache interface with Get/Put/Evict/Stats"
      contains: "interface IArcCache"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Cache/AdaptiveReplacementCache.cs"
      provides: "L1 in-process ARC with T1/T2/B1/B2 ghost lists"
      contains: "class AdaptiveReplacementCache"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Cache/ArcCacheL2Mmap.cs"
      provides: "L2 memory-mapped cache for large VDEs"
      contains: "class ArcCacheL2Mmap"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Cache/ArcCacheL3NVMe.cs"
      provides: "L3 NVMe read cache for tiered storage"
      contains: "class ArcCacheL3NVMe"
  key_links:
    - from: "AdaptiveReplacementCache.cs"
      to: "IBlockDevice"
      via: "reads blocks through device on cache miss"
      pattern: "IBlockDevice"
    - from: "ArcCacheL2Mmap.cs"
      to: "System.IO.MemoryMappedFiles"
      via: "memory-maps VDE region files"
      pattern: "MemoryMappedFile"
---

<objective>
Implement the 3-tier ARC cache (VOPT-03, VOPT-04, VOPT-05) for the VDE. The Adaptive Replacement Cache replaces simple TTL-based caching with a self-tuning algorithm that balances recency and frequency, with L2 mmap and L3 NVMe tiers for large-scale deployments.

Purpose: Critical performance infrastructure -- every block read flows through this cache. Required by SQL engine, MVCC, and tag index.
Output: Four files in `DataWarehouse.SDK/VirtualDiskEngine/Cache/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: IArcCache interface and L1 AdaptiveReplacementCache</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Cache/IArcCache.cs
    DataWarehouse.SDK/VirtualDiskEngine/Cache/AdaptiveReplacementCache.cs
  </files>
  <action>
Create `IArcCache` interface with `[SdkCompatibility("6.0.0")]`:
- `ValueTask<byte[]?> GetAsync(long blockNumber, CancellationToken ct = default)` -- returns cached block or null
- `ValueTask PutAsync(long blockNumber, ReadOnlyMemory<byte> data, CancellationToken ct = default)` -- inserts/updates block
- `void Evict(long blockNumber)` -- removes block from cache
- `void Clear()` -- flushes entire cache
- `ArcCacheStats GetStats()` -- returns hit/miss/eviction counts
- `long Capacity { get; }` -- max entries
- `long Count { get; }` -- current entries

Create `ArcCacheStats` readonly struct: `long Hits, Misses, Evictions, T1Size, T2Size, B1Size, B2Size, double HitRatio`.

Create `AdaptiveReplacementCache` implementing `IArcCache, IDisposable`:
- Full ARC algorithm with four lists: T1 (recent), T2 (frequent), B1 (ghost recent), B2 (ghost frequent)
- Self-tuning parameter `p` that shifts between recency/frequency based on ghost hits
- Constructor: `int maxEntries` -- if 0, auto-sizes from `GC.GetGCMemoryInfo().TotalAvailableMemoryBytes` and block size
- On cache miss (block not in T1 or T2): check B1/B2 ghost lists to adjust `p`, then evict from appropriate list
- On B1 hit (ghost recent): increase `p` (favor recency), move to T2
- On B2 hit (ghost frequent): decrease `p` (favor frequency), move to T2
- Thread-safe via `ReaderWriterLockSlim` -- read lock for Get, write lock for Put/Evict
- Internal storage: `Dictionary<long, LinkedListNode<(long BlockNumber, byte[] Data)>>` for O(1) lookup + O(1) LRU eviction
- Ghost lists store only block numbers (no data) with bounded size = maxEntries
- `[SdkCompatibility("6.0.0")]` on all types
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>L1 ARC cache with full T1/T2/B1/B2 algorithm, self-tuning p parameter, auto-sizing from RAM, thread-safe access.</done>
</task>

<task type="auto">
  <name>Task 2: L2 memory-mapped cache and L3 NVMe cache</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Cache/ArcCacheL2Mmap.cs
    DataWarehouse.SDK/VirtualDiskEngine/Cache/ArcCacheL3NVMe.cs
  </files>
  <action>
Create `ArcCacheL2Mmap` implementing `IArcCache, IDisposable`:
- Uses `System.IO.MemoryMappedFiles.MemoryMappedFile` for zero-copy read access
- Constructor: `string vdeFilePath, long regionStartOffset, long regionLength, int blockSize`
- `GetAsync` maps the requested block offset into the mmap view, returns data without copying to managed heap when possible
- `PutAsync` is a no-op (OS page cache manages L2 eviction)
- `Evict` is a no-op (OS manages)
- Activated automatically when VDE size exceeds available RAM
- Configurable per-region: `bool MmapEnabled` property
- Uses `MemoryMappedViewAccessor` with sequential read hints for scan workloads
- Dispose properly unmaps all views and closes the mmap handle
- `[SdkCompatibility("6.0.0")]`

Create `ArcCacheL3NVMe` implementing `IArcCache, IDisposable`:
- Stores warm blocks (evicted from L1) on a dedicated fast NVMe device
- Constructor: `string l3DevicePath, int blockSize, long maxCacheBytes`
- Organizes cache file as a hash table: block number -> slot index via `blockNumber % slotCount`
- Each slot: 8 bytes (block number) + blockSize bytes (data) + 8 bytes (checksum)
- `GetAsync` reads slot, verifies checksum (XxHash64), returns data if valid
- `PutAsync` writes to slot (open addressing with linear probe for collisions)
- Uses `FileStream` with `FileOptions.WriteThrough | FileOptions.Asynchronous` for durability
- Configurable `l3Device` path; disabled when path is null/empty
- `[SdkCompatibility("6.0.0")]`
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>L2 mmap cache provides zero-copy reads for large VDEs. L3 NVMe cache provides fast tiered storage for warm blocks evicted from L1.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- ARC algorithm correctly implements T1/T2/B1/B2 with self-tuning p
- L2 uses MemoryMappedFile for zero-copy
- L3 uses FileStream with WriteThrough for NVMe durability
</verification>

<success_criteria>
- VOPT-03 satisfied: L1 ARC with T1/T2/B1/B2 ghost lists, auto-sized from RAM
- VOPT-04 satisfied: L2 mmap for zero-copy read, OS page cache eviction
- VOPT-05 satisfied: L3 NVMe read cache with configurable device path
- All classes have [SdkCompatibility("6.0.0")] attribute
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-02-SUMMARY.md`
</output>
