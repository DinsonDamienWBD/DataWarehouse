---
phase: 87-vde-scalable-internals
plan: 04
type: execute
wave: 2
depends_on: ["87-01", "87-03"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Allocation/ExtentTree.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Allocation/ExtentTreeNode.cs
autonomous: true

must_haves:
  truths:
    - "Extent tree replaces indirect block pointers with start+length extent descriptors"
    - "Up to 4 extents stored inline in inode, overflow to extent tree blocks"
    - "1TB file requires ~64 extents instead of ~268M indirect pointers"
    - "Extent tree is B+tree ordered by logical offset for O(log n) lookup"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Allocation/ExtentTree.cs"
      provides: "B+tree of extents with insert, lookup, split, and merge"
      contains: "class ExtentTree"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Allocation/ExtentTreeNode.cs"
      provides: "On-disk node format for extent tree internal and leaf nodes"
      contains: "class ExtentTreeNode"
  key_links:
    - from: "ExtentTree.cs"
      to: "InodeExtent"
      via: "stores InodeExtent entries in tree nodes"
      pattern: "InodeExtent"
    - from: "ExtentTree.cs"
      to: "IBlockAllocator"
      via: "allocates blocks for new tree nodes"
      pattern: "IBlockAllocator"
---

<objective>
Implement extent-based inode addressing (VOPT-09) via an on-disk B+tree of extent descriptors. This replaces the traditional indirect/double-indirect/triple-indirect block pointer scheme with a compact extent tree that maps logical file offsets to physical block ranges.

Purpose: Reduces metadata overhead by orders of magnitude for large files (1TB file: ~64 extents vs ~268M indirect pointers).
Output: Two files in `DataWarehouse.SDK/VirtualDiskEngine/Allocation/`.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/IBlockAllocator.cs
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ExtentTreeNode on-disk format</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Allocation/ExtentTreeNode.cs
  </files>
  <action>
Create `ExtentTreeNode` class with `[SdkCompatibility("6.0.0")]`:
- Represents one block-sized node in the extent B+tree
- Header (32 bytes): Magic(4, "EXTN") + Level(2, 0=leaf) + EntryCount(2) + ParentBlock(8) + NextSiblingBlock(8, for leaf chain) + PrevSiblingBlock(8, for leaf chain)
- Node type: `bool IsLeaf => Level == 0`
- Leaf entries: array of `InodeExtent` (24 bytes each) sorted by LogicalOffset
- Internal entries: array of `(long LogicalOffset, long ChildBlockNumber)` (16 bytes each) sorted by LogicalOffset
- `int MaxLeafEntries(int blockSize)` = `(blockSize - 32 - UniversalBlockTrailerSize) / 24`
- `int MaxInternalEntries(int blockSize)` = `(blockSize - 32 - UniversalBlockTrailerSize) / 16`
- For 4KB blocks: ~168 leaf entries, ~253 internal entries per node
- `static void Serialize(ExtentTreeNode node, Span<byte> buffer, int blockSize)` -- writes node with Universal Block Trailer
- `static ExtentTreeNode Deserialize(ReadOnlySpan<byte> buffer, int blockSize)` -- reads and verifies trailer
- `InodeExtent? FindExtent(long logicalOffset)` -- binary search within leaf node
- `int InsertEntry(InodeExtent extent)` -- inserts maintaining sort order, returns index. Returns -1 if full.
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>ExtentTreeNode provides serializable B+tree nodes with sorted extent entries, supporting 168 extents per 4KB leaf node.</done>
</task>

<task type="auto">
  <name>Task 2: ExtentTree B+tree operations</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Allocation/ExtentTree.cs
  </files>
  <action>
Create `ExtentTree` class with `[SdkCompatibility("6.0.0")]`:
- Constructor: `IBlockDevice device, IBlockAllocator allocator, int blockSize, long rootBlockNumber`
- Tree operations (all async, block I/O via IBlockDevice):
  - `Task<InodeExtent?> LookupAsync(long logicalOffset, CancellationToken ct)` -- traverses from root to leaf, binary search at each level
  - `Task InsertAsync(InodeExtent extent, CancellationToken ct)` -- inserts extent, splits nodes if full (standard B+tree split)
  - `Task<bool> RemoveAsync(long logicalOffset, CancellationToken ct)` -- removes extent covering the offset, merges underfull nodes
  - `Task<IReadOnlyList<InodeExtent>> GetAllExtentsAsync(CancellationToken ct)` -- leaf chain scan returning all extents in order
  - `Task<long> GetPhysicalBlockAsync(long logicalOffset, int blockSize, CancellationToken ct)` -- translates logical offset to physical block number
- Split logic: when leaf is full, allocate new node, split entries 50/50, push median up to parent. If parent full, split recursively. If root splits, allocate new root (tree grows taller).
- Merge logic: when node falls below 40% capacity after delete, merge with sibling or redistribute
- Integration with InodeV2: first 4 extents from inode inline slots (ExtentCount 0-4 in InodeV2.Extents), overflow stored in this tree starting from IndirectExtentBlock
- `static Task<ExtentTree> CreateAsync(IBlockDevice device, IBlockAllocator allocator, int blockSize, CancellationToken ct)` -- allocates root block, initializes empty tree
- `int Height` property -- current tree depth
- `long NodeCount` property -- total nodes in tree
  </action>
  <verify>Build compiles: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>ExtentTree provides a complete B+tree for extent-based addressing with O(log n) lookup, insert, remove, and ordered scan.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with zero errors
- ExtentTree correctly integrates with InodeV2 inline extents (first 4) and overflow
- Node split/merge logic maintains B+tree invariants
</verification>

<success_criteria>
- VOPT-09 satisfied: Extent tree replaces indirect pointers with start+length extents
- Inline extents (<=4) stored in InodeV2, overflow in B+tree
- 1TB file with 4KB blocks = ~64 extents in tree (vs 268M indirect pointers)
</success_criteria>

<output>
After completion, create `.planning/phases/87-vde-scalable-internals/87-04-SUMMARY.md`
</output>
