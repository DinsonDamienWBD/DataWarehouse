---
phase: 65.2-raft-migration-persistence-verification-obsolete-code-removal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Consensus/IRaftLogStore.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Consensus/InMemoryRaftLogStore.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Locking/IDistributedLockService.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Locking/DistributedLockService.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Locking/DistributedLock.cs
autonomous: true

must_haves:
  truths:
    - "FileRaftLogStore exists in SDK namespace and implements SDK IRaftLogStore"
    - "DistributedLockService provides lease-based distributed locking via SDK contracts"
    - "SDK IRaftLogStore has GetPersistentStateAsync/SavePersistentStateAsync/CompactAsync methods"
    - "dotnet build DataWarehouse.slnx passes with zero warnings"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs"
      provides: "Production file-based Raft log store with fsync durability"
      contains: "class FileRaftLogStore"
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Locking/IDistributedLockService.cs"
      provides: "Distributed locking contract"
      contains: "interface IDistributedLockService"
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Locking/DistributedLockService.cs"
      provides: "Lease-based distributed lock implementation"
      contains: "class DistributedLockService"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs"
      to: "DataWarehouse.SDK/Infrastructure/Distributed/Consensus/IRaftLogStore.cs"
      via: "implements interface"
      pattern: "class FileRaftLogStore.*IRaftLogStore"
    - from: "DataWarehouse.SDK/Infrastructure/Distributed/Consensus/RaftConsensusEngine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs"
      via: "constructor injection"
      pattern: "IRaftLogStore"
---

<objective>
Migrate FileRaftLogStore and DistributedLock from the obsolete Raft plugin into the SDK, making them available for all plugins via SDK contracts.

Purpose: The old Raft plugin is marked obsolete and must be deleted, but FileRaftLogStore (file-based durable log with fsync) and DistributedLock (lease-based locking) are production assets needed by the SDK RaftConsensusEngine and MultiRaftManager. Moving them to SDK preserves these capabilities while enabling the old plugin's deletion.

Output: FileRaftLogStore.cs in SDK consensus directory, distributed locking service in SDK locking directory, updated IRaftLogStore interface with full API surface.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/IRaftLogStore.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/InMemoryRaftLogStore.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/RaftLogEntry.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/RaftState.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/RaftConsensusEngine.cs
@Plugins/DataWarehouse.Plugins.Raft/FileRaftLogStore.cs
@Plugins/DataWarehouse.Plugins.Raft/IRaftLogStore.cs
@Plugins/DataWarehouse.Plugins.Raft/RaftConsensusPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SDK IRaftLogStore and migrate FileRaftLogStore to SDK</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Distributed/Consensus/IRaftLogStore.cs
    DataWarehouse.SDK/Infrastructure/Distributed/Consensus/InMemoryRaftLogStore.cs
    DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs
  </files>
  <action>
1. **Extend SDK IRaftLogStore** (`DataWarehouse.SDK/Infrastructure/Distributed/Consensus/IRaftLogStore.cs`):
   The SDK's IRaftLogStore currently has: AppendAsync, GetAsync, GetRangeAsync, TruncateFromAsync, GetLastIndexAsync, GetLastTermAsync, GetFromAsync, Count.
   The old Raft plugin's IRaftLogStore additionally has: GetPersistentStateAsync, SavePersistentStateAsync, CompactAsync.
   Add these three methods to the SDK interface:
   - `Task<(long term, string? votedFor)> GetPersistentStateAsync();`
   - `Task SavePersistentStateAsync(long term, string? votedFor);`
   - `Task CompactAsync(long upToIndex);`
   Update the interface XML doc remarks to reference FileRaftLogStore by name.
   Update SdkCompatibility attribute to note "Phase 65.2: Added persistent state and compaction".

2. **Update InMemoryRaftLogStore** to implement the 3 new methods:
   - `GetPersistentStateAsync`: Return stored term/votedFor from in-memory fields (add `private long _currentTerm; private string? _votedFor;`).
   - `SavePersistentStateAsync`: Store term/votedFor in the in-memory fields.
   - `CompactAsync`: Remove entries up to the specified index, reindex remaining entries (same logic as old plugin's CompactAsync).
   Keep the class `internal sealed`.

3. **Create FileRaftLogStore** at `DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs`:
   - Namespace: `DataWarehouse.SDK.Infrastructure.Distributed`
   - Class: `public sealed class FileRaftLogStore : IRaftLogStore, IDisposable`
   - Port ALL logic from `Plugins/DataWarehouse.Plugins.Raft/FileRaftLogStore.cs` (362 lines).
   - The old plugin uses its own `RaftLogEntry` type (`DataWarehouse.Plugins.Raft.RaftLogEntry`) with properties: Index, Term, Command, Payload, ProposalId, Timestamp (DateTime).
   - The SDK's `RaftLogEntry` has: Index, Term, Command, Payload, Timestamp (DateTimeOffset).
   - Adapt the migrated code to use SDK's RaftLogEntry. Note that SDK's RaftLogEntry has DateTimeOffset instead of DateTime, and lacks ProposalId -- this is fine since ProposalId was never used in the file store serialization.
   - The old plugin's FileRaftLogStore implements `IRaftLogStore` from the old plugin namespace which has different method signatures:
     - Old: `GetEntryAsync(long index)` -> SDK: `GetAsync(long index)` (same semantics)
     - Old: `GetEntriesFromAsync(long startIndex)` returning `IEnumerable<RaftLogEntry>` -> SDK: `GetFromAsync(long fromIndex)` returning `IReadOnlyList<RaftLogEntry>`
     - Old has `GetPersistentStateAsync` / `SavePersistentStateAsync` / `CompactAsync` -> Add these to SDK interface (step 1 above)
     - SDK additionally requires: `GetRangeAsync(long fromIndex, long toIndex)` and `Count` property -> Implement these.
   - Preserve ALL durability guarantees: FileStream with FileOptions.WriteThrough, atomic rename via temp file, SemaphoreSlim for concurrency, corruption detection, post-crash recovery.
   - Add `[SdkCompatibility("5.0.0", Notes = "Phase 65.2: File-based durable Raft log store migrated from obsolete Raft plugin")]`
   - Add full XML documentation.
   - Use `Microsoft.Extensions.Logging.ILogger<FileRaftLogStore>` instead of Console.WriteLine for log messages (inject via constructor, make optional with null pattern).
   - Keep the `InitializeAsync()` pattern -- callers must call it before use.
  </action>
  <verify>
    `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors and zero warnings.
  </verify>
  <done>
    FileRaftLogStore.cs exists in SDK with all IRaftLogStore methods implemented including persistent state and compaction. InMemoryRaftLogStore updated with new methods. SDK builds clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add distributed locking service to SDK</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Distributed/Locking/IDistributedLockService.cs
    DataWarehouse.SDK/Infrastructure/Distributed/Locking/DistributedLockService.cs
    DataWarehouse.SDK/Infrastructure/Distributed/Locking/DistributedLock.cs
  </files>
  <action>
1. **Create directory** `DataWarehouse.SDK/Infrastructure/Distributed/Locking/` if it does not exist.

2. **Create DistributedLock.cs** — the lock record type:
   ```csharp
   namespace DataWarehouse.SDK.Infrastructure.Distributed;
   public sealed class DistributedLock
   {
       public string LockId { get; }
       public string Owner { get; }
       public DateTimeOffset AcquiredAt { get; }
       public TimeSpan LeaseTime { get; }
       public DateTimeOffset ExpiresAt => AcquiredAt + LeaseTime;
       public bool IsExpired => DateTimeOffset.UtcNow > ExpiresAt;
   }
   ```
   Use a constructor with required parameters (immutable). Add `[SdkCompatibility("5.0.0", Notes = "Phase 65.2")]`. Full XML docs.

3. **Create IDistributedLockService.cs** — the contract:
   ```csharp
   public interface IDistributedLockService
   {
       Task<DistributedLock?> TryAcquireAsync(string lockId, string owner, TimeSpan leaseTime, CancellationToken ct = default);
       Task<bool> TryRenewAsync(string lockId, string owner, TimeSpan newLeaseTime, CancellationToken ct = default);
       Task<bool> ReleaseAsync(string lockId, string owner, CancellationToken ct = default);
       Task<DistributedLock?> GetLockInfoAsync(string lockId, CancellationToken ct = default);
       Task CleanupExpiredLocksAsync(CancellationToken ct = default);
   }
   ```

4. **Create DistributedLockService.cs** — production implementation:
   - Uses BoundedDictionary<string, DistributedLock> for lock storage.
   - Thread-safe via SemaphoreSlim.
   - TryAcquireAsync: Check if lock exists and is not expired; if free, create lock and return it; if held, return null.
   - TryRenewAsync: Verify owner matches, update lease time.
   - ReleaseAsync: Verify owner matches, remove lock.
   - CleanupExpiredLocksAsync: Remove all expired locks.
   - Add ILogger<DistributedLockService> for observability.
   - This is the in-process implementation. For distributed (cross-node) locking, the RaftConsensusEngine can be used to achieve consensus on lock state -- document this in XML comments but keep the implementation self-contained.
   - `[SdkCompatibility("5.0.0", Notes = "Phase 65.2: Distributed locking service migrated from obsolete Raft plugin")]`

5. Build the SDK project to verify clean compilation.
  </action>
  <verify>
    `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors and zero warnings.
  </verify>
  <done>
    IDistributedLockService, DistributedLockService, and DistributedLock types exist in SDK. Lease-based acquire/renew/release/cleanup all implemented. SDK builds clean.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with zero errors and zero warnings
- FileRaftLogStore.cs exists at `DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs`
- Locking types exist at `DataWarehouse.SDK/Infrastructure/Distributed/Locking/`
- IRaftLogStore interface has AppendAsync, GetAsync, GetRangeAsync, TruncateFromAsync, GetLastIndexAsync, GetLastTermAsync, GetFromAsync, Count, GetPersistentStateAsync, SavePersistentStateAsync, CompactAsync
</verification>

<success_criteria>
- FileRaftLogStore migrated to SDK with full fsync durability preserved
- SDK IRaftLogStore extended with persistent state and compaction methods
- InMemoryRaftLogStore updated to implement new interface methods
- Distributed locking service with lease semantics in SDK
- SDK builds with zero errors and zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/65.2-raft-migration-persistence-verification-obsolete-code-removal/65.2-01-SUMMARY.md`
</output>
