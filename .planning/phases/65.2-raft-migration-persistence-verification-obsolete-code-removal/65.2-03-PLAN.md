---
phase: 65.2-raft-migration-persistence-verification-obsolete-code-removal
plan: 03
type: execute
wave: 2
depends_on: ["65.2-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateConsensus/UltimateConsensusPlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateConsensus/RaftGroup.cs
  - Plugins/DataWarehouse.Plugins.UltimateConsensus/LogEntry.cs
autonomous: true

must_haves:
  truths:
    - "UltimateConsensus uses SDK RaftConsensusEngine for distributed consensus instead of local-only RaftGroup"
    - "RaftGroup is replaced by SDK MultiRaftManager for group routing"
    - "Proposals go through real Raft log replication, not ConcurrentQueue"
    - "dotnet build DataWarehouse.slnx passes with zero warnings"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateConsensus/UltimateConsensusPlugin.cs"
      provides: "UltimateConsensus wired to SDK RaftConsensusEngine"
      contains: "RaftConsensusEngine"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateConsensus/UltimateConsensusPlugin.cs"
      to: "DataWarehouse.SDK/Infrastructure/Distributed/Consensus/RaftConsensusEngine.cs"
      via: "uses SDK engine for consensus"
      pattern: "RaftConsensusEngine"
    - from: "Plugins/DataWarehouse.Plugins.UltimateConsensus/UltimateConsensusPlugin.cs"
      to: "DataWarehouse.SDK/Infrastructure/Distributed/Consensus/MultiRaftManager.cs"
      via: "uses SDK multi-raft for group management"
      pattern: "MultiRaftManager"
---

<objective>
Rewire UltimateConsensus plugin to use the SDK's production RaftConsensusEngine and MultiRaftManager instead of its own simplified local-only RaftGroup.

Purpose: UltimateConsensus currently uses a simplified local-only RaftGroup class that simulates quorum (line 132: "For local Multi-Raft groups (same process), simulate quorum") and stores logs in a ConcurrentQueue with no persistence. This must be replaced with the SDK's production RaftConsensusEngine which has real leader election via RequestVote/AppendEntries RPCs, SWIM membership integration, HMAC-SHA256 auth, and IRaftLogStore-backed persistence.

Output: UltimateConsensusPlugin rewired to delegate consensus to SDK RaftConsensusEngine via MultiRaftManager. The simplified RaftGroup.cs either deleted or substantially refactored to be a thin wrapper.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/65.2-raft-migration-persistence-verification-obsolete-code-removal/65.2-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateConsensus/UltimateConsensusPlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateConsensus/RaftGroup.cs
@Plugins/DataWarehouse.Plugins.UltimateConsensus/LogEntry.cs
@Plugins/DataWarehouse.Plugins.UltimateConsensus/IRaftStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateConsensus/ConsistentHash.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/RaftConsensusEngine.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/MultiRaftManager.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/IRaftLogStore.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Consensus/FileRaftLogStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewire UltimateConsensusPlugin to use SDK RaftConsensusEngine</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateConsensus/UltimateConsensusPlugin.cs
    Plugins/DataWarehouse.Plugins.UltimateConsensus/RaftGroup.cs
    Plugins/DataWarehouse.Plugins.UltimateConsensus/LogEntry.cs
  </files>
  <action>
**IMPORTANT CONTEXT:** UltimateConsensus is a plugin that references ONLY the SDK. The SDK provides `RaftConsensusEngine`, `MultiRaftManager`, `IRaftLogStore`, `FileRaftLogStore`. The plugin must use these SDK types for real distributed consensus.

**Step 1: Understand the current architecture:**
- `UltimateConsensusPlugin` creates `_groupCount` RaftGroup instances in `InitializeGroupsAsync()`
- Each RaftGroup independently manages local-only leader election and ConcurrentQueue-based log
- `ConsistentHash` routes proposals to groups by key
- `IRaftStrategy` (Raft, Paxos, PBFT, ZAB) is the strategy pattern for consensus algorithms

**Step 2: Rewire UltimateConsensusPlugin:**
- Replace `BoundedDictionary<int, RaftGroup> _raftGroups` with SDK's `MultiRaftManager`
- The MultiRaftManager already handles: group creation/removal, jump consistent hash routing, per-group RaftConsensusEngine instances
- However, MultiRaftManager uses string group IDs and takes IClusterMembership + IP2PNetwork in constructor
- For single-node/local mode (which is what UltimateConsensus does now), the plugin needs to provide lightweight implementations of IClusterMembership and IP2PNetwork that work locally
- Check if the SDK already has local/in-process implementations of these interfaces. If InMemory/Local implementations exist, use them. If not, create minimal private inner classes within the plugin that implement these interfaces for local-only operation.

**Step 3: Adapt the wiring:**
- In `OnHandshakeAsync`, initialize MultiRaftManager instead of manual RaftGroup creation
- Create string group IDs like "group-0", "group-1", etc.
- For each group, MultiRaftManager creates a RaftConsensusEngine with the provided IRaftLogStore
- Use InMemoryRaftLogStore for single-node (local) mode. Use FileRaftLogStore when a data directory is configured (check plugin config or PluginBase.StateStore path).
- Route proposals via MultiRaftManager.ProposeToGroupAsync instead of custom ConsistentHash + RaftGroup

**Step 4: Keep IRaftStrategy interface:**
- The strategy pattern (Raft/Paxos/PBFT/ZAB) is the plugin's value-add on top of SDK infrastructure
- RaftStrategy should delegate to RaftConsensusEngine (via MultiRaftManager)
- Paxos/PBFT/ZAB strategies keep their existing implementations (they are independent consensus algorithms)

**Step 5: Handle RaftGroup.cs:**
- DELETE or gut RaftGroup.cs since MultiRaftManager + RaftConsensusEngine replace it entirely
- If any strategy (Paxos/PBFT/ZAB) still references RaftGroup-like state, refactor to use their own state objects
- The LogEntry.cs in UltimateConsensus can be deleted â€” use SDK's RaftLogEntry instead

**Step 6: Update ConsensusPluginBase overrides:**
- `IsLeader`: Query MultiRaftManager for any group where local node is leader
- `ProposeAsync(Proposal)`: Route through MultiRaftManager
- `ProposeAsync(byte[], CancellationToken)`: Route through MultiRaftManager
- `GetClusterStateAsync()`: Aggregate from MultiRaftManager's groups
- `GetStateAsync()`: Aggregate from MultiRaftManager
- `GetClusterHealthAsync()`: Aggregate health from all groups
- `IsLeaderAsync()`: Query MultiRaftManager

**Step 7: Preserve all existing public API:**
- `ProposeToGroupAsync(byte[], int, CancellationToken)` must still work
- `CreateStrategy(string)` and `SetActiveStrategy(string)` must still work
- `GroupCount` property must still work
- All message handlers (consensus.propose, consensus.status, consensus.health) must still work

**Step 8: Dispose properly:**
- Dispose MultiRaftManager in the Dispose override (it implements IDisposable)

**Anti-patterns to avoid:**
- Do NOT create a direct project reference to the old Raft plugin (it will be deleted in Plan 04)
- Do NOT duplicate RaftConsensusEngine logic -- delegate to SDK
- Do NOT remove Paxos/PBFT/ZAB strategies -- they are independent consensus implementations
  </action>
  <verify>
    `dotnet build DataWarehouse.slnx` compiles with zero errors and zero warnings. The UltimateConsensusPlugin.cs contains references to `RaftConsensusEngine` or `MultiRaftManager` from the SDK namespace.
  </verify>
  <done>
    UltimateConsensus delegates Raft consensus to SDK's RaftConsensusEngine via MultiRaftManager. The simplified local-only RaftGroup is removed. LogEntry.cs deleted (using SDK RaftLogEntry). All public API preserved. Build passes clean.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.slnx` passes with zero errors and zero warnings
- UltimateConsensusPlugin.cs references RaftConsensusEngine or MultiRaftManager
- RaftGroup.cs is deleted or reduced to a thin wrapper
- LogEntry.cs deleted (SDK RaftLogEntry used instead)
- All existing message bus topics (consensus.propose, consensus.status, consensus.health) still handled
</verification>

<success_criteria>
- UltimateConsensus uses production SDK RaftConsensusEngine for Raft consensus
- No more local-only quorum simulation for Raft
- Paxos/PBFT/ZAB strategies preserved
- All public API and message handlers preserved
- Build passes with zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/65.2-raft-migration-persistence-verification-obsolete-code-removal/65.2-03-SUMMARY.md`
</output>
