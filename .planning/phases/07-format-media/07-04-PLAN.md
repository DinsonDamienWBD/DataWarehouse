---
phase: 07-format-media
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/KafkaStreamStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/PulsarStreamStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/RabbitMqStreamStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/NatsStreamStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/MqttStreamStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/CoapStreamStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/LoRaWanStreamStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/ZigbeeStreamStrategy.cs
  - Metadata/TODO.md
autonomous: true

must_haves:
  truths:
    - "Message queue strategies (Kafka, Pulsar, RabbitMQ, NATS) handle pub/sub messaging"
    - "IoT protocol strategies (MQTT, CoAP, LoRaWAN, Zigbee) process sensor data streams"
    - "All strategies implement IStreamingStrategy from SDK"
    - "Strategies support windowing, state management, and fault tolerance"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/KafkaStreamStrategy.cs"
      provides: "Kafka streaming with exactly-once semantics"
      exports: ["KafkaStreamStrategy"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/MqttStreamStrategy.cs"
      provides: "MQTT pub/sub for IoT devices"
      exports: ["MqttStreamStrategy"]
  key_links:
    - from: "KafkaStreamStrategy"
      to: "SDK.Contracts.Streaming.StreamingStrategyBase"
      via: "inheritance with exactly-once delivery guarantee"
      pattern: "DeliveryGuarantee\\.ExactlyOnce"
    - from: "MqttStreamStrategy"
      to: "SDK.Contracts.Streaming.StreamingStrategyBase"
      via: "inheritance with QoS support"
      pattern: "SupportsQualityOfService = true"
---

<objective>
Verify and complete UltimateStreamingData message queue and IoT protocol strategies (T113.B2-B3).

Purpose: Verify existing UltimateStreamingData plugin (8 strategy category files already exist). Add missing message queue and IoT protocol strategies, or verify they're complete. Research shows plugin exists but strategy count unknown.

Output: Production-ready message queue and IoT streaming strategies.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-format-media/07-RESEARCH.md
@DataWarehouse.SDK/Contracts/Streaming/StreamingStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateStreamingData/UltimateStreamingDataPlugin.cs
@.planning/phases/06-interface-layer/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify existing strategies and identify gaps</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/StreamProcessing/StreamProcessingEngineStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/Windowing/WindowingStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/State/StateManagementStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/FaultTolerance/FaultToleranceStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/Analytics/StreamAnalyticsStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/Pipelines/RealTimePipelineStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/EventDriven/EventDrivenArchitectureStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/Scalability/ScalabilityStrategies.cs
  </files>
  <action>
**Audit existing strategy files:**

1. Read each of the 8 existing strategy category files
2. Count how many IStreamingStrategy implementations exist per file
3. Identify which strategies are present (e.g., Kafka, Pulsar, Flink, Spark)
4. Check if message queue and IoT strategies exist
5. Verify strategies extend StreamingStrategyBase from SDK

**Expected findings:**
- StreamProcessingEngineStrategies.cs: Kafka, Pulsar, Flink, Spark, etc.
- If message queue strategies already exist → mark T113.B2 complete
- If IoT strategies exist → mark T113.B3 complete
- If missing → identify gap and proceed to Task 2

**Discovery pattern from research:**
```csharp
// UltimateStreamingDataPlugin uses reflection-based discovery
var strategyTypes = assembly.GetTypes()
    .Where(t => !t.IsAbstract && typeof(IStreamingDataStrategy).IsAssignableFrom(t));
```

**Key distinction from research:** SDK has IStreamingStrategy (pub/sub) vs plugin-specific IStreamingDataStrategy (processing). Verify which interface is used.

**Report format:**
```
File: StreamProcessingEngineStrategies.cs
  Strategies found: [KafkaStreamStrategy, PulsarStreamStrategy, ...]
  Count: N
  Interface: IStreamingDataStrategy

File: [...]
```

**Action:** If message queue or IoT strategies NOT found → proceed to Task 2 to implement them.
  </action>
  <verify>
```bash
# Count total strategy classes:
grep -r "class.*Strategy.*:" Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/ | wc -l

# Check for Kafka:
grep -r "KafkaStreamStrategy\|KafkaStrategy" Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/

# Check for MQTT:
grep -r "MqttStreamStrategy\|MqttStrategy" Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/
```
  </verify>
  <done>
- [ ] All 8 strategy files audited
- [ ] Strategy count per file recorded
- [ ] Presence/absence of message queue strategies confirmed
- [ ] Presence/absence of IoT strategies confirmed
- [ ] Gap analysis complete
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement missing message queue and IoT strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/KafkaStreamStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/PulsarStreamStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/RabbitMqStreamStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/MessageQueue/NatsStreamStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/MqttStreamStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/CoapStreamStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/LoRaWanStreamStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreamingData/Strategies/IoT/ZigbeeStreamStrategy.cs
    Metadata/TODO.md
  </files>
  <action>
**CONDITIONAL: Only execute if Task 1 identified gaps.**

**If strategies already exist:** Mark T113.B2-B3 complete in TODO.md, skip implementation.

**If strategies missing:** Implement the following.

**Message Queue Strategies (4):**

**1. KafkaStreamStrategy** (strategyId: "kafka")
- Protocol: Apache Kafka
- StreamingCapabilities:
  - SupportsOrdering: true (partition ordering)
  - SupportsPartitioning: true (topic partitions)
  - SupportsExactlyOnce: true (idempotent producer + transactions)
  - SupportsReplay: true (consumer offsets)
  - SupportsPersistence: true (log-based storage)
  - SupportsConsumerGroups: true
  - MaxRetention: 7 days (configurable)
- PublishAsync: Send message to topic with optional partition key
- SubscribeAsync: Consumer group subscription with offset management
- **Research note:** Use Confluent.Kafka library (research don't-hand-roll section)

**2. PulsarStreamStrategy** (strategyId: "pulsar")
- Protocol: Apache Pulsar
- StreamingCapabilities:
  - SupportsOrdering: true
  - SupportsPartitioning: true
  - SupportsExactlyOnce: true (deduplication)
  - SupportsReplay: true
  - SupportsPersistence: true
  - SupportsMultiTenancy: true
- PublishAsync: Send to topic with tenant/namespace
- SubscribeAsync: Subscription modes (exclusive, shared, failover, key_shared)

**3. RabbitMqStreamStrategy** (strategyId: "rabbitmq")
- Protocol: AMQP 0-9-1
- StreamingCapabilities:
  - SupportsOrdering: false (no guaranteed ordering)
  - SupportsExactlyOnce: false (at-most-once or at-least-once)
  - SupportsPersistence: true (durable queues)
  - SupportsDeadLetterQueue: true
  - SupportsMessageFiltering: true (routing keys, headers exchange)
- PublishAsync: Publish to exchange with routing key
- SubscribeAsync: Bind queue to exchange with consumer

**4. NatsStreamStrategy** (strategyId: "nats")
- Protocol: NATS JetStream
- StreamingCapabilities:
  - SupportsOrdering: true (JetStream)
  - SupportsExactlyOnce: true (JetStream deduplication)
  - SupportsReplay: true (JetStream)
  - SupportsPersistence: true (JetStream)
  - MaxMessageSize: 1MB
- PublishAsync: Publish to subject
- SubscribeAsync: Subscribe to subject pattern with optional queue group

**IoT Protocol Strategies (4):**

**5. MqttStreamStrategy** (strategyId: "mqtt")
- Protocol: MQTT 3.1.1 / 5.0
- StreamingCapabilities:
  - SupportsQualityOfService: true (QoS 0, 1, 2)
  - SupportsRetainedMessages: true
  - SupportsWildcards: true (topic filters)
  - MaxMessageSize: 256MB (MQTT 5.0)
  - LowBandwidth: true
- PublishAsync: Publish to topic with QoS
- SubscribeAsync: Subscribe to topic pattern with QoS
- **Research note:** Ideal for IoT devices with unreliable networks

**6. CoapStreamStrategy** (strategyId: "coap")
- Protocol: CoAP (Constrained Application Protocol)
- StreamingCapabilities:
  - LowBandwidth: true
  - SupportsObservation: true (CoAP Observe)
  - MaxMessageSize: 1KB (typical)
  - UdpBased: true
- PublishAsync: POST to CoAP resource
- SubscribeAsync: GET with Observe option
- **Research note:** CoAP is RESTful protocol for constrained devices

**7. LoRaWanStreamStrategy** (strategyId: "lorawan")
- Protocol: LoRaWAN
- StreamingCapabilities:
  - LowBandwidth: true (extremely low)
  - LongRange: true (10+ km)
  - MaxMessageSize: 243 bytes
  - BatteryOptimized: true
- PublishAsync: Send uplink message via gateway
- SubscribeAsync: Receive downlink messages
- **Research note:** LoRaWAN for long-range, low-power IoT

**8. ZigbeeStreamStrategy** (strategyId: "zigbee")
- Protocol: Zigbee
- StreamingCapabilities:
  - MeshNetwork: true
  - LowPower: true
  - MaxMessageSize: 127 bytes (802.15.4)
- PublishAsync: Send to Zigbee coordinator
- SubscribeAsync: Receive from endpoint
- **Research note:** Zigbee for home automation and industrial IoT

**All strategies:**
- Extend StreamingStrategyBase from SDK
- Implement PublishAsync, SubscribeAsync, UnsubscribeAsync
- Set SupportedProtocols (e.g., ["kafka", "kafka-ssl"])
- Wire ConfigureIntelligence for AI integration
- Message bus routing for data operations (not direct I/O)

**Mark complete in TODO.md:** T113.B2 (message queue strategies), T113.B3 (IoT protocol strategies).

**Why this approach:** Research shows existing plugin but unknown strategy count. Verify-before-implement (Rule 13 compliance). Stubs acceptable for IoT protocols requiring hardware integration.
  </action>
  <verify>
```bash
cd Plugins/DataWarehouse.Plugins.UltimateStreamingData && dotnet build
# Expect: Build succeeded

# Count new strategies:
ls Strategies/MessageQueue/*.cs 2>/dev/null | wc -l  # Expect: 4
ls Strategies/IoT/*.cs 2>/dev/null | wc -l           # Expect: 4
```
  </verify>
  <done>
- [ ] Gap analysis from Task 1 drives implementation
- [ ] If strategies exist: TODO.md marked complete
- [ ] If strategies missing: 8 strategies implemented (4 message queue + 4 IoT)
- [ ] All strategies extend StreamingStrategyBase
- [ ] StreamingCapabilities defined with correct flags
- [ ] Builds without errors
  </done>
</task>

</tasks>

<verification>
1. Audit existing strategies: Read 8 strategy category files, count implementations
2. Build verification: `cd Plugins/DataWarehouse.Plugins.UltimateStreamingData && dotnet build`
3. Strategy discovery: Plugin orchestrator finds all strategies via reflection
4. Interface compliance: All strategies implement IStreamingStrategy or IStreamingDataStrategy
5. Capability flags: Kafka has ExactlyOnce=true, MQTT has QualityOfService=true
</verification>

<success_criteria>
- [ ] Existing strategies audited with gap analysis complete
- [ ] Message queue strategies (Kafka, Pulsar, RabbitMQ, NATS) verified or implemented
- [ ] IoT strategies (MQTT, CoAP, LoRaWAN, Zigbee) verified or implemented
- [ ] All strategies extend StreamingStrategyBase from SDK
- [ ] StreamingCapabilities correctly configured per protocol
- [ ] Build passes with zero errors
- [ ] TODO.md updated for T113.B2-B3
</success_criteria>

<output>
After completion, create `.planning/phases/07-format-media/07-04-SUMMARY.md`
</output>
