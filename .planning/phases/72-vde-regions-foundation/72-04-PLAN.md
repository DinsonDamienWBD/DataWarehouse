---
phase: 72-vde-regions-foundation
plan: 04
type: execute
wave: 3
depends_on: ["72-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/ReplicationStateRegion.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/RaidMetadataRegion.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "DVV vectors track causal ordering across replicas"
    - "Watermarks record per-replica sync progress"
    - "Dirty bitmap identifies blocks needing replication"
    - "Shard maps describe data distribution across RAID members"
    - "Parity layout records which blocks hold parity data"
    - "Rebuild progress tracks partial RAID reconstruction"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/ReplicationStateRegion.cs"
      provides: "DVV, watermarks, dirty bitmap for distributed sync"
      contains: "class ReplicationStateRegion"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/RaidMetadataRegion.cs"
      provides: "Shard maps, parity layout, rebuild progress"
      contains: "class RaidMetadataRegion"
  key_links:
    - from: "ReplicationStateRegion.cs"
      to: "BlockTypeTags.REPL"
      via: "block type tag"
      pattern: "BlockTypeTags\\.REPL"
    - from: "RaidMetadataRegion.cs"
      to: "BlockTypeTags.RAID"
      via: "block type tag"
      pattern: "BlockTypeTags\\.RAID"
---

<objective>
Implement the Replication State Region and RAID Metadata Region -- two infrastructure regions that enable distributed sync and redundancy.

Purpose: Replication State tracks causal ordering and sync progress for multi-node VDE replication. RAID Metadata stores the layout information needed for data striping, parity, and rebuild operations.
Output: Two production-ready region classes in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replication State Region (VREG-05)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/ReplicationStateRegion.cs</files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/Regions/ReplicationStateRegion.cs` in namespace `DataWarehouse.SDK.VirtualDiskEngine.Regions`.

**DottedVersionVector (DVV) struct:**
- `Guid ReplicaId` (16 bytes)
- `long Counter` (8 bytes) -- logical clock value
- `long TimestampUtcTicks` (8 bytes) -- wall-clock for conflict hints
- Serialized: 32 bytes per entry

**ReplicationWatermark struct:**
- `Guid ReplicaId` (16 bytes)
- `long LastSyncedBlock` (8 bytes) -- highest block known to be replicated
- `long LastSyncedGeneration` (8 bytes) -- generation at time of sync
- `long SyncTimestampUtcTicks` (8 bytes) -- when sync completed
- `byte SyncStatus` (1 byte) -- 0=Idle, 1=Syncing, 2=Complete, 3=Failed
- `byte Reserved1, Reserved2, Reserved3` (3 bytes padding)
- `int PendingBlockCount` (4 bytes) -- blocks awaiting replication
- Serialized: 48 bytes per entry

**DirtyBitmap:** A bit array where bit N=1 means block N has been modified since last successful replication. Stored as raw bytes.

**ReplicationStateRegion sealed class:**
- `public const int MaxReplicas = 32;` -- max tracked replica nodes
- `private readonly DottedVersionVector[] _vectors = new DottedVersionVector[MaxReplicas];`
- `private readonly ReplicationWatermark[] _watermarks = new ReplicationWatermark[MaxReplicas];`
- `private byte[] _dirtyBitmap;` -- initialized to track up to N blocks (configurable)
- `public int TrackedBlockCount { get; }` -- how many blocks the bitmap covers
- `public int ActiveReplicaCount { get; private set; }`
- `public uint Generation { get; set; }`

**Methods:**
- `ReplicationStateRegion(int trackedBlockCount)` -- constructor, bitmap size = ceil(trackedBlockCount/8)
- `void SetVector(int replicaIndex, DottedVersionVector dvv)` -- validates 0..31
- `DottedVersionVector GetVector(int replicaIndex)`
- `void IncrementVector(int replicaIndex)` -- increments counter, updates timestamp
- `DottedVersionVector[] GetAllVectors()` -- returns active vectors
- `void SetWatermark(int replicaIndex, ReplicationWatermark watermark)`
- `ReplicationWatermark GetWatermark(int replicaIndex)`
- `void MarkDirty(long blockIndex)` -- sets bit in dirty bitmap
- `void ClearDirty(long blockIndex)` -- clears bit
- `bool IsDirty(long blockIndex)` -- checks bit
- `int DirtyBlockCount` -- popcount of dirty bitmap
- `void ClearAllDirty()` -- zeros bitmap
- `IReadOnlyList<long> GetDirtyBlocks()` -- enumerates all set bits

**Serialization (2 blocks, registered with BlockTypeTags.REPL):**
- Block 0: [ActiveReplicaCount:2 LE][TrackedBlockCount:4 LE][Reserved:2][DVV entries x 32][Watermark entries x 32][UniversalBlockTrailer]
  - DVV: 32 * 32 = 1024 bytes. Watermarks: 32 * 48 = 1536 bytes. Header: 8 bytes. Total: 2568. Fits in 4080 payload.
- Block 1: [DirtyBitmap bytes...][zero-fill][UniversalBlockTrailer]
  - Max bitmap in one block payload (4080 bytes) = 32,640 blocks tracked. For larger VDEs, extend to more blocks.

**Methods:**
- `int RequiredBlocks(int blockSize)` -- 1 (header/vectors/watermarks) + ceil(bitmapBytes / payloadSize)
- `void Serialize(Span<byte> buffer, int blockSize)`
- `static ReplicationStateRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize, int blockCount)`

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- Replication State (VREG-05)")]`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class ReplicationStateRegion` confirms the file exists.
Grep for `DottedVersionVector` confirms DVV implementation.
Grep for `DirtyBitmap\|MarkDirty\|IsDirty` confirms dirty bitmap.
  </verify>
  <done>ReplicationStateRegion tracks up to 32 replicas with DVV vectors, per-replica watermarks, and a dirty bitmap for modified blocks. Serialize/Deserialize with trailer verification works.</done>
</task>

<task type="auto">
  <name>Task 2: RAID Metadata Region (VREG-06)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/RaidMetadataRegion.cs</files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/Regions/RaidMetadataRegion.cs` in namespace `DataWarehouse.SDK.VirtualDiskEngine.Regions`.

**RaidStrategy enum:**
- `None = 0, Raid0 = 1, Raid1 = 2, Raid5 = 3, Raid6 = 4, Raid10 = 5, RaidZ1 = 6, RaidZ2 = 7, RaidZ3 = 8`

**ShardDescriptor readonly struct:**
- `Guid DeviceId` (16 bytes) -- unique identifier of the storage device
- `long StartBlock` (8 bytes) -- first block on this device
- `long BlockCount` (8 bytes) -- number of blocks on this device
- `byte Status` (1 byte) -- 0=Online, 1=Degraded, 2=Offline, 3=Rebuilding, 4=Spare
- `byte Reserved1, Reserved2, Reserved3` (3 bytes padding)
- `int StripeIndex` (4 bytes) -- position in the stripe unit
- Serialized: 40 bytes per shard

**ParityDescriptor readonly struct:**
- `int StripeGroupIndex` (4 bytes) -- which stripe group
- `int ParityShardIndex` (4 bytes) -- which shard holds parity for this group
- `byte ParityType` (1 byte) -- 0=XOR, 1=ReedSolomon, 2=Diagonal
- `byte Reserved1, Reserved2, Reserved3` (3 bytes padding)
- Serialized: 12 bytes per descriptor

**RebuildProgress readonly struct:**
- `Guid DeviceId` (16 bytes) -- device being rebuilt
- `long TotalBlocks` (8 bytes) -- total blocks to rebuild
- `long CompletedBlocks` (8 bytes) -- blocks rebuilt so far
- `long LastRebuiltBlock` (8 bytes) -- last block successfully rebuilt
- `long StartTimeUtcTicks` (8 bytes)
- `long LastUpdateUtcTicks` (8 bytes)
- `byte Status` (1 byte) -- 0=NotStarted, 1=InProgress, 2=Paused, 3=Completed, 4=Failed
- `byte Reserved1, Reserved2, Reserved3` (3 bytes padding)
- `int ErrorCount` (4 bytes)
- Serialized: 64 bytes per rebuild

**RaidMetadataRegion sealed class:**
- `public const int MaxShards = 64;`
- `public const int MaxParityDescriptors = 256;`
- `public const int MaxConcurrentRebuilds = 4;`
- `public RaidStrategy Strategy { get; set; }`
- `public int StripeSize { get; set; }` -- blocks per stripe unit
- `public int DataShardCount { get; set; }`
- `public int ParityShardCount { get; set; }`
- `private readonly ShardDescriptor[] _shards = new ShardDescriptor[MaxShards];`
- `private readonly List<ParityDescriptor> _parityLayout;`
- `private readonly RebuildProgress[] _rebuilds = new RebuildProgress[MaxConcurrentRebuilds];`
- `public uint Generation { get; set; }`

**Methods:**
- `RaidMetadataRegion()` constructor
- `void SetShard(int index, ShardDescriptor shard)` -- validates 0..63
- `ShardDescriptor GetShard(int index)`
- `IReadOnlyList<ShardDescriptor> GetActiveShards()` -- returns non-Offline shards
- `void AddParityDescriptor(ParityDescriptor pd)`
- `IReadOnlyList<ParityDescriptor> GetParityLayout()`
- `void SetRebuildProgress(int index, RebuildProgress progress)` -- validates 0..3
- `RebuildProgress GetRebuildProgress(int index)`
- `bool HasActiveRebuild` -- any rebuild with Status=InProgress
- `double GetRebuildPercentage(int index)` -- CompletedBlocks / TotalBlocks * 100

**Serialization (2 blocks, registered with BlockTypeTags.RAID):**
- Block 0: [Strategy:1][StripeSize:4 LE][DataShardCount:1][ParityShardCount:1][ActiveShardCount:1][ParityDescCount:2 LE][RebuildCount:1][Reserved:5][ShardDescriptor entries x 64][UniversalBlockTrailer]
  - Header: 16 bytes. Shards: 64*40 = 2560. Total: 2576. Fits in 4080 payload.
- Block 1: [ParityDescriptor entries (up to 256)][RebuildProgress entries (up to 4)][zero-fill][UniversalBlockTrailer]
  - Parity: 256*12 = 3072. Rebuilds: 4*64 = 256. Total: 3328. Fits in 4080 payload.

**Methods:**
- `void Serialize(Span<byte> buffer, int blockSize)`
- `static RaidMetadataRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize)`

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- RAID Metadata (VREG-06)")]`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class RaidMetadataRegion` confirms the file exists.
Grep for `ShardDescriptor` confirms shard tracking.
Grep for `RebuildProgress` confirms rebuild progress tracking.
  </verify>
  <done>RaidMetadataRegion stores shard maps (64 shards), parity layout (256 descriptors), and rebuild progress (4 concurrent) for all RAID strategies. Serialize/Deserialize with trailer verification works.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- Both files exist in DataWarehouse.SDK/VirtualDiskEngine/Regions/
- ReplicationStateRegion has DVV, watermarks, dirty bitmap
- RaidMetadataRegion has shards, parity layout, rebuild progress
- Both use correct BlockTypeTags (REPL, RAID)
- Both write UniversalBlockTrailer on every block
</verification>

<success_criteria>
- ReplicationStateRegion: 32 replicas with DVV + watermarks + dirty bitmap for distributed sync
- RaidMetadataRegion: 64 shards, 256 parity descriptors, 4 concurrent rebuilds, all RAID strategies
- Both: production-ready serialization, [SdkCompatibility("6.0.0")]
</success_criteria>

<output>
After completion, create `.planning/phases/72-vde-regions-foundation/72-04-SUMMARY.md`
</output>
