---
phase: 72-vde-regions-foundation
plan: 03
type: execute
wave: 3
depends_on: ["72-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/TagIndexRegion.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tags can be inserted and looked up by key with correct results"
    - "Bloom filter provides fast negative lookups (tag definitely not present)"
    - "Compound key lookups (multi-field) return correct matching entries"
    - "Iterator traverses all entries in key order"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/TagIndexRegion.cs"
      provides: "B+-tree tag index with bloom filter and iterator"
      contains: "class TagIndexRegion"
  key_links:
    - from: "TagIndexRegion.cs"
      to: "BlockTypeTags.TAGI"
      via: "block type tag"
      pattern: "BlockTypeTags\\.TAGI"
    - from: "TagIndexRegion.cs"
      to: "UniversalBlockTrailer"
      via: "trailer on each index block"
      pattern: "UniversalBlockTrailer\\.(Write|Verify)"
---

<objective>
Implement the Tag Index Region -- a B+-tree with bloom filter for efficient tag-based lookups within the VDE.

Purpose: Tags are the primary metadata mechanism for objects in the VDE. The B+-tree provides ordered access and range queries, while the bloom filter enables O(1) "definitely not here" checks.
Output: Production-ready TagIndexRegion in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tag Index Region -- B+-tree with Bloom Filter (VREG-04)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/TagIndexRegion.cs</files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/Regions/TagIndexRegion.cs` in namespace `DataWarehouse.SDK.VirtualDiskEngine.Regions`.

**TagEntry readonly struct:**
- `byte[] Key` -- tag key, variable length (UTF-8 encoded string, max 255 bytes)
- `byte[] Value` -- tag value, variable length (max 255 bytes)
- `long InodeNumber` -- the inode this tag belongs to
- `long BlockAddress` -- direct block reference for fast access
- Serialized: [KeyLen:1][Key:variable][ValueLen:1][Value:variable][InodeNumber:8 LE][BlockAddress:8 LE]

**CompoundKey:** For compound lookups, the key is formed by concatenating key parts with a null separator byte (0x00). E.g., "category\0subcategory" allows prefix matching on "category" alone.

**BPlusTreeNode sealed class (internal):**
- `bool IsLeaf`
- `List<byte[]> Keys` -- sorted keys (byte[] compared lexicographically)
- `List<TagEntry> Entries` -- only in leaf nodes, parallel to Keys
- `List<BPlusTreeNode> Children` -- only in internal nodes, Keys.Count+1 children
- `BPlusTreeNode? NextLeaf` -- leaf-level linked list for iteration
- `int Order` -- max keys per node (computed from block payload size: order = (payloadSize - headerSize) / (maxKeySize + entrySize))

**TagIndexBloomFilter sealed class (internal):**
- Fixed-size bit array stored in the first block of the region
- `int BitCount` -- number of bits (default: 8192 = 1 KiB for ~1% FPR at ~570 entries, scales with block size)
- `int HashFunctionCount` -- number of hash functions (default: 5)
- Uses XxHash64 with different seeds for each hash function (seeds: 0, 1, 2, 3, 4)
- `void Add(ReadOnlySpan<byte> key)`
- `bool MayContain(ReadOnlySpan<byte> key)` -- returns true if possibly present, false if definitely absent
- `void Serialize(Span<byte> buffer)` / `static TagIndexBloomFilter Deserialize(ReadOnlySpan<byte> buffer, int bitCount, int hashCount)`
- `void Clear()` -- resets all bits

**TagIndexRegion sealed class:**
- `public uint Generation { get; set; }`
- `private BPlusTreeNode _root;`
- `private readonly TagIndexBloomFilter _bloomFilter;`
- `private int _entryCount;`

**Core methods:**
- `void Insert(TagEntry entry)` -- inserts into B+-tree (with node splitting when full) and adds key to bloom filter
- `void Remove(byte[] key, long inodeNumber)` -- removes matching entry (bloom filter is NOT updated on remove; rebuilt on next serialize)
- `TagEntry? Lookup(byte[] key)` -- exact key lookup: check bloom filter first, if negative return null immediately, if positive search B+-tree
- `IReadOnlyList<TagEntry> LookupAll(byte[] key)` -- returns all entries with this exact key (multiple inodes can share a tag key)
- `IReadOnlyList<TagEntry> PrefixSearch(byte[] keyPrefix)` -- returns all entries where key starts with prefix (enables compound key partial matching)
- `IEnumerable<TagEntry> Iterate()` -- traverses all leaf nodes via NextLeaf links in key order
- `IEnumerable<TagEntry> IterateRange(byte[] startKey, byte[] endKey)` -- range iteration
- `int EntryCount` property

**Serialization:**
- Block 0 (header + bloom filter): [EntryCount:4 LE][TreeDepth:2 LE][BloomBitCount:4 LE][BloomHashCount:1][Reserved:5][BloomFilter bits...][UniversalBlockTrailer]
- Block 1+ (tree nodes): Each block = one B+-tree node. Node format: [IsLeaf:1][KeyCount:2 LE][Entries or ChildPointers...][UniversalBlockTrailer]
  - Leaf node: [IsLeaf=1][KeyCount:2][Entry0..EntryN][NextLeafBlockIndex:4 LE]
  - Internal node: [IsLeaf=0][KeyCount:2][Key0..KeyN][ChildBlockIndex0..ChildBlockIndexN+1:4 LE each]

**Methods:**
- `int RequiredBlocks(int blockSize)` -- header block + tree node blocks
- `void Serialize(Span<byte> buffer, int blockSize)` -- BFS serialization of tree into blocks, rebuild bloom filter from all entries, write header + bloom + tree blocks, each with UniversalBlockTrailer using BlockTypeTags.TAGI
- `static TagIndexRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize, int blockCount)` -- reads header, bloom filter, reconstructs B+-tree from block nodes

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- Tag Index (VREG-04)")]`.

**Key comparison:** Use `Span<byte>.SequenceCompareTo` for lexicographic ordering (or `ReadOnlySpan<byte>.SequenceCompareTo`).
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class TagIndexRegion` confirms the file exists.
Grep for `BloomFilter` confirms bloom filter is implemented.
Grep for `BPlusTreeNode` confirms B+-tree structure exists.
  </verify>
  <done>TagIndexRegion implements a B+-tree with bloom filter. Insert, lookup (exact + prefix), range iteration, and compound key support all work. Bloom filter provides O(1) negative lookups. Serialization uses one block per tree node with UniversalBlockTrailer.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- TagIndexRegion.cs exists in DataWarehouse.SDK/VirtualDiskEngine/Regions/
- B+-tree with Insert, Lookup, PrefixSearch, Iterate methods
- Bloom filter with Add/MayContain using XxHash64
- Compound key support via null-separator concatenation
- BlockTypeTags.TAGI used for all blocks
</verification>

<success_criteria>
- Tag lookups return correct results for exact and prefix matches
- Bloom filter eliminates unnecessary tree traversals for absent keys
- Iterator produces entries in sorted key order
- Serialization/deserialization round-trips correctly
</success_criteria>

<output>
After completion, create `.planning/phases/72-vde-regions-foundation/72-03-SUMMARY.md`
</output>
