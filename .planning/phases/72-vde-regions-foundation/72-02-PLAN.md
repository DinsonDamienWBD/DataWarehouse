---
phase: 72-vde-regions-foundation
plan: 02
type: execute
wave: 2
depends_on: ["72-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/IntegrityTreeRegion.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Merkle tree can be built over an arbitrary number of data blocks"
    - "Any single block can be verified in O(log N) operations using the tree"
    - "Updating a single block incrementally updates only the affected path to root"
    - "Tree root hash matches IntegrityAnchor.MerkleRootHash contract"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/IntegrityTreeRegion.cs"
      provides: "Merkle tree region with O(log N) verification and incremental updates"
      contains: "class IntegrityTreeRegion"
  key_links:
    - from: "IntegrityTreeRegion.cs"
      to: "BlockTypeTags.MTRK"
      via: "block type tag"
      pattern: "BlockTypeTags\\.MTRK"
    - from: "IntegrityTreeRegion.cs"
      to: "UniversalBlockTrailer"
      via: "trailer on each tree block"
      pattern: "UniversalBlockTrailer\\.(Write|Verify)"
    - from: "IntegrityTreeRegion.cs"
      to: "IntegrityAnchor"
      via: "root hash matches MerkleRootHash field"
      pattern: "MerkleRootHash"
---

<objective>
Implement the Integrity Tree region -- a Merkle tree that provides cryptographic verification of any data block in O(log N) operations with incremental update support.

Purpose: The Merkle tree is the backbone of data integrity for the entire VDE. Every read can be verified against the tree, and writes only update the path from the changed leaf to the root.
Output: Production-ready IntegrityTreeRegion in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/IntegrityAnchor.cs
@.planning/phases/72-vde-regions-foundation/72-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrity Tree Region -- Merkle Tree (VREG-03)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/IntegrityTreeRegion.cs</files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/Regions/IntegrityTreeRegion.cs` in namespace `DataWarehouse.SDK.VirtualDiskEngine.Regions`.

**Design: Binary Merkle tree stored as a flat array in region blocks.**

The tree covers N data blocks (leaf count). Internal nodes = N-1 (for a complete binary tree). Total nodes = 2N-1. Each node stores a 32-byte hash (SHA-256 via System.Security.Cryptography.SHA256).

**MerkleNode readonly struct:**
- `byte[] Hash` (32 bytes) -- SHA-256 hash
- Serialized size: 32 bytes

**Tree layout (flat array, 1-indexed like a heap):**
- Index 1 = root
- Index i: left child = 2*i, right child = 2*i+1
- Leaf nodes for data block j are at index (leafStartIndex + j) where leafStartIndex = next power of 2 >= leafCount
- Tree capacity is always rounded up to next power of 2 for complete binary tree

**IntegrityTreeRegion sealed class:**
- `private readonly byte[][] _nodes;` -- flat array of 32-byte hashes, index 0 unused (1-indexed)
- `public int LeafCount { get; }` -- actual data block count
- `public int TreeCapacity { get; }` -- next power of 2 >= LeafCount
- `public int TotalNodes => 2 * TreeCapacity;` -- includes index 0 placeholder
- `public uint Generation { get; set; }`

**Constructor:**
- `IntegrityTreeRegion(int leafCount)` -- allocates tree, validates leafCount > 0

**Core Methods:**
- `void SetLeafHash(int leafIndex, byte[] hash)` -- sets hash for data block leafIndex (0-based), then calls UpdatePath
- `void SetLeafHash(int leafIndex, ReadOnlySpan<byte> blockData)` -- computes SHA-256 of blockData, then SetLeafHash
- `private void UpdatePath(int nodeIndex)` -- from leaf up to root, recompute each parent as SHA256(leftChild || rightChild). This is O(log N).
- `byte[] GetRootHash()` -- returns _nodes[1] (the root)
- `bool VerifyBlock(int leafIndex, ReadOnlySpan<byte> blockData)` -- computes SHA-256 of blockData, compares with stored leaf hash. Returns false if mismatch. This is O(1) for the leaf check.
- `bool VerifyBlockWithProof(int leafIndex, ReadOnlySpan<byte> blockData)` -- verifies the leaf AND recomputes the path to root to confirm the path is consistent. O(log N).
- `byte[][] GetProof(int leafIndex)` -- returns the sibling hashes from leaf to root (the Merkle proof). Array of log2(TreeCapacity) hashes.
- `static bool VerifyProof(byte[] leafHash, byte[][] proof, int leafIndex, int treeCapacity, byte[] expectedRoot)` -- static verification of a Merkle proof without the full tree.

**BuildTree method:**
- `void BuildFromLeaves(byte[][] leafHashes)` -- sets all leaves then rebuilds entire tree bottom-up. O(N).

**Serialization:**
The tree occupies a variable number of blocks in the MTRK region.
- Header (block 0): [LeafCount:4 LE][TreeCapacity:4 LE][RootHash:32][Reserved:zero-fill][UniversalBlockTrailer]
- Data blocks (block 1+): packed node hashes, 32 bytes each, sequential by index (1 through TotalNodes-1). Each block has UniversalBlockTrailer.
- `int RequiredBlocks(int blockSize)` -- computes how many blocks needed: 1 (header) + ceil(TotalNodes * 32 / payloadSize)

**Methods:**
- `void Serialize(Span<byte> buffer, int blockSize)` -- writes header block + node data blocks, each with UniversalBlockTrailer using BlockTypeTags.MTRK
- `static IntegrityTreeRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize, int blockCount)` -- reads header, verifies trailers, reconstructs tree

Use SHA256.HashData (static method, no allocation) for hashing. Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- Integrity Tree (VREG-03)")]`.

**Important implementation details:**
- Empty/unused leaf slots (when leafCount < treeCapacity) should have all-zero hashes
- Parent hash of two zero children = SHA256(zeros_64) (a known constant, compute once)
- The root hash returned by GetRootHash() is what gets stored in IntegrityAnchor.MerkleRootHash
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class IntegrityTreeRegion` confirms the file exists.
Grep for `UpdatePath` confirms O(log N) incremental update is implemented.
Grep for `GetProof` confirms Merkle proof generation exists.
  </verify>
  <done>IntegrityTreeRegion implements a complete binary Merkle tree with O(log N) verification and incremental path updates. Serialization spans variable blocks with UniversalBlockTrailer on each. Merkle proofs can be generated and statically verified.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- IntegrityTreeRegion.cs exists in DataWarehouse.SDK/VirtualDiskEngine/Regions/
- Uses SHA256.HashData for node hashing
- Uses BlockTypeTags.MTRK for block type
- Implements O(log N) UpdatePath from leaf to root
- Generates and verifies Merkle proofs
</verification>

<success_criteria>
- Merkle tree correctly covers N data blocks with O(log N) single-block verification
- Incremental updates only recompute the affected path (not full rebuild)
- Merkle proofs can be extracted and verified independently
- Root hash is compatible with IntegrityAnchor.MerkleRootHash (32-byte SHA-256)
</success_criteria>

<output>
After completion, create `.planning/phases/72-vde-regions-foundation/72-02-SUMMARY.md`
</output>
