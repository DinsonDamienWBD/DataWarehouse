---
phase: 72-vde-regions-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/PolicyVaultRegion.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/EncryptionHeaderRegion.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Policy definitions can be stored in a 2-block vault and retrieved intact"
    - "Tampered policy vault blocks are detected on read via HMAC verification"
    - "Encryption header manages 63 key slots with KDF parameters"
    - "Key rotation events are recorded in the encryption header"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/PolicyVaultRegion.cs"
      provides: "HMAC-sealed 2-block policy vault with serialize/deserialize"
      contains: "class PolicyVaultRegion"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/EncryptionHeaderRegion.cs"
      provides: "63 key slots, KDF params, rotation log"
      contains: "class EncryptionHeaderRegion"
  key_links:
    - from: "PolicyVaultRegion.cs"
      to: "UniversalBlockTrailer"
      via: "trailer write/verify on both blocks"
      pattern: "UniversalBlockTrailer\\.(Write|Verify)"
    - from: "PolicyVaultRegion.cs"
      to: "BlockTypeTags.POLV"
      via: "block type tag constant"
      pattern: "BlockTypeTags\\.POLV"
    - from: "EncryptionHeaderRegion.cs"
      to: "BlockTypeTags.ENCR"
      via: "block type tag constant"
      pattern: "BlockTypeTags\\.ENCR"
    - from: "EncryptionHeaderRegion.cs"
      to: "FormatConstants.MaxKeySlots"
      via: "63 key slot limit"
      pattern: "FormatConstants\\.MaxKeySlots"
---

<objective>
Implement the Policy Vault region and Encryption Header region -- the two security-critical foundational regions of the DWVD v2.0 format.

Purpose: These regions provide the cryptographic foundation that all other regions depend on. The Policy Vault stores HMAC-sealed policy definitions (tamper-detected on read). The Encryption Header manages key material for the entire VDE.
Output: Two production-ready region classes in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionDirectory.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionPointerTable.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/IntegrityAnchor.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Policy Vault Region (VREG-01)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/PolicyVaultRegion.cs</files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/Regions/PolicyVaultRegion.cs` in namespace `DataWarehouse.SDK.VirtualDiskEngine.Regions`.

Create directory `DataWarehouse.SDK/VirtualDiskEngine/Regions/` first.

The Policy Vault occupies 2 blocks (registered in RegionDirectory with BlockTypeTags.POLV).

**PolicyDefinition record:**
- `Guid PolicyId` (16 bytes)
- `ushort PolicyType` (2 bytes) -- enum-like identifier for policy category
- `ushort Version` (2 bytes)
- `long CreatedUtcTicks` (8 bytes)
- `long ModifiedUtcTicks` (8 bytes)
- `int DataLength` (4 bytes) -- length of the variable-length policy payload
- `byte[] Data` -- the serialized policy content (variable length)
- Total fixed header: 40 bytes per definition

**PolicyVaultRegion sealed class:**
- `public const int BlockCount = 2;`
- `private readonly List<PolicyDefinition> _policies;`
- `public uint Generation { get; set; }`
- `public byte[] HmacKey { get; }` -- 32-byte HMAC-SHA256 key, set at construction

**HMAC sealing:** On Serialize, compute HMAC-SHA256 over the raw policy data (all serialized definitions concatenated) using `System.Security.Cryptography.HMACSHA256`. Store the 32-byte HMAC at a fixed offset (immediately after the last policy entry header area, at offset 0 of block 1 payload). On Deserialize, recompute and compare; throw `InvalidDataException("Policy Vault HMAC verification failed: data has been tampered with.")` if mismatch.

**Block layout:**
- Block 0: [PolicyCount:4 LE][PolicyDefinition entries...][zero-fill][UniversalBlockTrailer]
  - Each entry: [PolicyId:16][PolicyType:2][Version:2][CreatedUtcTicks:8][ModifiedUtcTicks:8][DataLength:4][Data:variable]
- Block 1: [HmacHash:32][Reserved:zero-fill][UniversalBlockTrailer]
  - HMAC covers block 0 payload bytes [0..blockSize-16)

**Methods:**
- `PolicyVaultRegion(byte[] hmacKey)` -- constructor, validates key is 32 bytes
- `void AddPolicy(PolicyDefinition policy)` -- adds to list, validates total size fits in block 0 payload
- `bool RemovePolicy(Guid policyId)` -- removes by ID
- `PolicyDefinition? GetPolicy(Guid policyId)` -- lookup by ID
- `IReadOnlyList<PolicyDefinition> GetAllPolicies()` -- returns snapshot
- `int PolicyCount` -- property
- `void Serialize(Span<byte> buffer, int blockSize)` -- writes both blocks with HMAC seal + UniversalBlockTrailer on each
- `static PolicyVaultRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize, byte[] hmacKey)` -- reads, verifies block trailers via UniversalBlockTrailer.Verify, then verifies HMAC; throws on any failure

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- Policy Vault (VREG-01)")]` on the class.
Use BinaryPrimitives for all integer read/write. Use HMACSHA256 from System.Security.Cryptography.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class PolicyVaultRegion` confirms the file exists.
Grep for `HMACSHA256` confirms HMAC sealing is implemented.
  </verify>
  <done>PolicyVaultRegion serializes/deserializes 2 blocks with HMAC tamper detection. Adding, removing, and retrieving policies works. Tampered data throws InvalidDataException.</done>
</task>

<task type="auto">
  <name>Task 2: Encryption Header Region (VREG-02)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/EncryptionHeaderRegion.cs</files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/Regions/EncryptionHeaderRegion.cs` in namespace `DataWarehouse.SDK.VirtualDiskEngine.Regions`.

The Encryption Header occupies 2 blocks (registered with BlockTypeTags.ENCR).

**KeySlot readonly struct (nested or separate):**
- `byte SlotIndex` (1 byte)
- `byte Status` (1 byte) -- 0=Empty, 1=Active, 2=Retired, 3=Compromised
- `ushort AlgorithmId` (2 bytes) -- identifies cipher (AES-256-GCM=1, ChaCha20-Poly1305=2, etc.)
- `byte[] WrappedKey` (64 bytes fixed) -- encrypted key material, zero-padded if shorter
- `byte[] KeySalt` (32 bytes) -- KDF salt
- `uint KdfIterations` (4 bytes) -- PBKDF2/Argon2 iteration count
- `ushort KdfAlgorithmId` (2 bytes) -- 0=PBKDF2-SHA256, 1=Argon2id, 2=scrypt
- `ushort Reserved` (2 bytes)
- `long CreatedUtcTicks` (8 bytes)
- `long RetiredUtcTicks` (8 bytes) -- 0 if still active
- Total: 1+1+2+64+32+4+2+2+8+8 = 124 bytes per slot
- With 63 slots: 63 * 124 = 7,812 bytes (fits in 2 blocks at 4096 blockSize with trailers: 2*(4096-16) = 8,160 payload bytes)

**KeyRotationEvent readonly struct:**
- `long TimestampUtcTicks` (8 bytes)
- `byte OldSlotIndex` (1 byte)
- `byte NewSlotIndex` (1 byte)
- `ushort Reason` (2 bytes) -- 0=Scheduled, 1=Compromised, 2=PolicyChange, 3=Manual
- Total: 12 bytes per event

**EncryptionHeaderRegion sealed class:**
- `public const int BlockCount = 2;`
- `public const int MaxKeySlots = FormatConstants.MaxKeySlots;` // 63
- `private readonly KeySlot[] _slots = new KeySlot[MaxKeySlots];`
- `private readonly List<KeyRotationEvent> _rotationLog;`
- `public uint Generation { get; set; }`

**Block layout:**
- Block 0: [ActiveSlotIndex:1][TotalActiveSlots:1][RotationEventCount:2][Reserved:4][KeySlot entries x 63 starting at offset 8]...[UniversalBlockTrailer]
  - 8 + (63 * 124) = 8 + 7812 = 7820 bytes. Fits in 2 blocks.
  - If 7820 > blockSize-16 (4080 for 4096 blocks), spill remaining slots into block 1 start.
  - For 4096 block size: block 0 holds slots 0-32 (33 slots = 8 + 33*124 = 4100... too large).
  - Recalculate: payload per block = 4096-16 = 4080. After 8-byte header: 4072/124 = 32 slots in block 0. Remaining 31 slots in block 1.
- Block 0: [Header:8][KeySlot x 32][zero-fill][UniversalBlockTrailer]
  - Header: ActiveSlotIndex(1) + TotalActive(1) + RotationCount(2) + Reserved(4) = 8 bytes
  - 8 + 32*124 = 3976 bytes, fits in 4080 payload
- Block 1: [KeySlot x 31][RotationEvents...][zero-fill][UniversalBlockTrailer]
  - 31*124 = 3844 bytes for slots, leaving 4080-3844 = 236 bytes for rotation events
  - 236/12 = 19 rotation events max (keep last 19)

**Methods:**
- `EncryptionHeaderRegion()` -- constructor
- `void SetKeySlot(int index, KeySlot slot)` -- validates 0..62
- `KeySlot GetKeySlot(int index)` -- validates 0..62
- `int FindActiveSlot()` -- returns first Active slot index or -1
- `IReadOnlyList<KeySlot> GetAllSlots()` -- returns all 63
- `void RecordRotation(KeyRotationEvent evt)` -- appends to rotation log (keeps last 19)
- `IReadOnlyList<KeyRotationEvent> GetRotationLog()`
- `void Serialize(Span<byte> buffer, int blockSize)` -- writes both blocks with UniversalBlockTrailer
- `static EncryptionHeaderRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize)` -- reads, verifies trailers

Make the split logic aware of variable block sizes: compute `slotsInBlock0 = (payloadSize - 8) / KeySlot.SerializedSize` where `payloadSize = blockSize - UniversalBlockTrailer.Size`.

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- Encryption Header (VREG-02)")]`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class EncryptionHeaderRegion` confirms the file exists.
Grep for `MaxKeySlots` in the file confirms 63-slot capacity.
  </verify>
  <done>EncryptionHeaderRegion manages 63 key slots split across 2 blocks, stores KDF parameters per slot, records up to 19 key rotation events. Serialize/Deserialize with UniversalBlockTrailer verification works for all supported block sizes.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- Both files exist in DataWarehouse.SDK/VirtualDiskEngine/Regions/
- PolicyVaultRegion uses HMACSHA256 for tamper detection
- EncryptionHeaderRegion references FormatConstants.MaxKeySlots (63)
- Both classes use BlockTypeTags.POLV / BlockTypeTags.ENCR respectively
- Both classes write UniversalBlockTrailer on every block
</verification>

<success_criteria>
- PolicyVaultRegion: 2-block HMAC-sealed vault, add/remove/get policies, tamper detection on deserialize
- EncryptionHeaderRegion: 63 key slots, KDF params per slot, rotation log, variable block size support
- Both: production-ready serialization with UniversalBlockTrailer, [SdkCompatibility("6.0.0")]
</success_criteria>

<output>
After completion, create `.planning/phases/72-vde-regions-foundation/72-01-SUMMARY.md`
</output>
