---
phase: 72-vde-regions-foundation
plan: 05
type: execute
wave: 4
depends_on: ["72-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/StreamingAppendRegion.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/WormImmutableRegion.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Regions/ComplianceVaultRegion.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Streaming region starts at 0% allocation and grows on demand"
    - "Streaming region operates as a ring buffer wrapping around when full"
    - "WORM region enforces append-only with high-water mark"
    - "All write attempts below the WORM high-water mark are rejected"
    - "Compliance Vault stores CompliancePassport records with digital signatures"
    - "Digital signatures on compliance records are verifiable"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/StreamingAppendRegion.cs"
      provides: "Ring buffer with demand allocation"
      contains: "class StreamingAppendRegion"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/WormImmutableRegion.cs"
      provides: "Append-only region with HWM enforcement"
      contains: "class WormImmutableRegion"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Regions/ComplianceVaultRegion.cs"
      provides: "CompliancePassport storage with digital signatures"
      contains: "class ComplianceVaultRegion"
  key_links:
    - from: "StreamingAppendRegion.cs"
      to: "BlockTypeTags.STRE"
      via: "block type tag"
      pattern: "BlockTypeTags\\.STRE"
    - from: "WormImmutableRegion.cs"
      to: "BlockTypeTags.WORM"
      via: "block type tag"
      pattern: "BlockTypeTags\\.WORM"
    - from: "ComplianceVaultRegion.cs"
      to: "BlockTypeTags.CMVT"
      via: "block type tag"
      pattern: "BlockTypeTags\\.CMVT"
---

<objective>
Implement the Streaming Append Region, WORM Immutable Region, and Compliance Vault Region -- three regions covering streaming ingestion, immutability enforcement, and regulatory compliance.

Purpose: Streaming handles high-throughput append workloads with minimal pre-allocation. WORM guarantees data immutability for legal/regulatory requirements. Compliance Vault stores signed audit records.
Output: Three production-ready region classes in DataWarehouse.SDK/VirtualDiskEngine/Regions/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Streaming Append Region + WORM Immutable Region (VREG-07, VREG-08)</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Regions/StreamingAppendRegion.cs
    DataWarehouse.SDK/VirtualDiskEngine/Regions/WormImmutableRegion.cs
  </files>
  <action>
**StreamingAppendRegion** -- `DataWarehouse.SDK/VirtualDiskEngine/Regions/StreamingAppendRegion.cs`

Ring buffer region that starts at 0% allocation and grows on demand.

**StreamingAppendRegion sealed class:**
- `public long MaxCapacityBlocks { get; }` -- maximum blocks this region can grow to
- `public long AllocatedBlocks { get; private set; }` -- currently allocated blocks (starts at 0)
- `public long WriteHead { get; private set; }` -- next block to write (absolute position, wraps via modulo)
- `public long ReadTail { get; private set; }` -- oldest unread block (absolute position)
- `public long EntryCount { get; private set; }` -- number of valid entries in the buffer
- `public uint Generation { get; set; }`
- `public bool IsEmpty => EntryCount == 0;`
- `public bool IsFull => EntryCount == AllocatedBlocks && AllocatedBlocks == MaxCapacityBlocks;`
- `public double AllocationPercentage => MaxCapacityBlocks > 0 ? (double)AllocatedBlocks / MaxCapacityBlocks * 100 : 0;`

**Growth strategy:** When WriteHead catches up to AllocatedBlocks, grow by `Math.Min(GrowthIncrement, MaxCapacityBlocks - AllocatedBlocks)` blocks. Default GrowthIncrement = 16 blocks. Configurable via constructor.

**Ring buffer semantics:** WriteHead and ReadTail are absolute counters. Actual block index = counter % AllocatedBlocks. When buffer wraps and overwrites old data, ReadTail advances.

**Methods:**
- `StreamingAppendRegion(long maxCapacityBlocks, int growthIncrement = 16)` -- constructor, AllocatedBlocks starts at 0
- `long Append(ReadOnlySpan<byte> data, int blockSize)` -- writes data to WriteHead block, grows if needed, advances WriteHead. Returns the absolute write position. Throws if IsFull and cannot grow.
- `bool TryRead(long position, Span<byte> buffer, int blockSize)` -- reads block at absolute position if still in valid range (between ReadTail and WriteHead). Returns false if position has been overwritten.
- `void AdvanceReadTail()` -- moves ReadTail forward by 1
- `void Reset()` -- zeros WriteHead, ReadTail, EntryCount (does NOT deallocate)

**Serialization (1 header block, registered with BlockTypeTags.STRE):**
- Header block: [MaxCapacityBlocks:8 LE][AllocatedBlocks:8 LE][WriteHead:8 LE][ReadTail:8 LE][EntryCount:8 LE][GrowthIncrement:4 LE][Reserved:zero-fill][UniversalBlockTrailer]
- Data blocks are managed externally (the region tracks metadata only; actual ring buffer data lives in the allocated block range).

**Methods:**
- `void Serialize(Span<byte> buffer, int blockSize)` -- writes header block
- `static StreamingAppendRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize)` -- reads header

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- Streaming Append (VREG-07)")]`.

---

**WormImmutableRegion** -- `DataWarehouse.SDK/VirtualDiskEngine/Regions/WormImmutableRegion.cs`

Append-only region with high-water mark (HWM) enforcement. All write attempts below HWM are rejected.

**WormImmutableRegion sealed class:**
- `public long HighWaterMark { get; private set; }` -- all blocks below this are immutable (0 = empty)
- `public long TotalCapacityBlocks { get; }` -- total blocks in this region
- `public long UsedBlocks => HighWaterMark;`
- `public long FreeBlocks => TotalCapacityBlocks - HighWaterMark;`
- `public uint Generation { get; set; }`
- `public long RetentionPeriodTicks { get; set; }` -- minimum retention period before any cleanup (0 = forever)
- `public long CreatedUtcTicks { get; set; }`

**WormWriteRecord readonly struct:**
- `long BlockIndex` (8 bytes)
- `long TimestampUtcTicks` (8 bytes)
- `int DataLength` (4 bytes)
- `byte[] ContentHash` (32 bytes) -- SHA-256 of the written data
- Serialized: 52 bytes

**Methods:**
- `WormImmutableRegion(long totalCapacityBlocks)` -- constructor, HWM starts at 0
- `long Append(ReadOnlySpan<byte> data, int blockSize)` -- writes at HighWaterMark position, advances HWM by 1, records WormWriteRecord. Returns the block index written. Throws InvalidOperationException if region is full.
- `void Write(long blockIndex, ReadOnlySpan<byte> data, int blockSize)` -- ENFORCES HWM: if blockIndex < HighWaterMark, throws `InvalidOperationException("Cannot write below WORM high-water mark {HighWaterMark}. Block {blockIndex} is immutable.")`. Only allows write at exactly HighWaterMark (sequential append).
- `bool IsImmutable(long blockIndex)` -- returns blockIndex < HighWaterMark
- `IReadOnlyList<WormWriteRecord> GetWriteLog()` -- returns recorded writes (kept in memory, serialized to region)

**Serialization (1 header block, registered with BlockTypeTags.WORM):**
- Header block: [HighWaterMark:8 LE][TotalCapacityBlocks:8 LE][RetentionPeriodTicks:8 LE][CreatedUtcTicks:8 LE][WriteLogCount:4 LE][Reserved:4][WormWriteRecord entries...][UniversalBlockTrailer]
- Write log entries follow the header fields in the same block and overflow to additional blocks if needed.

**Methods:**
- `int RequiredBlocks(int blockSize)` -- header + overflow for write log
- `void Serialize(Span<byte> buffer, int blockSize)`
- `static WormImmutableRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize, int blockCount)`

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- WORM Immutable (VREG-08)")]`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class StreamingAppendRegion` and `class WormImmutableRegion` confirms both files exist.
Grep for `HighWaterMark` in WormImmutableRegion confirms HWM enforcement.
Grep for `AllocationPercentage` in StreamingAppendRegion confirms demand allocation tracking.
  </verify>
  <done>StreamingAppendRegion starts at 0% allocation, grows on demand, operates as ring buffer. WormImmutableRegion enforces append-only with HWM -- all writes below HWM are rejected with clear error message.</done>
</task>

<task type="auto">
  <name>Task 2: Compliance Vault Region (VREG-09)</name>
  <files>DataWarehouse.SDK/VirtualDiskEngine/Regions/ComplianceVaultRegion.cs</files>
  <action>
Create `DataWarehouse.SDK/VirtualDiskEngine/Regions/ComplianceVaultRegion.cs` in namespace `DataWarehouse.SDK.VirtualDiskEngine.Regions`.

**CompliancePassport readonly record struct:**
- `Guid PassportId` (16 bytes)
- `Guid ObjectId` (16 bytes) -- the data object this passport covers
- `ushort FrameworkId` (2 bytes) -- compliance framework identifier (0=GDPR, 1=HIPAA, 2=SOX, 3=PCI-DSS, 4=SOC2, 5=ISO27001, 6=CCPA, 7=FISMA, 8=FedRAMP)
- `ushort ComplianceStatus` (2 bytes) -- 0=Unknown, 1=Compliant, 2=NonCompliant, 3=Exempt, 4=PendingReview
- `long IssuedUtcTicks` (8 bytes)
- `long ExpiresUtcTicks` (8 bytes) -- 0 = no expiry
- `long LastVerifiedUtcTicks` (8 bytes)
- `int IssuerIdLength` (4 bytes) -- length of issuer identifier string
- `byte[] IssuerId` (variable, max 128 bytes, UTF-8) -- who issued this passport
- `int NotesLength` (4 bytes)
- `byte[] Notes` (variable, max 256 bytes, UTF-8) -- compliance notes
- `byte[] Signature` (64 bytes fixed) -- Ed25519 or RSA signature over the passport fields (excluding the signature itself)
- Fixed overhead: 16+16+2+2+8+8+8+4+4+64 = 132 bytes + variable (IssuerId + Notes, max 384)

**ComplianceVaultRegion sealed class:**
- `private readonly List<CompliancePassport> _passports;`
- `public uint Generation { get; set; }`

**Signature computation:** The signature covers the concatenation of all fields EXCEPT the Signature field itself. The signing/verification key is provided externally (not stored in this region -- it comes from the Encryption Header or an external HSM).

**Methods:**
- `ComplianceVaultRegion()` -- constructor
- `void AddPassport(CompliancePassport passport)` -- adds to list
- `bool RemovePassport(Guid passportId)` -- removes by ID
- `CompliancePassport? GetPassport(Guid passportId)` -- lookup by ID
- `IReadOnlyList<CompliancePassport> GetPassportsByObject(Guid objectId)` -- all passports for an object
- `IReadOnlyList<CompliancePassport> GetPassportsByFramework(ushort frameworkId)` -- all passports for a framework
- `IReadOnlyList<CompliancePassport> GetAllPassports()`
- `int PassportCount` property
- `static byte[] ComputeSignaturePayload(CompliancePassport passport)` -- serializes all fields except Signature into a byte array for signing
- `static bool VerifySignature(CompliancePassport passport, ReadOnlySpan<byte> publicKey)` -- verifies the Signature field using RSA-SHA256 (System.Security.Cryptography.RSA). Returns false if signature is invalid. Uses RSA.Create() + ImportSubjectPublicKeyInfo + VerifyData with SHA256 + PKCS1 padding.
- `static byte[] Sign(CompliancePassport passport, ReadOnlySpan<byte> privateKey)` -- signs with RSA-SHA256, returns 64-byte signature (truncated/padded from RSA output to fit fixed field; or use first 64 bytes of RSA-2048 signature which is 256 bytes -- CORRECTION: store full RSA signature).

**CORRECTION on signature size:** RSA-2048 signatures are 256 bytes. To keep things practical, use ECDSA with P-256 (64-byte signature). Use `ECDsa.Create(ECCurve.NamedCurves.nistP256)` for signing/verification. The 64-byte Signature field stores the raw (r,s) ECDSA signature.

**Methods (updated):**
- `static bool VerifySignature(CompliancePassport passport, ECDsa publicKey)` -- verifies using ECDsa.VerifyData with SHA256
- `static CompliancePassport SignPassport(CompliancePassport passport, ECDsa privateKey)` -- signs and returns new passport with Signature populated

**Serialization (variable blocks, registered with BlockTypeTags.CMVT):**
- Block 0 (header): [PassportCount:4 LE][Reserved:12][CompliancePassport entries...][UniversalBlockTrailer]
  - Entries are packed sequentially. If they overflow block 0, continue in block 1+.
- Each passport serialized as: [PassportId:16][ObjectId:16][FrameworkId:2][ComplianceStatus:2][IssuedUtcTicks:8][ExpiresUtcTicks:8][LastVerifiedUtcTicks:8][IssuerIdLength:4][IssuerId:variable][NotesLength:4][Notes:variable][Signature:64]

**Methods:**
- `int RequiredBlocks(int blockSize)` -- computes from total serialized size of all passports
- `void Serialize(Span<byte> buffer, int blockSize)`
- `static ComplianceVaultRegion Deserialize(ReadOnlySpan<byte> buffer, int blockSize, int blockCount)`

Use `[SdkCompatibility("6.0.0", Notes = "Phase 72: VDE regions -- Compliance Vault (VREG-09)")]`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
Grep for `class ComplianceVaultRegion` confirms the file exists.
Grep for `CompliancePassport` confirms passport record structure.
Grep for `ECDsa\|VerifySignature` confirms digital signature support.
  </verify>
  <done>ComplianceVaultRegion stores CompliancePassport records with ECDSA P-256 digital signatures. Passports can be added, queried by object/framework, and their signatures verified with a public key. Serialization spans variable blocks with UniversalBlockTrailer.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- All three files exist in DataWarehouse.SDK/VirtualDiskEngine/Regions/
- StreamingAppendRegion has ring buffer with demand growth from 0%
- WormImmutableRegion rejects writes below HighWaterMark
- ComplianceVaultRegion has ECDSA signature verification
- All use correct BlockTypeTags (STRE, WORM, CMVT)
</verification>

<success_criteria>
- Streaming: 0% initial allocation, demand growth, ring buffer wrap-around
- WORM: append-only, HWM enforcement with clear error on violation
- Compliance: CompliancePassport with ECDSA P-256 signatures, framework queries
- All: production-ready serialization, [SdkCompatibility("6.0.0")]
</success_criteria>

<output>
After completion, create `.planning/phases/72-vde-regions-foundation/72-05-SUMMARY.md`
</output>
