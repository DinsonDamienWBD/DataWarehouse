---
phase: 39-feature-composition
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Composition/AutonomousOperationsTypes.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Composition/AutonomousOperationsEngine.cs
autonomous: true

must_haves:
  truths:
    - "When observability detects 'storage node unhealthy', auto-remediation triggers replica redistribution"
    - "When observability detects 'disk 80% full', auto-remediation triggers auto-tiering of cold data"
    - "All auto-remediation actions are logged with full audit trail including rule matched, action taken, and outcome"
    - "Rules engine supports registration and removal of condition-action mappings at runtime"
    - "Engine operates safely with no remediation actions when no rules are registered"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Composition/AutonomousOperationsTypes.cs"
      provides: "RemediationRule, RemediationAction, RemediationLog, AutonomousOperationsConfig types"
      contains: "record RemediationRule"
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Composition/AutonomousOperationsEngine.cs"
      provides: "Rules engine that subscribes to observability alerts and triggers corrective strategies"
      contains: "class AutonomousOperationsEngine"
  key_links:
    - from: "AutonomousOperationsEngine"
      to: "IMessageBus"
      via: "SubscribePattern to observability.alert.* and publish remediation triggers"
      pattern: "SubscribePattern.*observability\\.alert"
    - from: "AutonomousOperationsEngine"
      to: "SelfHealingStorageStrategy"
      via: "Message bus topic composition.remediation.trigger-selfhealing for corruption/node-failure"
      pattern: "composition\\.remediation\\.trigger"
    - from: "AutonomousOperationsEngine"
      to: "AutoTieringFeature"
      via: "Message bus topic composition.remediation.trigger-tiering for capacity alerts"
      pattern: "composition\\.remediation\\.trigger-tiering"
---

<objective>
Build the Autonomous Operations Engine that subscribes to observability alerts and triggers auto-remediation via message bus, composing SelfHealingStorageStrategy + AutoTieringFeature + DataGravityScheduler with a configurable rules engine (COMP-04).

Purpose: Enable self-managing storage operations where observability alerts automatically trigger corrective actions (self-healing for corruption, auto-tiering for capacity, gravity scheduling for performance), all logged for audit.

Output: Remediation types in SDK + AutonomousOperationsEngine orchestrator in UltimateStorage plugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-feature-composition/39-RESEARCH.md

Key existing files:
@Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Innovation/SelfHealingStorageStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateStorage/Features/AutoTieringFeature.cs
@Plugins/DataWarehouse.Plugins.UltimateCompute/Strategies/IndustryFirst/DataGravitySchedulerStrategy.cs
@Plugins/DataWarehouse.Plugins.UniversalObservability/Strategies/Alerting/AlertManagerStrategy.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SDK autonomous operations types</name>
  <files>DataWarehouse.SDK/Contracts/Composition/AutonomousOperationsTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Composition/AutonomousOperationsTypes.cs` in namespace `DataWarehouse.SDK.Contracts.Composition`:

1. `enum AlertSeverity { Info, Warning, Critical, Fatal }`

2. `enum RemediationActionType { SelfHeal, AutoTier, DataGravityRebalance, ReplicaRedistribute, Custom }`

3. `enum RemediationOutcome { Success, PartialSuccess, Failed, Skipped, TimedOut }`

4. `record AlertCondition`:
   - `string AlertPattern` (init, required) -- pattern to match against alert topic (e.g., "storage.node.unhealthy", "storage.capacity.*")
   - `AlertSeverity MinSeverity` (init) = AlertSeverity.Warning
   - `IReadOnlyDictionary<string, string>? LabelMatchers` (init) -- optional label filters (e.g., {"component": "storage"})

5. `record RemediationAction`:
   - `RemediationActionType ActionType` (init, required)
   - `string MessageBusTopic` (init, required) -- topic to publish remediation trigger
   - `IReadOnlyDictionary<string, object>? Parameters` (init) -- action-specific parameters
   - `TimeSpan Timeout` (init) = TimeSpan.FromMinutes(5)

6. `record RemediationRule`:
   - `string RuleId` (init, required) -- GUID
   - `string Name` (init, required) -- human-readable rule name
   - `string Description` (init, required)
   - `AlertCondition Condition` (init, required)
   - `RemediationAction Action` (init, required)
   - `bool Enabled` (init) = true
   - `int Priority` (init) = 0 -- higher priority rules evaluated first
   - `TimeSpan Cooldown` (init) = TimeSpan.FromMinutes(10) -- minimum time between re-triggers
   - `int MaxRetries` (init) = 3

7. `record RemediationLogEntry`:
   - `string LogId` (init, required) -- GUID
   - `DateTimeOffset Timestamp` (init, required)
   - `string RuleId` (init, required)
   - `string RuleName` (init, required)
   - `string AlertTopic` (init, required) -- the alert that triggered this
   - `RemediationActionType ActionType` (init, required)
   - `RemediationOutcome Outcome` (init, required)
   - `TimeSpan Duration` (init, required)
   - `string? ErrorMessage` (init)
   - `IReadOnlyDictionary<string, string>? Context` (init) -- additional context about the action

8. `record AutonomousOperationsConfig`:
   - `int MaxConcurrentRemediations` (init) = 3
   - `int MaxRules` (init) = 1000
   - `int MaxLogEntries` (init) = 100_000
   - `bool DryRunMode` (init) = false -- log what WOULD happen without acting
   - `TimeSpan GlobalCooldown` (init) = TimeSpan.FromSeconds(30) -- minimum between any two remediations

All records use `init` setters. Full XML documentation.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors. `grep -r "RemediationRule" DataWarehouse.SDK/` returns matches.
  </verify>
  <done>All 8 autonomous operations types compile in SDK, immutable records, bounded config, XML docs.</done>
</task>

<task type="auto">
  <name>Task 2: AutonomousOperationsEngine rules engine and alert subscriber</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateStorage/Composition/AutonomousOperationsEngine.cs</files>
  <action>
Create `Plugins/DataWarehouse.Plugins.UltimateStorage/Composition/AutonomousOperationsEngine.cs` in namespace `DataWarehouse.Plugins.UltimateStorage.Composition`.

Lives in UltimateStorage because storage self-healing and auto-tiering are the primary remediation targets.

Class `AutonomousOperationsEngine`:
- Constructor takes `IMessageBus messageBus`, `AutonomousOperationsConfig? config = null`
- Implements `IDisposable`
- Internal state:
  - `ConcurrentDictionary<string, RemediationRule> _rules` (bounded to config.MaxRules)
  - `ConcurrentDictionary<string, DateTimeOffset> _lastTriggered` -- cooldown tracking per rule
  - `ConcurrentDictionary<string, RemediationLogEntry> _log` (bounded to config.MaxLogEntries, oldest-first eviction)
  - `SemaphoreSlim _remediationSemaphore` -- limits concurrent remediations to config.MaxConcurrentRemediations
  - `DateTimeOffset _lastGlobalRemediation` -- global cooldown tracking

Methods:

1. `Task StartAsync(CancellationToken ct)`:
   - Subscribes to `observability.alert.*` via `IMessageBus.SubscribePattern` to receive all observability alerts
   - Subscribes to `composition.remediation.register-rule` for runtime rule registration
   - Subscribes to `composition.remediation.remove-rule` for runtime rule removal
   - Registers default rules:
     - "storage-node-unhealthy": AlertPattern="observability.alert.storage.node.*", Severity>=Warning -> SelfHeal via `composition.remediation.trigger-selfhealing`
     - "storage-capacity-high": AlertPattern="observability.alert.storage.capacity.*", Severity>=Warning -> AutoTier via `composition.remediation.trigger-tiering`
     - "performance-degradation": AlertPattern="observability.alert.performance.*", Severity>=Critical -> DataGravityRebalance via `composition.remediation.trigger-gravity`
     - "replica-count-low": AlertPattern="observability.alert.replication.*", Severity>=Critical -> ReplicaRedistribute via `composition.remediation.trigger-replicate`
   - Logs startup with rule count

2. `Task StopAsync()`:
   - Disposes all subscriptions
   - Waits for in-flight remediations to complete (with timeout)

3. `Task RegisterRuleAsync(RemediationRule rule, CancellationToken ct)`:
   - Validates rule (RuleId not empty, Condition.AlertPattern not empty, Action.MessageBusTopic not empty)
   - Adds to _rules (bounded, rejects if at MaxRules)
   - Publishes `composition.remediation.rule-registered` event

4. `Task RemoveRuleAsync(string ruleId, CancellationToken ct)`:
   - Removes from _rules
   - Publishes `composition.remediation.rule-removed` event

5. Private `Task HandleAlertAsync(PluginMessage msg)`:
   - Extracts alert topic, severity, labels from message
   - Finds matching rules: iterate _rules sorted by Priority descending
   - For each matching rule:
     a. Check cooldown: skip if `_lastTriggered[ruleId] + rule.Cooldown > now`
     b. Check global cooldown: skip if `_lastGlobalRemediation + config.GlobalCooldown > now`
     c. Acquire semaphore (with timeout, skip if concurrency limit reached)
     d. If config.DryRunMode: log what WOULD happen, release semaphore, continue
     e. Execute remediation:
        - Record start time
        - Publish to `rule.Action.MessageBusTopic` with rule parameters + alert context
        - Wait for response (with rule.Action.Timeout)
        - Record outcome (Success/Failed/TimedOut)
        - Update _lastTriggered and _lastGlobalRemediation
     f. Create RemediationLogEntry and add to _log
     g. Release semaphore
     h. Publish `composition.remediation.action-completed` event with log entry
   - Only first matching rule fires per alert (highest priority wins) -- prevents cascade

6. `Task<IReadOnlyList<RemediationRule>> GetRulesAsync()` -- returns all registered rules
7. `Task<IReadOnlyList<RemediationLogEntry>> GetLogAsync(int limit = 100)` -- returns recent log entries
8. `Task<IReadOnlyDictionary<string, int>> GetRuleStatisticsAsync()` -- returns trigger count per rule

All remediation triggers via message bus. No direct references to SelfHealingStorageStrategy, AutoTieringFeature, DataGravitySchedulerStrategy, or AlertManagerStrategy. Bounded collections. SemaphoreSlim for concurrency control. Thread-safe throughout. Full XML documentation.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj` -- zero new errors. Verify engine structure: `grep -c "HandleAlert\|RegisterRule\|RemediationLog\|SubscribePattern\|SemaphoreSlim" Plugins/DataWarehouse.Plugins.UltimateStorage/Composition/AutonomousOperationsEngine.cs` returns >5 matches.
  </verify>
  <done>AutonomousOperationsEngine compiles, subscribes to observability alerts, evaluates rules by priority, triggers remediation via message bus with cooldown/concurrency limits, logs all actions, supports dry-run mode, degrades safely with no rules registered.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj` -- zero new errors
3. Default rules registered for storage-node-unhealthy, storage-capacity-high, performance-degradation, replica-count-low
4. Cooldown and concurrency controls prevent remediation storms
5. All remediation triggers via message bus (no direct plugin references)
6. All public types have XML documentation
7. Dry-run mode logs without acting
</verification>

<success_criteria>
- Alert -> Rule matching -> Remediation trigger -> Audit log pipeline works end-to-end via message bus
- Default rules cover the four primary remediation scenarios (self-heal, auto-tier, gravity rebalance, replica redistribute)
- Cooldown (per-rule and global) + concurrency limit prevent remediation storms
- Dry-run mode for safe testing
- Zero new build errors, bounded collections, IDisposable, thread-safe
</success_criteria>

<output>
After completion, create `.planning/phases/39-feature-composition/39-04-SUMMARY.md`
</output>
