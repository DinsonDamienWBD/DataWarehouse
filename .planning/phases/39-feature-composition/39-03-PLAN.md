---
phase: 39-feature-composition
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Composition/DataRoomTypes.cs
  - Plugins/DataWarehouse.Plugins.UltimateAccessControl/Composition/DataRoomOrchestrator.cs
autonomous: true

must_haves:
  truths:
    - "DataRoom can be created with participating orgs, datasets, and expiry time"
    - "Participants receive time-limited access via ephemeral sharing links"
    - "Geofencing constraints enforce data residency boundaries for shared data"
    - "Full audit trail records every access, invite, and policy change"
    - "After expiry, all shared access is automatically revoked and data references destroyed"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Composition/DataRoomTypes.cs"
      provides: "DataRoom, DataRoomParticipant, DataRoomConfig, DataRoomState record types"
      contains: "record DataRoom"
    - path: "Plugins/DataWarehouse.Plugins.UltimateAccessControl/Composition/DataRoomOrchestrator.cs"
      provides: "Lifecycle orchestrator composing EphemeralSharing + Geofencing + ZeroTrust + Marketplace"
      contains: "class DataRoomOrchestrator"
  key_links:
    - from: "DataRoomOrchestrator"
      to: "IMessageBus"
      via: "Publish to composition.dataroom.* topics for create/invite/expiry/destroy lifecycle"
      pattern: "composition\\.dataroom"
    - from: "DataRoomOrchestrator"
      to: "EphemeralSharingStrategy"
      via: "Message bus topic for generating time-limited access tokens"
      pattern: "composition\\.dataroom\\.generate-link"
    - from: "DataRoomOrchestrator"
      to: "ComplianceAuditStrategy"
      via: "Message bus topic for audit trail aggregation"
      pattern: "composition\\.dataroom\\.audit"
---

<objective>
Build the Cross-Organization Data Room orchestrator that composes EphemeralSharingStrategy + GeofencingStrategy + ZeroTrustStrategy + DataMarketplace into a full lifecycle data room (create, invite, set expiry, audit trail, auto-destruct) (COMP-03).

Purpose: Enable secure cross-organization data sharing with time-limited access, geographic boundary enforcement, zero-trust access control, and automatic cleanup -- composing four existing strategy families via message bus.

Output: DataRoom types in SDK + DataRoomOrchestrator in UltimateAccessControl plugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-feature-composition/39-RESEARCH.md

Key existing files:
@Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/EphemeralSharing/EphemeralSharingStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Geofencing/GeofencingStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Core/ZeroTrustStrategy.cs
@Plugins/DataWarehouse.Plugins.DataMarketplace/DataMarketplacePlugin.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SDK data room types</name>
  <files>DataWarehouse.SDK/Contracts/Composition/DataRoomTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Composition/DataRoomTypes.cs` in namespace `DataWarehouse.SDK.Contracts.Composition`:

1. `enum DataRoomState { Creating, Active, Expiring, Destroyed, Failed }`

2. `enum ParticipantRole { Owner, ReadOnly, ReadWrite, Admin }`

3. `record DataRoomParticipant`:
   - `string OrganizationId` (init, required)
   - `string OrganizationName` (init, required)
   - `ParticipantRole Role` (init, required)
   - `DateTimeOffset InvitedAt` (init, required)
   - `DateTimeOffset? JoinedAt` (init)
   - `string? AccessToken` (init) -- ephemeral sharing token
   - `DateTimeOffset? TokenExpiresAt` (init)

4. `record DataRoomDataset`:
   - `string DatasetId` (init, required)
   - `string DatasetName` (init, required)
   - `string OwnerId` (init, required) -- org that contributed this dataset
   - `IReadOnlyList<string>? GeofenceRegions` (init) -- null = no geographic restrictions
   - `bool RequiresZeroTrust` (init) = true

5. `record DataRoomAuditEntry`:
   - `string EntryId` (init, required) -- GUID
   - `DateTimeOffset Timestamp` (init, required)
   - `string ActorId` (init, required) -- who performed the action
   - `string Action` (init, required) -- "created", "invited", "accessed", "expired", "destroyed"
   - `string? TargetId` (init) -- dataset or participant affected
   - `string? Details` (init) -- human-readable description

6. `record DataRoom`:
   - `string RoomId` (init, required) -- GUID
   - `string Name` (init, required)
   - `DataRoomState State` (init, required)
   - `DateTimeOffset CreatedAt` (init, required)
   - `DateTimeOffset ExpiresAt` (init, required)
   - `string CreatedBy` (init, required) -- org ID of creator
   - `IReadOnlyList<DataRoomParticipant> Participants` (init, required)
   - `IReadOnlyList<DataRoomDataset> Datasets` (init, required)
   - `IReadOnlyList<DataRoomAuditEntry> AuditTrail` (init, required)
   - `bool IsExpired` computed property => `DateTimeOffset.UtcNow >= ExpiresAt`
   - `bool IsActive` computed property => `State == DataRoomState.Active && !IsExpired`

7. `record DataRoomConfig`:
   - `TimeSpan DefaultExpiry` (init) = TimeSpan.FromDays(30)
   - `TimeSpan TokenRefreshInterval` (init) = TimeSpan.FromHours(1)
   - `bool EnforceGeofencing` (init) = true
   - `bool RequireZeroTrust` (init) = true
   - `int MaxParticipants` (init) = 100
   - `int MaxDatasets` (init) = 1000
   - `int MaxAuditEntries` (init) = 100_000

All records use `init` setters for immutability. Full XML documentation on all public types.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors. `grep -r "DataRoom\b" DataWarehouse.SDK/Contracts/Composition/` returns matches.
  </verify>
  <done>All 7 data room types compile in SDK, immutable records, bounded config limits, XML docs.</done>
</task>

<task type="auto">
  <name>Task 2: DataRoomOrchestrator lifecycle manager</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateAccessControl/Composition/DataRoomOrchestrator.cs</files>
  <action>
Create `Plugins/DataWarehouse.Plugins.UltimateAccessControl/Composition/DataRoomOrchestrator.cs` in namespace `DataWarehouse.Plugins.UltimateAccessControl.Composition`.

Lives in UltimateAccessControl because access control is the primary concern of data rooms (ephemeral sharing, zero trust).

Class `DataRoomOrchestrator`:
- Constructor takes `IMessageBus messageBus`, `DataRoomConfig? config = null`
- Implements `IDisposable`
- Internal state: `ConcurrentDictionary<string, DataRoom> _rooms` (bounded to 10,000)
- Internal state: `Timer _expiryCheckTimer` -- checks for expired rooms every minute

State machine: Creating -> Active -> Expiring -> Destroyed (also Failed from any state)

Methods:

1. `async Task<DataRoom> CreateAsync(string name, string creatorOrgId, IReadOnlyList<DataRoomDataset> datasets, TimeSpan? expiry, CancellationToken ct)`:
   - Validates inputs (name not empty, datasets not empty, within MaxDatasets)
   - Creates DataRoom in Creating state
   - Publishes `composition.dataroom.configure-geofencing` for each dataset with GeofenceRegions
   - Publishes `composition.dataroom.configure-zerotrust` to set up zero-trust policies
   - Transitions to Active state
   - Records audit entry: "created"
   - Publishes `composition.dataroom.created` event
   - Stores in _rooms

2. `async Task<DataRoomParticipant> InviteAsync(string roomId, string orgId, string orgName, ParticipantRole role, CancellationToken ct)`:
   - Validates room exists and is Active
   - Validates participant count within MaxParticipants
   - Publishes `composition.dataroom.generate-link` to request ephemeral sharing token from EphemeralSharingStrategy
   - Creates DataRoomParticipant with token and expiry
   - Records audit entry: "invited"
   - Returns participant with access token

3. `async Task SetExpiryAsync(string roomId, DateTimeOffset newExpiry, CancellationToken ct)`:
   - Validates room exists and is Active
   - Updates room ExpiresAt
   - Records audit entry: "expiry-changed"
   - If new expiry is in the past, triggers immediate destruction

4. `async Task<IReadOnlyList<DataRoomAuditEntry>> GetAuditTrailAsync(string roomId, CancellationToken ct)`:
   - Returns audit trail for room
   - Also publishes `composition.dataroom.audit-request` to aggregate audit data from ComplianceAuditStrategy

5. `async Task DestroyAsync(string roomId, string reason, CancellationToken ct)`:
   - Transitions to Expiring state
   - Publishes `composition.dataroom.revoke-access` for each participant (revokes ephemeral tokens)
   - Publishes `composition.dataroom.remove-geofencing` to clean up geofencing policies
   - Publishes `composition.dataroom.remove-zerotrust` to clean up zero-trust policies
   - Records audit entry: "destroyed" with reason
   - Transitions to Destroyed state
   - Publishes `composition.dataroom.destroyed` event

6. `GetRoomAsync(string roomId)` -- returns current room state
7. `GetActiveRoomsAsync()` -- returns all active rooms

Private `CheckExpiredRooms(object? state)`:
- Timer callback, runs every 60 seconds
- Finds all rooms where IsExpired == true and State == Active
- Calls DestroyAsync for each with reason "expired"

Private `RefreshTokens(object? state)`:
- Periodically refreshes ephemeral access tokens for active participants
- Publishes `composition.dataroom.refresh-token` for each participant nearing token expiry

All cross-plugin communication via message bus. No direct references to EphemeralSharingStrategy, GeofencingStrategy, ZeroTrustStrategy, or DataMarketplacePlugin. Audit entries use bounded list (config.MaxAuditEntries with oldest-first eviction). All state transitions logged.

Note: The DataRoom record is immutable, so internal state management uses a mutable wrapper or re-creates the record with updated state. Use `DataRoom with { State = newState, ... }` pattern for state transitions (record `with` expressions).
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateAccessControl/DataWarehouse.Plugins.UltimateAccessControl.csproj` -- zero new errors. Verify lifecycle methods: `grep -c "Async\|composition\\.dataroom" Plugins/DataWarehouse.Plugins.UltimateAccessControl/Composition/DataRoomOrchestrator.cs` returns >15 matches.
  </verify>
  <done>DataRoomOrchestrator compiles, implements full lifecycle (create/invite/expiry/audit/destroy), composes 4 strategy families via message bus, auto-expires rooms, bounded collections, no direct plugin references.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. `dotnet build Plugins/DataWarehouse.Plugins.UltimateAccessControl/DataWarehouse.Plugins.UltimateAccessControl.csproj` -- zero new errors
3. DataRoom state machine: Creating -> Active -> Expiring -> Destroyed
4. All strategy composition via message bus (EphemeralSharing, Geofencing, ZeroTrust, Marketplace)
5. Auto-destruct on expiry works via timer
6. All public types have XML documentation
7. No direct plugin-to-plugin references
</verification>

<success_criteria>
- DataRoom lifecycle: create with datasets + orgs -> invite participants with ephemeral tokens -> enforce geofencing + zero-trust -> audit all access -> auto-destroy on expiry
- All four strategy families composed via message bus only
- Bounded collections, IDisposable, timer-based expiry checking
- Full audit trail of all room operations
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/39-feature-composition/39-03-SUMMARY.md`
</output>
