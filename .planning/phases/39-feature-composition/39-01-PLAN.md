---
phase: 39-feature-composition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Composition/SchemaEvolutionTypes.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataIntegration/Composition/SchemaEvolutionEngine.cs
autonomous: true

must_haves:
  truths:
    - "When >10% of ingested records contain new fields, the engine auto-proposes a schema evolution"
    - "Proposed schema evolution passes forward-compatibility check before being applied"
    - "Schema changes are tracked in LivingCatalog after approval/auto-apply"
    - "Engine operates in reduced mode (no pattern detection) when UltimateIntelligence is unavailable"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Composition/SchemaEvolutionTypes.cs"
      provides: "SchemaEvolutionProposal, SchemaEvolutionDecision, SchemaEvolutionEngineConfig record types"
      contains: "record SchemaEvolutionProposal"
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataIntegration/Composition/SchemaEvolutionEngine.cs"
      provides: "Orchestrator that wires Intelligence pattern detection -> SchemaEvolution -> LivingCatalog"
      contains: "class SchemaEvolutionEngine"
  key_links:
    - from: "SchemaEvolutionEngine"
      to: "IMessageBus"
      via: "Subscribe to data ingestion events and intelligence.connector.detect-anomaly.response"
      pattern: "Subscribe.*detect-anomaly"
    - from: "SchemaEvolutionEngine"
      to: "ForwardCompatibleSchemaStrategy"
      via: "Direct call to CheckCompatibilityAsync for proposed schema changes"
      pattern: "CheckCompatibilityAsync"
    - from: "SchemaEvolutionEngine"
      to: "SchemaEvolutionTrackerStrategy"
      via: "Direct call to RecordSchema for catalog updates after approved evolution"
      pattern: "RecordSchema"
---

<objective>
Build the Self-Evolving Schema Engine that wires UltimateIntelligence pattern detection to SchemaEvolution and LivingCatalog strategies via a feedback loop orchestrator (COMP-01).

Purpose: Enable automatic schema adaptation when data patterns change, composing three existing capabilities (intelligence pattern detection, schema evolution checking, living catalog tracking) into a unified feedback loop.

Output: SchemaEvolutionEngine class + SDK types for schema evolution proposals.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-feature-composition/39-RESEARCH.md

Key existing files:
@Plugins/DataWarehouse.Plugins.UltimateDataIntegration/Strategies/SchemaEvolution/SchemaEvolutionStrategies.cs
@Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/LivingCatalog/LivingCatalogStrategies.cs
@Plugins/DataWarehouse.Plugins.UltimateIntelligence/Strategies/ConnectorIntegration/IntelligenceTopics.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SDK composition types for schema evolution</name>
  <files>DataWarehouse.SDK/Contracts/Composition/SchemaEvolutionTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Composition/SchemaEvolutionTypes.cs` with the following types in namespace `DataWarehouse.SDK.Contracts.Composition`:

1. `record SchemaEvolutionProposal` with properties:
   - `string ProposalId` (init, required) -- GUID
   - `string SchemaId` (init, required)
   - `IReadOnlyList<FieldChange> DetectedChanges` (init, required)
   - `double ChangePercentage` (init, required) -- percentage of records with new pattern
   - `DateTimeOffset DetectedAt` (init, required)
   - `SchemaEvolutionDecision Decision` (init) -- defaults to Pending
   - `string? ApprovedBy` (init) -- null for auto-approve, username for manual
   - `DateTimeOffset? DecidedAt` (init)

2. `record FieldChange` with properties:
   - `string FieldName` (init, required)
   - `FieldChangeType ChangeType` (init, required)
   - `string? OldType` (init)
   - `string? NewType` (init)
   - `object? DefaultValue` (init)

3. `enum FieldChangeType { Added, Removed, TypeWidened, TypeChanged, DefaultChanged }`

4. `enum SchemaEvolutionDecision { Pending, AutoApproved, ManuallyApproved, Rejected }`

5. `record SchemaEvolutionEngineConfig` with properties:
   - `double ChangeThresholdPercent` (init) = 10.0 -- trigger threshold
   - `bool AutoApproveForwardCompatible` (init) = false -- auto-approve if forward-compatible
   - `TimeSpan DetectionInterval` (init) = TimeSpan.FromMinutes(5)
   - `int MaxPendingProposals` (init) = 100
   - `int MaxFieldChangesPerProposal` (init) = 50

Include full XML documentation on all public types and properties. Use C# records with `init` setters for immutability (AD-05 API contract safety). No NuGet dependencies.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors. Verify types exist with: `grep -r "SchemaEvolutionProposal" DataWarehouse.SDK/`.
  </verify>
  <done>All five types compile in SDK, are immutable records/enums, and have XML docs.</done>
</task>

<task type="auto">
  <name>Task 2: SchemaEvolutionEngine orchestrator</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataIntegration/Composition/SchemaEvolutionEngine.cs</files>
  <action>
Create `Plugins/DataWarehouse.Plugins.UltimateDataIntegration/Composition/SchemaEvolutionEngine.cs` in namespace `DataWarehouse.Plugins.UltimateDataIntegration.Composition`.

The class wires together intelligence pattern detection, schema evolution strategies, and living catalog tracking. It lives in the UltimateDataIntegration plugin because that plugin already owns SchemaEvolution strategies.

Class `SchemaEvolutionEngine`:
- Constructor takes `IMessageBus messageBus`, `SchemaEvolutionEngineConfig? config = null`
- Implements `IDisposable` (unsubscribes from message bus topics on dispose)
- Internal state: `ConcurrentDictionary<string, SchemaEvolutionProposal> _pendingProposals` (bounded to config.MaxPendingProposals)
- Internal state: `ConcurrentDictionary<string, List<SchemaEvolutionProposal>> _proposalHistory` (bounded, oldest-first eviction at 1000 per schema)

Methods:
1. `StartAsync(CancellationToken ct)`:
   - Subscribes to message bus topics:
     - `composition.schema.data-ingested` -- fired when new data batch arrives
     - `intelligence.connector.detect-anomaly.response` -- anomaly detection results
   - Starts a periodic timer (config.DetectionInterval) that publishes pattern detection requests via `intelligence.connector.detect-anomaly` topic
   - Logs startup

2. `StopAsync()`:
   - Disposes subscriptions, stops timer

3. Private `HandleAnomalyResponse(PluginMessage msg)`:
   - Deserializes anomaly detection result from message payload
   - If pattern change exceeds config.ChangeThresholdPercent:
     - Creates SchemaEvolutionProposal with detected field changes
     - Publishes to `composition.schema.evolution-proposed` topic
     - If config.AutoApproveForwardCompatible is true, calls `EvaluateProposal` immediately

4. `EvaluateProposalAsync(string proposalId, CancellationToken ct)`:
   - Gets proposal from _pendingProposals
   - Sends message to `composition.schema.check-compatibility` topic with the proposed changes
   - On response: if forward-compatible, marks Decision = AutoApproved; publishes to `composition.schema.evolution-approved`
   - On response: if NOT forward-compatible, marks Decision = Pending (needs manual approval)

5. `ApproveProposalAsync(string proposalId, string approvedBy, CancellationToken ct)`:
   - Manual approval path: marks Decision = ManuallyApproved
   - Publishes to `composition.schema.evolution-approved` topic

6. `RejectProposalAsync(string proposalId, string rejectedBy, CancellationToken ct)`:
   - Marks Decision = Rejected
   - Publishes to `composition.schema.evolution-rejected` topic

7. Private `HandleApprovedEvolution(PluginMessage msg)`:
   - Publishes to `composition.schema.apply-migration` topic to trigger SchemaMigrationStrategy
   - Publishes to `composition.schema.update-catalog` topic to trigger SchemaEvolutionTrackerStrategy
   - Moves proposal from pending to history

8. `GetPendingProposalsAsync()` -- returns current pending proposals
9. `GetProposalHistoryAsync(string schemaId)` -- returns history for a schema

Graceful degradation: If intelligence plugin is not loaded (message bus responses timeout), the engine logs a warning and continues operating -- proposals can still be created manually via message bus, and compatibility checking + catalog updates still work. The anomaly detection simply does not fire.

Use `System.Threading.Timer` for periodic detection. All message bus communication via `IMessageBus.PublishAsync` and `IMessageBus.Subscribe`. No direct plugin references. Use `System.Text.Json` for serialization. Bound all collections per Phase 23 patterns.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataIntegration/DataWarehouse.Plugins.UltimateDataIntegration.csproj` -- zero new errors. Verify class exists and has all methods: `grep -c "Async\|Proposal\|Subscribe" Plugins/DataWarehouse.Plugins.UltimateDataIntegration/Composition/SchemaEvolutionEngine.cs` returns >10 matches.
  </verify>
  <done>SchemaEvolutionEngine compiles, subscribes to message bus topics for anomaly detection and schema evolution lifecycle, evaluates proposals against forward-compatibility, supports auto-approve and manual approve/reject, updates catalog on approval, degrades gracefully when intelligence unavailable.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataIntegration/DataWarehouse.Plugins.UltimateDataIntegration.csproj` -- zero new errors
3. SchemaEvolutionProposal and SchemaEvolutionEngine types exist and are discoverable via grep
4. No direct plugin-to-plugin references (only message bus)
5. All public types have XML documentation
</verification>

<success_criteria>
- SchemaEvolutionEngine connects UltimateIntelligence pattern detection -> SchemaEvolution checking -> LivingCatalog tracking via message bus
- Feedback loop: detect pattern change > threshold -> propose -> evaluate compatibility -> approve/reject -> apply + update catalog
- Graceful degradation when intelligence unavailable (manual proposal path still works)
- All types immutable records, bounded collections, IDisposable
- Zero new build errors across affected projects
</success_criteria>

<output>
After completion, create `.planning/phases/39-feature-composition/39-01-SUMMARY.md`
</output>
