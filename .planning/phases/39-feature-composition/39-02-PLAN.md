---
phase: 39-feature-composition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Composition/ProvenanceCertificateTypes.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/Composition/ProvenanceCertificateService.cs
autonomous: true

must_haves:
  truths:
    - "Any stored object can produce a ProvenanceCertificate showing every transformation with before/after hashes"
    - "ProvenanceCertificate includes a blockchain-anchored root hash with verification result"
    - "Certificate.Verify() re-walks the hash chain and confirms each link is valid"
    - "Certificate verification is O(chain_length) and does not require external services for chain validation"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Composition/ProvenanceCertificateTypes.cs"
      provides: "ProvenanceCertificate, CertificateEntry, CertificateVerificationResult record types"
      contains: "record ProvenanceCertificate"
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataLineage/Composition/ProvenanceCertificateService.cs"
      provides: "Service that composes SelfTrackingData hash chains with TamperProof blockchain anchoring"
      contains: "class ProvenanceCertificateService"
  key_links:
    - from: "ProvenanceCertificateService"
      to: "IMessageBus"
      via: "Send to lineage.provenance.get-chain and tamperproof.blockchain.verify-anchor topics"
      pattern: "PublishAsync.*provenance|SendAsync.*blockchain"
    - from: "ProvenanceCertificate"
      to: "CertificateEntry list"
      via: "Chain property contains ordered TransformationRecords with hashes"
      pattern: "IReadOnlyList<CertificateEntry>"
---

<objective>
Build the Data DNA Provenance Certificate system that composes SelfTrackingDataStrategy per-object hash chains with TamperProof blockchain anchoring into unified, verifiable provenance certificates (COMP-02).

Purpose: Enable any stored object to produce a cryptographic provenance certificate showing its complete transformation history, anchored to the blockchain, with a Verify() method for independent chain validation.

Output: ProvenanceCertificate types in SDK + ProvenanceCertificateService orchestrator in UltimateDataLineage plugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-feature-composition/39-RESEARCH.md

Key existing files:
@Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs
@Plugins/DataWarehouse.Plugins.TamperProof/Services/BlockchainVerificationService.cs
@DataWarehouse.SDK/Contracts/TamperProof/IBlockchainProvider.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SDK provenance certificate types</name>
  <files>DataWarehouse.SDK/Contracts/Composition/ProvenanceCertificateTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Composition/ProvenanceCertificateTypes.cs` in namespace `DataWarehouse.SDK.Contracts.Composition`:

1. `record CertificateEntry`:
   - `string TransformId` (init, required) -- unique ID for this transformation step
   - `string Operation` (init, required) -- what was done (e.g., "encrypt", "compress", "write")
   - `string? SourceObjectId` (init) -- upstream object this derived from
   - `DateTimeOffset Timestamp` (init, required)
   - `string? BeforeHash` (init) -- hash of data before transformation
   - `string? AfterHash` (init) -- hash of data after transformation
   - `IReadOnlyDictionary<string, string>? Metadata` (init) -- optional additional context

2. `record BlockchainAnchorInfo`:
   - `string AnchorId` (init, required)
   - `long BlockNumber` (init, required)
   - `DateTimeOffset AnchoredAt` (init, required)
   - `string RootHash` (init, required) -- Merkle root or direct hash anchored
   - `int Confirmations` (init)
   - `bool IsValid` (init, required)
   - `string? TransactionId` (init)

3. `record ProvenanceCertificate`:
   - `string CertificateId` (init, required) -- GUID
   - `string ObjectId` (init, required) -- the object this certificate describes
   - `DateTimeOffset IssuedAt` (init, required)
   - `IReadOnlyList<CertificateEntry> Chain` (init, required) -- ordered transformation history (oldest first)
   - `BlockchainAnchorInfo? BlockchainAnchor` (init) -- null if no blockchain anchoring configured
   - `string CertificateHash` (init, required) -- SHA256 of the entire chain for tamper detection
   - Method `CertificateVerificationResult Verify()`:
     - Walks the chain from first to last entry
     - For each adjacent pair, verifies that entry[i].AfterHash matches entry[i+1].BeforeHash (the chain links)
     - Computes SHA256 of all chain entries and compares to CertificateHash
     - Returns CertificateVerificationResult with IsValid, BrokenLinkIndex, ErrorMessage

4. `record CertificateVerificationResult`:
   - `bool IsValid` (init, required)
   - `int ChainLength` (init, required)
   - `int? BrokenLinkIndex` (init) -- null if valid, index of first broken link if invalid
   - `string? ErrorMessage` (init)
   - `bool BlockchainAnchored` (init) -- whether blockchain anchor was included
   - Static factory: `CreateValid(int chainLength, bool anchored)`, `CreateInvalid(int chainLength, int brokenLinkIndex, string error)`

Use `System.Security.Cryptography.SHA256` for hash computation (FIPS-compliant, per Phase 23 decisions). The Verify() method is self-contained -- it validates the hash chain without needing external services, making offline verification possible. All types are immutable records with full XML documentation.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors. `grep -r "ProvenanceCertificate" DataWarehouse.SDK/` returns matches.
  </verify>
  <done>ProvenanceCertificate, CertificateEntry, BlockchainAnchorInfo, CertificateVerificationResult compile in SDK. Verify() method validates hash chain integrity without external dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: ProvenanceCertificateService orchestrator</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataLineage/Composition/ProvenanceCertificateService.cs</files>
  <action>
Create `Plugins/DataWarehouse.Plugins.UltimateDataLineage/Composition/ProvenanceCertificateService.cs` in namespace `DataWarehouse.Plugins.UltimateDataLineage.Composition`.

This service lives in UltimateDataLineage because it primarily orchestrates lineage data (SelfTrackingDataStrategy hash chains) and enriches them with blockchain anchoring from TamperProof.

Class `ProvenanceCertificateService`:
- Constructor takes `IMessageBus messageBus`
- Implements `IDisposable`

Methods:

1. `async Task<ProvenanceCertificate> IssueCertificateAsync(string objectId, CancellationToken ct)`:
   - Step 1: Request transformation history from lineage plugin via message bus
     - Send to topic `composition.provenance.get-history` with payload `{ "objectId": objectId }`
     - Response contains list of TransformationRecords (from SelfTrackingDataStrategy)
   - Step 2: Convert TransformationRecords to CertificateEntry list, ordered by timestamp (oldest first)
   - Step 3: Request blockchain anchor verification via message bus
     - Send to topic `composition.provenance.verify-anchor` with payload `{ "objectId": objectId }`
     - Response contains anchor info (block number, timestamp, validity)
     - If blockchain not configured or unavailable, set BlockchainAnchor = null (graceful degradation)
   - Step 4: Compute certificate hash (SHA256 of serialized chain entries)
   - Step 5: Assemble and return ProvenanceCertificate

2. `async Task<CertificateVerificationResult> VerifyCertificateAsync(ProvenanceCertificate certificate, CancellationToken ct)`:
   - Calls certificate.Verify() for local chain validation
   - If certificate has blockchain anchor, sends verification request via message bus
   - Returns combined result

3. `async Task<IReadOnlyList<ProvenanceCertificate>> GetCertificateHistoryAsync(string objectId, CancellationToken ct)`:
   - Retrieves all certificates ever issued for an object
   - Reads from local certificate store (ConcurrentDictionary, bounded to 10,000 entries)

4. `void StartListening()`:
   - Subscribes to `composition.provenance.request-certificate` topic
   - When a request arrives, calls IssueCertificateAsync and publishes result to `composition.provenance.certificate-issued`
   - This allows other plugins to request certificates via message bus

Internal certificate hash computation:
- Serialize all CertificateEntry fields to a canonical JSON string (sorted keys, no whitespace)
- Compute SHA256.HashData of UTF-8 bytes
- Convert to lowercase hex string

All cross-plugin communication via message bus (no direct references to TamperProof or SelfTrackingDataStrategy types). Use SDK types only. Bounded internal collections. Full XML documentation.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataLineage/DataWarehouse.Plugins.UltimateDataLineage.csproj` -- zero new errors. `grep -c "CertificateAsync\|Subscribe\|MessageBus" Plugins/DataWarehouse.Plugins.UltimateDataLineage/Composition/ProvenanceCertificateService.cs` returns >8 matches.
  </verify>
  <done>ProvenanceCertificateService compiles, issues certificates by composing lineage hash chains with blockchain anchoring via message bus, supports offline Verify(), stores certificate history in bounded collection, degrades gracefully when blockchain unavailable.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
2. `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataLineage/DataWarehouse.Plugins.UltimateDataLineage.csproj` -- zero new errors
3. ProvenanceCertificate.Verify() method exists and validates hash chain
4. ProvenanceCertificateService uses only message bus for cross-plugin communication
5. All public types have XML documentation
6. No direct references to TamperProof plugin
</verification>

<success_criteria>
- Any object can produce a ProvenanceCertificate with complete transformation chain + blockchain anchor
- Certificate.Verify() validates hash chain locally without external services
- Service composes lineage (SelfTrackingData) + integrity (TamperProof blockchain) via message bus
- Graceful degradation when blockchain not configured
- Zero new build errors, all types immutable, bounded collections
</success_criteria>

<output>
After completion, create `.planning/phases/39-feature-composition/39-02-SUMMARY.md`
</output>
