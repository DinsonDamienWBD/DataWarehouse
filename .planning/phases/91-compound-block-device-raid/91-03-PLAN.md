---
phase: 91-compound-block-device-raid
plan: 03
type: execute
wave: 2
depends_on: ["91-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceErasureCodingStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceErasureCodingStrategies.cs
autonomous: true

must_haves:
  truths:
    - "Reed-Solomon erasure coding operates at the device level for 8+3 and 16+4 configurations"
    - "Fountain code erasure coding operates at the device level for rateless redundancy"
    - "Encoding distributes data across k data devices and generates m parity devices"
    - "Any k devices out of k+m total can reconstruct all original data"
    - "Device-level erasure coding produces CompoundBlockDevice instances"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceErasureCodingStrategy.cs"
      provides: "SDK interface for device-level erasure coding"
      exports: ["IDeviceErasureCodingStrategy", "ErasureCodingConfiguration", "ErasureCodingScheme"]
      min_lines: 50
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceErasureCodingStrategies.cs"
      provides: "Reed-Solomon and fountain code device-level erasure strategies"
      exports: ["DeviceReedSolomonStrategy", "DeviceFountainCodeStrategy"]
      min_lines: 250
  key_links:
    - from: "DeviceReedSolomonStrategy"
      to: "CompoundBlockDevice"
      via: "creates compound device with erasure layout"
      pattern: "new CompoundBlockDevice"
    - from: "DeviceReedSolomonStrategy"
      to: "GaloisMultiply"
      via: "GF(2^8) arithmetic for encoding/decoding"
      pattern: "GaloisMultiply|GaloisField"
    - from: "DeviceErasureCodingStrategies"
      to: "IPhysicalBlockDevice"
      via: "device array for encoding targets"
      pattern: "IPhysicalBlockDevice"
---

<objective>
Implement erasure coding at the device level using Reed-Solomon and fountain codes on physical device arrays. Support 8+3 (8 data, 3 parity) and 16+4 (16 data, 4 parity) configurations that distribute encoded blocks across IPhysicalBlockDevice arrays.

Purpose: Erasure coding provides more flexible redundancy than traditional RAID parity, allowing configurable data-to-parity ratios. At the device level, this means physical devices can be lost and data reconstructed from any sufficient subset of surviving devices.

Output: SDK interface for device-level erasure coding, plus Reed-Solomon and fountain code strategy implementations.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/91-compound-block-device-raid/91-01-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundDeviceConfiguration.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceLayoutEngine.cs
@Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/ErasureCoding/ErasureCodingStrategies.cs
@Plugins/DataWarehouse.Plugins.UltimateRAID/RaidStrategyBase.cs
@DataWarehouse.SDK/Mathematics/ReedSolomon.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: IDeviceErasureCodingStrategy SDK interface</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceErasureCodingStrategy.cs
  </files>
  <action>
Create IDeviceErasureCodingStrategy.cs in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

1. `ErasureCodingScheme` enum with `[SdkCompatibility("6.0.0")]`:
   - `ReedSolomon` -- Vandermonde matrix encoding in GF(2^8)
   - `FountainCode` -- Rateless encoding (LT codes / Raptor codes style)

2. `ErasureCodingConfiguration` sealed record with `[SdkCompatibility("6.0.0")]`:
   - `ErasureCodingScheme Scheme` (required)
   - `int DataDeviceCount` (required, k)
   - `int ParityDeviceCount` (required, m)
   - `IReadOnlyList<IPhysicalBlockDevice> Devices` (required, must have k+m devices)
   - `IReadOnlyList<IPhysicalBlockDevice>? HotSpares` (optional)
   - `int StripeSizeBlocks` (default 256)
   - `int RebuildPriority` (0-100, default 50)
   - Validate: Devices.Count == DataDeviceCount + ParityDeviceCount

3. `ErasureCodingHealth` sealed record with `[SdkCompatibility("6.0.0")]`:
   - `bool IsHealthy`
   - `int AvailableDevices`
   - `int MinimumRequiredDevices` (k)
   - `int TotalDevices` (k+m)
   - `int FailedDevices`
   - `bool CanRecoverData` (AvailableDevices >= MinimumRequiredDevices)
   - `double StorageEfficiency`

4. `IDeviceErasureCodingStrategy` interface with `[SdkCompatibility("6.0.0")]`:
   - `string StrategyId { get; }`
   - `ErasureCodingScheme Scheme { get; }`
   - `int MaxTolerableFailures { get; }` -- equals m (parity count)
   - `double StorageEfficiency { get; }` -- k / (k+m)
   - `Task<CompoundBlockDevice> CreateCompoundDeviceAsync(ErasureCodingConfiguration config, CancellationToken ct = default)`
   - `Task<ErasureCodingHealth> CheckHealthAsync(ErasureCodingConfiguration config, CancellationToken ct = default)`
   - `Task RebuildDeviceAsync(int failedDeviceIndex, IPhysicalBlockDevice replacement, ErasureCodingConfiguration config, IProgress<double>? progress = null, CancellationToken ct = default)`
   - `Task EncodeStripeAsync(ReadOnlyMemory<byte> data, IReadOnlyList<IPhysicalBlockDevice> devices, long stripeOffset, CancellationToken ct = default)` -- encode and write one stripe
   - `Task<ReadOnlyMemory<byte>> DecodeStripeAsync(IReadOnlyList<IPhysicalBlockDevice> devices, bool[] deviceAvailable, long stripeOffset, int dataLength, CancellationToken ct = default)` -- read and decode one stripe
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
IDeviceErasureCodingStrategy interface and supporting types exist in SDK. Interface covers compound device creation, health checking, rebuild, and per-stripe encode/decode operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Device-level Reed-Solomon and Fountain Code strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceErasureCodingStrategies.cs
  </files>
  <action>
Create DeviceErasureCodingStrategies.cs in namespace DataWarehouse.Plugins.UltimateRAID.Strategies.DeviceLevel:

**DeviceReedSolomonStrategy** sealed class extending StrategyBase, implementing IDeviceErasureCodingStrategy, marked `[SdkCompatibility("6.0.0")]`:

- Constructor takes `int dataDevices, int parityDevices`. Validates dataDevices + parityDevices <= 255 (GF(2^8) limit).
- StrategyId = $"device-rs-{dataDevices}+{parityDevices}" (e.g. "device-rs-8+3", "device-rs-16+4")
- Scheme = ErasureCodingScheme.ReedSolomon
- MaxTolerableFailures = parityDevices
- StorageEfficiency = dataDevices / (double)(dataDevices + parityDevices)

- `_encodingMatrix`: Generate Vandermonde matrix in GF(2^8), size (k+m) x k. First k rows = identity (data passes through), last m rows = Vandermonde coefficients for parity.

- `CreateCompoundDeviceAsync`: Create CompoundDeviceConfiguration with Parity layout, ParityDeviceCount = m. Create CompoundBlockDevice. Also store the encoding matrix in an internal dictionary keyed by config hash for decode use.

- `EncodeStripeAsync`:
  1. Split data into k chunks of equal size (pad last if needed)
  2. For each of m parity chunks: multiply each data chunk byte by encoding matrix coefficient in GF(2^8), XOR results
  3. Write k data chunks to data devices and m parity chunks to parity devices using WriteBlockAsync
  4. Use parallel writes (Task.WhenAll)

- `DecodeStripeAsync`:
  1. Read available chunks from online devices
  2. If all k data devices available: return assembled data (fast path)
  3. Otherwise: select any k available chunks (data or parity), build k x k submatrix from encoding matrix rows corresponding to available chunks, invert in GF(2^8), multiply inverse by available chunks to recover data
  4. Cache inverted matrices by availability pattern (Dictionary<string, byte[,]> keyed by comma-joined available indices)

- `RebuildDeviceAsync`:
  1. For each stripe on the failed device: call DecodeStripeAsync to recover all data, then re-encode to get the failed device's chunk, write to replacement
  2. Process in batches of 256 stripes, report progress after each batch

- GF(2^8) operations: Reuse the same GaloisMultiply, GaloisInverse, GaloisPower methods from the existing ErasureCodingStrategies.cs (copy as private static methods -- cannot reference plugin internals directly, and these are small pure functions). Use primitive polynomial 0x11D (x^8 + x^4 + x^3 + x^2 + 1).

**Preset factory methods**:
- `static DeviceReedSolomonStrategy Create8Plus3() => new(8, 3)` -- 72.7% efficiency, tolerates 3 failures
- `static DeviceReedSolomonStrategy Create16Plus4() => new(16, 4)` -- 80% efficiency, tolerates 4 failures

**DeviceFountainCodeStrategy** sealed class extending StrategyBase, implementing IDeviceErasureCodingStrategy, marked `[SdkCompatibility("6.0.0")]`:

- Constructor takes `int dataDevices, int redundancyFactor` (redundancyFactor = how many extra encoded blocks per data block, typically 1.5-3.0x)
- StrategyId = $"device-fountain-{dataDevices}x{redundancyFactor}"
- Scheme = ErasureCodingScheme.FountainCode

- Fountain code encoding (LT code variant):
  1. Each encoded block is XOR of a random subset of data blocks (subset chosen by seeded PRNG from block index)
  2. Degree distribution: Robust Soliton distribution -- most encoded blocks XOR 1-2 source blocks, some XOR many
  3. `_degreeDistribution`: precompute CDF of Robust Soliton for k data blocks

- `EncodeStripeAsync`:
  1. Split data into k source blocks
  2. Generate n = k * redundancyFactor encoded blocks
  3. For each encoded block i: seed PRNG with i, sample degree d from Soliton, select d random source blocks, XOR them
  4. Distribute encoded blocks round-robin across all devices

- `DecodeStripeAsync` (belief propagation / peeling decoder):
  1. Read available encoded blocks
  2. Build bipartite graph: encoded blocks -> source blocks they XOR
  3. Peeling: find encoded block with degree 1, recover that source block, XOR it out of all other encoded blocks that include it, repeat
  4. If peeling stalls (no degree-1 blocks): use Gaussian elimination on remaining equations
  5. Return recovered source data

- `CreateCompoundDeviceAsync`: wraps encoding/decoding into a CompoundBlockDevice by using Striped layout with a custom read/write wrapper. The CompoundBlockDevice uses Striped layout for physical distribution, but the DeviceFountainCodeStrategy intercepts at a higher level via an internal `FountainCodeBlockDevice` that wraps CompoundBlockDevice and overrides ReadBlockAsync/WriteBlockAsync to encode/decode.

- Actually -- simpler approach: `FountainCodeBlockDevice` sealed class implementing IBlockDevice that internally holds the device array and fountain strategy. Constructor takes `IReadOnlyList<IPhysicalBlockDevice> devices, DeviceFountainCodeStrategy strategy, ErasureCodingConfiguration config`. ReadBlockAsync maps to DecodeStripeAsync, WriteBlockAsync maps to EncodeStripeAsync. CreateCompoundDeviceAsync returns this FountainCodeBlockDevice (which implements IBlockDevice).

- `RebuildDeviceAsync`: re-encode all stripes from decoded data to regenerate the lost device's blocks

Register both strategies in a `DeviceErasureCodingRegistry` static dictionary.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
DeviceReedSolomonStrategy handles 8+3 and 16+4 configurations with full GF(2^8) Vandermonde encoding/decoding. DeviceFountainCodeStrategy implements LT-code-based rateless erasure coding with peeling decoder. Both produce IBlockDevice instances for VDE. All strategies rebuild failed devices correctly.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore` -- 0 errors
- DeviceReedSolomonStrategy.Create8Plus3() and Create16Plus4() instantiate without error
- GF(2^8) encoding matrix is correct size: (k+m) x k
- All public types have `[SdkCompatibility("6.0.0")]`
</verification>

<success_criteria>
Device-level erasure coding works for both Reed-Solomon (8+3, 16+4) and fountain codes. Encoding distributes data+parity across physical devices. Decoding reconstructs from any k-of-(k+m) surviving devices. Both strategies produce IBlockDevice instances usable by VDE.
</success_criteria>

<output>
After completion, create `.planning/phases/91-compound-block-device-raid/91-03-SUMMARY.md`
</output>
