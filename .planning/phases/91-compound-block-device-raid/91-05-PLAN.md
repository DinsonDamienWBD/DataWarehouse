---
phase: 91-compound-block-device-raid
plan: 05
type: execute
wave: 4
depends_on: ["91-01", "91-02", "91-03", "91-04"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DualRaidIntegrationTests.cs
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/InMemoryPhysicalBlockDevice.cs
autonomous: true

must_haves:
  truths:
    - "Device-level RAID 6 and data-level erasure coding operate simultaneously on independent failure domains"
    - "VDE operations (ReadBlock, WriteBlock, Flush) work transparently on CompoundBlockDevice"
    - "Single device failure in RAID group does not cause data loss (rebuild from parity)"
    - "Double device failure in RAID 6 group does not cause data loss (P+Q parity)"
    - "InMemoryPhysicalBlockDevice enables testing without real hardware"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DualRaidIntegrationTests.cs"
      provides: "Integration tests for device-level + data-level dual RAID"
      exports: ["DualRaidIntegrationTests"]
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/InMemoryPhysicalBlockDevice.cs"
      provides: "In-memory IPhysicalBlockDevice for testing"
      exports: ["InMemoryPhysicalBlockDevice"]
      min_lines: 80
  key_links:
    - from: "DualRaidIntegrationTests"
      to: "CompoundBlockDevice"
      via: "creates and exercises compound devices"
      pattern: "CompoundBlockDevice"
    - from: "DualRaidIntegrationTests"
      to: "DeviceRaid6Strategy"
      via: "tests RAID 6 at device level"
      pattern: "DeviceRaid6"
    - from: "InMemoryPhysicalBlockDevice"
      to: "IPhysicalBlockDevice"
      via: "implements interface with in-memory storage"
      pattern: "class InMemoryPhysicalBlockDevice.*IPhysicalBlockDevice"
---

<objective>
Create integration tests verifying dual RAID operation (device-level + data-level), VDE transparency, and independent failure domain handling. Build InMemoryPhysicalBlockDevice for hardware-free testing.

Purpose: Validates that the entire Phase 91 stack works end-to-end -- CompoundBlockDevice, device-level RAID strategies, erasure coding, and hot-spare management all functioning together. Tests prove that VDE sees CompoundBlockDevice as a normal IBlockDevice and that dual RAID provides independent failure domains.

Output: InMemoryPhysicalBlockDevice (test infrastructure), DualRaidIntegrationTests (comprehensive integration test class).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/91-compound-block-device-raid/91-01-SUMMARY.md
@.planning/phases/91-compound-block-device-raid/91-02-SUMMARY.md
@.planning/phases/91-compound-block-device-raid/91-03-SUMMARY.md
@.planning/phases/91-compound-block-device-raid/91-04-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceRaidStrategy.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceErasureCodingStrategy.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/HotSpareManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: InMemoryPhysicalBlockDevice test infrastructure</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/InMemoryPhysicalBlockDevice.cs
  </files>
  <action>
Create InMemoryPhysicalBlockDevice.cs in namespace DataWarehouse.Plugins.UltimateRAID.Strategies.DeviceLevel:

`InMemoryPhysicalBlockDevice` sealed class implementing IPhysicalBlockDevice, marked `[SdkCompatibility("6.0.0")]`:

This is a production-grade in-memory implementation of IPhysicalBlockDevice for testing device-level RAID without real hardware. NOT a mock -- it actually stores and returns data correctly.

Constructor: `InMemoryPhysicalBlockDevice(string deviceId, long capacityBytes, int blockSize = 4096, MediaType mediaType = MediaType.NVMe)`

Fields:
- `_storage`: byte[] of capacityBytes (the backing store)
- `_isOnline`: volatile bool, default true
- `_lock`: ReaderWriterLockSlim for thread safety
- `_healthStatus`: PhysicalDeviceHealth with defaults

Properties (from IBlockDevice):
- `int BlockSize` => from constructor
- `long BlockCount` => capacityBytes / blockSize

Properties (from IPhysicalBlockDevice):
- `PhysicalDeviceInfo DeviceInfo` => constructed from parameters (serial = deviceId, mediaType, busType = Virtual, capacity = capacityBytes)
- `bool IsOnline` => _isOnline
- `long PhysicalSectorSize` => blockSize
- `long LogicalSectorSize` => blockSize

Methods:

`ReadBlockAsync(long blockNumber, Memory<byte> buffer, CancellationToken ct)`:
- Validate blockNumber in range, buffer size >= BlockSize
- If !IsOnline: throw IOException("Device offline")
- _lock.EnterReadLock(), copy from _storage at offset blockNumber * BlockSize, release

`WriteBlockAsync(long blockNumber, ReadOnlyMemory<byte> data, CancellationToken ct)`:
- Validate blockNumber in range, data.Length == BlockSize
- If !IsOnline: throw IOException("Device offline")
- _lock.EnterWriteLock(), copy to _storage at offset, release

`FlushAsync` => Task.CompletedTask (in-memory, no buffering)

`TrimAsync(long blockNumber, int blockCount, CancellationToken ct)`:
- Zero out the specified range in _storage

`ReadScatterAsync` / `WriteGatherAsync`:
- Iterate operations, call ReadBlockAsync/WriteBlockAsync for each, count successes

`GetHealthAsync` => return _healthStatus

`DisposeAsync` => set _isOnline = false

**Test control methods** (for integration tests to simulate failures):
- `SimulateFailure()` -- sets _isOnline = false
- `SimulateRecovery()` -- sets _isOnline = true
- `GetStorageSnapshot()` -- returns copy of _storage for verification
- `InjectCorruption(long blockNumber)` -- writes random data to a block (simulates bit rot)
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
InMemoryPhysicalBlockDevice is a production-grade in-memory IPhysicalBlockDevice implementation that correctly stores/retrieves data and supports failure simulation for testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dual RAID integration tests</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DualRaidIntegrationTests.cs
  </files>
  <action>
Create DualRaidIntegrationTests.cs in namespace DataWarehouse.Plugins.UltimateRAID.Strategies.DeviceLevel:

`DualRaidIntegrationTests` sealed class with `[SdkCompatibility("6.0.0")]`. This is a self-contained integration test suite that can be invoked programmatically (not xUnit -- this project has no test framework dependency). Each test method returns `(bool passed, string message)`.

Helper method: `CreateDeviceArray(int count, long capacityBytes = 64 * 1024 * 1024, int blockSize = 4096)` -- creates array of InMemoryPhysicalBlockDevice.

**Test 1: VDE transparency -- CompoundBlockDevice as IBlockDevice**
`async Task<(bool, string)> TestVdeTransparencyAsync()`:
1. Create 4 InMemoryPhysicalBlockDevice (64MB each)
2. Create CompoundBlockDevice with Striped layout
3. Cast to IBlockDevice -- must work (interface impl)
4. Write known pattern to block 0 via IBlockDevice.WriteBlockAsync
5. Read back via IBlockDevice.ReadBlockAsync
6. Verify data matches
7. Write to block at 50% capacity, read back, verify
8. FlushAsync succeeds
9. Pass if all read-back matches write

**Test 2: RAID 5 single device failure and reconstruction**
`async Task<(bool, string)> TestRaid5SingleFailureAsync()`:
1. Create 4 InMemoryPhysicalBlockDevice
2. Create CompoundBlockDevice via DeviceRaid5Strategy
3. Write known data pattern across 100 blocks
4. SimulateFailure() on device[2]
5. Read all 100 blocks -- must succeed (parity reconstruction)
6. Verify all data matches original writes
7. Pass if all reads succeed despite 1 device offline

**Test 3: RAID 6 double device failure and reconstruction**
`async Task<(bool, string)> TestRaid6DoubleFailureAsync()`:
1. Create 6 InMemoryPhysicalBlockDevice
2. Create CompoundBlockDevice via DeviceRaid6Strategy
3. Write data across 200 blocks
4. SimulateFailure() on device[1] and device[4]
5. Read all 200 blocks -- must succeed (P+Q parity)
6. Verify all data matches
7. Pass if all reads succeed despite 2 devices offline

**Test 4: RAID 10 mirror failover**
`async Task<(bool, string)> TestRaid10MirrorFailoverAsync()`:
1. Create 6 InMemoryPhysicalBlockDevice (3 mirror pairs)
2. Create CompoundBlockDevice via DeviceRaid10Strategy
3. Write data across 150 blocks
4. SimulateFailure() on device[0] (primary of pair 0)
5. Read all blocks -- must succeed (reads from secondary mirror)
6. SimulateFailure() on device[3] (primary of pair 1) -- now 2 different pairs degraded
7. Read all blocks -- must still succeed
8. Verify data integrity
9. Pass if all reads succeed

**Test 5: Hot-spare automatic failover**
`async Task<(bool, string)> TestHotSpareFailoverAsync()`:
1. Create 4 data devices + 1 spare (InMemoryPhysicalBlockDevice)
2. Create DeviceRaid5Strategy, get CompoundBlockDevice
3. Create HotSpareManager with policy (HealthCheckInterval = 100ms for fast test)
4. Register spare and device group
5. Start monitoring
6. Write data across 50 blocks
7. SimulateFailure() on device[1]
8. Wait up to 5 seconds for rebuild to start (poll GetActiveRebuilds)
9. Wait for rebuild to complete (poll IsComplete)
10. Verify data integrity by reading all blocks
11. Stop monitoring
12. Pass if rebuild completed and data is intact

**Test 6: Dual RAID -- device-level RAID 6 + data-level erasure coding**
`async Task<(bool, string)> TestDualRaidAsync()`:
1. Create 6 InMemoryPhysicalBlockDevice
2. Create CompoundBlockDevice via DeviceRaid6Strategy (device-level RAID)
3. Treat CompoundBlockDevice as IBlockDevice
4. Write data to CompoundBlockDevice using a pattern that the existing data-level RAID strategies can also protect:
   - Write 10 "logical stripes" where each stripe has data + Reed-Solomon parity (using the existing ReedSolomon class from SDK)
   - This simulates VDE writing erasure-coded data onto a device-level RAID array
5. SimulateFailure() on 1 device (device-level failure)
6. Read back via CompoundBlockDevice -- parity reconstruction at device level
7. Verify data-level erasure decoding still works on the read-back data
8. SimulateFailure() on 2nd device (still within RAID 6 tolerance)
9. Read back -- dual parity reconstruction
10. Verify data-level erasure decoding still produces correct original data
11. Pass if both RAID levels operate independently and data survives

**Test 7: Reed-Solomon 8+3 device-level erasure coding**
`async Task<(bool, string)> TestReedSolomon8Plus3Async()`:
1. Create 11 InMemoryPhysicalBlockDevice (8 data + 3 parity)
2. Create DeviceReedSolomonStrategy.Create8Plus3()
3. Create CompoundBlockDevice via strategy
4. Write data across multiple stripes
5. SimulateFailure() on 3 devices (any 3)
6. Read back -- Reed-Solomon decodes from any 8 of 11
7. Verify data matches
8. Pass if 3-failure tolerance works

**RunAllTests** method:
```csharp
public async Task<IReadOnlyList<(string testName, bool passed, string message)>> RunAllTestsAsync()
```
Runs all 7 tests, collects results, returns summary. Does NOT throw on failure -- reports pass/fail per test.

All tests use try/finally to clean up (DisposeAsync on devices and compound devices). No external dependencies -- purely self-contained.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
DualRaidIntegrationTests has 7 integration tests covering VDE transparency, RAID 5/6/10 failure tolerance, hot-spare failover, dual RAID operation, and 8+3 erasure coding. All tests use InMemoryPhysicalBlockDevice and are self-contained. RunAllTestsAsync exercises the full Phase 91 stack.
  </done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore` -- 0 errors
- DualRaidIntegrationTests.RunAllTestsAsync compiles (tests will be run in verification phase)
- InMemoryPhysicalBlockDevice implements IPhysicalBlockDevice completely
- All 7 tests cover the success criteria from ROADMAP.md
- All public types have `[SdkCompatibility("6.0.0")]`
</verification>

<success_criteria>
Comprehensive integration test suite covers: VDE transparency (CompoundBlockDevice as IBlockDevice), RAID 5/6/10 failure scenarios, hot-spare automatic failover and rebuild, dual RAID (device-level + data-level) independent failure domains, and 8+3 Reed-Solomon erasure coding. InMemoryPhysicalBlockDevice enables all testing without physical hardware.
</success_criteria>

<output>
After completion, create `.planning/phases/91-compound-block-device-raid/91-05-SUMMARY.md`
</output>
