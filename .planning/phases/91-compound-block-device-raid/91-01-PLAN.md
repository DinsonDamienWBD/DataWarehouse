---
phase: 91-compound-block-device-raid
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundBlockDevice.cs
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceLayoutEngine.cs
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundDeviceConfiguration.cs
autonomous: true

must_haves:
  truths:
    - "CompoundBlockDevice implements IBlockDevice and presents multiple IPhysicalBlockDevice instances as a single logical device"
    - "Logical block addresses are mapped to (deviceIndex, physicalBlock) tuples via configurable layout"
    - "Stripe, mirror, and parity layouts are supported by the layout engine"
    - "VDE code that operates on IBlockDevice works identically with CompoundBlockDevice"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundBlockDevice.cs"
      provides: "IBlockDevice implementation over IPhysicalBlockDevice[] array"
      exports: ["CompoundBlockDevice"]
      min_lines: 150
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceLayoutEngine.cs"
      provides: "Logical-to-physical block mapping for stripe/mirror/parity layouts"
      exports: ["DeviceLayoutEngine", "DeviceLayoutType", "BlockMapping"]
      min_lines: 120
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundDeviceConfiguration.cs"
      provides: "Configuration record for CompoundBlockDevice initialization"
      exports: ["CompoundDeviceConfiguration"]
      min_lines: 40
  key_links:
    - from: "CompoundBlockDevice"
      to: "IBlockDevice"
      via: "interface implementation"
      pattern: "class CompoundBlockDevice.*IBlockDevice"
    - from: "CompoundBlockDevice"
      to: "IPhysicalBlockDevice"
      via: "device array member field"
      pattern: "IPhysicalBlockDevice\\[\\]|IReadOnlyList<IPhysicalBlockDevice>"
    - from: "CompoundBlockDevice.ReadBlockAsync"
      to: "DeviceLayoutEngine.MapLogicalToPhysical"
      via: "block mapping delegation"
      pattern: "_layout\\.Map|_layoutEngine\\.Map"
---

<objective>
Create CompoundBlockDevice that implements IBlockDevice over an array of IPhysicalBlockDevice instances, with a DeviceLayoutEngine that maps logical block addresses to physical (device, block) tuples using stripe, mirror, or parity layouts.

Purpose: This is the foundational abstraction for device-level RAID -- it allows VDE to see multiple physical devices as a single block device, with the layout engine determining how blocks are distributed across devices.

Output: Three SDK files -- CompoundBlockDevice (the IBlockDevice impl), DeviceLayoutEngine (the mapping logic), CompoundDeviceConfiguration (the config record).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/PhysicalDeviceInfo.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DevicePoolDescriptor.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CompoundDeviceConfiguration and DeviceLayoutEngine</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundDeviceConfiguration.cs
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceLayoutEngine.cs
  </files>
  <action>
Create CompoundDeviceConfiguration.cs in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

1. `DeviceLayoutType` enum: `Striped`, `Mirrored`, `Parity`, `DoubleParity`, `StripedMirror` (maps to RAID 0/1/5/6/10).
2. `BlockMapping` readonly struct: `int DeviceIndex`, `long PhysicalBlock` -- the result of mapping a logical block.
3. `CompoundDeviceConfiguration` sealed record:
   - `DeviceLayoutType Layout` (required)
   - `int StripeSizeBlocks` (default 256, must be power-of-2)
   - `int MirrorCount` (default 2, for mirrored/striped-mirror layouts)
   - `int ParityDeviceCount` (default 1 for Parity, 2 for DoubleParity)
   - `bool EnableWriteBackCache` (default false)
   - `long? OverrideBlockSize` (null = use device block size)

Create DeviceLayoutEngine.cs:

1. `DeviceLayoutEngine` sealed class with `[SdkCompatibility("6.0.0")]`:
   - Constructor takes `CompoundDeviceConfiguration config, int deviceCount`
   - Validates device count against layout type (Striped: >=2, Mirrored: >=2, Parity: >=3, DoubleParity: >=4, StripedMirror: >=4 and even)
   - `BlockMapping[] MapLogicalToPhysical(long logicalBlock)` -- returns 1 mapping for striped, N for mirrored, N+parity for parity layouts
   - `long CalculateTotalLogicalBlocks(long perDeviceBlockCount)` -- returns usable capacity based on layout

Striped mapping: `deviceIndex = (logicalBlock / stripeSizeBlocks) % dataDeviceCount`, `physicalBlock = (logicalBlock / (stripeSizeBlocks * dataDeviceCount)) * stripeSizeBlocks + (logicalBlock % stripeSizeBlocks)`.

Mirrored mapping: returns BlockMapping for ALL mirror devices with the same physicalBlock.

Parity mapping: rotating parity device per stripe group (same pattern as RAID 5/6). Data devices = total - parityCount. Parity device for stripe S = `(S % deviceCount)`. Returns data mapping + parity device indices.

StripedMirror mapping: devices grouped into mirror pairs, then striped across pairs. Each write goes to both members of the target pair.

All [SdkCompatibility("6.0.0")] attributes on public types.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
DeviceLayoutEngine correctly maps logical blocks to physical (device, block) tuples for all 5 layout types. CompoundDeviceConfiguration captures all RAID-relevant configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: CompoundBlockDevice IBlockDevice implementation</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundBlockDevice.cs
  </files>
  <action>
Create CompoundBlockDevice.cs in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

1. `CompoundBlockDevice` sealed class implementing `IBlockDevice`, marked `[SdkCompatibility("6.0.0")]`:
   - Constructor: `CompoundBlockDevice(IReadOnlyList<IPhysicalBlockDevice> devices, CompoundDeviceConfiguration config)`
   - Validates all devices are online (IsOnline), have matching BlockSize (or use config override), minimum device count for layout type
   - Store `_devices`, `_config`, `_layout` (DeviceLayoutEngine), `_blockSize`, `_blockCount`

2. Properties:
   - `int BlockSize` => from devices or config override
   - `long BlockCount` => from `_layout.CalculateTotalLogicalBlocks(minDeviceBlockCount)`
   - `IReadOnlyList<IPhysicalBlockDevice> Devices` => expose for monitoring
   - `CompoundDeviceConfiguration Configuration` => expose for inspection
   - `DeviceLayoutType ActiveLayout` => from config

3. `ReadBlockAsync(long blockNumber, Memory<byte> buffer, CancellationToken ct)`:
   - Get mappings from `_layout.MapLogicalToPhysical(blockNumber)`
   - For striped: read from single device at physical block
   - For mirrored: read from first healthy device (check IsOnline), try next if first fails
   - For parity: read from data device; if device is offline, reconstruct using XOR of remaining data + parity blocks (read all other devices in the stripe, XOR together)
   - For double parity: same but can tolerate 2 device failures using P+Q parity
   - For striped mirror: read from primary in target pair, failover to secondary

4. `WriteBlockAsync(long blockNumber, ReadOnlyMemory<byte> data, CancellationToken ct)`:
   - Get mappings from layout
   - For striped: write to single device
   - For mirrored: write to ALL mirror devices in parallel (Task.WhenAll)
   - For parity: read-modify-write -- read old data + old parity, XOR to get new parity, write new data + new parity in parallel
   - For double parity: same but update both P and Q parity
   - For striped mirror: write to both members of target pair

5. `FlushAsync(CancellationToken ct)`:
   - Flush all devices in parallel: `Task.WhenAll(_devices.Select(d => d.FlushAsync(ct)))`

6. `DisposeAsync()`:
   - Dispose all devices

Use SemaphoreSlim for parity write serialization (read-modify-write must be atomic per stripe group). Data reads and striped writes can be fully concurrent.

Do NOT use mocks or stubs -- all I/O delegates to real IPhysicalBlockDevice methods (ReadBlockAsync, WriteBlockAsync).
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
CompoundBlockDevice fully implements IBlockDevice with correct stripe/mirror/parity/double-parity/striped-mirror I/O paths. Any VDE code that takes IBlockDevice can use CompoundBlockDevice transparently.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` succeeds with 0 errors
- All three new files exist under DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/
- CompoundBlockDevice implements IBlockDevice (grep confirms `: IBlockDevice`)
- DeviceLayoutEngine handles all 5 layout types
- All public types have `[SdkCompatibility("6.0.0")]`
</verification>

<success_criteria>
CompoundBlockDevice presents N physical devices as a single IBlockDevice. Logical block addresses are correctly mapped to physical (device, block) tuples for striped, mirrored, parity, double-parity, and striped-mirror layouts. SDK builds cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/91-compound-block-device-raid/91-01-SUMMARY.md`
</output>
