---
phase: 91-compound-block-device-raid
plan: 02
type: execute
wave: 2
depends_on: ["91-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceRaidStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelRaidStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelRaidAdapter.cs
autonomous: true

must_haves:
  truths:
    - "UltimateRAID strategies can operate on IPhysicalBlockDevice[] arrays at the device level, not just data blobs"
    - "RAID 0/1/5/6/10 device-level strategies correctly distribute blocks across physical devices"
    - "Parity block distribution rotates across devices per stripe (left-symmetric for RAID 5, P+Q rotation for RAID 6)"
    - "Device-level strategies produce CompoundBlockDevice instances that VDE uses transparently"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceRaidStrategy.cs"
      provides: "SDK interface for device-level RAID strategies"
      exports: ["IDeviceRaidStrategy", "DeviceRaidConfiguration", "DeviceRaidHealth"]
      min_lines: 60
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelRaidStrategies.cs"
      provides: "RAID 0/1/5/6/10 device-level strategy implementations"
      exports: ["DeviceRaid0Strategy", "DeviceRaid1Strategy", "DeviceRaid5Strategy", "DeviceRaid6Strategy", "DeviceRaid10Strategy"]
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelRaidAdapter.cs"
      provides: "Adapter wiring device-level strategies to CompoundBlockDevice"
      exports: ["DeviceLevelRaidAdapter"]
      min_lines: 80
  key_links:
    - from: "DeviceLevelRaidStrategies"
      to: "IPhysicalBlockDevice"
      via: "device array parameter"
      pattern: "IPhysicalBlockDevice\\[\\]|IReadOnlyList<IPhysicalBlockDevice>"
    - from: "DeviceLevelRaidAdapter"
      to: "CompoundBlockDevice"
      via: "creates CompoundBlockDevice from strategy + devices"
      pattern: "new CompoundBlockDevice"
    - from: "DeviceLevelRaidStrategies"
      to: "RaidStrategyBase"
      via: "extends SDK RAID base class"
      pattern: "class Device.*Strategy.*:.*RaidStrategyBase"
---

<objective>
Wire existing UltimateRAID strategies to operate at the device level on IPhysicalBlockDevice[] arrays. Create an SDK interface for device-level RAID, implement RAID 0/1/5/6/10 device-level strategies, and an adapter that produces CompoundBlockDevice instances.

Purpose: This bridges the existing RAID logic (which operates on data blobs) with the physical device layer, enabling RAID across actual physical devices rather than just data chunks.

Output: SDK interface IDeviceRaidStrategy, five device-level RAID strategy classes, and the DeviceLevelRaidAdapter.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/91-compound-block-device-raid/91-01-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceLayoutEngine.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundDeviceConfiguration.cs
@Plugins/DataWarehouse.Plugins.UltimateRAID/RaidStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateRAID/IRaidStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/Standard/StandardRaidStrategies.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: IDeviceRaidStrategy SDK interface and DeviceRaidConfiguration</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceRaidStrategy.cs
  </files>
  <action>
Create IDeviceRaidStrategy.cs in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

1. `DeviceRaidConfiguration` sealed record with `[SdkCompatibility("6.0.0")]`:
   - `IReadOnlyList<IPhysicalBlockDevice> Devices` (required)
   - `IReadOnlyList<IPhysicalBlockDevice>? HotSpares` (optional)
   - `int StripeSizeBlocks` (default 256)
   - `bool EnableWriteBackCache` (default false)
   - `int RebuildPriority` (0-100, default 50)

2. `DeviceRaidHealth` sealed record with `[SdkCompatibility("6.0.0")]`:
   - `bool IsHealthy`
   - `int HealthyDeviceCount`
   - `int FailedDeviceCount`
   - `int RebuildingDeviceCount`
   - `double RebuildProgress` (0.0-1.0)
   - `long UsableCapacityBytes`
   - `IReadOnlyList<(string DeviceId, bool IsOnline)> DeviceStatuses`

3. `IDeviceRaidStrategy` interface with `[SdkCompatibility("6.0.0")]`:
   - `string StrategyId { get; }` -- e.g. "device-raid0", "device-raid6"
   - `string StrategyName { get; }`
   - `DeviceLayoutType RequiredLayout { get; }` -- from Plan 01's enum
   - `int MinimumDevices { get; }`
   - `int FaultTolerance { get; }` -- max device failures tolerated
   - `double StorageEfficiency { get; }` -- usable/total ratio
   - `Task<CompoundBlockDevice> CreateCompoundDeviceAsync(DeviceRaidConfiguration config, CancellationToken ct = default)` -- creates configured CompoundBlockDevice
   - `Task<DeviceRaidHealth> CheckHealthAsync(IReadOnlyList<IPhysicalBlockDevice> devices, CancellationToken ct = default)`
   - `Task RebuildDeviceAsync(IPhysicalBlockDevice failedDevice, IPhysicalBlockDevice replacement, IReadOnlyList<IPhysicalBlockDevice> healthyDevices, IProgress<double>? progress = null, CancellationToken ct = default)`
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
IDeviceRaidStrategy interface exists in SDK with CreateCompoundDeviceAsync, CheckHealthAsync, and RebuildDeviceAsync. DeviceRaidConfiguration and DeviceRaidHealth records capture all needed config and status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Device-level RAID 0/1/5/6/10 strategies and adapter</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelRaidStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelRaidAdapter.cs
  </files>
  <action>
Create DeviceLevelRaidStrategies.cs in namespace DataWarehouse.Plugins.UltimateRAID.Strategies.DeviceLevel:

Implement 5 classes, each implementing IDeviceRaidStrategy and extending StrategyBase (for lifecycle/counters). All marked `[SdkCompatibility("6.0.0")]`:

**DeviceRaid0Strategy** (Striping):
- StrategyId = "device-raid0", MinimumDevices = 2, FaultTolerance = 0, StorageEfficiency = 1.0
- RequiredLayout = DeviceLayoutType.Striped
- CreateCompoundDeviceAsync: validates >=2 devices, creates CompoundBlockDevice with Striped layout
- CheckHealthAsync: all devices must be online
- RebuildDeviceAsync: throws NotSupportedException (RAID 0 has no redundancy)

**DeviceRaid1Strategy** (Mirroring):
- StrategyId = "device-raid1", MinimumDevices = 2, FaultTolerance = N-1, StorageEfficiency = 1.0/deviceCount
- RequiredLayout = DeviceLayoutType.Mirrored
- CreateCompoundDeviceAsync: creates CompoundBlockDevice with Mirrored layout, MirrorCount = device count
- RebuildDeviceAsync: copy all blocks from healthy device to replacement using scatter-gather I/O (ReadScatterAsync/WriteGatherAsync on IPhysicalBlockDevice) in 1MB batches

**DeviceRaid5Strategy** (Distributed Parity):
- StrategyId = "device-raid5", MinimumDevices = 3, FaultTolerance = 1, StorageEfficiency = (n-1)/n
- RequiredLayout = DeviceLayoutType.Parity
- CreateCompoundDeviceAsync: creates CompoundBlockDevice with Parity layout, ParityDeviceCount = 1
- RebuildDeviceAsync: for each stripe group, read all surviving data + parity blocks, XOR to reconstruct missing block, write to replacement. Use batch processing (256 blocks per batch). Report progress.

**DeviceRaid6Strategy** (Double Distributed Parity):
- StrategyId = "device-raid6", MinimumDevices = 4, FaultTolerance = 2, StorageEfficiency = (n-2)/n
- RequiredLayout = DeviceLayoutType.DoubleParity
- CreateCompoundDeviceAsync: creates CompoundBlockDevice with DoubleParity layout, ParityDeviceCount = 2
- RebuildDeviceAsync: use P+Q parity (XOR for P, Galois field for Q) -- reuse GaloisMultiply from RaidStrategyBase. For single failure: XOR reconstruction. For double failure: solve 2-equation system in GF(2^8).

**DeviceRaid10Strategy** (Striped Mirrors):
- StrategyId = "device-raid10", MinimumDevices = 4, FaultTolerance = 1-per-pair, StorageEfficiency = 0.5
- RequiredLayout = DeviceLayoutType.StripedMirror
- CreateCompoundDeviceAsync: validates even device count, creates CompoundBlockDevice with StripedMirror layout
- RebuildDeviceAsync: identify which mirror pair the failed device belongs to, copy from surviving pair member to replacement

For each strategy: constructor accepts optional IMessageBus for intelligence integration (via ConfigureIntelligence from StrategyBase). Register all 5 strategies in a static `DeviceLevelRaidRegistry` dictionary.

Create DeviceLevelRaidAdapter.cs:

`DeviceLevelRaidAdapter` sealed class with `[SdkCompatibility("6.0.0")]`:
- `CreateCompoundDevice(string strategyId, DeviceRaidConfiguration config)` -- looks up strategy by ID, calls CreateCompoundDeviceAsync
- `GetAvailableStrategies()` -- returns all registered device-level RAID strategies
- `RecommendStrategy(int deviceCount, bool prioritizeRedundancy)` -- returns best strategy for given device count (RAID 10 if >=4 and redundancy priority, RAID 6 if >=4, RAID 5 if >=3, RAID 1 if >=2, RAID 0 if performance only)
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
All 5 device-level RAID strategies implement IDeviceRaidStrategy, create CompoundBlockDevice instances, and handle rebuild. DeviceLevelRaidAdapter provides factory and recommendation API. Full solution builds.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore` -- 0 errors
- All 5 strategies implement IDeviceRaidStrategy
- DeviceLevelRaidAdapter.GetAvailableStrategies() returns 5 entries
- All public types have `[SdkCompatibility("6.0.0")]`
</verification>

<success_criteria>
UltimateRAID plugin has 5 device-level strategies (RAID 0/1/5/6/10) that operate on physical device arrays and produce CompoundBlockDevice instances. Each strategy handles rebuild correctly for its RAID level. The adapter provides factory and recommendation APIs.
</success_criteria>

<output>
After completion, create `.planning/phases/91-compound-block-device-raid/91-02-SUMMARY.md`
</output>
