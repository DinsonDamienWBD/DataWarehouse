---
phase: 91-compound-block-device-raid
plan: 04
type: execute
wave: 3
depends_on: ["91-01", "91-02"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/HotSpareManager.cs
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceAwareFreeExtent.cs
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelHotSpareIntegration.cs
autonomous: true

must_haves:
  truths:
    - "Hot-spare devices automatically replace failed devices in a CompoundBlockDevice"
    - "Rebuild runs in background with configurable priority while I/O continues on degraded array"
    - "Rebuild progress is tracked and reported via IProgress<double>"
    - "FreeExtent is extended with device awareness: (deviceGroupId, startBlock, blockCount)"
    - "I/O to the compound device continues during rebuild (degraded mode reads use parity/mirror)"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/HotSpareManager.cs"
      provides: "Automatic hot-spare failover and background rebuild orchestration"
      exports: ["HotSpareManager", "HotSparePolicy", "RebuildStatus"]
      min_lines: 150
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceAwareFreeExtent.cs"
      provides: "Device-aware free extent record extending FreeExtent concept"
      exports: ["DeviceAwareFreeExtent", "DeviceGroupId"]
      min_lines: 40
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelHotSpareIntegration.cs"
      provides: "Wiring hot-spare manager to device-level RAID strategies"
      exports: ["DeviceLevelHotSpareIntegration"]
      min_lines: 80
  key_links:
    - from: "HotSpareManager"
      to: "IDeviceRaidStrategy.RebuildDeviceAsync"
      via: "delegates rebuild to strategy"
      pattern: "RebuildDeviceAsync"
    - from: "HotSpareManager"
      to: "IPhysicalBlockDevice.IsOnline"
      via: "health monitoring detects failures"
      pattern: "\\.IsOnline|GetHealthAsync"
    - from: "DeviceLevelHotSpareIntegration"
      to: "HotSpareManager"
      via: "registers strategies with hot-spare manager"
      pattern: "HotSpareManager"
---

<objective>
Implement hot-spare management with automatic device failover, background rebuild, and I/O continuation. Extend FreeExtent with device awareness so VDE's FreeSpaceManager can track free space per device group.

Purpose: Hot-spare management ensures that device failures are handled automatically without data loss or I/O interruption. Device-aware free extents enable VDE to allocate space intelligently across device groups.

Output: HotSpareManager (failover + rebuild orchestration), DeviceAwareFreeExtent (device-group-aware extent), DeviceLevelHotSpareIntegration (wiring to RAID strategies).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/91-compound-block-device-raid/91-01-SUMMARY.md
@.planning/phases/91-compound-block-device-raid/91-02-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/CompoundBlockDevice.cs
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IDeviceRaidStrategy.cs
@DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/ExtentTree.cs
@DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/FreeSpaceManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: DeviceAwareFreeExtent and HotSpareManager</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceAwareFreeExtent.cs
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/HotSpareManager.cs
  </files>
  <action>
Create DeviceAwareFreeExtent.cs in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

1. `DeviceGroupId` readonly struct with `[SdkCompatibility("6.0.0")]`:
   - `Guid GroupId` -- identifies the CompoundBlockDevice / RAID group
   - `int DeviceIndex` -- which physical device within the group (-1 = any/unspecified)
   - Constructor, Equals, GetHashCode, ToString overrides
   - static `DeviceGroupId Any(Guid groupId) => new(groupId, -1)`

2. `DeviceAwareFreeExtent` sealed record with `[SdkCompatibility("6.0.0")]`:
   - `DeviceGroupId DeviceGroup` -- which device group this extent belongs to
   - `long StartBlock` -- start block within the group's logical address space
   - `int BlockCount` -- contiguous block count
   - `long EndBlock => StartBlock + BlockCount` (computed)
   - `bool Overlaps(DeviceAwareFreeExtent other)` -- true if same device group and block ranges overlap
   - `DeviceAwareFreeExtent? TryMerge(DeviceAwareFreeExtent other)` -- returns merged extent if adjacent and same device group, null otherwise

Create HotSpareManager.cs in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

1. `HotSparePolicy` sealed record with `[SdkCompatibility("6.0.0")]`:
   - `TimeSpan HealthCheckInterval` (default 30 seconds)
   - `int RebuildPriority` (0-100, default 50 -- controls I/O bandwidth allocated to rebuild)
   - `bool AutoFailover` (default true)
   - `int MaxConcurrentRebuilds` (default 1)
   - `TimeSpan RebuildThrottleDelay` (default 1ms -- delay between rebuild batches to yield I/O bandwidth)

2. `RebuildStatus` sealed record with `[SdkCompatibility("6.0.0")]`:
   - `Guid RebuildId`
   - `string FailedDeviceId`
   - `string ReplacementDeviceId`
   - `double Progress` (0.0-1.0)
   - `DateTime StartedUtc`
   - `TimeSpan? EstimatedRemaining`
   - `bool IsComplete`
   - `string? ErrorMessage`

3. `HotSpareManager` sealed class with `[SdkCompatibility("6.0.0")]`:

   Constructor: `HotSpareManager(HotSparePolicy policy)`

   Fields:
   - `_spareDevices`: ConcurrentDictionary<string, IPhysicalBlockDevice> (deviceId -> spare)
   - `_activeRebuilds`: ConcurrentDictionary<Guid, RebuildStatus>
   - `_monitoredGroups`: ConcurrentDictionary<Guid, MonitoredDeviceGroup> (internal record)
   - `_healthCheckTimer`: PeriodicTimer (from policy.HealthCheckInterval)
   - `_rebuildSemaphore`: SemaphoreSlim (from policy.MaxConcurrentRebuilds)
   - `_cts`: CancellationTokenSource for background tasks

   Internal record `MonitoredDeviceGroup`:
   - `Guid GroupId`
   - `IReadOnlyList<IPhysicalBlockDevice> Devices`
   - `IDeviceRaidStrategy Strategy`
   - `CompoundBlockDevice CompoundDevice`

   Methods:
   - `RegisterSpareDevice(IPhysicalBlockDevice spare)` -- adds to spare pool
   - `UnregisterSpareDevice(string deviceId)` -- removes from spare pool
   - `RegisterDeviceGroup(Guid groupId, IReadOnlyList<IPhysicalBlockDevice> devices, IDeviceRaidStrategy strategy, CompoundBlockDevice compoundDevice)` -- adds group to monitoring
   - `StartMonitoringAsync(CancellationToken ct)` -- starts background health check loop
   - `StopMonitoringAsync()` -- cancels background tasks, waits for completion
   - `GetActiveRebuilds()` -- returns snapshot of all active rebuild statuses
   - `GetSpareDeviceCount()` -- returns available spare count

   Background health check loop (private):
   - Every HealthCheckInterval: for each monitored group, check each device's IsOnline and GetHealthAsync
   - If device goes offline and AutoFailover is true:
     1. Find a spare from _spareDevices (prefer same MediaType from DeviceInfo, then any)
     2. Remove spare from pool
     3. Create RebuildStatus, add to _activeRebuilds
     4. Start rebuild on background Task via _rebuildSemaphore:
        a. Await semaphore
        b. Call strategy.RebuildDeviceAsync(failedDevice, spare, healthyDevices, progress, ct)
        c. progress callback updates RebuildStatus.Progress and EstimatedRemaining
        d. On completion: mark IsComplete = true
        e. On failure: set ErrorMessage, return spare to pool
     5. Publish message bus event "device.failover.started" with device IDs and group ID
   - If device comes back online after being failed: log but do not auto-revert (spare is now active member)

   - `ForceRebuildAsync(Guid groupId, string failedDeviceId, IPhysicalBlockDevice replacement, CancellationToken ct)` -- manual rebuild trigger

   The health check loop uses `Task.Run` with the class-level CancellationTokenSource. Rebuild tasks respect RebuildThrottleDelay by inserting `await Task.Delay(policy.RebuildThrottleDelay)` between batches (the strategy's RebuildDeviceAsync handles batching internally, but the manager adds inter-batch delays via the progress callback timing).

   Implements IAsyncDisposable: StopMonitoringAsync, dispose timer and semaphore.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
HotSpareManager monitors device health, automatically fails over to spare devices, and orchestrates background rebuilds. DeviceAwareFreeExtent tracks free space with device-group context. RebuildStatus provides full progress tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hot-spare manager to device-level RAID strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateRAID/Strategies/DeviceLevel/DeviceLevelHotSpareIntegration.cs
  </files>
  <action>
Create DeviceLevelHotSpareIntegration.cs in namespace DataWarehouse.Plugins.UltimateRAID.Strategies.DeviceLevel:

`DeviceLevelHotSpareIntegration` sealed class with `[SdkCompatibility("6.0.0")]`:

Constructor: `DeviceLevelHotSpareIntegration(HotSpareManager hotSpareManager, IMessageBus? messageBus = null)`

Methods:

1. `async Task<CompoundBlockDevice> CreateProtectedDeviceGroupAsync(string strategyId, DeviceRaidConfiguration config, CancellationToken ct = default)`:
   - Look up strategy from DeviceLevelRaidAdapter.GetAvailableStrategies()
   - Call strategy.CreateCompoundDeviceAsync(config) to get CompoundBlockDevice
   - Register the device group with HotSpareManager: `_hotSpareManager.RegisterDeviceGroup(groupId, config.Devices, strategy, compoundDevice)`
   - If config.HotSpares != null: register each spare with HotSpareManager
   - Publish message bus event "device.group.created" with group ID and strategy ID
   - Return the CompoundBlockDevice

2. `async Task<CompoundBlockDevice> CreateProtectedErasureGroupAsync(string strategyId, ErasureCodingConfiguration config, CancellationToken ct = default)`:
   - Same pattern but for erasure coding strategies from DeviceErasureCodingRegistry
   - Wrap IDeviceErasureCodingStrategy in an adapter that implements IDeviceRaidStrategy (for HotSpareManager compatibility)
   - Register with HotSpareManager

3. `ErasureCodingToRaidAdapter` private sealed class implementing IDeviceRaidStrategy:
   - Wraps IDeviceErasureCodingStrategy
   - Maps CreateCompoundDeviceAsync -> wraps ErasureCodingConfiguration into DeviceRaidConfiguration equivalent
   - Maps RebuildDeviceAsync -> delegates to erasure strategy's RebuildDeviceAsync
   - Maps CheckHealthAsync -> delegates to erasure strategy's CheckHealthAsync, converts ErasureCodingHealth to DeviceRaidHealth

4. `Task AddHotSpareAsync(IPhysicalBlockDevice spare)` -- registers with manager
5. `Task RemoveHotSpareAsync(string deviceId)` -- unregisters from manager
6. `IReadOnlyList<RebuildStatus> GetActiveRebuilds()` -- delegates to manager
7. `Task StartProtectionAsync(CancellationToken ct)` -- starts the HotSpareManager monitoring loop
8. `Task StopProtectionAsync()` -- stops monitoring

Message bus integration (if messageBus != null):
- Subscribe to "device.health.warning" from Phase 90's PhysicalDeviceManager -- proactively register predicted-failing devices for early spare allocation
- Publish "device.rebuild.progress" periodically during rebuilds (every 10% increment)
- Publish "device.rebuild.complete" when rebuild finishes
- Publish "device.rebuild.failed" if rebuild fails
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore 2>&1 | tail -5` shows 0 errors.
  </verify>
  <done>
DeviceLevelHotSpareIntegration wires HotSpareManager to both RAID and erasure coding strategies. Device groups are automatically monitored for failures. Hot spares failover seamlessly. Message bus events enable external monitoring.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj --no-restore` -- 0 errors
- HotSpareManager implements IAsyncDisposable
- DeviceAwareFreeExtent has DeviceGroupId, StartBlock, BlockCount fields
- All public types have `[SdkCompatibility("6.0.0")]`
</verification>

<success_criteria>
Hot-spare devices automatically take over for failed devices. Rebuild runs in background with progress tracking while I/O continues. FreeExtent concept is extended with device-group awareness. Integration class wires hot-spare management to both RAID and erasure coding strategies.
</success_criteria>

<output>
After completion, create `.planning/phases/91-compound-block-device-raid/91-04-SUMMARY.md`
</output>
