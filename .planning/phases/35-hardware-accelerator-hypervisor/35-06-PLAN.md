---
phase: 35-hardware-accelerator-hypervisor
plan: 06
type: execute
wave: 4
depends_on: [35-05]
files_modified:
  - DataWarehouse.SDK/Hardware/Hypervisor/IBalloonDriver.cs
  - DataWarehouse.SDK/Hardware/Hypervisor/BalloonDriver.cs
  - DataWarehouse.SDK/Hardware/Memory/INumaAllocator.cs
  - DataWarehouse.SDK/Hardware/Memory/NumaAllocator.cs
  - DataWarehouse.SDK/Hardware/Memory/NumaTopology.cs
autonomous: true

must_haves:
  truths:
    - "BalloonDriver cooperates with hypervisor memory management by releasing cache on memory pressure"
    - "NumaAllocator discovers NUMA topology and pins buffers to controller-local NUMA node"
    - "Allocation fallback chain: local NUMA node → adjacent node → any node"
    - "On non-NUMA systems, NumaAllocator degrades to standard allocation"
    - "Platform capability registry registers 'numa' when NUMA topology detected"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/Hypervisor/IBalloonDriver.cs"
      provides: "Interface for hypervisor memory balloon cooperation"
      min_lines: 25
    - path: "DataWarehouse.SDK/Hardware/Hypervisor/BalloonDriver.cs"
      provides: "Balloon driver implementation"
      min_lines: 150
    - path: "DataWarehouse.SDK/Hardware/Memory/INumaAllocator.cs"
      provides: "Interface for NUMA-aware memory allocation"
      min_lines: 30
    - path: "DataWarehouse.SDK/Hardware/Memory/NumaAllocator.cs"
      provides: "NUMA allocator implementation"
      min_lines: 200
    - path: "DataWarehouse.SDK/Hardware/Memory/NumaTopology.cs"
      provides: "NUMA topology model"
      min_lines: 50
  key_links:
    - from: "BalloonDriver"
      to: "IHypervisorDetector"
      via: "Uses hypervisor type to determine balloon protocol"
      pattern: "HypervisorType\\."
    - from: "NumaAllocator"
      to: "IPlatformCapabilityRegistry"
      via: "Registers 'numa' capability when topology detected"
      pattern: "registry\\.RegisterCapability.*numa"
---

<objective>
Create balloon driver and NUMA-aware allocator (HW-06). Balloon driver cooperates with hypervisor memory management, releasing cache under pressure. NUMA allocator pins storage buffers to the NUMA node closest to the storage controller for optimal performance on multi-socket systems.

Purpose: Improve memory efficiency in VMs (balloon driver) and reduce memory access latency on NUMA systems (local allocation). Critical for performance on hyperscale deployments.

Output:
- `DataWarehouse.SDK/Hardware/Hypervisor/IBalloonDriver.cs` — Interface
- `DataWarehouse.SDK/Hardware/Hypervisor/BalloonDriver.cs` — Implementation
- `DataWarehouse.SDK/Hardware/Memory/INumaAllocator.cs` — Interface
- `DataWarehouse.SDK/Hardware/Memory/NumaAllocator.cs` — Implementation
- `DataWarehouse.SDK/Hardware/Memory/NumaTopology.cs` — Model
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/35-hardware-accelerator-hypervisor/35-RESEARCH.md

@DataWarehouse.SDK/Hardware/Hypervisor/IHypervisorDetector.cs
@DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: IBalloonDriver Interface</name>
  <files>
    DataWarehouse.SDK/Hardware/Hypervisor/IBalloonDriver.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Hypervisor/IBalloonDriver.cs` in namespace `DataWarehouse.SDK.Hardware.Hypervisor`.

Define public interface `IBalloonDriver`:
```csharp
/// <summary>
/// Interface for cooperating with hypervisor memory balloon drivers.
/// </summary>
/// <remarks>
/// Balloon drivers allow hypervisors to reclaim guest memory under host memory pressure.
/// DataWarehouse cooperates by releasing cache buffers when notified of memory pressure.
/// </remarks>
[SdkCompatibility("3.0.0", Notes = "Phase 35: Balloon driver interface (HW-06)")]
public interface IBalloonDriver
{
    /// <summary>
    /// Gets whether balloon driver cooperation is available.
    /// </summary>
    /// <remarks>
    /// Returns true when running in a hypervisor environment that supports ballooning
    /// (VMware, Hyper-V, KVM, Xen). Returns false on bare metal.
    /// </remarks>
    bool IsAvailable { get; }

    /// <summary>
    /// Registers for memory pressure notifications.
    /// </summary>
    /// <param name="onMemoryPressure">
    /// Callback invoked when hypervisor requests memory release.
    /// Callback receives the amount of memory (in bytes) to release.
    /// </param>
    void RegisterPressureHandler(Action<long> onMemoryPressure);

    /// <summary>
    /// Reports memory release to hypervisor.
    /// </summary>
    /// <param name="bytesReleased">Number of bytes released.</param>
    /// <remarks>
    /// Call this after releasing cache buffers to inform the hypervisor that
    /// memory is available for reclamation.
    /// </remarks>
    void ReportMemoryReleased(long bytesReleased);
}
```

Add comprehensive XML documentation.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: Balloon driver interface (HW-06)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `interface IBalloonDriver`.
  </verify>
  <done>
IBalloonDriver interface exists with IsAvailable, RegisterPressureHandler, ReportMemoryReleased.
  </done>
</task>

<task type="auto">
  <name>Task 2: BalloonDriver Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/Hypervisor/BalloonDriver.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Hypervisor/BalloonDriver.cs` in namespace `DataWarehouse.SDK.Hardware.Hypervisor`.

Implement `public sealed class BalloonDriver : IBalloonDriver, IDisposable`.

**Fields**:
```csharp
private readonly IHypervisorDetector _hypervisorDetector;
private readonly HypervisorInfo _hypervisorInfo;
private bool _isAvailable = false;
private Action<long>? _pressureHandler;
private readonly object _lock = new();
```

**Constructor**:
```csharp
public BalloonDriver(IHypervisorDetector hypervisorDetector)
{
    _hypervisorDetector = hypervisorDetector;
    _hypervisorInfo = hypervisorDetector.Detect();

    // Balloon driver available only in VM environments that support it
    _isAvailable = _hypervisorInfo.BalloonDriverAvailable;
}
```

**Property**:
- `public bool IsAvailable => _isAvailable;`

**RegisterPressureHandler(Action<long> onMemoryPressure)**:
```csharp
public void RegisterPressureHandler(Action<long> onMemoryPressure)
{
    ArgumentNullException.ThrowIfNull(onMemoryPressure);

    lock (_lock)
    {
        _pressureHandler = onMemoryPressure;

        if (_isAvailable)
        {
            // Subscribe to OS memory pressure notifications
            // For Phase 35: SIMPLIFIED — use GC.RegisterForFullGCNotification as proxy
            // Production: subscribe to hypervisor-specific pressure APIs

            // TODO: Platform-specific pressure notification subscription
            // - VMware: monitor vmballoon driver via /sys/devices/virtual/misc/balloon
            // - Hyper-V: monitor hv_balloon via Windows performance counters
            // - KVM: monitor virtio-balloon via /sys/devices/virtual/virtio-ports/vport*
        }
    }
}
```

**ReportMemoryReleased(long bytesReleased)**:
```csharp
public void ReportMemoryReleased(long bytesReleased)
{
    if (!_isAvailable)
        return;

    ArgumentOutOfRangeException.ThrowIfNegativeOrZero(bytesReleased);

    lock (_lock)
    {
        // Inform hypervisor that memory has been released
        // For Phase 35: SIMPLIFIED — no-op (actual hypervisor notification is future work)
        // Production: write to balloon driver interface:
        // - VMware: write to /sys/devices/virtual/misc/balloon/target
        // - Hyper-V: use kernel32!SetProcessWorkingSetSize with smaller size
        // - KVM: write to /dev/vport0p1 (virtio-balloon communication channel)

        // TODO: Actual hypervisor memory release notification
    }
}
```

**Dispose()**:
```csharp
public void Dispose()
{
    lock (_lock)
    {
        _pressureHandler = null;
        // TODO: Unsubscribe from pressure notifications
    }
}
```

Add comprehensive XML documentation explaining:
- Balloon driver only available in VM environments
- Memory pressure handler called when hypervisor needs memory back
- ReportMemoryReleased informs hypervisor of released memory
- **IMPORTANT**: Phase 35 provides API contract + detection. Actual hypervisor-specific notification is future work.

Add TODO comments marking platform-specific pressure notification and memory release as future work.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: Balloon driver (HW-06)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `class BalloonDriver : IBalloonDriver`. Grep for `TODO.*balloon` confirms hypervisor integration is marked future work.
  </verify>
  <done>
BalloonDriver exists implementing IBalloonDriver with hypervisor detection and placeholder pressure handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: NUMA Topology Model</name>
  <files>
    DataWarehouse.SDK/Hardware/Memory/NumaTopology.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Memory/NumaTopology.cs` in namespace `DataWarehouse.SDK.Hardware.Memory`.

Define public records for NUMA topology:

```csharp
/// <summary>
/// Represents the NUMA (Non-Uniform Memory Access) topology of the system.
/// </summary>
[SdkCompatibility("3.0.0", Notes = "Phase 35: NUMA topology model (HW-06)")]
public sealed record NumaTopology
{
    /// <summary>
    /// Gets the number of NUMA nodes in the system.
    /// </summary>
    /// <remarks>
    /// Single-socket systems typically have 1 NUMA node.
    /// Multi-socket systems have one NUMA node per socket.
    /// </remarks>
    public required int NodeCount { get; init; }

    /// <summary>
    /// Gets the NUMA nodes.
    /// </summary>
    public required IReadOnlyList<NumaNode> Nodes { get; init; }

    /// <summary>
    /// Gets the distance matrix between NUMA nodes.
    /// </summary>
    /// <remarks>
    /// Distance[i][j] represents the relative memory access cost from node i to node j.
    /// Local access (i == j) has distance 10 (normalized baseline).
    /// Adjacent nodes typically have distance 20.
    /// Remote nodes can have distance 30 or higher.
    /// </remarks>
    public int[,]? DistanceMatrix { get; init; }
}

/// <summary>
/// Represents a single NUMA node.
/// </summary>
[SdkCompatibility("3.0.0", Notes = "Phase 35: NUMA node model (HW-06)")]
public sealed record NumaNode
{
    /// <summary>
    /// Gets the NUMA node ID (0-based).
    /// </summary>
    public required int NodeId { get; init; }

    /// <summary>
    /// Gets the total memory (in bytes) on this NUMA node.
    /// </summary>
    public required long TotalMemoryBytes { get; init; }

    /// <summary>
    /// Gets the CPU cores assigned to this NUMA node.
    /// </summary>
    public required IReadOnlyList<int> CpuCores { get; init; }

    /// <summary>
    /// Gets the PCI devices local to this NUMA node.
    /// </summary>
    /// <remarks>
    /// Includes storage controllers, network adapters, GPUs, etc.
    /// Empty list if device locality information is unavailable.
    /// </remarks>
    public IReadOnlyList<string> LocalDevices { get; init; } = Array.Empty<string>();
}
```

Add comprehensive XML documentation.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: NUMA topology (HW-06)")]` attributes.
  </action>
  <verify>
Build succeeds. File exists. Grep for `record NumaTopology` and `record NumaNode`.
  </verify>
  <done>
NumaTopology and NumaNode records exist modeling NUMA system structure.
  </done>
</task>

<task type="auto">
  <name>Task 4: INumaAllocator Interface</name>
  <files>
    DataWarehouse.SDK/Hardware/Memory/INumaAllocator.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Memory/INumaAllocator.cs` in namespace `DataWarehouse.SDK.Hardware.Memory`.

Define public interface `INumaAllocator`:
```csharp
/// <summary>
/// Interface for NUMA-aware memory allocation.
/// </summary>
/// <remarks>
/// NUMA (Non-Uniform Memory Access) systems have multiple memory controllers,
/// each with local CPUs and devices. Allocating memory on the NUMA node closest
/// to the storage controller reduces latency by 2-3x compared to remote access.
/// </remarks>
[SdkCompatibility("3.0.0", Notes = "Phase 35: NUMA allocator interface (HW-06)")]
public interface INumaAllocator
{
    /// <summary>
    /// Gets the NUMA topology of the system.
    /// </summary>
    /// <remarks>
    /// Returns null on non-NUMA systems (single-socket or NUMA disabled).
    /// </remarks>
    NumaTopology? Topology { get; }

    /// <summary>
    /// Gets whether NUMA-aware allocation is available.
    /// </summary>
    bool IsNumaAware { get; }

    /// <summary>
    /// Allocates a buffer on the specified NUMA node.
    /// </summary>
    /// <param name="sizeInBytes">Size of the buffer to allocate.</param>
    /// <param name="preferredNodeId">Preferred NUMA node ID (0-based).</param>
    /// <returns>
    /// Allocated buffer. If allocation on the preferred node fails,
    /// falls back to adjacent node, then any node.
    /// </returns>
    byte[] Allocate(int sizeInBytes, int preferredNodeId);

    /// <summary>
    /// Gets the NUMA node ID for a storage device.
    /// </summary>
    /// <param name="devicePath">Device path (e.g., "/dev/nvme0n1", "\\.\PhysicalDrive0").</param>
    /// <returns>
    /// NUMA node ID where the device is located. Returns 0 if device locality
    /// cannot be determined.
    /// </returns>
    int GetDeviceNumaNode(string devicePath);
}
```

Add comprehensive XML documentation.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: NUMA allocator interface (HW-06)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `interface INumaAllocator`.
  </verify>
  <done>
INumaAllocator interface exists with Topology, IsNumaAware, Allocate, GetDeviceNumaNode.
  </done>
</task>

<task type="auto">
  <name>Task 5: NumaAllocator Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/Memory/NumaAllocator.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Memory/NumaAllocator.cs` in namespace `DataWarehouse.SDK.Hardware.Memory`.

Implement `public sealed class NumaAllocator : INumaAllocator`.

**Fields**:
```csharp
private readonly IPlatformCapabilityRegistry _registry;
private NumaTopology? _topology;
private bool _isNumaAware = false;
private readonly object _lock = new();
```

**Constructor**:
```csharp
public NumaAllocator(IPlatformCapabilityRegistry registry)
{
    _registry = registry;
    DetectTopology();
}
```

**Properties**:
- `public NumaTopology? Topology => _topology;`
- `public bool IsNumaAware => _isNumaAware;`

**DetectTopology() — private**:
```csharp
private void DetectTopology()
{
    lock (_lock)
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            _topology = DetectWindowsNumaTopology();
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            _topology = DetectLinuxNumaTopology();
        }

        _isNumaAware = _topology is not null && _topology.NodeCount > 1;

        if (_isNumaAware)
        {
            _registry.RegisterCapability("numa");
        }
    }
}
```

**DetectWindowsNumaTopology() — private**:
```csharp
private static NumaTopology? DetectWindowsNumaTopology()
{
    // Windows API: GetNumaHighestNodeNumber, GetNumaNodeProcessorMask, GetNumaAvailableMemoryNode
    // For Phase 35: SIMPLIFIED — return null (NUMA detection is future work)
    // Production: P/Invoke to kernel32.dll

    // TODO: Actual Windows NUMA detection via kernel32 APIs
    return null;
}
```

**DetectLinuxNumaTopology() — private**:
```csharp
private static NumaTopology? DetectLinuxNumaTopology()
{
    // Linux: /sys/devices/system/node/node*/meminfo, /sys/devices/system/node/node*/cpulist
    // For Phase 35: SIMPLIFIED — return null (NUMA detection is future work)
    // Production: parse /sys filesystem

    // TODO: Actual Linux NUMA detection via /sys/devices/system/node
    return null;
}
```

**Allocate(int sizeInBytes, int preferredNodeId)**:
```csharp
public byte[] Allocate(int sizeInBytes, int preferredNodeId)
{
    ArgumentOutOfRangeException.ThrowIfNegativeOrZero(sizeInBytes);

    if (!_isNumaAware || _topology is null)
    {
        // Non-NUMA system — standard allocation
        return new byte[sizeInBytes];
    }

    // NUMA-aware allocation
    // For Phase 35: SIMPLIFIED — use standard allocation with TODO comment
    // Production: use VirtualAllocExNuma (Windows) or numa_alloc_onnode (Linux)

    // TODO: Actual NUMA-aware allocation
    // - Windows: VirtualAllocExNuma(preferredNodeId)
    // - Linux: numa_alloc_onnode(preferredNodeId) via libnuma

    return new byte[sizeInBytes]; // Fallback to standard allocation
}
```

**GetDeviceNumaNode(string devicePath)**:
```csharp
public int GetDeviceNumaNode(string devicePath)
{
    ArgumentException.ThrowIfNullOrEmpty(devicePath);

    if (!_isNumaAware || _topology is null)
        return 0; // Non-NUMA system

    // For Phase 35: SIMPLIFIED — return 0 (device locality detection is future work)
    // Production:
    // - Windows: use PCI device properties via SetupAPI
    // - Linux: parse /sys/block/{device}/device/numa_node

    // TODO: Actual device NUMA node detection
    return 0;
}
```

Add comprehensive XML documentation explaining:
- NUMA-aware allocation improves performance on multi-socket systems
- Allocation fallback: preferred node → adjacent → any
- Non-NUMA systems degrade gracefully to standard allocation
- **IMPORTANT**: Phase 35 provides API contract + detection structure. Actual NUMA APIs (VirtualAllocExNuma, libnuma) are future work.

Add TODO comments on all platform-specific methods.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: NUMA allocator (HW-06)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `class NumaAllocator : INumaAllocator`. Grep for `RegisterCapability.*numa`. Grep for `TODO.*NUMA` confirms platform APIs are marked future work.
  </verify>
  <done>
NumaAllocator exists implementing INumaAllocator with topology detection structure and placeholder allocation.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Five new files exist: IBalloonDriver.cs, BalloonDriver.cs, INumaAllocator.cs, NumaAllocator.cs, NumaTopology.cs
3. IBalloonDriver interface with IsAvailable, RegisterPressureHandler, ReportMemoryReleased
4. BalloonDriver uses IHypervisorDetector to determine availability
5. NumaTopology and NumaNode records model NUMA system structure
6. INumaAllocator interface with Topology, IsNumaAware, Allocate, GetDeviceNumaNode
7. NumaAllocator registers 'numa' capability when multi-node topology detected
8. All implementations gracefully degrade on unsupported systems
9. TODO comments mark platform-specific APIs as future work
10. Zero new NuGet dependencies
</verification>

<success_criteria>
- BalloonDriver and NumaAllocator compile and implement interfaces
- BalloonDriver.IsAvailable returns true in VM, false on bare metal
- NumaAllocator.IsNumaAware returns false (Phase 35 detection is placeholder)
- Allocate() returns byte[] on all systems (standard allocation)
- Platform capability registry receives 'numa' when topology detected
- Code builds on Windows and Linux
- Zero new NuGet dependencies
- Clear TODO comments for future platform-specific implementations
</success_criteria>

<output>
After completion, create `.planning/phases/35-hardware-accelerator-hypervisor/35-06-SUMMARY.md`
</output>
