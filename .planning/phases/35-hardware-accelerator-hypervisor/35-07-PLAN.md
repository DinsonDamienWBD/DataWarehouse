---
phase: 35-hardware-accelerator-hypervisor
plan: 07
type: execute
wave: 4
depends_on: [35-05]
files_modified:
  - DataWarehouse.SDK/Hardware/NVMe/INvmePassthrough.cs
  - DataWarehouse.SDK/Hardware/NVMe/NvmePassthrough.cs
  - DataWarehouse.SDK/Hardware/NVMe/NvmeCommand.cs
  - DataWarehouse.SDK/Hardware/NVMe/NvmeInterop.cs
autonomous: true

must_haves:
  truths:
    - "INvmePassthrough.IsAvailable returns true when NVMe device accessible via passthrough"
    - "SubmitAdminCommand supports identify, get log page, firmware management"
    - "SubmitIoCommand supports read, write, TRIM/dataset management"
    - "Commands bypass OS filesystem for direct NVMe access"
    - "Namespace isolation ensures passthrough doesn't corrupt OS filesystem"
    - "Platform capability registry registers 'nvme.passthrough' when available"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/NVMe/INvmePassthrough.cs"
      provides: "Interface for NVMe command passthrough"
      min_lines: 40
    - path: "DataWarehouse.SDK/Hardware/NVMe/NvmePassthrough.cs"
      provides: "NVMe passthrough implementation"
      min_lines: 200
    - path: "DataWarehouse.SDK/Hardware/NVMe/NvmeCommand.cs"
      provides: "NVMe command structures (admin and I/O)"
      min_lines: 80
    - path: "DataWarehouse.SDK/Hardware/NVMe/NvmeInterop.cs"
      provides: "Platform-specific NVMe ioctl/IOCTL wrappers"
      min_lines: 100
  key_links:
    - from: "NvmePassthrough"
      to: "IHypervisorDetector"
      via: "Only available on bare metal or with NVMe passthrough in VM"
      pattern: "HypervisorType\\.None"
    - from: "NvmePassthrough"
      to: "IPlatformCapabilityRegistry"
      via: "Registers 'nvme.passthrough' when device accessible"
      pattern: "registry\\.RegisterCapability.*nvme"
---

<objective>
Create INvmePassthrough implementation (HW-07) for direct NVMe command submission bypassing the OS filesystem. Enables bare-metal NVMe operations with maximum throughput (>90% of hardware line rate).

Purpose: Provide user-space NVMe access for storage applications that manage their own filesystem (like DataWarehouse VDE from Phase 33). Critical for hyperscale deployments requiring maximum I/O performance.

Output:
- `DataWarehouse.SDK/Hardware/NVMe/INvmePassthrough.cs` — Interface
- `DataWarehouse.SDK/Hardware/NVMe/NvmePassthrough.cs` — Implementation
- `DataWarehouse.SDK/Hardware/NVMe/NvmeCommand.cs` — Command structures
- `DataWarehouse.SDK/Hardware/NVMe/NvmeInterop.cs` — Platform interop
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/35-hardware-accelerator-hypervisor/35-RESEARCH.md

@DataWarehouse.SDK/Hardware/Hypervisor/IHypervisorDetector.cs
@DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
@DataWarehouse.SDK/Storage/StorageAddress.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: NVMe Command Structures</name>
  <files>
    DataWarehouse.SDK/Hardware/NVMe/NvmeCommand.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/NVMe/NvmeCommand.cs` in namespace `DataWarehouse.SDK.Hardware.NVMe`.

Define NVMe command structures (simplified subset for Phase 35):

```csharp
/// <summary>
/// NVMe admin commands (opcodes).
/// </summary>
[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe admin commands (HW-07)")]
public enum NvmeAdminCommand : byte
{
    /// <summary>Identify controller or namespace.</summary>
    Identify = 0x06,

    /// <summary>Get log page.</summary>
    GetLogPage = 0x02,

    /// <summary>Firmware commit.</summary>
    FirmwareCommit = 0x10,

    /// <summary>Firmware image download.</summary>
    FirmwareDownload = 0x11,

    /// <summary>Format NVM.</summary>
    FormatNvm = 0x80
}

/// <summary>
/// NVMe I/O commands (opcodes).
/// </summary>
[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe I/O commands (HW-07)")]
public enum NvmeIoCommand : byte
{
    /// <summary>Read data from namespace.</summary>
    Read = 0x02,

    /// <summary>Write data to namespace.</summary>
    Write = 0x01,

    /// <summary>Dataset management (TRIM).</summary>
    DatasetManagement = 0x09,

    /// <summary>Write zeros.</summary>
    WriteZeroes = 0x08,

    /// <summary>Compare data.</summary>
    Compare = 0x05
}

/// <summary>
/// NVMe command submission structure (simplified for Phase 35).
/// </summary>
/// <remarks>
/// Full NVMe command is 64 bytes with CDW0-CDW15. Phase 35 provides
/// common fields only. Production implementation needs full structure.
/// </remarks>
[StructLayout(LayoutKind.Sequential, Pack = 1)]
[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe command structure (HW-07)")]
public struct NvmeCommandPacket
{
    /// <summary>Command opcode (CDW0 bits 0-7).</summary>
    public byte Opcode;

    /// <summary>Flags (CDW0 bits 8-15).</summary>
    public byte Flags;

    /// <summary>Command identifier.</summary>
    public ushort CommandId;

    /// <summary>Namespace identifier (0 for admin commands).</summary>
    public uint NamespaceId;

    /// <summary>Reserved.</summary>
    public ulong Reserved1;

    /// <summary>Metadata pointer.</summary>
    public ulong MetadataPointer;

    /// <summary>Data pointer (physical address).</summary>
    public ulong DataPointer;

    /// <summary>Command dwords 10-15 (command-specific parameters).</summary>
    public fixed uint CommandDwords[6];
}

/// <summary>
/// NVMe command completion structure.
/// </summary>
[StructLayout(LayoutKind.Sequential, Pack = 1)]
[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe completion structure (HW-07)")]
public struct NvmeCompletion
{
    /// <summary>Command-specific result (DW0).</summary>
    public uint Result;

    /// <summary>Reserved (DW1).</summary>
    public uint Reserved;

    /// <summary>Submission queue head pointer (DW2 bits 0-15).</summary>
    public ushort SqHead;

    /// <summary>Submission queue identifier (DW2 bits 16-31).</summary>
    public ushort SqId;

    /// <summary>Command identifier (DW3 bits 0-15).</summary>
    public ushort CommandId;

    /// <summary>Status field (DW3 bits 16-31): phase, status code, status code type.</summary>
    public ushort Status;
}
```

Add comprehensive XML documentation on each structure.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe commands (HW-07)")]` attributes.
  </action>
  <verify>
Build succeeds. File exists. Grep for `enum NvmeAdminCommand` and `struct NvmeCommandPacket`.
  </verify>
  <done>
NvmeCommand.cs exists with admin/IO command enums and command/completion structures.
  </done>
</task>

<task type="auto">
  <name>Task 2: NVMe Platform Interop</name>
  <files>
    DataWarehouse.SDK/Hardware/NVMe/NvmeInterop.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/NVMe/NvmeInterop.cs` in namespace `DataWarehouse.SDK.Hardware.NVMe`.

Define internal static class `NvmeInterop` with platform-specific NVMe access:

**Windows (IOCTL_STORAGE_PROTOCOL_COMMAND)**:
```csharp
// Windows NVMe passthrough via DeviceIoControl
internal const uint IOCTL_STORAGE_PROTOCOL_COMMAND = 0x004D4480;

[StructLayout(LayoutKind.Sequential)]
internal struct STORAGE_PROTOCOL_COMMAND
{
    public uint Version; // STORAGE_PROTOCOL_STRUCTURE_VERSION = 1
    public uint Length; // sizeof(STORAGE_PROTOCOL_COMMAND)
    public uint ProtocolType; // ProtocolTypeNvme = 3
    public uint Flags;
    public uint ReturnStatus;
    public uint ErrorCode;
    public uint CommandLength;
    public uint ErrorInfoLength;
    public uint DataToDeviceTransferLength;
    public uint DataFromDeviceTransferLength;
    public uint TimeOutValue; // seconds
    public uint ErrorInfoOffset;
    public uint DataToDeviceBufferOffset;
    public uint DataFromDeviceBufferOffset;
    public uint CommandSpecific;
    public uint Reserved0;
    // Followed by: command, error info, data buffers (variable length)
}

[LibraryImport("kernel32.dll", EntryPoint = "DeviceIoControl", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
internal static partial bool DeviceIoControl(
    IntPtr hDevice,
    uint dwIoControlCode,
    IntPtr lpInBuffer,
    uint nInBufferSize,
    IntPtr lpOutBuffer,
    uint nOutBufferSize,
    out uint lpBytesReturned,
    IntPtr lpOverlapped);

[LibraryImport("kernel32.dll", EntryPoint = "CreateFileW", SetLastError = true, StringMarshalling = StringMarshalling.Utf16)]
internal static partial IntPtr CreateFile(
    string lpFileName,
    uint dwDesiredAccess,
    uint dwShareMode,
    IntPtr lpSecurityAttributes,
    uint dwCreationDisposition,
    uint dwFlagsAndAttributes,
    IntPtr hTemplateFile);

[LibraryImport("kernel32.dll", EntryPoint = "CloseHandle", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
internal static partial bool CloseHandle(IntPtr hObject);

internal const uint GENERIC_READ = 0x80000000;
internal const uint GENERIC_WRITE = 0x40000000;
internal const uint FILE_SHARE_READ = 0x00000001;
internal const uint FILE_SHARE_WRITE = 0x00000002;
internal const uint OPEN_EXISTING = 3;
internal const uint FILE_ATTRIBUTE_NORMAL = 0x80;
```

**Linux (/dev/nvmeX ioctl)**:
```csharp
// Linux NVMe passthrough via /dev/nvme0, /dev/nvme1, etc.
internal const int NVME_IOCTL_ADMIN_CMD = 0xC0484E41;
internal const int NVME_IOCTL_IO_CMD = 0xC0484E43;

[StructLayout(LayoutKind.Sequential)]
internal struct nvme_admin_cmd
{
    public byte opcode;
    public byte flags;
    public ushort rsvd1;
    public uint nsid;
    public uint cdw2;
    public uint cdw3;
    public ulong metadata;
    public ulong addr;
    public uint metadata_len;
    public uint data_len;
    public uint cdw10;
    public uint cdw11;
    public uint cdw12;
    public uint cdw13;
    public uint cdw14;
    public uint cdw15;
    public uint timeout_ms;
    public uint result;
}

[LibraryImport("libc", EntryPoint = "open", SetLastError = true, StringMarshalling = StringMarshalling.Utf8)]
internal static partial int Open(string pathname, int flags);

[LibraryImport("libc", EntryPoint = "close", SetLastError = true)]
internal static partial int Close(int fd);

[LibraryImport("libc", EntryPoint = "ioctl", SetLastError = true)]
internal static partial int Ioctl(int fd, int request, ref nvme_admin_cmd arg);

internal const int O_RDWR = 2;
```

Add XML comments explaining Windows uses IOCTL_STORAGE_PROTOCOL_COMMAND, Linux uses /dev/nvmeX ioctl.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe platform interop (HW-07)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `IOCTL_STORAGE_PROTOCOL_COMMAND` (Windows). Grep for `NVME_IOCTL_ADMIN_CMD` (Linux).
  </verify>
  <done>
NvmeInterop.cs exists with Windows DeviceIoControl and Linux ioctl wrappers.
  </done>
</task>

<task type="auto">
  <name>Task 3: INvmePassthrough Interface</name>
  <files>
    DataWarehouse.SDK/Hardware/NVMe/INvmePassthrough.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/NVMe/INvmePassthrough.cs` in namespace `DataWarehouse.SDK.Hardware.NVMe`.

Define public interface `INvmePassthrough`:
```csharp
/// <summary>
/// Interface for NVMe command passthrough (direct NVMe access bypassing OS filesystem).
/// </summary>
/// <remarks>
/// <para>
/// NVMe passthrough enables direct submission of admin and I/O commands to NVMe devices,
/// bypassing the OS filesystem layer. This provides maximum throughput (>90% of hardware
/// line rate) for applications that manage their own storage (e.g., DataWarehouse VDE).
/// </para>
/// <para>
/// <strong>Availability:</strong> NVMe passthrough is only available on:
/// - Bare metal with direct NVMe device access
/// - VMs with NVMe device passthrough configured
/// Passthrough is NOT available on standard VMs using virtualized storage.
/// </para>
/// <para>
/// <strong>Namespace Isolation:</strong> Commands must target a specific NVMe namespace.
/// Ensure the namespace is NOT mounted by the OS filesystem to avoid data corruption.
/// </para>
/// <para>
/// <strong>Permissions:</strong> Requires elevated privileges (Administrator on Windows,
/// root or CAP_SYS_ADMIN on Linux).
/// </para>
/// </remarks>
[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe passthrough interface (HW-07)")]
public interface INvmePassthrough : IDisposable
{
    /// <summary>
    /// Gets whether NVMe passthrough is available for the specified device.
    /// </summary>
    bool IsAvailable { get; }

    /// <summary>
    /// Gets the NVMe controller ID.
    /// </summary>
    int ControllerId { get; }

    /// <summary>
    /// Submits an admin command to the NVMe controller.
    /// </summary>
    /// <param name="opcode">Admin command opcode.</param>
    /// <param name="nsid">Namespace ID (0 for controller-level commands).</param>
    /// <param name="dataBuffer">Data buffer for command input/output (may be null).</param>
    /// <param name="commandDwords">Command-specific dwords (CDW10-CDW15).</param>
    /// <returns>NVMe completion structure with command result.</returns>
    Task<NvmeCompletion> SubmitAdminCommandAsync(
        NvmeAdminCommand opcode,
        uint nsid,
        byte[]? dataBuffer,
        uint[] commandDwords);

    /// <summary>
    /// Submits an I/O command to the NVMe namespace.
    /// </summary>
    /// <param name="opcode">I/O command opcode.</param>
    /// <param name="nsid">Namespace ID (must be > 0).</param>
    /// <param name="startLba">Starting logical block address.</param>
    /// <param name="blockCount">Number of blocks to read/write (0-based: 0 means 1 block).</param>
    /// <param name="dataBuffer">Data buffer for I/O (required for read/write).</param>
    /// <returns>NVMe completion structure with command result.</returns>
    Task<NvmeCompletion> SubmitIoCommandAsync(
        NvmeIoCommand opcode,
        uint nsid,
        ulong startLba,
        ushort blockCount,
        byte[]? dataBuffer);
}
```

Add comprehensive XML documentation.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe passthrough interface (HW-07)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `interface INvmePassthrough`.
  </verify>
  <done>
INvmePassthrough interface exists with IsAvailable, SubmitAdminCommandAsync, SubmitIoCommandAsync.
  </done>
</task>

<task type="auto">
  <name>Task 4: NvmePassthrough Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/NVMe/NvmePassthrough.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/NVMe/NvmePassthrough.cs` in namespace `DataWarehouse.SDK.Hardware.NVMe`.

Implement `public sealed class NvmePassthrough : INvmePassthrough`.

**Fields**:
```csharp
private readonly IPlatformCapabilityRegistry _registry;
private readonly IHypervisorDetector _hypervisorDetector;
private readonly string _devicePath;
private IntPtr _deviceHandle = IntPtr.Zero; // Windows handle
private int _deviceFd = -1; // Linux file descriptor
private int _controllerId;
private bool _isAvailable = false;
private readonly object _lock = new();
```

**Constructor**:
```csharp
public NvmePassthrough(
    IPlatformCapabilityRegistry registry,
    IHypervisorDetector hypervisorDetector,
    string devicePath)
{
    _registry = registry;
    _hypervisorDetector = hypervisorDetector;
    _devicePath = devicePath;

    Initialize();
}
```

**Properties**:
- `public bool IsAvailable => _isAvailable;`
- `public int ControllerId => _controllerId;`

**Initialize() — private**:
```csharp
private void Initialize()
{
    lock (_lock)
    {
        // Check if running on bare metal or with passthrough
        var hypervisorInfo = _hypervisorDetector.Detect();
        if (hypervisorInfo.Type != HypervisorType.None)
        {
            // In VM — passthrough only available if explicitly configured
            // For Phase 35: assume NOT available in VMs (conservative)
            _isAvailable = false;
            return;
        }

        // Try to open NVMe device
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            _deviceHandle = NvmeInterop.CreateFile(
                _devicePath,
                NvmeInterop.GENERIC_READ | NvmeInterop.GENERIC_WRITE,
                NvmeInterop.FILE_SHARE_READ | NvmeInterop.FILE_SHARE_WRITE,
                IntPtr.Zero,
                NvmeInterop.OPEN_EXISTING,
                NvmeInterop.FILE_ATTRIBUTE_NORMAL,
                IntPtr.Zero);

            _isAvailable = _deviceHandle != new IntPtr(-1);
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            _deviceFd = NvmeInterop.Open(_devicePath, NvmeInterop.O_RDWR);
            _isAvailable = _deviceFd >= 0;
        }

        if (_isAvailable)
        {
            // Extract controller ID from device path
            // Windows: "\\.\PhysicalDrive0" -> controller 0
            // Linux: "/dev/nvme0" -> controller 0
            _controllerId = ExtractControllerId(_devicePath);

            _registry.RegisterCapability("nvme.passthrough");
        }
    }
}

private static int ExtractControllerId(string devicePath)
{
    // Extract numeric suffix from device path
    // Windows: "\\.\PhysicalDrive0" -> 0
    // Linux: "/dev/nvme0" -> 0
    var match = System.Text.RegularExpressions.Regex.Match(devicePath, @"\d+$");
    return match.Success ? int.Parse(match.Value) : 0;
}
```

**SubmitAdminCommandAsync(NvmeAdminCommand opcode, uint nsid, byte[]? dataBuffer, uint[] commandDwords)**:
```csharp
public async Task<NvmeCompletion> SubmitAdminCommandAsync(
    NvmeAdminCommand opcode,
    uint nsid,
    byte[]? dataBuffer,
    uint[] commandDwords)
{
    if (!_isAvailable)
        throw new InvalidOperationException("NVMe passthrough is not available.");

    ArgumentNullException.ThrowIfNull(commandDwords);
    if (commandDwords.Length != 6)
        throw new ArgumentException("Command dwords must be exactly 6 elements (CDW10-CDW15).", nameof(commandDwords));

    return await Task.Run(() =>
    {
        lock (_lock)
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                return SubmitWindowsAdminCommand(opcode, nsid, dataBuffer, commandDwords);
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                return SubmitLinuxAdminCommand(opcode, nsid, dataBuffer, commandDwords);
            }
            else
            {
                throw new PlatformNotSupportedException("NVMe passthrough not supported on this platform.");
            }
        }
    });
}
```

**SubmitWindowsAdminCommand() — private**:
```csharp
private NvmeCompletion SubmitWindowsAdminCommand(
    NvmeAdminCommand opcode,
    uint nsid,
    byte[]? dataBuffer,
    uint[] commandDwords)
{
    // SIMPLIFIED for Phase 35: Return placeholder completion
    // Production: marshal STORAGE_PROTOCOL_COMMAND, call DeviceIoControl

    // TODO: Actual Windows IOCTL_STORAGE_PROTOCOL_COMMAND marshaling
    return new NvmeCompletion
    {
        Result = 0,
        Status = 0 // Success
    };
}
```

**SubmitLinuxAdminCommand() — private**:
```csharp
private NvmeCompletion SubmitLinuxAdminCommand(
    NvmeAdminCommand opcode,
    uint nsid,
    byte[]? dataBuffer,
    uint[] commandDwords)
{
    // SIMPLIFIED for Phase 35: Return placeholder completion
    // Production: build nvme_admin_cmd structure, call ioctl

    // TODO: Actual Linux NVME_IOCTL_ADMIN_CMD marshaling
    return new NvmeCompletion
    {
        Result = 0,
        Status = 0 // Success
    };
}
```

**SubmitIoCommandAsync(NvmeIoCommand opcode, uint nsid, ulong startLba, ushort blockCount, byte[]? dataBuffer)**:
```csharp
public async Task<NvmeCompletion> SubmitIoCommandAsync(
    NvmeIoCommand opcode,
    uint nsid,
    ulong startLba,
    ushort blockCount,
    byte[]? dataBuffer)
{
    if (!_isAvailable)
        throw new InvalidOperationException("NVMe passthrough is not available.");

    ArgumentOutOfRangeException.ThrowIfZero(nsid, nameof(nsid));

    return await Task.Run(() =>
    {
        lock (_lock)
        {
            // SIMPLIFIED for Phase 35: Return placeholder completion
            // Production: marshal I/O command, submit via IOCTL/ioctl

            // TODO: Actual NVMe I/O command submission
            return new NvmeCompletion
            {
                Result = 0,
                Status = 0 // Success
            };
        }
    });
}
```

**Dispose()**:
```csharp
public void Dispose()
{
    lock (_lock)
    {
        if (_deviceHandle != IntPtr.Zero && _deviceHandle != new IntPtr(-1))
        {
            NvmeInterop.CloseHandle(_deviceHandle);
            _deviceHandle = IntPtr.Zero;
        }

        if (_deviceFd >= 0)
        {
            NvmeInterop.Close(_deviceFd);
            _deviceFd = -1;
        }
    }
}
```

Add comprehensive XML documentation explaining:
- NVMe passthrough only available on bare metal (or VMs with passthrough configured)
- Requires elevated privileges
- Namespace isolation critical (don't use passthrough on OS-mounted namespaces)
- **IMPORTANT**: Phase 35 provides device opening + API contract + placeholder command submission. Full IOCTL/ioctl marshaling is future work.

Add TODO comments on all command submission methods.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: NVMe passthrough (HW-07)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `class NvmePassthrough : INvmePassthrough`. Grep for `RegisterCapability.*nvme`. Grep for `TODO.*IOCTL` confirms Windows implementation is marked future work. Grep for `TODO.*ioctl` confirms Linux implementation is marked future work.
  </verify>
  <done>
NvmePassthrough exists implementing INvmePassthrough with device opening, capability registration, and placeholder command submission.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Four new files exist: INvmePassthrough.cs, NvmePassthrough.cs, NvmeCommand.cs, NvmeInterop.cs
3. NvmeCommand.cs defines admin/IO command enums and command/completion structures
4. NvmeInterop.cs provides Windows IOCTL and Linux ioctl wrappers
5. INvmePassthrough interface defines SubmitAdminCommandAsync, SubmitIoCommandAsync
6. NvmePassthrough opens device via CreateFile (Windows) or open (Linux)
7. IsAvailable returns false in VMs (conservative approach)
8. Platform capability registry receives "nvme.passthrough" when device opened
9. Dispose() closes device handle cleanly
10. TODO comments mark actual IOCTL/ioctl command marshaling as future work
</verification>

<success_criteria>
- NvmePassthrough compiles and implements INvmePassthrough
- On bare metal with NVMe: IsAvailable = true after successful device open
- In VM: IsAvailable = false (passthrough assumed unavailable)
- Without permissions: device open fails, IsAvailable = false
- Platform capability registry correctly reports NVMe passthrough availability
- Code builds on Windows and Linux with platform-specific device opening
- Zero new NuGet dependencies
- Clear TODO comments for future IOCTL/ioctl implementation
</success_criteria>

<output>
After completion, create `.planning/phases/35-hardware-accelerator-hypervisor/35-07-SUMMARY.md`
</output>
