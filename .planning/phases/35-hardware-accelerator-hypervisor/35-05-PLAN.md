---
phase: 35-hardware-accelerator-hypervisor
plan: 05
type: execute
wave: 3
depends_on: []
files_modified:
  - DataWarehouse.SDK/Hardware/Hypervisor/IHypervisorDetector.cs
  - DataWarehouse.SDK/Hardware/Hypervisor/HypervisorDetector.cs
  - DataWarehouse.SDK/Hardware/Hypervisor/HypervisorType.cs
  - DataWarehouse.SDK/Hardware/Hypervisor/HypervisorInfo.cs
autonomous: true

must_haves:
  truths:
    - "IHypervisorDetector.Detect() accurately identifies VMware, Hyper-V, KVM, Xen, and bare-metal"
    - "Detection completes in <100ms via CPUID or platform-specific APIs"
    - "HypervisorInfo provides environment type, version (if detectable), optimization hints"
    - "Optimization hints include paravirtualized I/O recommendations (virtio-blk, PVSCSI)"
    - "Platform capability registry registers 'hypervisor', 'hypervisor.vmware|hyperv|kvm|xen' based on detection"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/Hypervisor/IHypervisorDetector.cs"
      provides: "Interface for hypervisor detection"
      min_lines: 30
    - path: "DataWarehouse.SDK/Hardware/Hypervisor/HypervisorDetector.cs"
      provides: "Hypervisor detection implementation via CPUID and platform APIs"
      min_lines: 200
    - path: "DataWarehouse.SDK/Hardware/Hypervisor/HypervisorType.cs"
      provides: "Enum for hypervisor types"
      min_lines: 15
    - path: "DataWarehouse.SDK/Hardware/Hypervisor/HypervisorInfo.cs"
      provides: "Record with hypervisor details and optimization hints"
      min_lines: 30
  key_links:
    - from: "HypervisorDetector"
      to: "IPlatformCapabilityRegistry"
      via: "Registers 'hypervisor.*' capabilities when virtualization detected"
      pattern: "registry\\.RegisterCapability.*hypervisor"
---

<objective>
Create IHypervisorDetector implementation (HW-05) that accurately identifies the virtualization environment (VMware ESXi, Hyper-V, KVM, Xen, or bare-metal) and provides environment-specific optimization hints.

Purpose: Enable environment-aware optimizations. On VMware, use PVSCSI. On Hyper-V, use enlightenments. On bare-metal, use direct hardware access. Critical for Phase 37 (multi-environment deployment).

Output:
- `DataWarehouse.SDK/Hardware/Hypervisor/IHypervisorDetector.cs` — Interface
- `DataWarehouse.SDK/Hardware/Hypervisor/HypervisorDetector.cs` — Implementation
- `DataWarehouse.SDK/Hardware/Hypervisor/HypervisorType.cs` — Enum
- `DataWarehouse.SDK/Hardware/Hypervisor/HypervisorInfo.cs` — Info record
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/35-hardware-accelerator-hypervisor/35-RESEARCH.md

@DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: HypervisorType Enum</name>
  <files>
    DataWarehouse.SDK/Hardware/Hypervisor/HypervisorType.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Hypervisor/HypervisorType.cs` in namespace `DataWarehouse.SDK.Hardware.Hypervisor`.

Define public enum `HypervisorType`:
```csharp
/// <summary>
/// Types of hypervisors/virtualization environments.
/// </summary>
[SdkCompatibility("3.0.0", Notes = "Phase 35: Hypervisor detection (HW-05)")]
public enum HypervisorType
{
    /// <summary>No hypervisor detected — running on bare metal.</summary>
    None,

    /// <summary>VMware ESXi hypervisor.</summary>
    VMware,

    /// <summary>Microsoft Hyper-V hypervisor.</summary>
    HyperV,

    /// <summary>KVM (Kernel-based Virtual Machine) hypervisor.</summary>
    KVM,

    /// <summary>Xen hypervisor.</summary>
    Xen,

    /// <summary>QEMU without KVM acceleration.</summary>
    QEMU,

    /// <summary>Microsoft Virtual PC (legacy).</summary>
    VirtualPC,

    /// <summary>Oracle VirtualBox.</summary>
    VirtualBox,

    /// <summary>Parallels Desktop.</summary>
    Parallels,

    /// <summary>Unknown or unrecognized hypervisor.</summary>
    Unknown
}
```

Add XML documentation on each member explaining the hypervisor.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: Hypervisor types (HW-05)")]` attribute on the enum.
  </action>
  <verify>
Build succeeds. File exists. Grep for `enum HypervisorType` confirms all variants.
  </verify>
  <done>
HypervisorType enum exists with 10 variants.
  </done>
</task>

<task type="auto">
  <name>Task 2: HypervisorInfo Record</name>
  <files>
    DataWarehouse.SDK/Hardware/Hypervisor/HypervisorInfo.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Hypervisor/HypervisorInfo.cs` in namespace `DataWarehouse.SDK.Hardware.Hypervisor`.

Define public record `HypervisorInfo`:
```csharp
/// <summary>
/// Information about the detected hypervisor environment.
/// </summary>
[SdkCompatibility("3.0.0", Notes = "Phase 35: Hypervisor detection info (HW-05)")]
public sealed record HypervisorInfo
{
    /// <summary>
    /// Gets the detected hypervisor type.
    /// </summary>
    public required HypervisorType Type { get; init; }

    /// <summary>
    /// Gets the hypervisor version string, if detectable.
    /// </summary>
    /// <remarks>
    /// May be null if version information is not available.
    /// Examples: "ESXi 7.0.3", "Hyper-V 2022", "KVM 5.15.0".
    /// </remarks>
    public string? Version { get; init; }

    /// <summary>
    /// Gets environment-specific optimization hints.
    /// </summary>
    /// <remarks>
    /// Provides recommendations for optimal performance in this environment.
    /// Examples:
    /// - "use virtio-blk for storage" (KVM)
    /// - "use PVSCSI for storage" (VMware)
    /// - "enable Hyper-V enlightenments" (Hyper-V)
    /// - "direct hardware access available" (bare metal)
    /// </remarks>
    public required IReadOnlyList<string> OptimizationHints { get; init; }

    /// <summary>
    /// Gets whether paravirtualized I/O is available.
    /// </summary>
    public bool ParavirtualizedIoAvailable { get; init; }

    /// <summary>
    /// Gets whether the hypervisor supports memory ballooning.
    /// </summary>
    public bool BalloonDriverAvailable { get; init; }
}
```

Add comprehensive XML documentation explaining each property.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: Hypervisor info record (HW-05)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `record HypervisorInfo` confirms structure.
  </verify>
  <done>
HypervisorInfo record exists with Type, Version, OptimizationHints, ParavirtualizedIoAvailable, BalloonDriverAvailable.
  </done>
</task>

<task type="auto">
  <name>Task 3: IHypervisorDetector Interface</name>
  <files>
    DataWarehouse.SDK/Hardware/Hypervisor/IHypervisorDetector.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Hypervisor/IHypervisorDetector.cs` in namespace `DataWarehouse.SDK.Hardware.Hypervisor`.

Define public interface `IHypervisorDetector`:
```csharp
/// <summary>
/// Interface for detecting the hypervisor/virtualization environment.
/// </summary>
[SdkCompatibility("3.0.0", Notes = "Phase 35: Hypervisor detection interface (HW-05)")]
public interface IHypervisorDetector
{
    /// <summary>
    /// Detects the current hypervisor environment.
    /// </summary>
    /// <returns>
    /// Information about the detected hypervisor. Returns <see cref="HypervisorType.None"/>
    /// when running on bare metal (no hypervisor detected).
    /// </returns>
    /// <remarks>
    /// Detection is performed via CPUID instruction (x86/x64), platform-specific APIs
    /// (Windows registry, Linux /sys filesystem), or other heuristics. Detection completes
    /// in under 100ms and is safe to call repeatedly (results are cached).
    /// </remarks>
    HypervisorInfo Detect();
}
```

Add comprehensive XML documentation.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: Hypervisor detector interface (HW-05)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `interface IHypervisorDetector`.
  </verify>
  <done>
IHypervisorDetector interface exists with Detect() method.
  </done>
</task>

<task type="auto">
  <name>Task 4: HypervisorDetector Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/Hypervisor/HypervisorDetector.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Hypervisor/HypervisorDetector.cs` in namespace `DataWarehouse.SDK.Hardware.Hypervisor`.

Implement `public sealed class HypervisorDetector : IHypervisorDetector`.

**Fields**:
```csharp
private readonly IPlatformCapabilityRegistry _registry;
private HypervisorInfo? _cachedResult;
private readonly object _lock = new();
```

**Constructor**:
```csharp
public HypervisorDetector(IPlatformCapabilityRegistry registry)
{
    _registry = registry;
}
```

**Detect()**:
```csharp
public HypervisorInfo Detect()
{
    if (_cachedResult is not null)
        return _cachedResult;

    lock (_lock)
    {
        if (_cachedResult is not null)
            return _cachedResult;

        HypervisorType type = DetectHypervisorType();
        string? version = DetectVersion(type);
        List<string> hints = BuildOptimizationHints(type);
        bool paravirt = HasParavirtualizedIo(type);
        bool balloon = HasBalloonDriver(type);

        _cachedResult = new HypervisorInfo
        {
            Type = type,
            Version = version,
            OptimizationHints = hints.AsReadOnly(),
            ParavirtualizedIoAvailable = paravirt,
            BalloonDriverAvailable = balloon
        };

        RegisterCapabilities(type);

        return _cachedResult;
    }
}
```

**DetectHypervisorType() — private**:
```csharp
private static HypervisorType DetectHypervisorType()
{
    // Strategy 1: CPUID (x86/x64 only)
    if (RuntimeInformation.ProcessArchitecture == Architecture.X64 ||
        RuntimeInformation.ProcessArchitecture == Architecture.X86)
    {
        string cpuidSignature = GetCpuidHypervisorSignature();
        if (!string.IsNullOrEmpty(cpuidSignature))
        {
            return cpuidSignature switch
            {
                "VMwareVMware" => HypervisorType.VMware,
                "Microsoft Hv" => HypervisorType.HyperV,
                "KVMKVMKVM" => HypervisorType.KVM,
                "XenVMMXenVMM" => HypervisorType.Xen,
                "TCGTCGTCGTCG" => HypervisorType.QEMU,
                "VBoxVBoxVBox" => HypervisorType.VirtualBox,
                _ => HypervisorType.Unknown
            };
        }
    }

    // Strategy 2: Platform-specific detection
    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    {
        return DetectWindowsHypervisor();
    }
    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
    {
        return DetectLinuxHypervisor();
    }

    // Strategy 3: No hypervisor detected
    return HypervisorType.None;
}
```

**GetCpuidHypervisorSignature() — private**:
```csharp
private static string GetCpuidHypervisorSignature()
{
    // CPUID leaf 0x40000000 returns hypervisor signature in EBX, ECX, EDX
    // For Phase 35: SIMPLIFIED — use placeholder
    // Production: use System.Runtime.Intrinsics.X86.X86Base.CpuId(0x40000000, 0)

    // TODO: Actual CPUID implementation
    // For now, return empty string (falls back to platform-specific detection)
    return string.Empty;
}
```

**DetectWindowsHypervisor() — private**:
```csharp
private static HypervisorType DetectWindowsHypervisor()
{
    // Check registry for VM signatures
    // Hyper-V: HKLM\SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters
    // VMware: HKLM\SOFTWARE\VMware, Inc.\VMware Tools
    // VirtualBox: HKLM\HARDWARE\ACPI\DSDT\VBOX__

    try
    {
        using var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters");
        if (key is not null)
            return HypervisorType.HyperV;
    }
    catch { }

    try
    {
        using var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\VMware, Inc.\VMware Tools");
        if (key is not null)
            return HypervisorType.VMware;
    }
    catch { }

    // TODO: Check other registry keys for VirtualBox, Parallels, etc.

    return HypervisorType.None;
}
```

**DetectLinuxHypervisor() — private**:
```csharp
private static HypervisorType DetectLinuxHypervisor()
{
    // Check /sys/hypervisor/type
    const string hypervisorTypePath = "/sys/hypervisor/type";
    if (File.Exists(hypervisorTypePath))
    {
        string typeStr = File.ReadAllText(hypervisorTypePath).Trim();
        return typeStr switch
        {
            "xen" => HypervisorType.Xen,
            _ => HypervisorType.Unknown
        };
    }

    // Check /proc/cpuinfo for hypervisor flag
    const string cpuinfoPath = "/proc/cpuinfo";
    if (File.Exists(cpuinfoPath))
    {
        string cpuinfo = File.ReadAllText(cpuinfoPath);
        if (cpuinfo.Contains("hypervisor"))
        {
            // Hypervisor present, but type unknown — use CPUID fallback
            return HypervisorType.Unknown;
        }
    }

    return HypervisorType.None;
}
```

**DetectVersion(HypervisorType type) — private**:
```csharp
private static string? DetectVersion(HypervisorType type)
{
    // For Phase 35: return null (version detection is complex and platform-specific)
    // Production: query hypervisor-specific APIs for version
    return null;
}
```

**BuildOptimizationHints(HypervisorType type) — private**:
```csharp
private static List<string> BuildOptimizationHints(HypervisorType type)
{
    return type switch
    {
        HypervisorType.VMware => new List<string>
        {
            "Use PVSCSI for storage I/O",
            "Use VMXNET3 for network",
            "Enable VMware Tools for guest operations"
        },
        HypervisorType.HyperV => new List<string>
        {
            "Enable Hyper-V enlightenments",
            "Use synthetic storage (SCSI) instead of IDE",
            "Use synthetic network adapter",
            "Enable Dynamic Memory cooperation"
        },
        HypervisorType.KVM => new List<string>
        {
            "Use virtio-blk for storage",
            "Use virtio-net for network",
            "Enable paravirtualized clock",
            "Use virtio-scsi for multi-queue support"
        },
        HypervisorType.Xen => new List<string>
        {
            "Use Xen paravirtualized drivers (blkfront, netfront)",
            "Enable Xen PV clock",
            "Use grant tables for shared memory"
        },
        HypervisorType.None => new List<string>
        {
            "Direct hardware access available",
            "Use native NVMe drivers",
            "NUMA-aware allocation recommended",
            "No virtualization overhead"
        },
        _ => new List<string>()
    };
}
```

**HasParavirtualizedIo(HypervisorType type) — private**:
```csharp
private static bool HasParavirtualizedIo(HypervisorType type)
{
    return type is HypervisorType.VMware or HypervisorType.HyperV or HypervisorType.KVM or HypervisorType.Xen;
}
```

**HasBalloonDriver(HypervisorType type) — private**:
```csharp
private static bool HasBalloonDriver(HypervisorType type)
{
    return type is HypervisorType.VMware or HypervisorType.HyperV or HypervisorType.KVM or HypervisorType.Xen;
}
```

**RegisterCapabilities(HypervisorType type) — private**:
```csharp
private void RegisterCapabilities(HypervisorType type)
{
    if (type == HypervisorType.None)
        return; // Bare metal — no hypervisor capabilities

    _registry.RegisterCapability("hypervisor");

    string typeKey = type switch
    {
        HypervisorType.VMware => "hypervisor.vmware",
        HypervisorType.HyperV => "hypervisor.hyperv",
        HypervisorType.KVM => "hypervisor.kvm",
        HypervisorType.Xen => "hypervisor.xen",
        HypervisorType.QEMU => "hypervisor.qemu",
        HypervisorType.VirtualBox => "hypervisor.virtualbox",
        HypervisorType.Parallels => "hypervisor.parallels",
        HypervisorType.VirtualPC => "hypervisor.virtualpc",
        _ => "hypervisor.unknown"
    };

    _registry.RegisterCapability(typeKey);
}
```

Add comprehensive XML documentation on the class explaining:
- Detection via CPUID (x86/x64), Windows registry, Linux /sys filesystem
- Results are cached — safe to call repeatedly
- Detection completes in <100ms
- Optimization hints guide environment-specific tuning

Add TODO comments on GetCpuidHypervisorSignature explaining actual CPUID implementation is future work.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: Hypervisor detection (HW-05)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `class HypervisorDetector : IHypervisorDetector`. Grep for `RegisterCapability.*hypervisor`. Grep for `DetectHypervisorType`. Grep for `TODO.*CPUID` confirms CPUID implementation is marked future work.
  </verify>
  <done>
HypervisorDetector exists implementing IHypervisorDetector with multi-strategy detection, optimization hints, and capability registration.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Four new files exist: IHypervisorDetector.cs, HypervisorDetector.cs, HypervisorType.cs, HypervisorInfo.cs
3. HypervisorType enum has 10 variants
4. HypervisorInfo record has Type, Version, OptimizationHints, ParavirtualizedIoAvailable, BalloonDriverAvailable
5. IHypervisorDetector defines Detect() method
6. HypervisorDetector implements detection via Windows registry and Linux /sys
7. Optimization hints are environment-specific (VMware → PVSCSI, KVM → virtio-blk, etc.)
8. Platform capability registry receives "hypervisor" + specific type ("hypervisor.vmware", etc.)
9. Results are cached — repeated calls return same instance
10. TODO comment marks CPUID implementation as future work
</verification>

<success_criteria>
- HypervisorDetector compiles and implements IHypervisorDetector
- On bare metal: Detect() returns Type = None, hints include "direct hardware access"
- On Hyper-V: Detect() returns Type = HyperV, hints include "Enable Hyper-V enlightenments"
- On VMware: Detect() returns Type = VMware, hints include "Use PVSCSI"
- Platform capability registry correctly reports hypervisor type
- Detection completes quickly (<100ms) via registry/filesystem checks
- Zero new NuGet dependencies
- Clear TODO for CPUID implementation
</success_criteria>

<output>
After completion, create `.planning/phases/35-hardware-accelerator-hypervisor/35-05-SUMMARY.md`
</output>
