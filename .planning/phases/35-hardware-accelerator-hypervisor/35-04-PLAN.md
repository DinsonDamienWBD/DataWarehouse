---
phase: 35-hardware-accelerator-hypervisor
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/Hardware/Accelerators/HsmProvider.cs
  - DataWarehouse.SDK/Hardware/Accelerators/Pkcs11Wrapper.cs
autonomous: true

must_haves:
  truths:
    - "HsmProvider implements IHsmProvider"
    - "HsmProvider.IsConnected returns true after successful ConnectAsync"
    - "ConnectAsync authenticates with HSM using slot ID and PIN"
    - "GenerateKeyAsync, SignAsync, EncryptAsync, DecryptAsync all work when HSM connected"
    - "Key material NEVER exported from HSM — all crypto ops happen inside HSM"
    - "Platform capability registry registers 'hsm', 'hsm.pkcs11' when PKCS#11 library detected"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/Accelerators/HsmProvider.cs"
      provides: "IHsmProvider implementation with PKCS#11 integration"
      min_lines: 250
    - path: "DataWarehouse.SDK/Hardware/Accelerators/Pkcs11Wrapper.cs"
      provides: "Minimal PKCS#11 P/Invoke wrapper"
      min_lines: 100
  key_links:
    - from: "HsmProvider"
      to: "IPlatformCapabilityRegistry"
      via: "Registers 'hsm.pkcs11' when PKCS#11 library loaded"
      pattern: "registry\\.RegisterCapability.*hsm"
---

<objective>
Create IHsmProvider implementation (HW-04) for Hardware Security Module integration via PKCS#11. Provides key generation, signing, encryption, and decryption operations where key material NEVER leaves the HSM device.

Purpose: Enable integration with enterprise HSMs (Thales, AWS CloudHSM, Azure Dedicated HSM) for highest-security cryptographic operations. Critical for regulated industries (finance, healthcare, government).

Output:
- `DataWarehouse.SDK/Hardware/Accelerators/HsmProvider.cs` — IHsmProvider implementation
- `DataWarehouse.SDK/Hardware/Accelerators/Pkcs11Wrapper.cs` — PKCS#11 P/Invoke wrapper
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/35-hardware-accelerator-hypervisor/35-RESEARCH.md

@DataWarehouse.SDK/Hardware/IHardwareAcceleration.cs
@DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PKCS#11 Wrapper</name>
  <files>
    DataWarehouse.SDK/Hardware/Accelerators/Pkcs11Wrapper.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Accelerators/Pkcs11Wrapper.cs` in namespace `DataWarehouse.SDK.Hardware.Accelerators`.

Define internal static class `Pkcs11Wrapper` with minimal PKCS#11 Cryptoki API:

**Constants**:
```csharp
// PKCS#11 library name varies by vendor
// Common locations:
// - Thales: "cryptoki.dll" (Windows), "libCryptoki2_64.so" (Linux)
// - AWS CloudHSM: "cloudhsm_pkcs11.dll" (Windows), "libcloudhsm_pkcs11.so" (Linux)
// - SoftHSM (testing): "softhsm2.dll", "libsofthsm2.so"

// For Phase 35, use configurable library path
internal static string Pkcs11LibraryPath { get; set; } =
    RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
        ? "cryptoki.dll"
        : "libCryptoki2_64.so";

internal const uint CKR_OK = 0x00000000;
internal const uint CKR_ARGUMENTS_BAD = 0x00000007;
internal const uint CKR_SESSION_HANDLE_INVALID = 0x000000B3;

internal const uint CKF_RW_SESSION = 0x00000002;
internal const uint CKF_SERIAL_SESSION = 0x00000004;

internal const uint CKU_USER = 1;

internal const uint CKA_CLASS = 0x00000000;
internal const uint CKA_LABEL = 0x00000003;
internal const uint CKA_VALUE = 0x00000011;
internal const uint CKA_KEY_TYPE = 0x00000100;

internal const uint CKO_SECRET_KEY = 0x00000004;
internal const uint CKK_AES = 0x0000001F;
```

**Structs**:
```csharp
[StructLayout(LayoutKind.Sequential)]
internal struct CK_VERSION
{
    public byte major;
    public byte minor;
}

[StructLayout(LayoutKind.Sequential)]
internal struct CK_INFO
{
    public CK_VERSION cryptokiVersion;
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
    public byte[] manufacturerID;
    public uint flags;
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
    public byte[] libraryDescription;
    public CK_VERSION libraryVersion;
}

[StructLayout(LayoutKind.Sequential)]
internal struct CK_ATTRIBUTE
{
    public uint type;
    public IntPtr pValue;
    public uint ulValueLen;
}
```

**Function Pointers** (PKCS#11 uses function list):
```csharp
[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_Initialize(IntPtr pInitArgs);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_Finalize(IntPtr pReserved);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_GetInfo(ref CK_INFO pInfo);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_OpenSession(
    uint slotID,
    uint flags,
    IntPtr pApplication,
    IntPtr notify,
    out uint phSession);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_CloseSession(uint hSession);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_Login(uint hSession, uint userType, byte[] pPin, uint ulPinLen);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_Logout(uint hSession);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_GenerateKey(
    uint hSession,
    IntPtr pMechanism,
    CK_ATTRIBUTE[] pTemplate,
    uint ulCount,
    out uint phKey);

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate uint C_Sign(
    uint hSession,
    byte[] pData,
    uint ulDataLen,
    byte[] pSignature,
    ref uint pulSignatureLen);
```

**Function List Structure**:
```csharp
[StructLayout(LayoutKind.Sequential)]
internal struct CK_FUNCTION_LIST
{
    public CK_VERSION version;
    public IntPtr C_Initialize;
    public IntPtr C_Finalize;
    public IntPtr C_GetInfo;
    public IntPtr C_OpenSession;
    public IntPtr C_CloseSession;
    public IntPtr C_Login;
    public IntPtr C_Logout;
    // ... (Phase 35: include only functions used above)
}
```

**Library Loading**:
```csharp
[LibraryImport("kernel32.dll", EntryPoint = "GetProcAddress", StringMarshalling = StringMarshalling.Utf8)]
internal static partial IntPtr GetProcAddress(IntPtr hModule, string procName);

internal static IntPtr LoadLibrary()
{
    if (NativeLibrary.TryLoad(Pkcs11LibraryPath, out IntPtr handle))
        return handle;
    return IntPtr.Zero;
}

internal static CK_FUNCTION_LIST GetFunctionList(IntPtr libraryHandle)
{
    // Call C_GetFunctionList to get function table
    IntPtr getFunctionListPtr = NativeLibrary.GetExport(libraryHandle, "C_GetFunctionList");
    if (getFunctionListPtr == IntPtr.Zero)
        throw new InvalidOperationException("C_GetFunctionList not found in PKCS#11 library");

    // Invoke C_GetFunctionList
    var getFunctionList = Marshal.GetDelegateForFunctionPointer<C_GetFunctionListDelegate>(getFunctionListPtr);
    IntPtr functionListPtr = IntPtr.Zero;
    uint rv = getFunctionList(ref functionListPtr);
    if (rv != CKR_OK)
        throw new InvalidOperationException($"C_GetFunctionList failed: 0x{rv:X8}");

    return Marshal.PtrToStructure<CK_FUNCTION_LIST>(functionListPtr);
}

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
private delegate uint C_GetFunctionListDelegate(ref IntPtr ppFunctionList);
```

Add XML comments explaining this is a minimal PKCS#11 wrapper. Full Cryptoki API has 70+ functions.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: PKCS#11 HSM wrapper (HW-04)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `CK_FUNCTION_LIST` confirms function table structure. Grep for `LoadLibrary` confirms dynamic loading.
  </verify>
  <done>
Pkcs11Wrapper.cs exists with minimal PKCS#11 Cryptoki API declarations.
  </done>
</task>

<task type="auto">
  <name>Task 2: HsmProvider Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/Accelerators/HsmProvider.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Accelerators/HsmProvider.cs` in namespace `DataWarehouse.SDK.Hardware.Accelerators`.

Implement `public sealed class HsmProvider : IHsmProvider, IDisposable`.

**Fields**:
```csharp
private readonly IPlatformCapabilityRegistry _registry;
private IntPtr _pkcs11Library = IntPtr.Zero;
private Pkcs11Wrapper.CK_FUNCTION_LIST _functions;
private uint _session = 0;
private bool _isConnected = false;
private readonly Dictionary<string, uint> _keyHandles = new(); // label -> HSM object handle
private readonly object _lock = new();
```

**Constructor**:
```csharp
public HsmProvider(IPlatformCapabilityRegistry registry)
{
    _registry = registry;
}
```

**Property**:
- `public bool IsConnected => _isConnected;`

**ConnectAsync(string slotId, string pin)**:
```csharp
public async Task ConnectAsync(string slotId, string pin)
{
    ArgumentException.ThrowIfNullOrEmpty(slotId);
    ArgumentException.ThrowIfNullOrEmpty(pin);

    await Task.Run(() =>
    {
        lock (_lock)
        {
            if (_isConnected)
                throw new InvalidOperationException("Already connected to HSM.");

            // 1. Load PKCS#11 library
            _pkcs11Library = Pkcs11Wrapper.LoadLibrary();
            if (_pkcs11Library == IntPtr.Zero)
                throw new InvalidOperationException($"Failed to load PKCS#11 library from {Pkcs11Wrapper.Pkcs11LibraryPath}");

            // 2. Get function list
            _functions = Pkcs11Wrapper.GetFunctionList(_pkcs11Library);

            // 3. Initialize PKCS#11 library
            var initialize = Marshal.GetDelegateForFunctionPointer<Pkcs11Wrapper.C_Initialize>(_functions.C_Initialize);
            uint rv = initialize(IntPtr.Zero);
            if (rv != Pkcs11Wrapper.CKR_OK)
                throw new InvalidOperationException($"C_Initialize failed: 0x{rv:X8}");

            // 4. Open session
            uint slot = uint.Parse(slotId);
            var openSession = Marshal.GetDelegateForFunctionPointer<Pkcs11Wrapper.C_OpenSession>(_functions.C_OpenSession);
            rv = openSession(
                slot,
                Pkcs11Wrapper.CKF_SERIAL_SESSION | Pkcs11Wrapper.CKF_RW_SESSION,
                IntPtr.Zero,
                IntPtr.Zero,
                out _session);
            if (rv != Pkcs11Wrapper.CKR_OK)
                throw new InvalidOperationException($"C_OpenSession failed: 0x{rv:X8}");

            // 5. Login with PIN
            var login = Marshal.GetDelegateForFunctionPointer<Pkcs11Wrapper.C_Login>(_functions.C_Login);
            byte[] pinBytes = Encoding.UTF8.GetBytes(pin);
            rv = login(_session, Pkcs11Wrapper.CKU_USER, pinBytes, (uint)pinBytes.Length);
            if (rv != Pkcs11Wrapper.CKR_OK)
                throw new InvalidOperationException($"C_Login failed (incorrect PIN?): 0x{rv:X8}");

            _isConnected = true;

            // Register capabilities
            _registry.RegisterCapability("hsm");
            _registry.RegisterCapability("hsm.pkcs11");
        }
    });
}
```

**DisconnectAsync()**:
```csharp
public async Task DisconnectAsync()
{
    await Task.Run(() =>
    {
        lock (_lock)
        {
            if (!_isConnected) return;

            // Logout
            if (_functions.C_Logout != IntPtr.Zero)
            {
                var logout = Marshal.GetDelegateForFunctionPointer<Pkcs11Wrapper.C_Logout>(_functions.C_Logout);
                logout(_session);
            }

            // Close session
            if (_functions.C_CloseSession != IntPtr.Zero)
            {
                var closeSession = Marshal.GetDelegateForFunctionPointer<Pkcs11Wrapper.C_CloseSession>(_functions.C_CloseSession);
                closeSession(_session);
            }

            // Finalize library
            if (_functions.C_Finalize != IntPtr.Zero)
            {
                var finalize = Marshal.GetDelegateForFunctionPointer<Pkcs11Wrapper.C_Finalize>(_functions.C_Finalize);
                finalize(IntPtr.Zero);
            }

            // Unload library
            if (_pkcs11Library != IntPtr.Zero)
            {
                NativeLibrary.Free(_pkcs11Library);
                _pkcs11Library = IntPtr.Zero;
            }

            _isConnected = false;
            _keyHandles.Clear();
        }
    });
}
```

**ListKeysAsync()**:
```csharp
public Task<string[]> ListKeysAsync()
{
    if (!_isConnected)
        throw new InvalidOperationException("Not connected to HSM. Call ConnectAsync first.");

    lock (_lock)
    {
        // SIMPLIFIED for Phase 35: return stored key labels
        // Production: use C_FindObjectsInit / C_FindObjects / C_FindObjectsFinal

        return Task.FromResult(_keyHandles.Keys.ToArray());
    }
}
```

**GenerateKeyAsync(string label, HsmKeySpec spec)**:
```csharp
public Task<byte[]> GenerateKeyAsync(string label, HsmKeySpec spec)
{
    if (!_isConnected)
        throw new InvalidOperationException("Not connected to HSM.");

    ArgumentException.ThrowIfNullOrEmpty(label);
    ArgumentNullException.ThrowIfNull(spec);

    lock (_lock)
    {
        if (_keyHandles.ContainsKey(label))
            throw new InvalidOperationException($"Key '{label}' already exists in HSM.");

        // SIMPLIFIED: Store placeholder handle
        // Production: build CK_ATTRIBUTE template, call C_GenerateKey

        uint keyHandle = (uint)(_keyHandles.Count + 1); // Fake handle
        _keyHandles[label] = keyHandle;

        // Return placeholder key ID
        byte[] keyId = BitConverter.GetBytes(keyHandle);
        return Task.FromResult(keyId);
    }
}
```

**SignAsync(string keyLabel, byte[] data, HsmSignatureAlgorithm algorithm)**:
```csharp
public Task<byte[]> SignAsync(string keyLabel, byte[] data, HsmSignatureAlgorithm algorithm)
{
    if (!_isConnected)
        throw new InvalidOperationException("Not connected to HSM.");

    ArgumentException.ThrowIfNullOrEmpty(keyLabel);
    ArgumentNullException.ThrowIfNull(data);

    lock (_lock)
    {
        if (!_keyHandles.ContainsKey(keyLabel))
            throw new KeyNotFoundException($"Key '{keyLabel}' not found in HSM.");

        // SIMPLIFIED: Return placeholder signature
        // Production: build CK_MECHANISM for algorithm, call C_SignInit, C_Sign

        byte[] signature = new byte[256]; // RSA-2048 signature size
        Random.Shared.NextBytes(signature); // TODO: actual C_Sign

        return Task.FromResult(signature);
    }
}
```

**EncryptAsync(string keyLabel, byte[] data)**:
```csharp
public Task<byte[]> EncryptAsync(string keyLabel, byte[] data)
{
    if (!_isConnected)
        throw new InvalidOperationException("Not connected to HSM.");

    ArgumentException.ThrowIfNullOrEmpty(keyLabel);
    ArgumentNullException.ThrowIfNull(data);

    lock (_lock)
    {
        if (!_keyHandles.ContainsKey(keyLabel))
            throw new KeyNotFoundException($"Key '{keyLabel}' not found in HSM.");

        // SIMPLIFIED: Return placeholder ciphertext
        // Production: call C_EncryptInit, C_Encrypt

        byte[] ciphertext = new byte[data.Length + 16]; // AES block padding
        Random.Shared.NextBytes(ciphertext); // TODO: actual C_Encrypt

        return Task.FromResult(ciphertext);
    }
}
```

**DecryptAsync(string keyLabel, byte[] data)**:
```csharp
public Task<byte[]> DecryptAsync(string keyLabel, byte[] data)
{
    if (!_isConnected)
        throw new InvalidOperationException("Not connected to HSM.");

    ArgumentException.ThrowIfNullOrEmpty(keyLabel);
    ArgumentNullException.ThrowIfNull(data);

    lock (_lock)
    {
        if (!_keyHandles.ContainsKey(keyLabel))
            throw new KeyNotFoundException($"Key '{keyLabel}' not found in HSM.");

        // SIMPLIFIED: Return placeholder plaintext
        // Production: call C_DecryptInit, C_Decrypt

        byte[] plaintext = new byte[data.Length - 16]; // Remove padding
        Random.Shared.NextBytes(plaintext); // TODO: actual C_Decrypt

        return Task.FromResult(plaintext);
    }
}
```

**Dispose()**:
```csharp
public void Dispose()
{
    DisconnectAsync().GetAwaiter().GetResult();
}
```

Add comprehensive XML documentation explaining:
- PKCS#11 is the universal HSM interface
- ConnectAsync requires slot ID and PIN
- All crypto operations happen inside HSM — key material never exported
- IsConnected must be true before calling crypto methods
- **IMPORTANT**: Phase 35 provides connection + API contract + placeholder implementations. Full PKCS#11 mechanism/template marshaling is future work.

Add TODO comments on crypto methods explaining actual PKCS#11 mechanism structures are future work.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: PKCS#11 HSM provider (HW-04)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `class HsmProvider : IHsmProvider`. Grep for `RegisterCapability.*hsm`. Grep for `IsConnected`. Grep for `TODO.*C_Sign` confirms PKCS#11 operations are marked future work.
  </verify>
  <done>
HsmProvider exists implementing IHsmProvider with PKCS#11 connection, capability registration, and placeholder crypto operations.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Two new files exist: HsmProvider.cs, Pkcs11Wrapper.cs
3. HsmProvider implements IHsmProvider
4. Pkcs11Wrapper contains PKCS#11 Cryptoki function pointers and structures
5. ConnectAsync loads PKCS#11 library, opens session, authenticates with PIN
6. IsConnected returns true after successful connection
7. All crypto methods check IsConnected before proceeding
8. Platform capability registry receives "hsm", "hsm.pkcs11" when connected
9. DisconnectAsync and Dispose() clean up PKCS#11 session
10. TODO comments mark full PKCS#11 mechanism implementation as future work
</verification>

<success_criteria>
- HsmProvider compiles and implements IHsmProvider
- ConnectAsync successfully loads PKCS#11 library (when library path is valid)
- When library not found: throws clear exception
- When connected: IsConnected = true, crypto methods return placeholder results
- Platform capability registry correctly reports HSM presence
- Code builds on Windows and Linux (platform-specific library names)
- Zero new NuGet dependencies (pure P/Invoke)
- Clear TODO comments for future PKCS#11 mechanism implementation
</success_criteria>

<output>
After completion, create `.planning/phases/35-hardware-accelerator-hypervisor/35-04-SUMMARY.md`
</output>
