---
phase: 35-hardware-accelerator-hypervisor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Hardware/Accelerators/QatAccelerator.cs
  - DataWarehouse.SDK/Hardware/Accelerators/QatNativeInterop.cs
autonomous: true

must_haves:
  truths:
    - "QatAccelerator implements IQatAccelerator and IHardwareAccelerator"
    - "QatAccelerator.IsAvailable returns true on QAT-equipped machines, false otherwise"
    - "CompressQatAsync, DecompressQatAsync, EncryptQatAsync, DecryptQatAsync all work when QAT is available"
    - "When QAT is unavailable, IsAvailable = false and methods throw InvalidOperationException with clear message"
    - "Platform capability registry registers 'qat', 'qat.compression', 'qat.encryption' capabilities when QAT detected"
    - "Zero exceptions during construction even when QAT is absent (detection is lazy or safe)"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/Accelerators/QatAccelerator.cs"
      provides: "IQatAccelerator implementation with hardware detection and fallback"
      min_lines: 200
    - path: "DataWarehouse.SDK/Hardware/Accelerators/QatNativeInterop.cs"
      provides: "P/Invoke declarations for Intel QAT native library"
      min_lines: 80
  key_links:
    - from: "QatAccelerator"
      to: "IPlatformCapabilityRegistry"
      via: "Registers 'qat.*' capabilities when hardware detected"
      pattern: "registry\\.RegisterCapability.*qat"
    - from: "QatAccelerator"
      to: "IHardwareProbe"
      via: "Queries for PCI device with vendor ID 0x8086, device ID 0x37C8 (QAT)"
      pattern: "HardwareDeviceType\\.PciDevice"
---

<objective>
Create IQatAccelerator implementation (HW-01) for Intel QuickAssist Technology hardware acceleration of compression (deflate, LZ4) and encryption (AES-GCM, AES-CBC).

Purpose: Offload CPU-intensive compression and encryption operations to Intel QAT hardware when available. Provides >3x throughput improvement for supported algorithms on QAT-equipped servers.

Output:
- `DataWarehouse.SDK/Hardware/Accelerators/QatAccelerator.cs` — IQatAccelerator implementation with detection and fallback
- `DataWarehouse.SDK/Hardware/Accelerators/QatNativeInterop.cs` — P/Invoke declarations for QAT library
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/35-hardware-accelerator-hypervisor/35-RESEARCH.md

@DataWarehouse.SDK/Hardware/IHardwareAcceleration.cs
@DataWarehouse.SDK/Hardware/IHardwareProbe.cs
@DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: QAT Native Interop</name>
  <files>
    DataWarehouse.SDK/Hardware/Accelerators/QatNativeInterop.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Accelerators/QatNativeInterop.cs` in namespace `DataWarehouse.SDK.Hardware.Accelerators`.

This file provides P/Invoke declarations for the Intel QAT native library.

**Strategy**: Use [LibraryImport] instead of DllImport (preferred in .NET 9 for source generation and better trimming).

Define internal static class `QatNativeInterop` with the following:

**Constants**:
- Library name: `private const string QatLibrary = "qatlib";` (Linux) or `"qat.dll"` (Windows) — use `RuntimeInformation.IsOSPlatform(OSPlatform.Windows)` conditional
- Status codes: `QAT_STATUS_SUCCESS = 0`, `QAT_STATUS_FAIL = -1`, `QAT_STATUS_RETRY = -2`

**Structs** (simplified, production would have full structures):
```csharp
[StructLayout(LayoutKind.Sequential)]
internal struct CpaBufferList
{
    public uint NumBuffers;
    public IntPtr Buffers; // CpaFlatBuffer*
    public IntPtr PrivateMetaData;
}

[StructLayout(LayoutKind.Sequential)]
internal struct CpaFlatBuffer
{
    public uint DataLenInBytes;
    public IntPtr PData; // byte*
}
```

**Functions** (minimum required for demo):
```csharp
[LibraryImport(QatLibrary, EntryPoint = "cpaDcGetNumInstances")]
internal static partial int GetNumInstances(out ushort numInstances);

[LibraryImport(QatLibrary, EntryPoint = "cpaDcGetInstances")]
internal static partial int GetInstances(ushort numInstances, IntPtr[] instances);

[LibraryImport(QatLibrary, EntryPoint = "cpaDcStartInstance")]
internal static partial int StartInstance(IntPtr instance);

[LibraryImport(QatLibrary, EntryPoint = "cpaDcStopInstance")]
internal static partial int StopInstance(IntPtr instance);

[LibraryImport(QatLibrary, EntryPoint = "cpaDcCompressData")]
internal static partial int CompressData(
    IntPtr instance,
    IntPtr sessionHandle,
    ref CpaBufferList srcBuffer,
    ref CpaBufferList dstBuffer,
    ref IntPtr results,
    IntPtr callbackTag);

[LibraryImport(QatLibrary, EntryPoint = "cpaDcDecompressData")]
internal static partial int DecompressData(
    IntPtr instance,
    IntPtr sessionHandle,
    ref CpaBufferList srcBuffer,
    ref CpaBufferList dstBuffer,
    ref IntPtr results,
    IntPtr callbackTag);
```

Add XML comments explaining that this is a minimal QAT API surface for DataWarehouse integration. Full QAT API is much larger.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: QAT native interop (HW-01)")]` attribute.

**Error handling**: All functions return int status codes. Caller must check for `QAT_STATUS_SUCCESS`.

**Safety**: Use `NativeLibrary.TryLoad()` to test library availability before calling functions. See QatAccelerator implementation.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists. Grep for `LibraryImport.*qat` confirms P/Invoke declarations.
  </verify>
  <done>
QatNativeInterop.cs exists with P/Invoke declarations for QAT library.
  </done>
</task>

<task type="auto">
  <name>Task 2: QatAccelerator Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/Accelerators/QatAccelerator.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Accelerators/QatAccelerator.cs` in namespace `DataWarehouse.SDK.Hardware.Accelerators`.

Implement `public sealed class QatAccelerator : IQatAccelerator, IDisposable`.

**Fields**:
```csharp
private readonly IPlatformCapabilityRegistry _registry;
private readonly IHardwareProbe _probe;
private IntPtr _qatInstance = IntPtr.Zero;
private bool _isAvailable = false;
private bool _initialized = false;
private long _operationsCompleted = 0;
private readonly object _lock = new();
```

**Constructor**:
```csharp
public QatAccelerator(IPlatformCapabilityRegistry registry, IHardwareProbe probe)
```

Store dependencies. Do NOT initialize QAT in constructor (lazy initialization in InitializeAsync).

**Properties**:
- `public AcceleratorType Type => AcceleratorType.IntelQAT;`
- `public bool IsAvailable => _isAvailable;`

**InitializeAsync()**:
```csharp
public async Task InitializeAsync()
{
    lock (_lock)
    {
        if (_initialized) return;

        // 1. Try to load QAT library via NativeLibrary.TryLoad("qatlib" or "qat.dll")
        //    If load fails, set _isAvailable = false, _initialized = true, return

        // 2. Call QatNativeInterop.GetNumInstances(out ushort count)
        //    If status != SUCCESS or count == 0, unload library, _isAvailable = false, return

        // 3. Call GetInstances, StartInstance on first instance
        //    If success, set _qatInstance, _isAvailable = true

        // 4. If available, register capabilities with registry:
        //    _registry.RegisterCapability("qat")
        //    _registry.RegisterCapability("qat.compression")
        //    _registry.RegisterCapability("qat.encryption")

        _initialized = true;
    }
}
```

**CompressQatAsync(byte[] data, QatCompressionLevel level)**:
```csharp
public async Task<byte[]> CompressQatAsync(byte[] data, QatCompressionLevel level)
{
    if (!_isAvailable)
        throw new InvalidOperationException("QAT hardware is not available on this system. Check IsAvailable before calling.");

    ArgumentNullException.ThrowIfNull(data);

    // Allocate output buffer (conservative: input size + 1024 for header)
    byte[] output = new byte[data.Length + 1024];

    // Create CpaBufferList structures, pin byte arrays with GCHandle
    // Call QatNativeInterop.CompressData
    // If status == SUCCESS, return actual compressed bytes
    // If status == FAIL, throw InvalidOperationException("QAT compression failed")

    Interlocked.Increment(ref _operationsCompleted);

    return output; // (truncated to actual size)
}
```

Implement similar pattern for `DecompressQatAsync`, `EncryptQatAsync`, `DecryptQatAsync`.

**ProcessAsync(byte[] data, AcceleratorOperation operation)** — IHardwareAccelerator contract:
```csharp
public Task<byte[]> ProcessAsync(byte[] data, AcceleratorOperation operation)
{
    return operation switch
    {
        AcceleratorOperation.Compress => CompressQatAsync(data, QatCompressionLevel.Balanced),
        AcceleratorOperation.Decompress => DecompressQatAsync(data),
        AcceleratorOperation.Encrypt => throw new NotSupportedException("Use EncryptQatAsync with explicit key"),
        AcceleratorOperation.Decrypt => throw new NotSupportedException("Use DecryptQatAsync with explicit key"),
        _ => throw new ArgumentException($"Operation {operation} not supported by QAT accelerator", nameof(operation))
    };
}
```

**GetStatisticsAsync()**:
```csharp
public Task<AcceleratorStatistics> GetStatisticsAsync()
{
    return Task.FromResult(new AcceleratorStatistics(
        Type: AcceleratorType.IntelQAT,
        OperationsCompleted: Interlocked.Read(ref _operationsCompleted),
        AverageThroughputMBps: 0.0, // TODO: track throughput
        CurrentUtilization: 0.0, // QAT doesn't expose utilization directly
        TotalProcessingTime: TimeSpan.Zero // TODO: track time
    ));
}
```

**Dispose()**:
```csharp
public void Dispose()
{
    if (_qatInstance != IntPtr.Zero)
    {
        QatNativeInterop.StopInstance(_qatInstance);
        _qatInstance = IntPtr.Zero;
    }
}
```

Add comprehensive XML documentation on the class explaining:
- QAT must be installed on the host (Intel QAT driver + library)
- IsAvailable returns false when hardware is absent
- >3x throughput improvement for compression/encryption on QAT hardware
- Transparent fallback: caller checks IsAvailable and uses software path if false

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: Intel QAT hardware acceleration (HW-01)")]` attribute.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists. Grep for `class QatAccelerator : IQatAccelerator` confirms implementation. Grep for `RegisterCapability.*qat` confirms capability registration. Grep for `IsAvailable` confirms detection logic.
  </verify>
  <done>
QatAccelerator exists implementing IQatAccelerator with hardware detection, capability registration, and graceful fallback when QAT is unavailable.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Two new files exist: QatAccelerator.cs, QatNativeInterop.cs
3. QatAccelerator implements IQatAccelerator and IHardwareAccelerator
4. QatNativeInterop contains LibraryImport declarations for QAT library
5. InitializeAsync uses NativeLibrary.TryLoad for safe library loading
6. IsAvailable property returns false when QAT is not present
7. All QAT methods check IsAvailable and throw clear exception when unavailable
8. Platform capability registry receives "qat", "qat.compression", "qat.encryption" when available
9. Dispose() stops QAT instance cleanly
10. Zero external dependencies added to SDK (QAT library is runtime dependency only)
</verification>

<success_criteria>
- QatAccelerator compiles and implements both IQatAccelerator and IHardwareAccelerator
- On machine without QAT: IsAvailable = false, methods throw with clear error message
- On machine with QAT: IsAvailable = true, compression/encryption offload to hardware
- Platform capability registry correctly reports QAT presence
- Zero exceptions during construction (detection is lazy in InitializeAsync)
- Zero new NuGet dependencies
- Code builds on Windows and Linux (platform-specific library names handled)
</success_criteria>

<output>
After completion, create `.planning/phases/35-hardware-accelerator-hypervisor/35-01-SUMMARY.md`
</output>
