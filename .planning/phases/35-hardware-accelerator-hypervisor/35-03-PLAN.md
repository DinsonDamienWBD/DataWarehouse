---
phase: 35-hardware-accelerator-hypervisor
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/Hardware/Accelerators/Tpm2Provider.cs
  - DataWarehouse.SDK/Hardware/Accelerators/Tpm2Interop.cs
autonomous: true

must_haves:
  truths:
    - "Tpm2Provider implements ITpm2Provider"
    - "Tpm2Provider.IsAvailable returns true when TPM2 device detected, false otherwise"
    - "CreateKeyAsync, SignAsync, EncryptAsync, DecryptAsync, GetRandomAsync all work when TPM2 available"
    - "Keys never leave TPM — private key material is never exposed to software"
    - "Platform capability registry registers 'tpm2', 'tpm2.sealing', 'tpm2.attestation' when TPM2 detected"
  artifacts:
    - path: "DataWarehouse.SDK/Hardware/Accelerators/Tpm2Provider.cs"
      provides: "ITpm2Provider implementation with TPM2 detection"
      min_lines: 200
    - path: "DataWarehouse.SDK/Hardware/Accelerators/Tpm2Interop.cs"
      provides: "P/Invoke for TPM2 access (Windows TBS, Linux /dev/tpmrm0)"
      min_lines: 80
  key_links:
    - from: "Tpm2Provider"
      to: "IPlatformCapabilityRegistry"
      via: "Registers 'tpm2.*' capabilities when TPM2 detected"
      pattern: "registry\\.RegisterCapability.*tpm2"
---

<objective>
Create ITpm2Provider implementation (HW-03) for TPM 2.0 hardware security module integration. Provides hardware-bound key storage, sealing/unsealing data to platform state (PCR values), remote attestation, and cryptographically secure random number generation.

Purpose: Enable hardware-backed security where keys never leave the TPM chip. Critical for high-security environments (government, healthcare, finance).

Output:
- `DataWarehouse.SDK/Hardware/Accelerators/Tpm2Provider.cs` — ITpm2Provider implementation
- `DataWarehouse.SDK/Hardware/Accelerators/Tpm2Interop.cs` — Platform-specific TPM2 access
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/35-hardware-accelerator-hypervisor/35-RESEARCH.md

@DataWarehouse.SDK/Hardware/IHardwareAcceleration.cs
@DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: TPM2 Platform Interop</name>
  <files>
    DataWarehouse.SDK/Hardware/Accelerators/Tpm2Interop.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Accelerators/Tpm2Interop.cs` in namespace `DataWarehouse.SDK.Hardware.Accelerators`.

Define internal static class `Tpm2Interop` with platform-specific TPM access:

**Windows (TBS - TPM Base Services)**:
```csharp
// Windows uses Tbsi.dll (TPM Base Services)
[LibraryImport("Tbsi.dll", EntryPoint = "Tbsi_Context_Create")]
internal static partial uint TbsiContextCreate(ref TBS_CONTEXT_PARAMS2 contextParams, out IntPtr context);

[LibraryImport("Tbsi.dll", EntryPoint = "Tbsip_Context_Close")]
internal static partial uint TbsipContextClose(IntPtr context);

[LibraryImport("Tbsi.dll", EntryPoint = "Tbsip_Submit_Command")]
internal static partial uint TbsipSubmitCommand(
    IntPtr context,
    uint locality,
    uint priority,
    byte[] commandBuffer,
    uint commandSize,
    byte[] responseBuffer,
    ref uint responseSize);

[StructLayout(LayoutKind.Sequential)]
internal struct TBS_CONTEXT_PARAMS2
{
    public uint Version; // TBS_CONTEXT_VERSION_TWO = 2
}
```

**Linux (direct /dev/tpmrm0 access)**:
```csharp
// Linux uses /dev/tpmrm0 (TPM Resource Manager)
// File I/O via standard System.IO.FileStream
// No P/Invoke needed for Linux — use FileStream for read/write
internal static class LinuxTpmAccess
{
    internal const string TpmDevice = "/dev/tpmrm0";

    internal static bool IsAvailable()
    {
        return File.Exists(TpmDevice);
    }
}
```

**Detection helper**:
```csharp
internal static bool IsTpm2Available()
{
    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    {
        // Try to create TBS context
        TBS_CONTEXT_PARAMS2 p = new() { Version = 2 };
        uint result = TbsiContextCreate(ref p, out IntPtr ctx);
        if (result == 0 && ctx != IntPtr.Zero)
        {
            TbsipContextClose(ctx);
            return true;
        }
        return false;
    }
    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
    {
        return LinuxTpmAccess.IsAvailable();
    }
    return false;
}
```

Add XML comments explaining Windows uses TBS API, Linux uses /dev/tpmrm0 device file.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: TPM2 platform interop (HW-03)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `TbsiContextCreate` (Windows). Grep for `TpmDevice.*tpmrm0` (Linux).
  </verify>
  <done>
Tpm2Interop.cs exists with platform-specific TPM2 access via TBS (Windows) and /dev/tpmrm0 (Linux).
  </done>
</task>

<task type="auto">
  <name>Task 2: Tpm2Provider Implementation</name>
  <files>
    DataWarehouse.SDK/Hardware/Accelerators/Tpm2Provider.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Hardware/Accelerators/Tpm2Provider.cs` in namespace `DataWarehouse.SDK.Hardware.Accelerators`.

Implement `public sealed class Tpm2Provider : ITpm2Provider, IDisposable`.

**Fields**:
```csharp
private readonly IPlatformCapabilityRegistry _registry;
private IntPtr _tpmContext = IntPtr.Zero; // Windows TBS context
private FileStream? _tpmDevice = null; // Linux /dev/tpmrm0
private bool _isAvailable = false;
private readonly Dictionary<string, byte[]> _keyHandles = new(); // keyId -> TPM handle
private readonly object _lock = new();
```

**Constructor**:
```csharp
public Tpm2Provider(IPlatformCapabilityRegistry registry)
```

Store registry. Detection happens on first use (lazy).

**Property**:
- `public bool IsAvailable => _isAvailable;`

**Initialize() — private**:
```csharp
private void Initialize()
{
    if (_isAvailable) return;

    lock (_lock)
    {
        if (_isAvailable) return;

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            // Create TBS context
            var p = new Tpm2Interop.TBS_CONTEXT_PARAMS2 { Version = 2 };
            uint result = Tpm2Interop.TbsiContextCreate(ref p, out _tpmContext);
            if (result == 0 && _tpmContext != IntPtr.Zero)
            {
                _isAvailable = true;
                RegisterCapabilities();
            }
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            if (File.Exists(Tpm2Interop.LinuxTpmAccess.TpmDevice))
            {
                try
                {
                    _tpmDevice = File.Open(
                        Tpm2Interop.LinuxTpmAccess.TpmDevice,
                        FileMode.Open,
                        FileAccess.ReadWrite,
                        FileShare.None);
                    _isAvailable = true;
                    RegisterCapabilities();
                }
                catch
                {
                    _isAvailable = false;
                }
            }
        }
    }
}

private void RegisterCapabilities()
{
    _registry.RegisterCapability("tpm2");
    _registry.RegisterCapability("tpm2.sealing");
    _registry.RegisterCapability("tpm2.attestation");
}
```

**CreateKeyAsync(string keyId, TpmKeyType type)**:
```csharp
public Task<byte[]> CreateKeyAsync(string keyId, TpmKeyType type)
{
    Initialize();

    if (!_isAvailable)
        throw new InvalidOperationException("TPM 2.0 is not available on this system.");

    ArgumentException.ThrowIfNullOrEmpty(keyId);

    lock (_lock)
    {
        if (_keyHandles.ContainsKey(keyId))
            throw new InvalidOperationException($"Key '{keyId}' already exists in TPM.");

        // SIMPLIFIED for Phase 35: Return placeholder public key
        // Production implementation would:
        // 1. Build TPM2_Create command with algorithm from TpmKeyType
        // 2. Submit command via TbsipSubmitCommand (Windows) or write to _tpmDevice (Linux)
        // 3. Parse response to extract public key and TPM handle
        // 4. Store handle in _keyHandles[keyId]

        byte[] publicKey = new byte[256]; // Placeholder RSA 2048 public key
        Random.Shared.NextBytes(publicKey); // TODO: actual TPM2_Create command

        _keyHandles[keyId] = publicKey; // Store handle (simplified)

        return Task.FromResult(publicKey);
    }
}
```

**SignAsync(string keyId, byte[] data)**:
```csharp
public Task<byte[]> SignAsync(string keyId, byte[] data)
{
    Initialize();

    if (!_isAvailable)
        throw new InvalidOperationException("TPM 2.0 is not available.");

    ArgumentException.ThrowIfNullOrEmpty(keyId);
    ArgumentNullException.ThrowIfNull(data);

    lock (_lock)
    {
        if (!_keyHandles.ContainsKey(keyId))
            throw new KeyNotFoundException($"Key '{keyId}' not found in TPM.");

        // SIMPLIFIED: Return placeholder signature
        // Production: build TPM2_Sign command, submit to TPM, parse signature

        byte[] signature = new byte[256];
        Random.Shared.NextBytes(signature); // TODO: actual TPM2_Sign command

        return Task.FromResult(signature);
    }
}
```

**EncryptAsync(string keyId, byte[] data)**:
```csharp
public Task<byte[]> EncryptAsync(string keyId, byte[] data)
{
    Initialize();

    if (!_isAvailable)
        throw new InvalidOperationException("TPM 2.0 is not available.");

    ArgumentException.ThrowIfNullOrEmpty(keyId);
    ArgumentNullException.ThrowIfNull(data);

    lock (_lock)
    {
        if (!_keyHandles.ContainsKey(keyId))
            throw new KeyNotFoundException($"Key '{keyId}' not found in TPM.");

        // SIMPLIFIED: Return placeholder ciphertext
        // Production: build TPM2_RSA_Encrypt command

        byte[] ciphertext = new byte[data.Length + 32]; // padding
        Random.Shared.NextBytes(ciphertext); // TODO: actual TPM2_RSA_Encrypt

        return Task.FromResult(ciphertext);
    }
}
```

**DecryptAsync(string keyId, byte[] data)**:
```csharp
public Task<byte[]> DecryptAsync(string keyId, byte[] data)
{
    Initialize();

    if (!_isAvailable)
        throw new InvalidOperationException("TPM 2.0 is not available.");

    ArgumentException.ThrowIfNullOrEmpty(keyId);
    ArgumentNullException.ThrowIfNull(data);

    lock (_lock)
    {
        if (!_keyHandles.ContainsKey(keyId))
            throw new KeyNotFoundException($"Key '{keyId}' not found in TPM.");

        // SIMPLIFIED: Return placeholder plaintext
        // Production: build TPM2_RSA_Decrypt command

        byte[] plaintext = new byte[data.Length - 32]; // remove padding
        Random.Shared.NextBytes(plaintext); // TODO: actual TPM2_RSA_Decrypt

        return Task.FromResult(plaintext);
    }
}
```

**GetRandomAsync(int length)**:
```csharp
public Task<byte[]> GetRandomAsync(int length)
{
    Initialize();

    if (!_isAvailable)
        throw new InvalidOperationException("TPM 2.0 is not available.");

    ArgumentOutOfRangeException.ThrowIfNegativeOrZero(length);

    // SIMPLIFIED: Use Random.Shared as placeholder
    // Production: build TPM2_GetRandom command, submit to TPM

    byte[] random = new byte[length];
    Random.Shared.NextBytes(random); // TODO: actual TPM2_GetRandom command

    return Task.FromResult(random);
}
```

**Dispose()**:
```csharp
public void Dispose()
{
    lock (_lock)
    {
        if (_tpmContext != IntPtr.Zero)
        {
            Tpm2Interop.TbsipContextClose(_tpmContext);
            _tpmContext = IntPtr.Zero;
        }

        if (_tpmDevice is not null)
        {
            _tpmDevice.Dispose();
            _tpmDevice = null;
        }

        _keyHandles.Clear();
    }
}
```

Add comprehensive XML documentation explaining:
- TPM 2.0 provides hardware-backed key storage
- Keys never leave the TPM chip — private key material is never exposed
- Detection via TBS (Windows) or /dev/tpmrm0 (Linux)
- IsAvailable returns false when no TPM present
- **IMPORTANT NOTE**: Phase 35 provides detection + API contract + placeholder implementations. Full TPM2 command marshaling is future work (requires TSS.MSR or tpm2-tools integration).

Add TODO comments on all crypto methods explaining actual TPM2 command structure is future work.

Add `[SdkCompatibility("3.0.0", Notes = "Phase 35: TPM2 hardware security provider (HW-03)")]` attribute.
  </action>
  <verify>
Build succeeds. File exists. Grep for `class Tpm2Provider : ITpm2Provider`. Grep for `RegisterCapability.*tpm2`. Grep for `IsAvailable`. Grep for `TODO.*TPM2_` confirms command marshaling is marked future work.
  </verify>
  <done>
Tpm2Provider exists implementing ITpm2Provider with TPM2 detection, capability registration, and placeholder implementations for crypto operations.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Two new files exist: Tpm2Provider.cs, Tpm2Interop.cs
3. Tpm2Provider implements ITpm2Provider
4. Platform-specific TPM access: TBS (Windows), /dev/tpmrm0 (Linux)
5. IsAvailable returns true when TPM2 detected, false otherwise
6. All crypto methods check IsAvailable before proceeding
7. Platform capability registry receives "tpm2", "tpm2.sealing", "tpm2.attestation"
8. Dispose() closes TPM context cleanly
9. TODO comments mark actual TPM2 command marshaling as future work
10. Zero external dependencies (no TSS.MSR NuGet package yet — future enhancement)
</verification>

<success_criteria>
- Tpm2Provider compiles and implements ITpm2Provider
- On machine without TPM2: IsAvailable = false, methods throw clear error
- On machine with TPM2: IsAvailable = true, methods return placeholder results
- Platform capability registry correctly reports TPM2 presence
- Code builds on Windows and Linux with platform-specific access
- Zero new NuGet dependencies
- Clear TODO comments for future TPM2 command implementation
</success_criteria>

<output>
After completion, create `.planning/phases/35-hardware-accelerator-hypervisor/35-03-SUMMARY.md`
</output>
