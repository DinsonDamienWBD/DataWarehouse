# Plan 31.1-04: Batch 2 Data Management Plugins — Group A (7 plugins)

## Goal
Implement real production-ready strategy method bodies for the first 7 of 15 Batch 2 Data Management plugins. These plugins all have production-ready orchestration layers (message bus, auto-discovery, intelligence integration) but skeleton strategy bodies that return placeholder results.

## Approach
Each strategy body needs real logic replacing `return placeholder`. The pattern is consistent: ParseAsync, SerializeAsync, TransferAsync, BackupAsync, etc. return defaults. Replace with real algorithms, data structures, and I/O operations. No new NuGet dependencies — use .NET BCL APIs.

## Plugins

### 1. UltimateDatabaseProtocol (~50 strategies)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDatabaseProtocol/`
**Why here:** Wire protocol encoding/decoding is DatabaseProtocol's domain. Each strategy implements the binary format for a specific database's client-server protocol. This is self-contained — no cross-plugin delegation needed. The protocol strategies produce/consume byte arrays representing wire-format messages.

Replace placeholder wire protocol encoding/decoding with real binary protocol implementations:
- **Relational**: PostgreSQL v3 wire protocol (startup, query, parse/bind/execute, copy), MySQL client/server (handshake, COM_QUERY, prepared statements), TDS for SQL Server
- **NoSQL**: MongoDB wire protocol (OP_MSG, OP_QUERY), Redis RESP3 (inline, bulk string, array), Cassandra CQL binary v4
- **Time-Series**: InfluxDB line protocol, Prometheus remote write protobuf
- **Graph**: Neo4j Bolt protocol, Gremlin bytecode
- **Search**: Elasticsearch transport, OpenSearch

### 2. UltimateDatabaseStorage (~45 strategies)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDatabaseStorage/`
**Why here:** Database CRUD operations are DatabaseStorage's domain. Each strategy implements storage operations for a specific database type. Uses ADO.NET patterns (DbConnection, DbCommand) for relational, document-model for NoSQL. Self-contained — the actual database connections are configured via connection strings.

Replace placeholder storage operations with real CRUD implementations:
- Use ADO.NET patterns (DbConnection, DbCommand) for relational databases
- Use document-model patterns for NoSQL (JSON documents with indexing)
- Use key-value patterns for cache stores
- File-backed implementations for embedded databases (SQLite, DuckDB)

### 3. UltimateDataCatalog (~80 strategies)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataCatalog/`
**Why here:** Metadata management, asset discovery, and catalog operations are DataCatalog's domain. Schema registry, data relationships, full-text search — all catalog-specific operations.

**SemanticSearch Architecture (pulled from Phase 39-01):**
- **SemanticSearchStrategy** in DataCatalog is a THIN ORCHESTRATOR that DELEGATES to UltimateIntelligence via message bus
- DataCatalog calls `MessageBus.RequestAsync("intelligence.search.semantic", query)` to get results
- The HNSW vector index + TF-IDF embedding engine are implemented in **UltimateIntelligence** (which already owns embedding providers and vector stores) — see Plan 31.1-02 Task 1 item 10 (SemanticClusterIndex)
- Phase 39-01 plan will be updated with a pre-completion note

Replace placeholder catalog operations with real metadata management:
- Asset discovery: file system scanning, database metadata queries
- Schema registry: schema versioning with compatibility checking (forward/backward/full)
- Search: in-memory full-text index with TF-IDF scoring (local catalog search)
- Data relationships: directed graph with cycle detection
- SemanticSearchStrategy: message bus delegation to `intelligence.search.semantic` topic (NOT local HNSW — that lives in UltimateIntelligence)

### 4. UltimateDataFabric (~13 strategies)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataFabric/`
**Why here:** Data fabric topology and virtualization are DataFabric's domain. Basic graph-based node tracking and query rewriting are DataFabric-specific — they don't depend on other plugins.

**[MINIMAL — Phase 34 builds federation orchestration at SDK level]**
Replace placeholder fabric operations with basic implementations:
- Topology management: basic graph-based node tracking (simple adjacency list)
- Data virtualization: basic query rewriting and result merging
- Mesh integration: basic domain registration and data product catalog
- Do NOT build: manifest services, federation orchestrators, UUID-based addressing, or cross-node routing. Phase 34 builds all of that at the SDK/infrastructure level.

### 5. UltimateDataFormat (~10 strategies — non-stub ones)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataFormat/`
**Why here:** Format routing and orchestration are DataFormat's domain. These are the orchestration-level strategies that need real format routing logic (as opposed to the 14 individual format parsers handled in Plan 31.1-03 Task 2).

Note: The 14 stub strategies needing external libraries or binary format parsing are handled in Plan 31.1-03. These ~10 are the orchestration-level strategies that need real format routing logic.

### 6. UltimateDataGovernance (~70 strategies)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataGovernance/`
**Why here:** Governance policy enforcement is DataGovernance's domain. Rule evaluation, classification, ownership tracking, retention — all governance-specific. Policy enforcement EVALUATES metadata locally; only data DELETION is delegated to storage via message bus.

Replace placeholder governance operations with real policy engines:
- Policy enforcement: rule evaluation against data metadata (predicate-based engine)
- Classification: pattern-based sensitivity detection (PII, PHI, PCI) using regex matchers
- Ownership: RACI matrix tracking with role-based assignment
- Retention: time-based lifecycle with legal hold support — DELEGATES deletion to UltimateStorage via `storage.delete.governed` topic

### 7. UltimateDataIntegration (~70 strategies)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataIntegration/`
**Why here:** ETL/ELT pipeline operations are DataIntegration's domain. Extract, transform, load, CDC, schema evolution — all integration-specific. Pipeline execution may DELEGATE individual operations via message bus (e.g., `storage.read` for extraction, `storage.write` for loading), but the orchestration logic is owned here.

Replace placeholder integration operations with real ETL/ELT pipelines:
- ETL: extract (file/stream reading), transform (type conversion, mapping), load (stream writing)
- CDC: timestamp-based change detection, journal-based log tailing
- Schema evolution: forward/backward compatibility checking with field mapping

## Placement Audit Summary
- UltimateDatabaseProtocol: owns wire protocol encoding — self-contained binary format work
- UltimateDatabaseStorage: owns database CRUD — self-contained with ADO.NET patterns
- UltimateDataCatalog: owns metadata catalog — SemanticSearch DELEGATES to Intelligence via bus
- UltimateDataFabric: owns topology/virtualization — MINIMAL (Phase 34 builds federation)
- UltimateDataFormat: owns format routing orchestration — parsing is in Plan 31.1-03
- UltimateDataGovernance: owns policy enforcement — DELEGATES deletion to storage via bus
- UltimateDataIntegration: owns ETL/ELT — DELEGATES I/O to storage via bus

## Success Criteria
- [ ] All 7 plugins' strategy methods contain real production logic
- [ ] No placeholder return values remain
- [ ] SemanticSearchStrategy delegates to UltimateIntelligence via message bus (not local HNSW)
- [ ] Full solution builds with 0 new errors
- [ ] PLUGIN-CATALOG.md updated for each plugin
