# Plan 31.1-02: Simulated Backend Replacement

## Goal
Replace simulated backends in UltimateIntelligence, TamperProof, UltimateDataProtection, UltimateStreamingData, UltimateRAID, and UltimateDeployment with production-ready implementations.

## Approach
For backends that require external services (Redis, Postgres, S3, etc.), implement using the **provider pattern**: define an internal interface, implement with real client code that gracefully degrades when the service is unavailable. Use connection string / config to determine if the backend is available. When unavailable, use bounded in-memory fallback with clear logging.

## Tasks

### Task 1: UltimateIntelligence Persistence Backends (15 backends)

**Pattern:** Each backend should:
- Attempt real connection using standard .NET clients
- Fall back to bounded in-memory ConcurrentDictionary with warning log
- Include connection health check

1. **RocksDbPersistenceBackend** — Use file-based persistence with `FileStream` (RocksDB is a local engine, implement as file-backed sorted store)
2. **RedisPersistenceBackend** — Use `StackExchange.Redis` connection pattern with graceful fallback
3. **PostgresPersistenceBackend** — Use `Npgsql` connection pattern with graceful fallback
4. **MongoDbPersistenceBackend** — Use `MongoDB.Driver` connection pattern with graceful fallback
5. **CassandraPersistenceBackend** — Use connection string detection, graceful fallback
6. **EventStreamingBackends** (Kafka, FoundationDB) — Graceful fallback for both
7. **CloudStorageBackends** (Azure, S3, GCS) — Graceful fallback for all three
8. **ONNXEmbeddingProvider** — Replace random embeddings with real ONNX inference when Microsoft.ML.OnnxRuntime available, otherwise use simple hash-based pseudo-embeddings
9. **PgVectorStore** — Real PgVector queries via Npgsql when available
10. **SemanticClusterIndex** — Use hash-based embeddings instead of random floats
11. **Fix 2 NotImplementedException** — AutoMLEngine Parquet/Database schema extraction

**Important:** These backends should NOT add new NuGet PackageReferences. Instead, use reflection-based late binding or connection-string-driven fallback. The SDK already has the pattern of graceful degradation.

### Task 2: TamperProof Storage Backends (2 classes)

1. **S3WormStorage** — Replace in-memory Dictionary with real file-based storage using SDK storage contracts. In production, this would be wired to UltimateStorage's S3 strategy via message bus.
2. **AzureWormStorage** — Same pattern: file-based local storage + message bus delegation to UltimateStorage's Azure strategy.

### Task 3: UltimateDataProtection Innovations (20+ methods)

Replace simulated byte arrays and fake operations with real implementations:
1. **Backup strategies** — Use real FileStream for backup archive creation (not `new byte[1024*1024]`)
2. **Crypto delegation** — Delegate encryption to SDK's cryptographic utilities (AES-256-GCM)
3. **Verification** — Use real SHA-256 hash verification (not simulated checksum)
4. **BackupValidator** — Implement real checksum, test restore, chain verification

### Task 4: UltimateStreamingData (8 methods)

Replace simulated lookups with message bus request-response pattern:
1. **RealTimePipeline** — Database/API/ML lookups via MessageBus.RequestAsync
2. **EventDriven** — Step execution via MessageBus.PublishAsync for saga orchestration
3. **StreamAnalytics** — ML inference via MessageBus.RequestAsync to Intelligence plugin

### Task 5: UltimateRAID (12 methods)

**VDE COMPATIBILITY NOTE:** UltimateRAID already uses `VirtualDisk` class and `logicalBlockAddress` in `IRaidStrategy.WriteBlockAsync/ReadBlockAsync`. Phase 33 (VDE) will introduce `IBlockDevice` as the fundamental block abstraction. RAID sits between VDE and physical storage: `VDE → IBlockDevice → RAID → VirtualDisk → Physical I/O`. Therefore:
- Use a **file-backed block device** abstraction — implement block read/write against files using `FileStream` with explicit offset/length positioning. Do NOT use raw file paths or stream-level APIs. Use `RandomAccess.ReadAsync/WriteAsync` for true block-level I/O.
- Keep `VirtualDisk`'s block addressing clean (offset + length) so VDE Phase 33 can later provide its own `IBlockDevice` implementation beneath RAID.
- Make block size configurable (currently hardcoded in strategies) — VDE will define its own block sizes.
- Ensure erasure coding operates at the **block level** (not file level) so VDE blocks can be protected by RAID.

Replace simulated disk/storage operations with real implementations:
1. **StandardRaidStrategies** disk read/write — Use `RandomAccess.ReadAsync/WriteAsync` for true block-level I/O against VirtualDisk backing files
2. **Snapshots block restore** — Real block copy with offset tracking for block-level granularity
3. **Snapshots compression** — Use System.IO.Compression (GZip/Brotli) for real snapshot compression at block level
4. **Snapshots encryption** — Use Aes.Create() with GCM mode for real snapshot encryption per block
5. **Snapshots remote send** — Use message bus to delegate to UltimateReplication/DataTransit
6. **Deduplication storage ops** — Real content-addressed block storage with SHA-256 fingerprints per block
7. **BadBlockRemapping** — Software-level block remapping with persistent block map (file-backed ConcurrentDictionary)
8. **Monitoring signing** — Real SHA-256 + HMAC signing for integrity verification
9. **ErasureCoding** — Implement Reed-Solomon math in software (Galois field GF(2^8) arithmetic, XOR-based parity, no ISA-L needed)

### Task 6: UltimateDeployment (4 methods)

Replace simulated infrastructure operations with real implementations:
1. **RollingUpdateStrategy** — Real process restart orchestration via message bus commands
2. **CanaryStrategy** — Real traffic splitting via message bus routing rules
3. **BlueGreenStrategy** — Real environment switching via message bus publish/subscribe
4. **KubernetesStrategies** — Real kubectl-style API calls via HttpClient to K8s API server

## Success Criteria
- [ ] UltimateIntelligence persistence backends use file-based or connection-driven real storage
- [ ] ONNX provider generates deterministic embeddings (not random)
- [ ] TamperProof S3/Azure WORM use file-based storage with message bus delegation
- [ ] UltimateDataProtection creates real backup archives with real crypto
- [ ] UltimateStreamingData uses message bus for external lookups
- [ ] UltimateRAID uses real FileStream I/O, real crypto, real Reed-Solomon erasure coding
- [ ] UltimateDeployment uses real process management and message bus orchestration
- [ ] No new NuGet dependencies added
- [ ] Full solution builds with 0 new errors
