# Plan 31.1-02: Simulated Backend Replacement

## Goal
Replace simulated backends in UltimateIntelligence, TamperProof, UltimateDataProtection, UltimateStreamingData, UltimateRAID, and UltimateDeployment with production-ready implementations.

## Approach
For backends that require external services (Redis, Postgres, S3, etc.), implement using the **provider pattern**: define an internal interface, implement with real client code that gracefully degrades when the service is unavailable. Use connection string / config to determine if the backend is available. When unavailable, use bounded in-memory fallback with clear logging.

## Tasks

### Task 1: UltimateIntelligence Persistence Backends (15 backends)

**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateIntelligence/`
**Why here:** All persistence backends are INTERNAL to UltimateIntelligence — they store AI models, embeddings, and knowledge graph data. This is Intelligence's own data, not cross-plugin storage.

**Pattern:** Each backend should:
- Attempt real connection using standard .NET clients
- Fall back to bounded in-memory ConcurrentDictionary with warning log
- Include connection health check

1. **RocksDbPersistenceBackend** — Use file-based persistence with `FileStream` (RocksDB is a local engine, implement as file-backed sorted store)
2. **RedisPersistenceBackend** — Use `StackExchange.Redis` connection pattern with graceful fallback
3. **PostgresPersistenceBackend** — Use `Npgsql` connection pattern with graceful fallback
4. **MongoDbPersistenceBackend** — Use `MongoDB.Driver` connection pattern with graceful fallback
5. **CassandraPersistenceBackend** — Use connection string detection, graceful fallback
6. **EventStreamingBackends** (Kafka, FoundationDB) — Graceful fallback for both
7. **CloudStorageBackends** (Azure, S3, GCS) — Graceful fallback for all three
8. **ONNXEmbeddingProvider** — **[MINIMAL — Phase 36-04 builds proper WASI-NN + ONNX Runtime]** Replace `random.NextDouble()` with deterministic hash-based pseudo-embeddings (~10 lines). Do NOT build ONNX Runtime integration — Phase 36-04 does that properly.
9. **PgVectorStore** — Real PgVector queries via Npgsql when available
10. **SemanticClusterIndex** — **[PULLED FROM PHASE 40-01]** Implement HNSW vector index + TF-IDF embedding engine here in UltimateIntelligence (not in DataCatalog — Intelligence owns vector stores and embeddings). DataCatalog's SemanticSearchStrategy will delegate to Intelligence via `intelligence.search.semantic` message bus topic.
11. **Fix 2 NotImplementedException** — AutoMLEngine Parquet/Database schema extraction

**Important:** These backends should NOT add new NuGet PackageReferences. Instead, use reflection-based late binding or connection-string-driven fallback. The SDK already has the pattern of graceful degradation.

### Task 2: TamperProof Storage Backends (2 classes)
**TARGET:** `Plugins/DataWarehouse.Plugins.TamperProof/`
**Why here:** WORM storage is TamperProof's own responsibility. But actual S3/Azure I/O is DELEGATED to UltimateStorage via message bus `storage.write.worm` topic.

1. **S3WormStorage** — Replace in-memory Dictionary with real file-based storage using SDK storage contracts. In production, this would be wired to UltimateStorage's S3 strategy via message bus.
2. **AzureWormStorage** — Same pattern: file-based local storage + message bus delegation to UltimateStorage's Azure strategy.

### Task 3: UltimateDataProtection Innovations (20+ methods)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataProtection/`
**Why here:** Backup/recovery strategies are DataProtection's domain. Crypto uses inline SDK utilities (not UltimateEncryption) because backup operations must work independently of the pipeline.

Replace simulated byte arrays and fake operations with real implementations:
1. **Backup strategies** — Use real FileStream for backup archive creation (not `new byte[1024*1024]`)
2. **Crypto delegation** — Delegate encryption to SDK's cryptographic utilities (AES-256-GCM)
3. **Verification** — Use real SHA-256 hash verification (not simulated checksum)
4. **BackupValidator** — Implement real checksum, test restore, chain verification

### Task 4: UltimateStreamingData (8 methods)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateStreamingData/`
**Why here:** Streaming pipeline orchestration is StreamingData's domain. External lookups (database, ML inference) are DELEGATED to other plugins via message bus — StreamingData doesn't implement the storage or ML itself, it orchestrates the streaming pipeline and delegates enrichment.

Replace simulated lookups with message bus request-response pattern:
1. **RealTimePipeline** — Database/API/ML lookups via MessageBus.RequestAsync to `storage.query` and `intelligence.infer` topics
2. **EventDriven** — Step execution via MessageBus.PublishAsync for saga orchestration to `pipeline.step.*` topics
3. **StreamAnalytics** — ML inference via MessageBus.RequestAsync to `intelligence.analyze.stream` topic (delegated to UltimateIntelligence)

### Task 5: UltimateRAID (12 methods)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateRAID/`
**Why here:** RAID array management is UltimateRAID's domain. Block I/O, erasure coding, deduplication, bad block remapping — all RAID-specific. Phase 33 VDE will later provide `IBlockDevice` BENEATH RAID, but RAID's algorithms (Reed-Solomon, dedup, remapping) are orthogonal.

**VDE COMPATIBILITY NOTE:** UltimateRAID already uses `VirtualDisk` class and `logicalBlockAddress` in `IRaidStrategy.WriteBlockAsync/ReadBlockAsync`. Phase 33 (VDE) will introduce `IBlockDevice` as the fundamental block abstraction. RAID sits between VDE and physical storage: `VDE → IBlockDevice → RAID → VirtualDisk → Physical I/O`.

**v3.0 OPTIMIZATION NOTE:** Phase 33 VDE provides `FileBlockDevice` (RandomAccess API), `BlockChecksummer` (XxHash3), `CowBlockManager`, and `SnapshotManager`. Therefore:
- **MINIMAL** for block I/O: Use simple `FileStream` wrappers for disk read/write. Do NOT build a sophisticated block device abstraction — VDE Phase 33 provides `IBlockDevice` and `FileBlockDevice`.
- **SKIP** block-level checksumming — VDE Phase 33-04 provides `BlockChecksummer`.
- **SKIP** snapshot compression/encryption engine — VDE Phase 33-06 provides `CowBlockManager` + `SnapshotManager`.
- **KEEP** Reed-Solomon erasure coding math — VDE has NO equivalent. This is RAID-specific.
- **KEEP** deduplication + bad block remapping — orthogonal to VDE.
- Keep `VirtualDisk`'s block addressing clean (offset + length) so VDE Phase 33 can later provide its own `IBlockDevice` implementation beneath RAID.
- Make block size configurable (currently hardcoded in strategies) — VDE will define its own block sizes.

Replace simulated disk/storage operations with real implementations:
1. **StandardRaidStrategies** disk read/write — **[MINIMAL]** Use simple `FileStream` with offset/length positioning (VDE replaces with `IBlockDevice` later)
2. **Snapshots block restore** — **[MINIMAL]** Basic file copy with offset tracking (VDE's CoW replaces)
3. **Snapshots compression** — **[SKIP — Phase 33-06 VDE SnapshotManager]** Leave as-is, VDE handles snapshot compression
4. **Snapshots encryption** — **[SKIP — Phase 33-06 VDE SnapshotManager]** Leave as-is, VDE handles snapshot encryption
5. **Snapshots remote send** — **[KEEP]** Use message bus to delegate to UltimateReplication/DataTransit
6. **Deduplication storage ops** — **[KEEP]** Real content-addressed block storage with SHA-256 fingerprints per block
7. **BadBlockRemapping** — **[KEEP]** Software-level block remapping with persistent block map (file-backed ConcurrentDictionary)
8. **Monitoring signing** — **[KEEP]** Real SHA-256 + HMAC signing for integrity verification
9. **ErasureCoding** — **[KEEP]** Implement Reed-Solomon math in software (Galois field GF(2^8) arithmetic, XOR-based parity, no ISA-L needed)

### Task 6: UltimateDeployment (4 methods)
**TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDeployment/`
**Why here:** Deployment orchestration is UltimateDeployment's domain. Rolling/canary/blue-green are deployment STRATEGIES that use message bus to coordinate with other plugins (e.g., `deployment.health.check`, `deployment.traffic.route`). K8s is minimal because Phase 37-04 builds proper hyperscale cloud automation.

Replace simulated infrastructure operations with real implementations:
1. **RollingUpdateStrategy** — Real process restart orchestration via MessageBus.PublishAsync to `deployment.instance.restart` topic
2. **CanaryStrategy** — Real traffic splitting via MessageBus.PublishAsync to `deployment.traffic.route` topic with weight configuration
3. **BlueGreenStrategy** — Real environment switching via MessageBus.PublishAsync to `deployment.environment.switch` topic
4. **KubernetesStrategies** — **[MINIMAL — Phase 37-04 builds proper hyperscale cloud automation]** Minimal HttpClient pattern that can call K8s API. Do NOT build a comprehensive K8s client library.

## Success Criteria
- [ ] UltimateIntelligence persistence backends use file-based or connection-driven real storage
- [ ] ONNX provider generates deterministic embeddings (not random)
- [ ] TamperProof S3/Azure WORM use file-based storage with message bus delegation
- [ ] UltimateDataProtection creates real backup archives with real crypto
- [ ] UltimateStreamingData uses message bus for external lookups
- [ ] UltimateRAID uses real FileStream I/O, real crypto, real Reed-Solomon erasure coding
- [ ] UltimateDeployment uses real process management and message bus orchestration
- [ ] No new NuGet dependencies added
- [ ] Full solution builds with 0 new errors
