# Plan 31.1-01: Security Fixes + Build Errors + Wiring

## Goal
Fix all P0 security-critical fakes, P1 build-breaking errors, and P2 wiring gaps. This is the highest-priority, smallest-scope work.

## Tasks

### Task 1: P0 Security Fixes (4 methods)

1. **QuantumSafeApiStrategy** — Replace Base64 encode/decode with real AES-256-GCM encryption using SDK's cryptographic utilities
   - **TARGET:** `Plugins/DataWarehouse.Plugins.UltimateInterface/Strategies/Security/QuantumSafeApiStrategy.cs`
   - Lines 264, 295: Replace Base64 with Aes.Create() + GCM mode
   - **Why here:** Security strategy in UltimateInterface — correct. Encryption logic inline using SDK crypto (not delegated to UltimateEncryption because this is request-level API encryption, not pipeline-stage encryption).

2. **AirGappedBackupStrategy** — Implement real encryption delegation
   - **TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataProtection/Strategies/Advanced/AirGappedBackupStrategy.cs`
   - Line 523: Use AES-256-GCM to actually encrypt backup data
   - **Why here:** Backup strategy in DataProtection — correct. Uses inline AES-GCM (SDK crypto utilities), not message bus delegation, because backup encryption must work without Intelligence/Encryption plugin availability (air-gapped scenario).

3. **BreakGlassRecoveryStrategy** — Implement real encrypt/decrypt
   - **TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataProtection/Strategies/Advanced/BreakGlassRecoveryStrategy.cs`
   - Lines 613, 619: Use AES-256-GCM for backup encryption/decryption
   - **Why here:** Same reasoning as AirGapped — emergency recovery must work standalone.

4. **SneakernetOrchestratorStrategy** — Implement real SHA-256 integrity verification
   - **TARGET:** `Plugins/DataWarehouse.Plugins.UltimateDataProtection/Strategies/Innovations/SneakernetOrchestratorStrategy.cs`
   - Line 997: Replace `return true` with SHA-256 hash comparison
   - **Why here:** Integrity check within DataProtection — correct. Hash verification is local computation, not a cross-plugin concern.

### Task 2: P1 Build Error Fixes (13 errors)

1. **UltimateCompression** — Fix SharpCompress v0.45.1 API changes (12 errors)
   - **TARGET:** `Plugins/DataWarehouse.Plugins.UltimateCompression/` — XzStrategy.cs, SevenZipStrategy.cs, LzmaStrategy.cs, Lzma2Strategy.cs, Bzip2Strategy.cs
   - Update LzmaStream constructor calls (3→2 args), BZip2Stream constructor calls
   - Research exact SharpCompress v0.45.1 API before fixing
   - **Why here:** Compression strategies in UltimateCompression — correct.

2. **AedsCore** — Fix MQTTnet v5.x namespace (1 error)
   - **TARGET:** `Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/MqttControlPlanePlugin.cs`
   - Update `using MQTTnet.Client` to correct v5.x namespace
   - **Why here:** MQTT control plane in AedsCore — correct.

### Task 3: P2 Wiring Fixes (8 issues)

1. **TamperProof message bus wiring**
   - **TARGET:** `Plugins/DataWarehouse.Plugins.TamperProof/`
   - Remove custom `IMessageBusClient` interface from Services/MessageBusIntegration.cs
   - Use SDK's `IMessageBus` from base class `MessageBus` property
   - Instantiate `MessageBusIntegrationService` in plugin constructor
   - Uncomment `PublishAsync` calls for violation/alert events
   - Fix RecoveryService placeholder hash → real content hash
   - Fix ComplianceReportingService GUID hash → real block hash
   - **Why here:** TamperProof wiring — correct. These are internal wiring issues within the plugin.

2. **FuseDriver message bus fix**
   - **TARGET:** `Plugins/DataWarehouse.Plugins.FuseDriver/`
   - Replace `GetMessageBus()` with base class `MessageBus` property
   - Remove null-check bailouts at lines 680, 691
   - **Why here:** FuseDriver — correct. Internal wiring fix.

3. **UltimateInterface webhook wiring**
   - **TARGET:** `Plugins/DataWarehouse.Plugins.UltimateInterface/Strategies/Advanced/GenericWebhookStrategy.cs`
   - Uncomment `MessageBus.PublishAsync(topic, payload, ct)` at line 144
   - **Why here:** UltimateInterface — correct. Webhook should forward to message bus.

4. **UltimateAccessControl AI integration**
   - **TARGET:** `Plugins/DataWarehouse.Plugins.UltimateAccessControl/`
   - UebaStrategy: Replace `null` with real `MessageBus.RequestAsync<AnalysisRequest, AnalysisResponse>()` call to `intelligence.analyze.behavior` topic
   - ThreatIntelStrategy: Replace `null` with real `MessageBus.RequestAsync<EnrichmentRequest, EnrichmentResponse>()` call to `intelligence.enrich.threat` topic
   - **Why here:** AccessControl — correct. These are security strategies that DELEGATE AI analysis to UltimateIntelligence via message bus (not implementing AI themselves).

## Placement Audit Summary
All tasks correctly target the plugin that OWNS the strategy. Cross-plugin concerns use message bus delegation:
- **Encryption/Decryption → ALWAYS delegated to UltimateEncryption via `encryption.encrypt`/`encryption.decrypt` message bus topics** (NO inline AES-GCM — UltimateEncryption is the single owner of all crypto operations)
- AI analysis → delegated to UltimateIntelligence via message bus `intelligence.*` topics
- Storage operations → delegated to UltimateStorage via message bus `storage.*` topics

## Success Criteria
- [x] Zero fake encryption (QuantumSafe, AirGapped, BreakGlass delegate to UltimateEncryption via message bus)
- [x] SneakernetOrchestrator verifies actual SHA-256 hashes
- [x] UltimateCompression builds (0 CS1729 errors)
- [x] AedsCore builds (0 CS0234 errors)
- [ ] TamperProof publishes events to message bus
- [ ] FuseDriver uses base class MessageBus
- [ ] UltimateInterface webhook forwards events
- [ ] UltimateAccessControl UEBA/ThreatIntel use message bus request-response
- [ ] Full solution builds with 0 new errors
