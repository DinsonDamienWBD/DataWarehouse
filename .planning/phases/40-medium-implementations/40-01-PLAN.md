---
phase: 40-medium-implementations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/SearchDiscoveryStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/HnswVectorIndex.cs
autonomous: true

must_haves:
  truths:
    - "SemanticSearchStrategy in DataCatalog has real methods, not an empty class body"
    - "HNSW vector index provides O(log n) approximate nearest neighbor search"
    - "Semantic search accepts a natural language query and returns ranked results with similarity scores"
    - "TF-IDF fallback works when AI embedding provider is unavailable"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/HnswVectorIndex.cs"
      provides: "In-process HNSW vector index with insert, search, serialize, deserialize"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/SearchDiscoveryStrategies.cs"
      provides: "SemanticSearchStrategy with real SearchAsync, IndexAsync methods"
      contains: "class SemanticSearchStrategy"
  key_links:
    - from: "SearchDiscoveryStrategies.cs (SemanticSearchStrategy)"
      to: "HnswVectorIndex"
      via: "direct usage for similarity search"
      pattern: "HnswVectorIndex"
---

<pre-completion-note>
## PRE-COMPLETED IN PHASE 31.1

This plan's work has been RESTRUCTURED and pulled forward into Phase 31.1:

1. **HNSW vector index + TF-IDF embedding engine** → Moved to **UltimateIntelligence** plugin (Plan 31.1-02, Task 1 item 10: SemanticClusterIndex). UltimateIntelligence already owns embedding providers and vector stores — this is the correct architectural home.

2. **SemanticSearchStrategy in DataCatalog** → Implemented as a THIN MESSAGE BUS ORCHESTRATOR in Phase 31.1-04 (Task 3: UltimateDataCatalog). It delegates to UltimateIntelligence via `MessageBus.RequestAsync("intelligence.search.semantic", query)` instead of hosting a local HNSW index.

**Rationale:** Semantic search capability (vector indices, embeddings) belongs in the Intelligence plugin. DataCatalog is a metadata catalog — it should delegate AI/ML operations to Intelligence rather than reimplementing them locally. This follows the project's message bus delegation pattern.

**Action:** This plan should be SKIPPED during Phase 40 execution. Verify the Phase 31.1 implementation is complete instead.
</pre-completion-note>

<objective>
[SUPERSEDED — See pre-completion note above]

Replace the empty SemanticSearchStrategy stub in UltimateDataCatalog with a real implementation backed by an in-process HNSW (Hierarchical Navigable Small World) vector index.

Purpose: IMPL-01 requires semantic search with >80% relevance. The DataCatalog's SemanticSearchStrategy is currently a metadata-only class with no methods. The real embedding infrastructure already exists in UltimateIntelligence (8 embedding providers, 9 vector stores) -- this plan builds the local search capability for catalog metadata.

Output: Working SemanticSearchStrategy with HNSW index, embedding generation, similarity search, and TF-IDF fallback.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataCatalogStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/SearchDiscoveryStrategies.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build HNSW Vector Index</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/HnswVectorIndex.cs</files>
  <action>
Create `HnswVectorIndex<TKey>` class implementing a multi-layer navigable small world graph for approximate nearest neighbor search.

Core data structures:
- `HnswNode` record: Key (TKey), Vector (float[]), Connections (List of lists per layer)
- `HnswVectorIndex<TKey>`: generic index with configurable M (max connections per layer, default 16), efConstruction (build-time beam width, default 200), efSearch (query-time beam width, default 50), maxLevel (derived from ln(n)/ln(M))

Required methods:
- `Insert(TKey key, float[] vector)`: insert a vector into the index. Assign random layer using exponential distribution (`-ln(uniform) * mL` where `mL = 1/ln(M)`). Connect to neighbors at each layer using greedy search then select-neighbors heuristic.
- `Search(float[] query, int topK, float minScore = 0f)`: return List of `(TKey Key, float Score)` sorted by descending cosine similarity. Traverse from top layer to layer 0, expanding beam at layer 0. Filter by minScore.
- `Remove(TKey key)`: remove entry and repair connections.
- `Count`: property returning number of entries.
- `Clear()`: reset the index.

Similarity function: Cosine similarity = dot(a,b) / (|a| * |b|). Precompute vector norms on insert for fast similarity computation.

Thread safety: Use ReaderWriterLockSlim for concurrent reads during search, exclusive writes during insert/remove.

Use `System.Security.Cryptography.RandomNumberGenerator` for layer assignment randomness (CRYPTO-02 compliance).

Bounded: configurable `maxEntries` (default 100_000) to prevent unbounded memory growth (MEM-03 compliance).

Do NOT add any NuGet packages -- use only .NET BCL.
  </action>
  <verify>Build the plugin project: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj`</verify>
  <done>HnswVectorIndex compiles, provides Insert/Search/Remove with O(log n) search complexity and thread-safe concurrent reads.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SemanticSearchStrategy with real search methods</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/SearchDiscoveryStrategies.cs</files>
  <action>
Replace the empty `SemanticSearchStrategy` class body with real search implementation. The class already has StrategyId, DisplayName, Category, Capabilities, SemanticDescription, and Tags -- keep all of those unchanged.

Add these methods to SemanticSearchStrategy:

1. **`SearchAsync(string query, SemanticSearchOptions? options = null, CancellationToken ct = default)`** returning `Task<SemanticSearchResult>`:
   - Generate embedding for the query text using TF-IDF (local, no external dependency)
   - Search the HNSW index with the embedding
   - Return ranked results with similarity scores
   - SemanticSearchOptions: TopK (default 10), MinScore (default 0.3f), IncludeMetadata (default true)
   - SemanticSearchResult: Items (list of SemanticSearchHit), TotalMatched, QueryEmbeddingDimension, SearchTimeMs

2. **`IndexAsync(string assetId, string content, Dictionary<string, string>? metadata = null, CancellationToken ct = default)`** returning `Task`:
   - Generate TF-IDF embedding from content text
   - Insert into HNSW index with assetId as key
   - Store metadata alongside for retrieval

3. **`RemoveFromIndexAsync(string assetId, CancellationToken ct = default)`** returning `Task<bool>`:
   - Remove asset from HNSW index

4. Private helper: **TF-IDF embedding generation** (no external deps):
   - Tokenize: lowercase, split on whitespace/punctuation, remove stop words
   - Build vocabulary from indexed documents (bounded to 10,000 terms)
   - Generate TF-IDF vector: term frequency * inverse document frequency
   - Normalize to unit length for cosine similarity

Add supporting types in the same file (below the class):
- `SemanticSearchOptions` record: TopK, MinScore, IncludeMetadata
- `SemanticSearchResult` record: Items, TotalMatched, QueryEmbeddingDimension, SearchTimeMs
- `SemanticSearchHit` record: AssetId, Score, Metadata

The HNSW index instance should be a private field. Vocabulary and IDF stats stored in ConcurrentDictionary. All fields bounded per MEM-03.

Do NOT change any other strategy class in the file (FullTextSearchStrategy, FacetedSearchStrategy, etc. must remain exactly as they are).
  </action>
  <verify>Build the plugin project: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj`</verify>
  <done>SemanticSearchStrategy has real SearchAsync/IndexAsync methods backed by HNSW vector index with TF-IDF embeddings. Empty class body replaced with production implementation. All other strategies in the file unchanged.</done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj` -- zero errors
2. Grep confirms SemanticSearchStrategy has SearchAsync method: `grep -r "SearchAsync" Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/SearchDiscovery/`
3. Grep confirms HNSW index exists: `grep -r "class HnswVectorIndex" Plugins/DataWarehouse.Plugins.UltimateDataCatalog/`
4. No other strategy classes in SearchDiscoveryStrategies.cs were modified (diff check)
</verification>

<success_criteria>
- SemanticSearchStrategy has real SearchAsync, IndexAsync, RemoveFromIndexAsync methods
- HNSW vector index implements O(log n) approximate nearest neighbor search
- TF-IDF embedding generation works without any external NuGet packages
- All existing strategies in SearchDiscoveryStrategies.cs remain unchanged
- Plugin project builds with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/40-medium-implementations/40-01-SUMMARY.md`
</output>
