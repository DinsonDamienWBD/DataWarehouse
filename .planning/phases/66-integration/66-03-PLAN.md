---
phase: 66-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.Tests/Integration/StrategyRegistryTests.cs
  - .planning/phases/66-integration/STRATEGY-REGISTRY-REPORT.md
autonomous: true

must_haves:
  truths:
    - "All strategies are registered and discoverable via their plugin's registration code"
    - "No strategy class exists without being registered in a plugin"
    - "Every strategy inherits from the correct domain strategy base"
  artifacts:
    - path: "DataWarehouse.Tests/Integration/StrategyRegistryTests.cs"
      provides: "Strategy registration completeness tests"
      min_lines: 100
    - path: ".planning/phases/66-integration/STRATEGY-REGISTRY-REPORT.md"
      provides: "Complete strategy inventory with registration status"
      min_lines: 40
  key_links:
    - from: "Strategy concrete classes"
      to: "Plugin RegisterStrategies methods"
      via: "Strategy registration calls"
      pattern: "RegisterStrategy|AddStrategy|strategies\\.Add"
---

<objective>
Verify that all ~2,500+ strategies across 60+ plugins are properly registered and discoverable. No orphaned strategy classes.

Purpose: A strategy that exists but is not registered is dead code that appears functional. Users cannot select it, the intelligence stack cannot recommend it, and the capability registry does not know about it.
Output: Strategy registry tests and inventory report.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Strategy inventory and registration audit</name>
  <files>.planning/phases/66-integration/STRATEGY-REGISTRY-REPORT.md</files>
  <action>
  Scan all plugin directories to build a complete strategy inventory:

  1. Find all concrete strategy classes: grep for classes that inherit from StrategyBase or any domain strategy base (EncryptionStrategyBase, CompressionStrategyBase, StorageStrategyBase, SecurityStrategyBase, etc.). Use pattern: `class \w+Strategy\w* : \w+StrategyBase` and `class \w+ : StrategyBase`
  2. Find all strategy registration calls: grep for `RegisterStrategy`, `AddStrategy`, `strategies.Add`, `yield return new`, or similar patterns in plugin registration methods (typically in the plugin class's `RegisterStrategies`, `GetStrategies`, `InitializeAsync`, or constructor)
  3. Cross-reference: for each concrete strategy class, verify it appears in a registration call somewhere in the same plugin
  4. Count by plugin and domain

  Write STRATEGY-REGISTRY-REPORT.md with:
  - Total strategy count by plugin (table: plugin | strategy count | registered count | orphaned count)
  - Summary: total strategies, total registered, total orphaned
  - List of any orphaned strategies (class exists but not registered)
  - List of any registration references to non-existent classes
  - v5.0 new strategies (from phases 55-63)
  - Domain base class distribution (how many per domain base)
  </action>
  <verify>Report exists with inventory covering all plugins</verify>
  <done>Complete strategy inventory documented with registration status for every strategy class</done>
</task>

<task type="auto">
  <name>Task 2: Strategy registry completeness tests</name>
  <files>DataWarehouse.Tests/Integration/StrategyRegistryTests.cs</files>
  <action>
  Create StrategyRegistryTests.cs with:

  1. AllStrategyClassesInheritFromDomainBase: scan all strategy .cs files and verify each concrete strategy class inherits from a recognized domain strategy base (not directly from object or a random base). Recognized bases: StrategyBase, EncryptionStrategyBase, CompressionStrategyBase, StorageStrategyBase, ReplicationStrategyBase, SecurityStrategyBase, InterfaceStrategyBase, ConnectorStrategyBase, ComputeStrategyBase, ObservabilityStrategyBase, MediaStrategyBase, StreamingStrategyBase, FormatStrategyBase, TransitStrategyBase, DataManagementStrategyBase, KeyManagementStrategyBase, ComplianceStrategyBase, DataProtectionStrategyBase, RaidStrategyBase, DatabaseStorageStrategyBase, DataLakeStrategyBase, DataMeshStrategyBase
  2. NoStrategyUsesLegacyBases: verify no strategy inherits from deprecated bases (LegacyStrategyBase, IntelligenceAwareStrategyBase if they still exist)
  3. StrategyNamesAreUnique: scan all strategy classes and verify no two strategies in the same plugin share the same Name property value (if discoverable from source)
  4. EveryPluginHasAtLeastOneStrategy: for each plugin directory, verify at least one strategy class exists (excluding infrastructure-only plugins like AedsCore, Kernel, etc. -- maintain an exclusion list)

  Use xUnit. Parse .cs source files statically.
  </action>
  <verify>Run `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~StrategyRegistry"` -- all tests pass</verify>
  <done>All strategy classes inherit correct bases, no orphaned strategies, no legacy base usage</done>
</task>

</tasks>

<verification>
- STRATEGY-REGISTRY-REPORT.md has complete inventory
- All StrategyRegistry tests pass
- Zero orphaned strategies (or documented exceptions)
</verification>

<success_criteria>
All ~2,500+ strategies registered and discoverable. Every strategy inherits from the correct domain base. No orphaned strategy classes.
</success_criteria>

<output>
After completion, create `.planning/phases/66-integration/66-03-SUMMARY.md`
</output>
