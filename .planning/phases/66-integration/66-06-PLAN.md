---
phase: 66-integration
plan: 06
type: execute
wave: 3
depends_on: ["66-02", "66-04"]
files_modified:
  - DataWarehouse.Tests/Integration/EndToEndLifecycleTests.cs
  - DataWarehouse.Tests/Integration/Helpers/IntegrationTestHarness.cs
autonomous: true

must_haves:
  truths:
    - "Data can flow through the full lifecycle: ingest -> classify -> tag -> score -> passport -> place -> replicate -> sync -> monitor -> archive"
    - "Each pipeline stage hands off to the next via message bus events"
    - "No stage is a dead end (every stage either passes data forward or terminates with documented reason)"
  artifacts:
    - path: "DataWarehouse.Tests/Integration/EndToEndLifecycleTests.cs"
      provides: "End-to-end data lifecycle integration tests"
      min_lines: 200
    - path: "DataWarehouse.Tests/Integration/Helpers/IntegrationTestHarness.cs"
      provides: "Shared test infrastructure for integration tests"
      min_lines: 80
  key_links:
    - from: "Data ingest (storage.write)"
      to: "Classification (tag.classify)"
      via: "Message bus event on write completion"
      pattern: "storage\\.write\\.completed|data\\.ingested"
    - from: "Tag assignment"
      to: "Compliance passport"
      via: "tag.assigned event triggers passport evaluation"
      pattern: "tag\\.assigned|passport\\.evaluate"
    - from: "Placement decision"
      to: "Replication"
      via: "placement.decided triggers replication"
      pattern: "placement\\.decided|replication\\.requested"
---

<objective>
Verify the complete data lifecycle pipeline works end-to-end: ingest -> classify -> tag -> score -> passport -> place -> replicate -> sync -> monitor -> archive.

Purpose: Individual features work in isolation (verified by their own phases). This plan verifies the HANDOFFS between features -- that each stage's output events trigger the next stage's input. One broken handoff means the pipeline silently stops.
Output: End-to-end lifecycle test suite with a shared test harness.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/66-integration/66-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integration test harness with in-memory message bus tracing</name>
  <files>DataWarehouse.Tests/Integration/Helpers/IntegrationTestHarness.cs</files>
  <action>
  Create IntegrationTestHarness.cs providing shared infrastructure for all integration tests:

  1. TracingMessageBus: wraps InMemoryFederatedMessageBus and records every Publish/Subscribe call with timestamp, topic, and payload type. Provides:
     - GetPublishedMessages(string topicFilter) -> list of recorded messages
     - GetSubscriptionCount(string topic) -> int
     - WaitForMessage(string topic, TimeSpan timeout) -> Task<MessageRecord>
     - GetMessageFlow() -> ordered list of all messages (the "trace")
     - Reset() to clear between tests
  2. TestPluginHost: minimal plugin host that can load and initialize specific plugins in isolation with the TracingMessageBus. Must support:
     - AddPlugin<T>() where T : PluginBase
     - InitializeAll() -> initializes all added plugins with the tracing bus
     - ShutdownAll() -> proper cleanup
  3. TestStorageBackend: in-memory IStorageStrategy implementation for tests (store byte[] by key, supports read/write/delete/list)
  4. TestConfigurationProvider: returns test configuration values, supports per-test overrides

  Use the existing SDK base classes. Reference InMemoryFederatedMessageBus from DataWarehouse.SDK/Infrastructure/InMemory/. Follow the existing test helper patterns in DataWarehouse.Tests/Helpers/.
  </action>
  <verify>File compiles as part of DataWarehouse.Tests project</verify>
  <done>IntegrationTestHarness provides TracingMessageBus, TestPluginHost, TestStorageBackend, TestConfigurationProvider</done>
</task>

<task type="auto">
  <name>Task 2: End-to-end data lifecycle integration tests</name>
  <files>DataWarehouse.Tests/Integration/EndToEndLifecycleTests.cs</files>
  <action>
  Create EndToEndLifecycleTests.cs with tests for each lifecycle stage handoff using the IntegrationTestHarness:

  1. IngestTriggersClassification: simulate a data write event on the message bus, verify a classification/tagging event is published within the trace
  2. ClassificationTriggersTagAssignment: publish a classification result event, verify tag assignment events fire
  3. TagAssignmentTriggersValueScoring: publish tag.assigned event, verify data consciousness scoring is triggered (if DataConsciousness plugin exists)
  4. TagAssignmentTriggersPassportEvaluation: publish tag.assigned event, verify compliance passport evaluation is triggered (if CompliancePassport plugin exists)
  5. PassportTriggersPlacement: publish passport.issued event, verify placement optimizer is consulted (if UniversalFabric plugin exists)
  6. PlacementTriggersReplication: publish placement.decided event, verify replication is requested
  7. ReplicationTriggersSync: publish replication.completed event, verify semantic sync evaluation (if SemanticSync plugin exists)
  8. MonitoringObservesAllStages: verify observability/monitoring events are published at each pipeline stage
  9. ArchiveTriggeredByPolicy: publish a time-based or policy event, verify archive/tiering action is triggered
  10. FullPipelineEndToEnd: chain all stages together, publish initial ingest event, verify the trace shows messages flowing through classify -> tag -> score -> passport -> place -> replicate in order

  For each test: if the relevant plugin does not exist yet (phases not executed), skip with [Fact(Skip = "Plugin not yet implemented")] and a descriptive message.

  Tests that DO run should verify the message flow pattern exists in source code even if they cannot instantiate the full plugin chain at runtime. Use static analysis of subscriber registrations to verify the wiring path exists.
  </action>
  <verify>Run `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~EndToEndLifecycle"` -- tests pass or skip with explanation</verify>
  <done>End-to-end lifecycle tests verify each handoff in the data pipeline, with graceful skips for not-yet-implemented plugins</done>
</task>

</tasks>

<verification>
- IntegrationTestHarness compiles and provides tracing infrastructure
- EndToEndLifecycle tests pass or skip gracefully
- Message flow trace shows data moving through pipeline stages
</verification>

<success_criteria>
Every pipeline stage handoff is tested. No dead ends in the data lifecycle. Message flow is observable and traceable.
</success_criteria>

<output>
After completion, create `.planning/phases/66-integration/66-06-SUMMARY.md`
</output>
