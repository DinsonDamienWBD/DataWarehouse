---
phase: 66-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.Tests/Integration/MessageBusTopologyTests.cs
  - .planning/phases/66-integration/MESSAGE-BUS-TOPOLOGY-REPORT.md
autonomous: true

must_haves:
  truths:
    - "Every message bus topic published by a plugin has at least one subscriber"
    - "No dead-letter topics exist (published but never consumed)"
    - "All v5.0 features use message bus for inter-plugin communication, not direct calls"
  artifacts:
    - path: "DataWarehouse.Tests/Integration/MessageBusTopologyTests.cs"
      provides: "Message bus wiring verification"
      min_lines: 120
    - path: ".planning/phases/66-integration/MESSAGE-BUS-TOPOLOGY-REPORT.md"
      provides: "Complete topic map with publishers and subscribers"
      min_lines: 50
  key_links:
    - from: "Plugin Publish calls"
      to: "Plugin Subscribe handlers"
      via: "IMessageBus topic strings"
      pattern: "Publish|Subscribe|HandleMessage"
---

<objective>
Audit the entire message bus topology -- every topic, publisher, and subscriber across all 60+ plugins.

Purpose: The message bus is THE communication backbone. Dead topics or orphaned publishers mean broken cross-plugin flows. This audit finds them before integration tests expose them as mysterious failures.
Output: Topology test suite and a comprehensive topic map report.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Static analysis of message bus topic publishers and subscribers</name>
  <files>.planning/phases/66-integration/MESSAGE-BUS-TOPOLOGY-REPORT.md</files>
  <action>
  Scan ALL .cs files across the entire solution (SDK, Kernel, Plugins, Shared) for message bus topic usage:

  1. Find all PUBLISH patterns: grep for `Publish(`, `PublishAsync(`, `SendCommand(`, `SendCommandAsync(` and extract the topic string (first argument, usually a string literal or constant reference)
  2. Find all SUBSCRIBE patterns: grep for `Subscribe(`, `SubscribeAsync(`, `HandleMessage`, `OnMessage`, topic handler registrations and extract the topic string
  3. Find all topic CONSTANT definitions: grep for `const string.*Topic`, `static.*readonly.*string.*Topic`, patterns like `"storage."`, `"security."`, `"integrity."`, `"blockchain."`, `"tag."`, `"passport."`, `"sovereignty."`, `"consciousness."`, `"chaos."`, `"carbon."`, `"fabric."`, `"semantic."`, `"crypto."` etc.

  Build a map: Topic -> [Publishers] -> [Subscribers]

  Identify:
  - Dead topics: published but never subscribed (potential orphans)
  - Orphan subscribers: subscribed but never published (waiting for nothing)
  - High-fan-out topics: >5 subscribers (potential performance concern)
  - v5.0 new topics: from phases 55-63 features

  Write the report to MESSAGE-BUS-TOPOLOGY-REPORT.md with sections:
  - Summary statistics (total topics, publishers, subscribers)
  - Complete topic map table (topic | publishers | subscribers | status)
  - Dead topics list with recommended action
  - Orphan subscribers list with recommended action
  - v5.0 cross-feature topic connections
  </action>
  <verify>Report exists and has a complete topic map with at least 30 distinct topics documented</verify>
  <done>Complete message bus topology documented with dead/orphan identification</done>
</task>

<task type="auto">
  <name>Task 2: Message bus topology integration tests</name>
  <files>DataWarehouse.Tests/Integration/MessageBusTopologyTests.cs</files>
  <action>
  Create MessageBusTopologyTests.cs with tests that verify the message bus wiring at the code level:

  1. TopicConstantsAreUnique: scan all topic constant definitions and assert no two different semantic purposes share the same topic string
  2. AllPublishedTopicsHaveSubscribers: using the static analysis from Task 1, verify every published topic has at least one subscriber. Allow an exclusion list for intentionally fire-and-forget topics (document each exclusion with reason)
  3. NoDirectPluginMethodCalls: scan .cs files in Plugins/ for patterns that indicate direct cross-plugin method invocation (e.g., `new UltimateEncryptionPlugin()`, casting to specific plugin types). Use regex on source files.
  4. MessageBusUsageInNewPlugins: for each plugin directory that was added/modified by v5.0 phases, verify it contains at least one Publish or Subscribe call (not a dead plugin)
  5. FederatedMessageBusIsUsed: verify that FederatedMessageBus (or InMemoryFederatedMessageBus) is referenced in kernel initialization, not raw InMemoryMessageBus

  Use xUnit [Fact] and [Theory] attributes. Tests should parse source files statically (no runtime plugin loading needed).
  </action>
  <verify>Run `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~MessageBusTopology"` -- all tests pass</verify>
  <done>All message bus topology tests pass, no dead topics or orphaned publishers detected</done>
</task>

</tasks>

<verification>
- MESSAGE-BUS-TOPOLOGY-REPORT.md exists with complete topic map
- All MessageBusTopology tests pass
- Zero dead topics (or documented exceptions)
</verification>

<success_criteria>
Every message bus topic has matching publisher(s) and subscriber(s). No orphaned wiring. Report documents the full topology.
</success_criteria>

<output>
After completion, create `.planning/phases/66-integration/66-02-SUMMARY.md`
</output>
