---
phase: 22-build-safety-supply-chain
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.CLI/Program.cs
  - DataWarehouse.CLI/DataWarehouse.CLI.csproj
autonomous: true

must_haves:
  truths:
    - "DataWarehouse.CLI uses ONLY the stable System.CommandLine 2.0.3 SetAction API -- zero references to NamingConventionBinder or CommandHandler.Create"
    - "All 8 CommandHandler.Create call sites are migrated to command.SetAction with ParseResult and CancellationToken parameters"
    - "The CreateSubCommand helper uses SetAction and returns exit codes directly"
    - "CLI builds and compiles with zero errors"
    - "No import of System.CommandLine.NamingConventionBinder or System.CommandLine.Invocation namespace"
  artifacts:
    - path: "DataWarehouse.CLI/Program.cs"
      provides: "CLI entry point with all commands using stable SetAction API"
      contains: "SetAction"
    - path: "DataWarehouse.CLI/DataWarehouse.CLI.csproj"
      provides: "CLI project with System.CommandLine 2.0.3, no NamingConventionBinder reference"
      contains: "System.CommandLine"
  key_links:
    - from: "Program.CreateSubCommand"
      to: "command.SetAction"
      via: "SetAction lambda with ParseResult parameter replacing CommandHandler.Create"
      pattern: "SetAction.*ParseResult"
    - from: "Program.Main"
      to: "rootCommand.Parse(args).InvokeAsync()"
      via: "Separated parse and invoke per 2.0 stable API"
      pattern: "Parse.*Invoke"
---

<objective>
Migrate DataWarehouse.CLI from deprecated System.CommandLine.NamingConventionBinder to the stable System.CommandLine 2.0.3 SetAction API.

Purpose: Eliminate deprecated API usage (CLI-01) -- NamingConventionBinder was never stabilized and will be removed in future System.CommandLine releases.
Output: Program.cs using only stable 2.0 API (SetAction, ParseResult, Aliases.Add, Subcommands.Add), no NamingConventionBinder dependency.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-build-safety-supply-chain/22-RESEARCH.md

# CLI source files
@DataWarehouse.CLI/Program.cs
@DataWarehouse.CLI/DataWarehouse.CLI.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate all CommandHandler.Create call sites to SetAction API</name>
  <files>
    DataWarehouse.CLI/Program.cs
  </files>
  <action>
Read `DataWarehouse.CLI/Program.cs` (642 lines). There are 8 uses of `CommandHandler.Create` that must be migrated to `command.SetAction(...)`.

**Step 1: Remove deprecated imports**

Remove these using statements:
```csharp
using System.CommandLine.NamingConventionBinder;  // deprecated, remove entirely
using System.CommandLine.Invocation;               // InvocationContext is gone in 2.0
```

Add (if not already present):
```csharp
using System.CommandLine.Parsing;  // for ParseResult
```

**Step 2: Migrate rootCommand default handler (line ~276)**

BEFORE:
```csharp
rootCommand.Handler = CommandHandler.Create(() =>
{
    ShowWelcome();
});
```

AFTER:
```csharp
rootCommand.SetAction((ParseResult parseResult, CancellationToken token) =>
{
    ShowWelcome();
    return 0;
});
```

**Step 3: Migrate shell completion handlers (lines ~487-512)**

There are 4 shell completion commands (bash, zsh, fish, powershell), each using `CommandHandler.Create(() => ...)`.

BEFORE (example -- bash):
```csharp
bashCmd.Handler = CommandHandler.Create(() =>
{
    var generator = new ShellCompletionGenerator(_executor!);
    Console.WriteLine(generator.Generate(ShellType.Bash));
});
```

AFTER:
```csharp
bashCmd.SetAction((ParseResult parseResult, CancellationToken token) =>
{
    var generator = new ShellCompletionGenerator(_executor!);
    Console.WriteLine(generator.Generate(ShellType.Bash));
    return 0;
});
```

Apply the same pattern to zsh, fish, and powershell commands.

**Step 4: Migrate interactive command handler (line ~525)**

BEFORE:
```csharp
command.Handler = CommandHandler.Create(async () => await RunInteractiveModeAsync());
```

AFTER:
```csharp
command.SetAction(async (ParseResult parseResult, CancellationToken token) =>
{
    await RunInteractiveModeAsync();
    return 0;
});
```

**Step 5: Migrate connect command handler (line ~541)**

BEFORE:
```csharp
command.Handler = CommandHandler.Create<string?, int, string?>(async (host, port, localPath) =>
{
    // ... connection logic using host, port, localPath parameters
});
```

AFTER -- must use explicit ParseResult.GetValue to extract parameters:
```csharp
command.SetAction(async (ParseResult parseResult, CancellationToken token) =>
{
    var host = parseResult.GetValue(hostOption);
    var port = parseResult.GetValue(portOption);
    var localPath = parseResult.GetValue(localPathOption);

    // ... rest of connection logic unchanged ...
    return 0;
});
```

NOTE: The options (hostOption, portOption, localPathOption) are local variables in `CreateConnectCommand()` and must be captured by the lambda. They are already in scope -- no structural changes needed.

**Step 6: Migrate the critical CreateSubCommand helper (lines 575-639)**

This is the most important migration -- it covers ~30 subcommands automatically.

BEFORE:
```csharp
command.Handler = CommandHandler.Create<InvocationContext>(async (context) =>
{
    var parameters = new Dictionary<string, object?>();

    foreach (var arg in arguments)
    {
        var value = context.ParseResult.GetValueForArgument(arg);
        if (value != null) parameters[arg.Name] = value;
    }

    foreach (var opt in options)
    {
        var value = context.ParseResult.GetValueForOption(opt);
        if (value != null)
        {
            var optName = opt.Name.TrimStart('-').Replace("-", "");
            parameters[optName] = value;
        }
    }

    var format = context.ParseResult.GetValueForOption(formatOption);
    var result = await _executor!.ExecuteAsync(sharedCommandName, parameters);
    _renderer.Render(result, format);
    _history?.Add(sharedCommandName, parameters, result.Success);
    context.ExitCode = result.ExitCode;
});
```

AFTER:
```csharp
command.SetAction(async (ParseResult parseResult, CancellationToken token) =>
{
    var parameters = new Dictionary<string, object?>();

    foreach (var arg in arguments)
    {
        var value = parseResult.GetValue(arg);
        if (value != null) parameters[arg.Name] = value;
    }

    foreach (var opt in options)
    {
        var value = parseResult.GetValue(opt);
        if (value != null)
        {
            var optName = opt.Name.TrimStart('-').Replace("-", "");
            parameters[optName] = value;
        }
    }

    var format = parseResult.GetValue(formatOption);
    var result = await _executor!.ExecuteAsync(sharedCommandName, parameters);
    _renderer.Render(result, format);
    _history?.Add(sharedCommandName, parameters, result.Success);
    return result.ExitCode;
});
```

Key changes in CreateSubCommand:
- `context.ParseResult.GetValueForArgument(arg)` becomes `parseResult.GetValue(arg)`
- `context.ParseResult.GetValueForOption(opt)` becomes `parseResult.GetValue(opt)`
- `context.ExitCode = result.ExitCode;` becomes `return result.ExitCode;`
- Lambda signature changes from `InvocationContext` to `(ParseResult parseResult, CancellationToken token)`

**Step 7: Migrate rootCommand.Invoke to Parse+InvokeAsync**

In `Main`, find where `rootCommand.Invoke(args)` or `rootCommand.InvokeAsync(args)` is called.

BEFORE:
```csharp
return await rootCommand.InvokeAsync(args);
```

AFTER (System.CommandLine 2.0 pattern):
```csharp
var parseResult = rootCommand.Parse(args);
return await parseResult.InvokeAsync();
```

NOTE: Check whether `rootCommand.InvokeAsync(args)` still compiles in 2.0.3 -- it may still work as a convenience method. If it compiles without warnings, it can be left as-is. Only change if it produces deprecation warnings. The key migration target is the handler pattern (CommandHandler.Create -> SetAction), not necessarily the invocation entry point.

**Step 8: Update Add/AddAlias patterns (if present)**

Search for any `.Add(subcommand)` patterns and update to `.Subcommands.Add(subcommand)`. Similarly `.Add(option)` becomes `.Options.Add(option)`, and `.Add(argument)` becomes `.Arguments.Add(argument)`.

Check if `.AddAlias("-x")` is used -- it becomes `.Aliases.Add("-x")` in 2.0.

NOTE: The current code at lines 250-273 uses `rootCommand.Add(...)` for adding subcommands. In System.CommandLine 2.0.3, check if `.Add()` still compiles. If it does (as an extension method), leave it. If it produces warnings, change to `.Subcommands.Add()`. The priority is eliminating NamingConventionBinder, not migrating every convenience method.

CRITICAL: Do NOT change any business logic. This is a pure API migration -- same behavior, new API surface. Every command must produce identical output.

CRITICAL: The `CreateSubCommand` helper's parameter extraction logic must remain identical -- it iterates over `arguments` and `options` lists and builds a `Dictionary<string, object?>`. Only the API calls change, not the logic.
  </action>
  <verify>
1. `dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj` succeeds with zero errors
2. `grep -n "CommandHandler.Create" DataWarehouse.CLI/Program.cs` returns ZERO matches
3. `grep -n "NamingConventionBinder" DataWarehouse.CLI/Program.cs` returns ZERO matches
4. `grep -n "InvocationContext" DataWarehouse.CLI/Program.cs` returns ZERO matches
5. `grep -n "SetAction" DataWarehouse.CLI/Program.cs` returns 8 matches (one per handler)
6. `grep -n "GetValueForOption\|GetValueForArgument" DataWarehouse.CLI/Program.cs` returns ZERO matches (all migrated to GetValue)
  </verify>
  <done>
All 8 CommandHandler.Create sites migrated to SetAction. CreateSubCommand helper uses ParseResult.GetValue. No NamingConventionBinder or InvocationContext references remain. CLI compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Clean up CLI project file and verify NamingConventionBinder removal</name>
  <files>
    DataWarehouse.CLI/DataWarehouse.CLI.csproj
  </files>
  <action>
Read `DataWarehouse.CLI/DataWarehouse.CLI.csproj`.

**Step 1: Check for NamingConventionBinder package reference**

The research noted NamingConventionBinder may be a transitive dependency rather than a direct PackageReference. Check the .csproj:
- If `<PackageReference Include="System.CommandLine.NamingConventionBinder" .../>` exists, REMOVE it
- If it does NOT exist (transitive only), no .csproj change needed for that package

The import `using System.CommandLine.NamingConventionBinder;` in Program.cs was already removed in Task 1. After removing the using statement, if the package is only transitive, it will remain in the dependency tree but unused -- that's acceptable.

**Step 2: Verify System.CommandLine version**

Confirm `<PackageReference Include="System.CommandLine" Version="2.0.3" />` is present and pinned (not floating).

**Step 3: Build and run verification**

Build the CLI project:
```bash
dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj
```

Then verify the CLI still runs correctly:
```bash
dotnet run --project DataWarehouse.CLI/DataWarehouse.CLI.csproj -- --help
```

This should display the help text with all subcommands listed. Verify:
- `storage`, `backup`, `plugin`, `config`, `raid`, `audit`, `server`, `benchmark`, `system` subcommands appear
- `completions`, `interactive`, `connect` subcommands appear
- No runtime exceptions

Also test a specific subcommand help:
```bash
dotnet run --project DataWarehouse.CLI/DataWarehouse.CLI.csproj -- storage --help
```

**Step 4: Verify no forbidden patterns**

```bash
grep -rn "TODO\|NotImplementedException\|placeholder\|stub\|simulate" DataWarehouse.CLI/Program.cs
```
Should return zero matches.

NOTE: Do NOT add XML documentation to CLI types in this plan. BUILD-04 requires XML docs on "SDK public APIs" -- the CLI is an application, not a library. The CLI's public types are internal implementation details. If GenerateDocumentationFile is ever enabled for CLI, it would produce CS1591 warnings that need CS1591 in NoWarn -- this is already handled per-project for plugins that have it.
  </action>
  <verify>
1. `dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj` succeeds with zero errors
2. `dotnet run --project DataWarehouse.CLI/DataWarehouse.CLI.csproj -- --help` shows all subcommands
3. No `System.CommandLine.NamingConventionBinder` PackageReference in .csproj
4. `System.CommandLine` version is `2.0.3` (pinned, not floating)
5. Zero forbidden patterns (TODO, NotImplementedException, placeholder, stub, simulate)
  </verify>
  <done>
CLI .csproj clean -- no NamingConventionBinder reference, System.CommandLine 2.0.3 confirmed. CLI builds and runs successfully. Help output displays all subcommands. Zero forbidden patterns (CLI-01 satisfied).
  </done>
</task>

</tasks>

<verification>
- [ ] Zero references to `CommandHandler.Create` in Program.cs
- [ ] Zero references to `NamingConventionBinder` in Program.cs or .csproj
- [ ] Zero references to `InvocationContext` in Program.cs
- [ ] Zero references to `GetValueForOption` or `GetValueForArgument` in Program.cs
- [ ] 8 `SetAction` calls in Program.cs (matching 8 original handler assignments)
- [ ] `dotnet build DataWarehouse.CLI/DataWarehouse.CLI.csproj` exits 0
- [ ] `dotnet run --project DataWarehouse.CLI -- --help` shows all subcommands
- [ ] `System.CommandLine` version is 2.0.3 (pinned) in .csproj
- [ ] No forbidden patterns (Rule 13)
</verification>

<success_criteria>
Plan 22-04 succeeds when:
1. All 8 CommandHandler.Create call sites replaced with SetAction (CLI-01)
2. CreateSubCommand helper migrated to ParseResult.GetValue pattern (covers ~30 subcommands)
3. No deprecated NamingConventionBinder or InvocationContext usage anywhere
4. CLI compiles and runs correctly with all subcommands functional
5. Zero Rule 13 violations
</success_criteria>

<output>
After completion, create `.planning/phases/22-build-safety-supply-chain/22-04-SUMMARY.md`
</output>
