---
phase: 68-sdk-foundation
plan: 02
type: execute
wave: 2
depends_on: ["68-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
  - DataWarehouse.SDK/Contracts/Policy/IEffectivePolicy.cs
  - DataWarehouse.SDK/Contracts/Policy/IPolicyStore.cs
  - DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs
  - DataWarehouse.SDK/Contracts/Policy/IMetadataResidencyResolver.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "IPolicyEngine interface defines methods for resolving effective policies at any path"
    - "IEffectivePolicy interface represents a resolved policy snapshot for a given context"
    - "IPolicyStore interface provides CRUD operations for policy definitions"
    - "IPolicyPersistence interface abstracts the storage backend for policies"
    - "IMetadataResidencyResolver resolves residency mode per feature per metadata type with per-field fallback"
    - "All interfaces compile with zero errors and have full XML documentation"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs"
      provides: "IPolicyEngine — core policy resolution contract"
      contains: "interface IPolicyEngine"
    - path: "DataWarehouse.SDK/Contracts/Policy/IEffectivePolicy.cs"
      provides: "IEffectivePolicy — resolved policy snapshot"
      contains: "interface IEffectivePolicy"
    - path: "DataWarehouse.SDK/Contracts/Policy/IPolicyStore.cs"
      provides: "IPolicyStore — policy CRUD operations"
      contains: "interface IPolicyStore"
    - path: "DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs"
      provides: "IPolicyPersistence — pluggable storage backend"
      contains: "interface IPolicyPersistence"
    - path: "DataWarehouse.SDK/Contracts/Policy/IMetadataResidencyResolver.cs"
      provides: "IMetadataResidencyResolver — per-feature, per-field residency resolution"
      contains: "interface IMetadataResidencyResolver"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs"
      via: "uses FeaturePolicy, PolicyResolutionContext, OperationalProfile"
      pattern: "PolicyResolutionContext"
    - from: "DataWarehouse.SDK/Contracts/Policy/IMetadataResidencyResolver.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/MetadataResidencyTypes.cs"
      via: "uses MetadataResidencyMode, MetadataResidencyConfig, FieldResidencyOverride"
      pattern: "MetadataResidencyMode"
---

<objective>
Define the four core Policy Engine SDK interfaces (IPolicyEngine, IEffectivePolicy, IPolicyStore, IPolicyPersistence) and the IMetadataResidencyResolver interface.

Purpose: These interfaces are the contracts that all v6.0 phases implement against. Phase 69 implements IPolicyPersistence, Phase 70 implements IPolicyEngine cascade logic, and every plugin uses IMetadataResidencyResolver for metadata placement decisions.

Output: Five interface files in `DataWarehouse.SDK/Contracts/Policy/` with full XML documentation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/68-sdk-foundation/68-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core policy engine interfaces</name>
  <files>
    DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
    DataWarehouse.SDK/Contracts/Policy/IEffectivePolicy.cs
    DataWarehouse.SDK/Contracts/Policy/IPolicyStore.cs
    DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs
  </files>
  <action>
All files in namespace `DataWarehouse.SDK.Contracts.Policy`. Use block-scoped namespace (match existing codebase style). Full XML docs on every interface, method, and parameter.

**IPolicyEngine.cs** (SDKF-01):
```csharp
public interface IPolicyEngine
{
    /// Resolve the effective policy for a specific feature at a given context (path, user, hardware, security).
    /// The engine walks the cascade chain (Block->Chunk->Object->Container->VDE) applying CascadeStrategy rules.
    Task<IEffectivePolicy> ResolveAsync(string featureId, PolicyResolutionContext context, CancellationToken ct = default);

    /// Resolve effective policies for ALL features at a given context. Returns a dictionary keyed by featureId.
    Task<IReadOnlyDictionary<string, IEffectivePolicy>> ResolveAllAsync(PolicyResolutionContext context, CancellationToken ct = default);

    /// Get the current OperationalProfile (Speed/Balanced/Standard/Strict/Paranoid/Custom).
    Task<OperationalProfile> GetActiveProfileAsync(CancellationToken ct = default);

    /// Set the active OperationalProfile. All subsequent resolves use this profile's feature policies as defaults.
    Task SetActiveProfileAsync(OperationalProfile profile, CancellationToken ct = default);

    /// Simulate policy resolution without applying changes (PERF-07 placeholder — returns what-if analysis).
    Task<IEffectivePolicy> SimulateAsync(string featureId, PolicyResolutionContext context, FeaturePolicy hypotheticalPolicy, CancellationToken ct = default);
}
```

**IEffectivePolicy.cs** (SDKF-01):
```csharp
public interface IEffectivePolicy
{
    /// The feature this policy applies to.
    string FeatureId { get; }

    /// The resolved intensity level (0-100) after cascade.
    int EffectiveIntensity { get; }

    /// The resolved AI autonomy level after cascade.
    AiAutonomyLevel EffectiveAiAutonomy { get; }

    /// The cascade strategy that was used to produce this result.
    CascadeStrategy AppliedCascade { get; }

    /// The policy level at which the final decision was made (e.g., Container overrode Object).
    PolicyLevel DecidedAtLevel { get; }

    /// The full chain of policies consulted during resolution (ordered from most specific to least).
    IReadOnlyList<FeaturePolicy> ResolutionChain { get; }

    /// Custom parameters merged from the resolution chain.
    IReadOnlyDictionary<string, string> MergedParameters { get; }

    /// Snapshot timestamp — operations in flight use this snapshot (CASC-06 contract).
    DateTimeOffset SnapshotTimestamp { get; }
}
```

**IPolicyStore.cs** (SDKF-01):
```csharp
public interface IPolicyStore
{
    /// Get the policy for a feature at a specific level and path.
    Task<FeaturePolicy?> GetAsync(string featureId, PolicyLevel level, string path, CancellationToken ct = default);

    /// Set (create or update) a policy for a feature at a specific level and path.
    Task SetAsync(string featureId, PolicyLevel level, string path, FeaturePolicy policy, CancellationToken ct = default);

    /// Remove a policy override at a specific level and path.
    Task RemoveAsync(string featureId, PolicyLevel level, string path, CancellationToken ct = default);

    /// List all policy overrides for a feature across all levels.
    Task<IReadOnlyList<(PolicyLevel Level, string Path, FeaturePolicy Policy)>> ListOverridesAsync(string featureId, CancellationToken ct = default);

    /// Check if any override exists at a given level and path (used by bloom filter fast-path).
    Task<bool> HasOverrideAsync(PolicyLevel level, string path, CancellationToken ct = default);
}
```

**IPolicyPersistence.cs** (SDKF-01):
```csharp
public interface IPolicyPersistence
{
    /// Load all policies from the persistence backend.
    Task<IReadOnlyList<(string FeatureId, PolicyLevel Level, string Path, FeaturePolicy Policy)>> LoadAllAsync(CancellationToken ct = default);

    /// Save a single policy to the persistence backend.
    Task SaveAsync(string featureId, PolicyLevel level, string path, FeaturePolicy policy, CancellationToken ct = default);

    /// Delete a policy from the persistence backend.
    Task DeleteAsync(string featureId, PolicyLevel level, string path, CancellationToken ct = default);

    /// Save the active OperationalProfile.
    Task SaveProfileAsync(OperationalProfile profile, CancellationToken ct = default);

    /// Load the active OperationalProfile.
    Task<OperationalProfile?> LoadProfileAsync(CancellationToken ct = default);

    /// Flush any pending writes (for lazy/batched implementations).
    Task FlushAsync(CancellationToken ct = default);
}
```

Ensure all methods use `CancellationToken ct = default` for consistency with existing SDK patterns.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero errors. Grep for all 4 interface names to confirm presence.
  </verify>
  <done>
IPolicyEngine (5 methods), IEffectivePolicy (8 properties), IPolicyStore (5 methods), IPolicyPersistence (6 methods) all compile cleanly with full XML docs. All methods reference types from Plan 01 (FeaturePolicy, PolicyResolutionContext, OperationalProfile, PolicyLevel, CascadeStrategy, AiAutonomyLevel).
  </done>
</task>

<task type="auto">
  <name>Task 2: IMetadataResidencyResolver interface</name>
  <files>
    DataWarehouse.SDK/Contracts/Policy/IMetadataResidencyResolver.cs
  </files>
  <action>
**IMetadataResidencyResolver.cs** — namespace `DataWarehouse.SDK.Contracts.Policy` (MRES-02, MRES-10):

```csharp
public interface IMetadataResidencyResolver
{
    /// Resolve the residency configuration for a specific feature and metadata type.
    /// Returns the MetadataResidencyConfig that determines where metadata lives (VDE vs plugin).
    Task<MetadataResidencyConfig> ResolveAsync(string featureId, string metadataType, CancellationToken ct = default);

    /// Resolve per-field residency overrides within a single inode for a feature.
    /// Returns field-level overrides that allow mixed-state inodes where some fields are Tier 1 (VDE)
    /// and others are Tier 2 (plugin-managed). Returns empty list if no per-field overrides exist.
    /// (MRES-10: per-field residency within a single inode)
    Task<IReadOnlyList<FieldResidencyOverride>> ResolveFieldOverridesAsync(string featureId, string metadataType, CancellationToken ct = default);

    /// Get the default residency configuration used when no feature-specific or field-specific override exists.
    MetadataResidencyConfig DefaultConfig { get; }

    /// Check if a specific field within an inode should use plugin fallback (Tier 2).
    /// This is the hot-path method called during inode reads to determine per-field behavior.
    /// (MRES-10: supports per-field fallback within a single inode)
    bool ShouldFallbackToPlugin(string featureId, string metadataType, string fieldName);
}
```

XML doc the interface itself explaining:
- This resolver is the single entry point for metadata residency decisions.
- Plugins call `ResolveAsync` to determine where to read/write their metadata.
- The VDE engine calls `ShouldFallbackToPlugin` on the hot path during inode field reads to decide Tier 1 vs Tier 2.
- Per-field granularity enables mixed-state inodes (MRES-10) where, e.g., encryption key references are PluginOnly (HSM-backed) while all other fields are VdePrimary.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero errors. Verify IMetadataResidencyResolver has all 4 members (2 async methods, 1 property, 1 sync method).
  </verify>
  <done>
IMetadataResidencyResolver interface compiles cleanly with 4 members. References MetadataResidencyConfig, FieldResidencyOverride, MetadataResidencyMode from Plan 01. Supports both per-feature resolution and per-field fallback within single inodes (MRES-10).
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` completes with 0 errors, 0 warnings from new files
- All 5 interfaces defined with correct method signatures
- All interfaces reference types from Plan 01 (no `any`, no `object` — strongly typed)
- Full XML documentation on every interface, method, property, and parameter
</verification>

<success_criteria>
5 SDK interface files compile cleanly. IPolicyEngine + IEffectivePolicy + IPolicyStore + IPolicyPersistence satisfy SDKF-01. IMetadataResidencyResolver satisfies MRES-02 and MRES-10. Ready for Plan 03 to wire PolicyContext into PluginBase.
</success_criteria>

<output>
After completion, create `.planning/phases/68-sdk-foundation/68-02-SUMMARY.md`
</output>
