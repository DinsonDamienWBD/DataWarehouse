---
phase: 68-sdk-foundation
plan: 03
type: execute
wave: 3
depends_on: ["68-01", "68-02"]
files_modified:
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
  - DataWarehouse.SDK/Contracts/Policy/IAiHook.cs
  - DataWarehouse.SDK/Contracts/Policy/PolicyContext.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PluginBase has a PolicyContext property that all 53 plugins inherit automatically"
    - "IntelligenceAwarePluginBase exposes IAiHook, ObservationEmitter, and RecommendationReceiver"
    - "UltimateIntelligencePlugin inherits DataTransformationPluginBase (which inherits PluginBase), NOT IntelligenceAwarePluginBase"
    - "Full solution builds with 0 errors, 0 warnings after all changes"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "PolicyContext property on PluginBase"
      contains: "PolicyContext"
    - path: "DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs"
      provides: "IAiHook, ObservationEmitter, RecommendationReceiver on IntelligenceAwarePluginBase"
      contains: "IAiHook"
    - path: "DataWarehouse.SDK/Contracts/Policy/IAiHook.cs"
      provides: "IAiHook interface and ObservationEmitter/RecommendationReceiver types"
      contains: "interface IAiHook"
    - path: "DataWarehouse.SDK/Contracts/Policy/PolicyContext.cs"
      provides: "PolicyContext class holding IPolicyEngine reference for plugins"
      contains: "class PolicyContext"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/PolicyContext.cs"
      via: "PolicyContext property"
      pattern: "PolicyContext.*Policy"
    - from: "DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/IAiHook.cs"
      via: "IAiHook implementation"
      pattern: "IAiHook"
---

<objective>
Extend PluginBase with PolicyContext, enhance IntelligenceAwarePluginBase with AI hook contracts, and verify UltimateIntelligence isolation.

Purpose: After this plan, every plugin in the system is policy-aware (via PluginBase.PolicyContext), and intelligence-aware plugins have the observation/recommendation pipeline contracts they need for AI policy tuning. UltimateIntelligence remains isolated from IntelligenceAwarePluginBase to prevent AI-observing-AI feedback loops (SDKF-12).

Output: Modified PluginBase.cs, modified IntelligenceAwarePluginBase.cs, new IAiHook.cs and PolicyContext.cs.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/68-sdk-foundation/68-01-SUMMARY.md
@.planning/phases/68-sdk-foundation/68-02-SUMMARY.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
@Plugins/DataWarehouse.Plugins.UltimateIntelligence/UltimateIntelligencePlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PolicyContext class and IAiHook contracts</name>
  <files>
    DataWarehouse.SDK/Contracts/Policy/PolicyContext.cs
    DataWarehouse.SDK/Contracts/Policy/IAiHook.cs
  </files>
  <action>
**PolicyContext.cs** — namespace `DataWarehouse.SDK.Contracts.Policy`:

Create a `PolicyContext` sealed class that plugins use to interact with the policy engine:

```csharp
/// <summary>
/// Provides policy engine access to plugins. Injected into PluginBase during initialization.
/// Plugins use this to resolve effective policies for their features, check AI autonomy levels,
/// and read the active OperationalProfile.
/// </summary>
public sealed class PolicyContext
{
    /// The policy engine instance for resolving effective policies.
    public IPolicyEngine? Engine { get; }

    /// The metadata residency resolver for determining where metadata lives.
    public IMetadataResidencyResolver? ResidencyResolver { get; }

    /// Whether the policy engine is available (false during startup or in minimal deployments).
    public bool IsAvailable => Engine != null;

    /// Constructor. Null engine is valid — plugins gracefully degrade when policy engine is absent.
    public PolicyContext(IPolicyEngine? engine, IMetadataResidencyResolver? residencyResolver)
    {
        Engine = engine;
        ResidencyResolver = residencyResolver;
    }

    /// Empty context for when no policy engine is configured.
    public static PolicyContext Empty { get; } = new PolicyContext(null, null);
}
```

**IAiHook.cs** — namespace `DataWarehouse.SDK.Contracts.Policy` (SDKF-11):

```csharp
/// <summary>
/// Contract for plugins that participate in the AI observation/recommendation pipeline.
/// Implemented by IntelligenceAwarePluginBase to enable AI policy tuning.
/// UltimateIntelligencePlugin does NOT implement this (SDKF-12: prevents AI-observing-AI loops).
/// </summary>
public interface IAiHook
{
    /// Called when the AI observation pipeline has a recommendation for this plugin.
    Task OnRecommendationReceivedAsync(PolicyRecommendation recommendation, CancellationToken ct = default);

    /// Get the observation emitter for this plugin. Used to push metrics/observations to the AI pipeline.
    ObservationEmitter Observations { get; }

    /// Get the recommendation receiver for this plugin. Used to subscribe to AI recommendations.
    RecommendationReceiver Recommendations { get; }
}

/// <summary>
/// Emits observations (metrics, events, anomalies) from a plugin to the AI observation pipeline.
/// Observations are lock-free and async — zero hot-path impact (AIPI-01 contract placeholder).
/// </summary>
public sealed class ObservationEmitter
{
    private readonly string _pluginId;
    private readonly IMessageBus? _messageBus;

    public ObservationEmitter(string pluginId, IMessageBus? messageBus)
    {
        _pluginId = pluginId;
        _messageBus = messageBus;
    }

    /// Emit a metric observation (e.g., compression ratio, encryption latency).
    public Task EmitMetricAsync(string metricName, double value, CancellationToken ct = default)
    {
        // Phase 77 (AI Policy Intelligence) will implement the full pipeline.
        // For now, this is a no-op that compiles clean — the contract is what matters in Phase 68.
        return Task.CompletedTask;
    }

    /// Emit an anomaly observation (e.g., unexpected pattern, performance degradation).
    public Task EmitAnomalyAsync(string anomalyType, string description, CancellationToken ct = default)
    {
        return Task.CompletedTask;
    }
}

/// <summary>
/// Receives AI-generated policy recommendations for a plugin.
/// </summary>
public sealed class RecommendationReceiver
{
    private readonly string _pluginId;

    public RecommendationReceiver(string pluginId)
    {
        _pluginId = pluginId;
    }

    /// Subscribe to recommendations. Returns a disposable subscription handle.
    public IDisposable Subscribe(Func<PolicyRecommendation, CancellationToken, Task> handler)
    {
        // Phase 77 will implement the full subscription pipeline.
        return new NoOpDisposable();
    }

    private sealed class NoOpDisposable : IDisposable
    {
        public void Dispose() { }
    }
}

/// <summary>
/// An AI-generated recommendation to adjust a feature policy.
/// </summary>
public sealed record PolicyRecommendation(
    string FeatureId,
    string Rationale,
    FeaturePolicy SuggestedPolicy,
    AiAutonomyLevel RequiredAutonomy,
    double ConfidenceScore,
    DateTimeOffset GeneratedAt
);
```

Note: ObservationEmitter needs `IMessageBus` — use the existing `DataWarehouse.SDK.Primitives.IMessageBus` type. Add a `using DataWarehouse.SDK.Primitives;` at the top. If `IMessageBus` is in a different namespace, find it with grep and use the correct one.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` and confirm zero errors. Verify IAiHook has 3 members, ObservationEmitter has 2 emit methods, RecommendationReceiver has Subscribe, PolicyRecommendation has 6 properties.
  </verify>
  <done>
PolicyContext class with Engine/ResidencyResolver/IsAvailable/Empty compiles clean. IAiHook interface with Observations/Recommendations/OnRecommendationReceivedAsync compiles clean. ObservationEmitter and RecommendationReceiver with no-op implementations compile clean. PolicyRecommendation record compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend PluginBase and IntelligenceAwarePluginBase</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
  </files>
  <action>
**PluginBase.cs** modification (SDKF-10):

1. Add `using DataWarehouse.SDK.Contracts.Policy;` at the top.

2. Add a new property after the existing `StateStore` property:
```csharp
/// <summary>
/// Policy context providing access to the v6.0 Policy Engine.
/// Automatically available to all plugins. Null-safe — check <see cref="PolicyContext.IsAvailable"/>
/// before using. Set during kernel initialization; plugins do not set this themselves.
/// </summary>
protected PolicyContext PolicyContext { get; private set; } = PolicyContext.Empty;
```

3. Find the `InitializeAsync` method (or equivalent kernel-called initialization). Add a public setter method that the kernel calls to inject the PolicyContext:
```csharp
/// <summary>
/// Called by the kernel to inject the policy context into this plugin.
/// Plugins should NOT call this directly.
/// </summary>
public void SetPolicyContext(PolicyContext context)
{
    PolicyContext = context ?? PolicyContext.Empty;
}
```

IMPORTANT: Do NOT break any existing code. The `PolicyContext` property defaults to `PolicyContext.Empty` so all 53 existing plugins continue to work without modification. The `SetPolicyContext` method is additive — it does not change any existing method signatures.

**IntelligenceAwarePluginBase.cs** modification (SDKF-11):

1. Add `using DataWarehouse.SDK.Contracts.Policy;` at the top.

2. Make the class implement `IAiHook`:
```csharp
public abstract class IntelligenceAwarePluginBase : PluginBase, IIntelligenceAware, IIntelligenceAwareNotifiable, IFeaturePlugin, IAiHook
```

3. Add the IAiHook implementation as new properties/methods (after the existing fields, before existing methods):
```csharp
/// <summary>
/// Observation emitter for this plugin. Sends metrics and anomalies to the AI pipeline.
/// Initialized during StartAsync when MessageBus is available.
/// </summary>
public ObservationEmitter Observations { get; private set; } = null!;

/// <summary>
/// Recommendation receiver for this plugin. Subscribes to AI policy recommendations.
/// Initialized during construction.
/// </summary>
public RecommendationReceiver Recommendations { get; private set; } = null!;
```

4. In the constructor (or if there is no constructor, add one), initialize:
```csharp
Recommendations = new RecommendationReceiver(Id);
```

If there is no constructor, instead initialize in the field declaration using a lazy pattern or in the existing StartAsync method. Find the pattern used by the existing code and match it.

5. In the existing `StartAsync` override (or `OnStartCoreAsync`), after MessageBus is available, add:
```csharp
Observations = new ObservationEmitter(Id, MessageBus);
```

6. Add the `OnRecommendationReceivedAsync` implementation:
```csharp
/// <summary>
/// Called when the AI pipeline has a recommendation for this plugin.
/// Override in derived classes to act on recommendations.
/// Default implementation is a no-op.
/// </summary>
public virtual Task OnRecommendationReceivedAsync(PolicyRecommendation recommendation, CancellationToken ct = default)
{
    return Task.CompletedTask;
}
```

IMPORTANT: Do NOT remove or modify any existing methods, fields, or interfaces. This is purely additive. The `IAiHook` interface is added to the class declaration, and 3 new members are added. All existing 53 plugins that derive from IntelligenceAwarePluginBase continue to work because `OnRecommendationReceivedAsync` is virtual with a default no-op implementation.

**UltimateIntelligence verification** (SDKF-12):

Verify (do NOT modify) that `UltimateIntelligencePlugin` at `Plugins/DataWarehouse.Plugins.UltimateIntelligence/UltimateIntelligencePlugin.cs` inherits from `DataTransformationPluginBase` (which inherits from `DataPipelinePluginBase` -> `PluginBase`), NOT from `IntelligenceAwarePluginBase`. Grep for its class declaration to confirm. If it already inherits from something other than IntelligenceAwarePluginBase, it is correct. Log the verification result.
  </action>
  <verify>
1. `dotnet build DataWarehouse.sln` — full solution build with 0 errors, 0 warnings from modified files.
2. Grep `PolicyContext` in PluginBase.cs — must find the property.
3. Grep `IAiHook` in IntelligenceAwarePluginBase.cs — must find it in the class declaration.
4. Grep `class UltimateIntelligencePlugin` — must NOT contain `IntelligenceAwarePluginBase`.
  </verify>
  <done>
PluginBase has PolicyContext property defaulting to Empty (SDKF-10). IntelligenceAwarePluginBase implements IAiHook with ObservationEmitter, RecommendationReceiver, and OnRecommendationReceivedAsync (SDKF-11). UltimateIntelligencePlugin confirmed to inherit PluginBase chain, NOT IntelligenceAwarePluginBase (SDKF-12). Full solution builds with 0 errors.
  </done>
</task>

</tasks>

<verification>
- Full solution `dotnet build DataWarehouse.sln` passes with 0 errors, 0 warnings from modified/new files
- All 53 existing plugins compile without modification (PolicyContext defaults to Empty)
- IntelligenceAwarePluginBase now implements IAiHook
- UltimateIntelligencePlugin does NOT implement IAiHook (confirmed by inheritance chain)
- PluginBase.PolicyContext accessible from any plugin
</verification>

<success_criteria>
Every plugin is policy-aware via PolicyContext (SDKF-10). Intelligence-aware plugins expose AI hooks (SDKF-11). UltimateIntelligence isolation verified (SDKF-12). Zero compilation errors across the full solution.
</success_criteria>

<output>
After completion, create `.planning/phases/68-sdk-foundation/68-03-SUMMARY.md`
</output>
