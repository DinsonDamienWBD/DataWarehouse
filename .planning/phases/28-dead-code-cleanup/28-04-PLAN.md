---
phase: 28-dead-code-cleanup
plan: 04
type: execute
wave: 3
depends_on: ["28-02", "28-03"]
files_modified:
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/SpecializedIntelligenceAwareBases.cs
autonomous: true

must_haves:
  truths:
    - "If Phase 27 is complete: LegacyFeaturePluginBase, IntelligenceAwarePluginBase wrappers, and SpecializedIntelligenceAwareBases.cs are removed"
    - "If Phase 27 is NOT complete: conditional removals are skipped with documentation explaining why"
    - "Full solution build passes with zero errors"
    - "LOC impact report is generated showing total lines removed"
    - "All CLEAN-01, CLEAN-02, CLEAN-03 requirements are satisfied"
  artifacts:
    - path: ".planning/phases/28-dead-code-cleanup/28-04-SUMMARY.md"
      provides: "LOC impact report, complete dead code inventory, phase completion status"
      min_lines: 30
  key_links:
    - from: "dotnet build"
      to: "zero errors"
      via: "full solution compilation"
      pattern: "Build succeeded"
    - from: "Phase 28 completion"
      to: "CLEAN-01, CLEAN-02, CLEAN-03"
      via: "All requirements verified"
      pattern: "CLEAN-0[123]"
---

<objective>
Conditional post-Phase-27 cleanup, full build verification, orphaned using cleanup, and LOC impact report.

Purpose: If Phase 27 has completed, remove the now-dead LegacyFeaturePluginBase and IntelligenceAware* specialized bases (~5,800 LOC). Regardless of Phase 27 status, run comprehensive build verification, clean up any orphaned using directives from Plans 01-03, and produce a final LOC impact report documenting everything removed.

Output: Conditional dead code removal, verified green build, complete LOC report.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-dead-code-cleanup/28-RESEARCH.md
@.planning/phases/28-dead-code-cleanup/28-01-SUMMARY.md
@.planning/phases/28-dead-code-cleanup/28-02-SUMMARY.md
@.planning/phases/28-dead-code-cleanup/28-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Conditional Phase 27 dead code removal</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/SpecializedIntelligenceAwareBases.cs
  </files>
  <action>
    **Step 1: Determine Phase 27 completion status.**

    Check if Phase 27 plans have been executed:
    ```
    ls .planning/phases/27-*/*-SUMMARY.md
    ```
    If 5 SUMMARY files exist (27-01 through 27-05), Phase 27 is complete. If fewer or none, Phase 27 is incomplete.

    Also verify by grepping: if `LegacyFeaturePluginBase` still has 42+ external refs (plugins inheriting from it), Phase 27 migration is NOT complete. If refs have dropped to 0-1 (self-only), Phase 27 IS complete.

    **IF Phase 27 IS complete (LegacyFeaturePluginBase has 0-1 external refs):**

    1. **Remove LegacyFeaturePluginBase from PluginBase.cs:**
       - It is marked [Obsolete] and was only kept for Phase 27 migration.
       - Grep to confirm 0 external refs (all 21 plugins migrated).
       - Remove the class definition from PluginBase.cs.

    2. **Remove IntelligenceAwarePluginBase wrappers** (if any remain):
       - Check if IntelligenceAwarePluginBase still has any external refs from plugins.
       - If 0 refs (all migrated to Hierarchy bases): remove from PluginBase.cs.
       - If refs remain: KEEP (not all plugins migrated yet).

    3. **Delete SpecializedIntelligenceAwareBases.cs (4,168 LOC):**
       - Grep for each specialized base (IntelligenceAwareConnectorPluginBase, IntelligenceAwareStoragePluginBase, etc.).
       - If all have 0 external refs (plugins migrated to Hierarchy domain bases): delete the file.
       - If ANY have refs: only remove the dead ones, keep the file with live types.

    4. Run `dotnet build DataWarehouse.slnx` to verify.

    **IF Phase 27 is NOT complete:**

    1. DO NOT remove LegacyFeaturePluginBase, IntelligenceAwarePluginBase, or SpecializedIntelligenceAwareBases.cs.
    2. Log in the SUMMARY: "Phase 27 incomplete -- conditional removals deferred. LegacyFeaturePluginBase has {N} refs, SpecializedIntelligenceAwareBases.cs types have {N} refs."
    3. Proceed to Task 2 (build verification still needed).
  </action>
  <verify>
    If Phase 27 complete: `dotnet build DataWarehouse.slnx` passes, grep for LegacyFeaturePluginBase returns 0 matches. If Phase 27 incomplete: no files modified, log entry created.
  </verify>
  <done>
    Phase 27 conditional cleanup handled. If complete: ~5,800 LOC removed (LegacyFeaturePluginBase + SpecializedIntelligenceAwareBases.cs). If incomplete: documented as deferred with current reference counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Full build verification, orphaned using cleanup, and LOC impact report</name>
  <files></files>
  <action>
    **Step 1: Full clean build.**
    ```bash
    dotnet build DataWarehouse.slnx --no-incremental
    ```
    This forces a full rebuild (not incremental) to catch ANY transitive reference breaks that incremental builds might miss.

    If errors: diagnose and fix each one. Common issues:
    - CS8019 (unnecessary using directive) -- remove the orphaned `using` line
    - CS0246 (type not found) -- a live type was accidentally deleted or its extraction in Plan 01 was incomplete. Find and restore.
    - CS0234 (namespace not found) -- a deleted file had the last type in its namespace. Remove the using directive.

    **Step 2: Orphaned using directive sweep.**
    After build passes, search for likely orphaned usings from deleted namespaces:
    ```bash
    grep -rn "using DataWarehouse.SDK.Services" --include="*.cs" . | grep -v "obj/"
    grep -rn "using DataWarehouse.SDK.Governance" --include="*.cs" . | grep -v "obj/"
    grep -rn "using DataWarehouse.SDK.Licensing" --include="*.cs" . | grep -v "obj/"
    ```
    If any of these namespaces no longer exist (all files in that folder deleted), remove the using directives from referencing files.

    Also check for references to specific deleted types in XML doc comments or string literals (these would not cause build errors but are stale):
    ```bash
    grep -rn "SemanticAnalyzerBase\|InstancePoolingService\|VfsPlaceholderService\|SmartFolderService" --include="*.cs" . | grep -v "obj/"
    ```
    Remove any stale references found.

    Rebuild after fixes: `dotnet build DataWarehouse.slnx`

    **Step 3: Run tests.**
    ```bash
    dotnet test DataWarehouse.slnx --no-build
    ```
    All existing tests must pass. If any test fails: investigate. Dead code removal should NEVER break tests (the code was unused). If a test directly tested dead code, that test is itself dead -- remove it.

    **Step 4: LOC impact report.**
    Generate a comprehensive report by counting lines removed. Use `git diff --stat` against the commit before Phase 28 started:
    ```bash
    git diff --stat HEAD~{N}  # where N is number of commits in Phase 28
    # or
    git log --oneline --since="Phase 28 start"
    git diff --stat {pre-phase-28-commit}..HEAD
    ```

    Compile the report as a table:

    | Category | Files Deleted | Files Modified | LOC Removed | LOC Added |
    |----------|--------------|----------------|-------------|-----------|
    | Plugin bases (1A) | X | 0 | X | 0 |
    | Services (1B) | X | 0 | X | 0 |
    | Infrastructure (1C) | X | 0 | X | 0 |
    | AI module (1D) | X | 0 | X | 0 |
    | Misc (1E) | X | 0 | X | 0 |
    | Mixed files (2) | 0 | X | X | 0 |
    | Future-ready (3) | 0 | 9 | 0 | ~30 |
    | Superseded (4A) | 1 | 7 | X | ~7 |
    | Post-Phase 27 (5) | X or 0 | X or 0 | X or 0 | 0 |
    | Using cleanup | 0 | X | X | 0 |
    | **Total** | **X** | **X** | **X** | **X** |

    **Step 5: Requirements verification.**
    Verify each requirement is met:
    - **CLEAN-01**: List all deleted files and confirm zero references (no inheritance, no instantiation, no import) for each.
    - **CLEAN-02**: List superseded code removed (KnowledgeObject duplicate, dead bases replaced by Hierarchy).
    - **CLEAN-03**: List all 9 future-ready files with FUTURE: comments preserved.
    - **REGR-06**: Confirm dead code cleanup happened AFTER Phase 27 verification (or document that Phase 27 is incomplete).
    - **AD-06**: Confirm future-ready interfaces for quantum, brain-reading, DNA, neuromorphic, RDMA, io_uring, NUMA, TPM2, HSM are all preserved.
    - **AD-08**: Confirm zero functionality lost (build passes, tests pass, all live types accounted for).
  </action>
  <verify>
    `dotnet build DataWarehouse.slnx --no-incremental` -- zero errors, zero new warnings. `dotnet test DataWarehouse.slnx --no-build` -- all existing tests pass. LOC report generated.
  </verify>
  <done>
    Full clean build passes. All tests pass. Orphaned usings cleaned. LOC impact report shows total dead code removed (target: 27,000-33,000 LOC). CLEAN-01, CLEAN-02, CLEAN-03, REGR-06, AD-06, AD-08 all verified.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.slnx --no-incremental` -- zero errors
2. `dotnet test DataWarehouse.slnx` -- all existing tests pass (zero regression)
3. LOC impact report generated with per-category breakdown
4. CLEAN-01 verified: all zero-reference classes/files removed
5. CLEAN-02 verified: superseded implementations removed
6. CLEAN-03 verified: 9 future-ready files preserved with FUTURE: comments
7. AD-06 verified: all future-ready technology interfaces preserved
8. AD-08 verified: zero functionality lost
</verification>

<success_criteria>
- Full clean build passes with zero errors
- All existing tests pass (zero regression per AD-08)
- Conditional Phase 27 cleanup completed or documented as deferred
- No orphaned using directives remain
- LOC impact report shows 27,000-33,000 lines removed
- All three CLEAN-* requirements verified as complete
- Phase 28 is complete and ready for Phase 29
</success_criteria>

<output>
After completion, create `.planning/phases/28-dead-code-cleanup/28-04-SUMMARY.md`
</output>
