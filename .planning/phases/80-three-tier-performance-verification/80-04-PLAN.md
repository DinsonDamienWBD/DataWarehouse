---
phase: 80-three-tier-performance-verification
plan: 04
type: execute
wave: 2
depends_on: ["80-01", "80-02", "80-03"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Verification/TierFeatureMap.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Verification/TierPerformanceBenchmark.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Verification/ThreeTierVerificationSuite.cs
autonomous: true
must_haves:
  truths:
    - "Per-feature tier mapping documents which tier each of the 19 features uses by default and what triggers promotion or demotion"
    - "Benchmarks demonstrate measurable performance differences between Tier 1, Tier 2, and Tier 3 for at least 5 representative features"
    - "A unified verification suite runs all three tier verifiers and produces a consolidated report"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Verification/TierFeatureMap.cs"
      provides: "Per-feature tier mapping with default tier, promotion/demotion triggers"
      min_lines: 120
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Verification/TierPerformanceBenchmark.cs"
      provides: "Performance benchmarks comparing Tier 1 vs Tier 2 vs Tier 3"
      min_lines: 150
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Verification/ThreeTierVerificationSuite.cs"
      provides: "Unified verification suite running all tier checks"
      min_lines: 80
  key_links:
    - from: "TierFeatureMap"
      to: "ModuleRegistry"
      via: "maps all 19 modules to tier assignments"
      pattern: "ModuleRegistry\\.AllModules"
    - from: "TierPerformanceBenchmark"
      to: "Regions/*"
      via: "benchmarks region read/write for Tier 1 representative features"
      pattern: "Serialize|Deserialize|WriteTo|ReadFrom"
    - from: "ThreeTierVerificationSuite"
      to: "Tier1ModuleVerifier, Tier2PipelineVerifier, Tier3BasicFallbackVerifier"
      via: "orchestrates all three verifiers"
      pattern: "VerifyAllModules"
---

<objective>
Create the per-feature tier mapping documentation and performance benchmarks that prove measurable differences between Tier 1, Tier 2, and Tier 3 for representative features.

Purpose: TIER-04 requires a documented mapping showing which tier each feature defaults to and what triggers tier promotion/demotion. TIER-05 requires benchmarks proving performance differences. This plan creates the TierFeatureMap (static mapping for all 19 modules), TierPerformanceBenchmark (benchmarks for 5+ representative features), and ThreeTierVerificationSuite (unified orchestrator).

Output: TierFeatureMap with complete mapping, TierPerformanceBenchmark with comparative metrics, ThreeTierVerificationSuite as the unified entry point.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs
@DataWarehouse.SDK/VirtualDiskEngine/ModuleManagement/Tier2FallbackGuard.cs
@.planning/phases/80-three-tier-performance-verification/80-01-SUMMARY.md
@.planning/phases/80-three-tier-performance-verification/80-02-SUMMARY.md
@.planning/phases/80-three-tier-performance-verification/80-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TierFeatureMap with per-module tier assignments</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Verification/TierFeatureMap.cs
  </files>
  <action>
Create a sealed class TierFeatureMap with:

1. **FeatureTierAssignment** record (nested or separate):
   - `ModuleId Module`
   - `string FeatureName`
   - `TierLevel DefaultTier` -- enum: Tier1_VdeIntegrated, Tier2_PipelineOptimized, Tier3_BasicFallback
   - `string DefaultTierRationale` -- why this is the default
   - `string PromotionTrigger` -- what causes upgrade to higher tier
   - `string DemotionTrigger` -- what causes downgrade to lower tier
   - `TierLevel HighestAvailableTier` -- best tier available for this module
   - `TierLevel LowestAvailableTier` -- worst case fallback tier

2. **TierLevel** enum: Tier1_VdeIntegrated = 1, Tier2_PipelineOptimized = 2, Tier3_BasicFallback = 3 (lower number = better performance)

3. **Static mapping** via FrozenDictionary<ModuleId, FeatureTierAssignment> covering all 19 modules:
   - Modules WITH regions (17): Default=Tier1, Highest=Tier1, Lowest=Tier3
     - PromotionTrigger: "VDE module bit set in manifest + region populated"
     - DemotionTrigger: "VDE module removed -> Tier 2; plugin unloaded -> Tier 3"
   - Sustainability (no region, has inode): Default=Tier2, Highest=Tier2 (no dedicated region means Tier 1 is inode-only, not a full region), Lowest=Tier3
     - PromotionTrigger: "UltimateSustainability plugin loaded with metrics pipeline"
     - DemotionTrigger: "Plugin unloaded -> Tier 3 (no metrics collection)"
   - Transit (no region, has inode): Default=Tier2, Highest=Tier2, Lowest=Tier3
     - PromotionTrigger: "UltimateDataTransit plugin loaded with transit optimization"
     - DemotionTrigger: "Plugin unloaded -> Tier 3 (direct transfer only)"

4. **GetFeatureMap()** returns IReadOnlyList<FeatureTierAssignment> (all 19)
5. **GetAssignment(ModuleId)** returns single module's assignment
6. **GetModulesAtTier(TierLevel)** returns modules currently defaulting to that tier

Mark with `[SdkCompatibility("6.0.0", Notes = "Phase 80: Per-feature tier mapping (TIER-04)")]`
  </action>
  <verify>
    `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles. Grep for all 19 ModuleId names in TierFeatureMap.cs confirms full coverage.
  </verify>
  <done>
    TierFeatureMap has 19 FeatureTierAssignment entries. Each entry specifies DefaultTier, promotion/demotion triggers, highest/lowest available tiers. TIER-04 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TierPerformanceBenchmark and ThreeTierVerificationSuite</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Verification/TierPerformanceBenchmark.cs
    DataWarehouse.SDK/VirtualDiskEngine/Verification/ThreeTierVerificationSuite.cs
  </files>
  <action>
1. **TierPerformanceBenchmark.cs**: Create a sealed class with:
   - **BenchmarkResult** record: ModuleId, string FeatureName, long Tier1NanosPerOp, long Tier2NanosPerOp, long Tier3NanosPerOp, double Tier1vsTier2Ratio, double Tier1vsTier3Ratio, string Analysis
   - **RunBenchmarks()** returns IReadOnlyList<BenchmarkResult> for 5+ representative features:
     a. **Security (PolicyVault)**: Tier 1 = direct region read via PolicyVaultRegion binary deserialization; Tier 2 = plugin-mediated policy lookup (simulated extra indirection + serialization overhead); Tier 3 = in-memory dictionary lookup (fastest for reads but no persistence). Benchmark: create PolicyDefinition, measure serialize+deserialize time (Tier 1), add dictionary lookup + JSON overhead (Tier 2 simulation), plain ConcurrentDictionary get (Tier 3).
     b. **Integrity (MerkleTree)**: Tier 1 = direct IntegrityTreeRegion hash verification; Tier 2 = plugin-computed hash tree; Tier 3 = no verification (instant but unsafe). Benchmark: build small tree, verify proof path.
     c. **Compression (Dictionary)**: Tier 1 = CompressionDictionaryRegion direct lookup; Tier 2 = plugin-managed dictionary with extra lookup layer; Tier 3 = no compression (raw copy). Benchmark: dictionary entry add+lookup.
     d. **Query (BTreeIndex)**: Tier 1 = BTreeIndexForest region-integrated search; Tier 2 = plugin-managed B-tree with serialization overhead; Tier 3 = linear scan. Benchmark: insert N entries, search by key.
     e. **Snapshot (SnapshotTable)**: Tier 1 = SnapshotTableRegion direct entry creation; Tier 2 = plugin snapshot management; Tier 3 = in-memory snapshot metadata. Benchmark: create+lookup snapshot entries.
   - Use `System.Diagnostics.Stopwatch` with warmup iterations (100) and measured iterations (1000). Calculate nanoseconds per operation.
   - Tier 1 simulation: use the actual region's Serialize/Deserialize (binary, zero-copy where possible)
   - Tier 2 simulation: add an indirection layer (extra method call + simulated plugin lookup overhead via dictionary indirection + extra byte[] allocation for serialization boundary)
   - Tier 3 simulation: use simplest possible operation (ConcurrentDictionary get, no serialization, or skip entirely for things like integrity check)
   - Calculate ratios: Tier1vsTier2Ratio = Tier2Nanos / Tier1Nanos (>1.0 means Tier 1 is faster), Tier1vsTier3Ratio similarly
   - Expected outcomes: Tier 1 should be fastest for structured data operations (binary region access), Tier 3 may be faster for pure reads (in-memory) but loses persistence/correctness guarantees
   - Mark with `[SdkCompatibility("6.0.0", Notes = "Phase 80: Tier performance benchmarks (TIER-05)")]`

2. **ThreeTierVerificationSuite.cs**: Create a sealed class that orchestrates everything:
   - **VerificationReport** record: IReadOnlyList<Tier1VerificationResult> Tier1Results, IReadOnlyList<Tier2VerificationResult> Tier2Results, IReadOnlyList<Tier3VerificationResult> Tier3Results, IReadOnlyList<FeatureTierAssignment> TierMap, IReadOnlyList<BenchmarkResult> Benchmarks, bool AllTier1Passed, bool AllTier2Passed, bool AllTier3Passed, int TotalModules (19), string Summary
   - **RunFullVerification()** returns VerificationReport:
     a. Call Tier1ModuleVerifier.VerifyAllModules()
     b. Call Tier2PipelineVerifier.VerifyAllModules()
     c. Call Tier3BasicFallbackVerifier.VerifyAllModules()
     d. Call TierFeatureMap.GetFeatureMap()
     e. Call TierPerformanceBenchmark.RunBenchmarks()
     f. Compute AllTier1Passed/AllTier2Passed/AllTier3Passed
     g. Generate Summary string: "{N}/19 Tier 1 passed, {N}/19 Tier 2 passed, {N}/19 Tier 3 passed, {N} benchmarks completed"
   - Mark with `[SdkCompatibility("6.0.0", Notes = "Phase 80: Three-tier verification suite (TIER-01..TIER-05)")]`
  </action>
  <verify>
    `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles without errors. Grep for "RunBenchmarks" and "RunFullVerification" confirms both entry points exist. Grep for "Security|Integrity|Compression|Query|Snapshot" in TierPerformanceBenchmark.cs confirms 5 features benchmarked.
  </verify>
  <done>
    TierPerformanceBenchmark.RunBenchmarks() produces BenchmarkResults for 5 representative features with Tier 1/2/3 nanosecond-per-operation measurements and ratio analysis. ThreeTierVerificationSuite.RunFullVerification() orchestrates all verifiers and produces a consolidated VerificationReport. TIER-04 and TIER-05 satisfied.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds
- TierFeatureMap covers all 19 modules with tier assignments
- TierPerformanceBenchmark benchmarks 5+ features across all 3 tiers
- ThreeTierVerificationSuite orchestrates all verification classes
- All TIER-01 through TIER-05 requirements addressed
</verification>

<success_criteria>
- 19-module tier mapping with default/promotion/demotion documented in code
- 5+ feature benchmarks with nanosecond-per-op measurements and tier ratios
- Unified verification suite produces consolidated report
- All 5 TIER requirements (TIER-01 through TIER-05) covered across phases 80-01 through 80-04
</success_criteria>

<output>
After completion, create `.planning/phases/80-three-tier-performance-verification/80-04-SUMMARY.md`
</output>
