---
phase: 83-integration-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.Tests/Policy/PolicyEngineContractTests.cs
  - DataWarehouse.Tests/Policy/PolicyPersistenceTests.cs
  - DataWarehouse.Tests/Policy/PolicyCascadeEdgeCaseTests.cs
autonomous: true

must_haves:
  truths:
    - "PolicyResolutionEngine resolves correct effective policy at every PolicyLevel for Override, Inherit, Enforce, Merge, MostRestrictive cascade strategies"
    - "PolicyStore CRUD operations (SetAsync, GetAsync, HasOverrideAsync, RemoveAsync) work correctly for all 5 levels and round-trip policy data"
    - "All persistence backends (InMemory, File, Database, TamperProof, Hybrid) serialize and deserialize FeaturePolicy with identical results"
    - "VersionedPolicyCache invalidates on version change and serves cached results for same version"
    - "CircularReferenceDetector catches inherit loops and MergeConflictResolver resolves per-key conflicts"
    - "PolicyCategoryDefaults supplies correct fallback when no explicit policy exists"
    - "CascadeOverrideStore composite keys round-trip correctly"
    - "PolicyComplianceScorer produces correct GDPR/HIPAA/SOC2/FedRAMP scores"
  artifacts:
    - path: "DataWarehouse.Tests/Policy/PolicyEngineContractTests.cs"
      provides: "IPolicyEngine contract coverage: ResolveAsync, ResolveAllAsync, SimulateAsync, GetActiveProfileAsync, SetActiveProfileAsync"
      min_lines: 400
    - path: "DataWarehouse.Tests/Policy/PolicyPersistenceTests.cs"
      provides: "All IPolicyPersistence implementations: InMemory, File, Database, TamperProof, Hybrid; serialization round-trip"
      min_lines: 400
    - path: "DataWarehouse.Tests/Policy/PolicyCascadeEdgeCaseTests.cs"
      provides: "Edge cases: circular references, empty levels, category defaults, override store, compliance scoring, marketplace templates"
      min_lines: 400
  key_links:
    - from: "DataWarehouse.Tests/Policy/PolicyEngineContractTests.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs"
      via: "direct instantiation with InMemoryPolicyStore"
      pattern: "PolicyResolutionEngine"
    - from: "DataWarehouse.Tests/Policy/PolicyPersistenceTests.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/*PolicyPersistence.cs"
      via: "IPolicyPersistence SaveAsync/LoadAsync round-trip"
      pattern: "SaveAsync.*LoadAsync"
---

<objective>
PolicyEngine and cascade unit tests (~200 tests)

Purpose: Verify the complete PolicyEngine contract, all cascade strategy behaviors, all persistence backends, and supporting infrastructure (cache, compliance scorer, marketplace templates, circular reference detection). This is INTG-01 coverage.

Output: Three test files covering engine contracts, persistence backends, and cascade edge cases. Combined with existing 63 cascade tests, total reaches 200+.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.Tests/Policy/CascadeResolutionTests.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
@DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyStore.cs
@DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyPersistence.cs
@DataWarehouse.SDK/Infrastructure/Policy/VersionedPolicyCache.cs
@DataWarehouse.SDK/Infrastructure/Policy/CascadeStrategies.cs
@DataWarehouse.SDK/Infrastructure/Policy/CircularReferenceDetector.cs
@DataWarehouse.SDK/Infrastructure/Policy/MergeConflictResolver.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyCategoryDefaults.cs
@DataWarehouse.SDK/Infrastructure/Policy/CascadeOverrideStore.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyComplianceScorer.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyMarketplace.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceComplianceValidator.cs
@DataWarehouse.SDK/Infrastructure/Policy/FilePolicyPersistence.cs
@DataWarehouse.SDK/Infrastructure/Policy/DatabasePolicyPersistence.cs
@DataWarehouse.SDK/Infrastructure/Policy/TamperProofPolicyPersistence.cs
@DataWarehouse.SDK/Infrastructure/Policy/HybridPolicyPersistence.cs
@DataWarehouse.SDK/Infrastructure/Policy/EffectivePolicy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PolicyEngine contract tests + persistence round-trip tests</name>
  <files>
    DataWarehouse.Tests/Policy/PolicyEngineContractTests.cs
    DataWarehouse.Tests/Policy/PolicyPersistenceTests.cs
  </files>
  <action>
Create PolicyEngineContractTests.cs (~70 tests) covering the full IPolicyEngine contract via PolicyResolutionEngine:

1. **ResolveAsync contract** (~25 tests):
   - Resolve at each PolicyLevel (VDE, Container, Object, Chunk, Block) returns correct level
   - Each CascadeStrategy (Override, Inherit, Enforce, Merge, MostRestrictive) resolves correctly for 2+ levels in chain
   - Resolve with no store entries returns profile default
   - Resolve with null/empty featureId throws ArgumentException
   - Resolve across all 6 OperationalProfilePresets (Speed/Balanced/Standard/Strict/Paranoid/Custom) produces different intensity baselines
   - Override at Block level overrides VDE-level policy
   - Enforce at VDE level cannot be overridden by Block-level Override
   - Inherit copies parent unchanged when child has no explicit policy
   - Merge combines custom parameters from parent and child
   - MostRestrictive picks lowest intensity across chain

2. **ResolveAllAsync** (~10 tests):
   - Returns policies for all registered features
   - Each returned policy matches individual ResolveAsync result
   - Empty store returns profile defaults for all features
   - Multiple features with different cascade strategies resolved independently

3. **SimulateAsync** (~10 tests):
   - Simulation does not persist the hypothetical policy
   - Simulated policy correctly shadows existing policy at same level
   - Simulation with Enforce at parent still blocks Override at child
   - Simulation returns IEffectivePolicy with correct resolved values

4. **Profile management** (~10 tests):
   - SetActiveProfileAsync changes subsequent resolution baseline
   - GetActiveProfileAsync returns what was set
   - Each preset (Speed through Paranoid) has different default feature policies
   - Custom profile with explicit feature policies used as baseline

5. **OperationalProfile as baseline** (~15 tests):
   - Speed profile produces high intensity, high AI autonomy defaults
   - Paranoid profile produces max security, ManualOnly AI defaults
   - Per-feature overrides in store take precedence over profile defaults
   - Profile switch mid-session changes resolution results immediately

Follow existing test pattern from CascadeResolutionTests.cs: use InMemoryPolicyStore + InMemoryPolicyPersistence, MakePolicy helper, [Trait("Category", "Unit")].

Create PolicyPersistenceTests.cs (~60 tests) covering all IPolicyPersistence implementations:

1. **InMemoryPolicyPersistence** (~10 tests):
   - SaveAsync stores, LoadAsync retrieves identical FeaturePolicy list
   - SaveAsync overwrites previous data
   - LoadAsync with no prior save returns empty
   - Multiple feature policies round-trip

2. **FilePolicyPersistence** (~12 tests):
   - SaveAsync creates file, LoadAsync reads it back identically
   - SHA-256 truncated filenames consistent
   - Atomic write (temp-rename) survives simulated crash (write partial then load)
   - Resilient per-file load: corrupt one file, others still load
   - Use temp directory via Path.GetTempPath() for file I/O

3. **DatabasePolicyPersistence** (~10 tests):
   - Uses nested IDbPolicyStore (ConcurrentDictionary-based in-memory impl)
   - CRUD round-trip for composite keys (featureId:level:path)
   - LWW timestamp ordering: newer write wins

4. **TamperProofPolicyPersistence** (~10 tests):
   - Wraps inner IPolicyPersistence (use InMemory)
   - SaveAsync stores via inner, LoadAsync retrieves identically
   - Decorator does not double-serialize

5. **HybridPolicyPersistence** (~10 tests):
   - Composes two IPolicyPersistence instances
   - Both-must-succeed semantics: if one fails, operation fails
   - Data retrievable from either backend

6. **PolicySerializationHelper** (~8 tests):
   - System.Text.Json round-trip with camelCase and JsonStringEnumConverter
   - All enum values (CascadeStrategy, AiAutonomyLevel, PolicyLevel) survive serialization
   - CustomParameters dictionary round-trips
   - Null/empty custom parameters handled
  </action>
  <verify>
    Run `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~PolicyEngineContract|FullyQualifiedName~PolicyPersistence" --no-build` after building. All tests pass. Count: 130+ tests.
  </verify>
  <done>
    PolicyEngineContractTests.cs has 70+ [Fact]/[Theory] tests covering ResolveAsync, ResolveAllAsync, SimulateAsync, profile management. PolicyPersistenceTests.cs has 60+ tests covering InMemory, File, Database, TamperProof, Hybrid persistence and serialization round-trips. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: PolicyEngine cascade edge cases, compliance, and marketplace tests</name>
  <files>
    DataWarehouse.Tests/Policy/PolicyCascadeEdgeCaseTests.cs
  </files>
  <action>
Create PolicyCascadeEdgeCaseTests.cs (~70 tests) covering edge cases and supporting infrastructure:

1. **CircularReferenceDetector** (~8 tests):
   - Detects redirect loop (A->B->C->A) within 20 hops
   - Detects inherit_from cycle
   - No false positive on deep but non-circular chain (20 levels)
   - Empty chain returns no circular reference

2. **MergeConflictResolver** (~10 tests):
   - Per-tag-key MostRestrictive resolution picks lower intensity
   - Closest resolution picks nearest level's value
   - Union resolution combines all unique keys
   - Default strategy is Closest
   - Multiple conflicting keys resolved independently

3. **VersionedPolicyCache** (~8 tests):
   - Cache hit returns same IEffectivePolicy without store access
   - Version change (Interlocked.Exchange) invalidates cache
   - Double-buffered ImmutableDictionary swap is thread-safe (parallel reads during write)
   - Cache miss triggers store access and populates cache

4. **CascadeOverrideStore** (~8 tests):
   - Composite key featureId:level round-trips
   - __cascade_override__ persistence convention stored correctly
   - Override takes precedence in resolution order: Enforce > override > explicit > category default
   - Remove override restores original resolution

5. **PolicyCategoryDefaults** (~8 tests):
   - Unknown feature gets sensible default (intensity 50, SuggestExplain, Inherit, VDE)
   - Category default used when no explicit policy at any level
   - Category default cascade strategy applied correctly

6. **PolicyComplianceScorer** (~10 tests):
   - GDPR scoring: retention_policy and export_format key-existence checks (empty-string value)
   - HIPAA scoring with required encryption parameters
   - SOC2 scoring with audit requirements
   - FedRAMP scoring with FIPS requirements
   - Weighted scoring: sum(passed.Weight)/sum(all.Weight)*100
   - Grade thresholds: A=90+, B=80+, C=70+, D=60+, F<60

7. **PolicyPersistenceComplianceValidator** (~8 tests):
   - 6 rules checked across HIPAA/SOC2/GDPR/FedRAMP
   - Actionable remediation messages produced for failures
   - All rules pass for correctly configured persistence

8. **PolicyMarketplace** (~10 tests):
   - Built-in HIPAA/GDPR/HighPerformance templates load correctly
   - Template import with SHA-256 checksum verification
   - Template export produces valid checksum
   - Deterministic GUIDs for built-in templates
   - Version serialized as string via custom converter
  </action>
  <verify>
    Run `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~PolicyCascadeEdgeCase" --no-build` after building. All tests pass. Count: 70+ tests.
  </verify>
  <done>
    PolicyCascadeEdgeCaseTests.cs has 70+ tests covering CircularReferenceDetector, MergeConflictResolver, VersionedPolicyCache, CascadeOverrideStore, PolicyCategoryDefaults, PolicyComplianceScorer, PolicyPersistenceComplianceValidator, and PolicyMarketplace. Combined with existing 63 cascade tests and 130 from Task 1, total PolicyEngine tests exceed 200. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.Tests/DataWarehouse.Tests.csproj` completes with 0 errors
2. `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~Policy" --no-build` â€” all tests pass
3. Total Policy test count (existing 63 + new ~200) exceeds success criterion of 200+
</verification>

<success_criteria>
- 200+ total PolicyEngine tests (63 existing + ~200 new) covering all contracts, cascade strategies, edge cases, and persistence backends
- Zero test failures
- All 5 CascadeStrategy values tested in resolution scenarios
- All 5 PolicyLevel values tested
- All 6 OperationalProfilePreset values tested
- All persistence backends verified for round-trip fidelity
</success_criteria>

<output>
After completion, create `.planning/phases/83-integration-testing/83-01-SUMMARY.md`
</output>
