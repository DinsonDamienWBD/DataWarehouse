---
phase: 83-integration-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.Tests/Policy/PerFeatureMultiLevelTests.cs
  - DataWarehouse.Tests/Policy/FeaturePolicyMatrixTests.cs
autonomous: true

must_haves:
  truths:
    - "Every feature category (security, performance, storage, AI, compliance, privacy, observability) has tests confirming correct effective policy at VDE, Container, Object, Chunk, and Block levels"
    - "Override at lower level correctly overrides inherited VDE policy for each feature"
    - "Enforce at VDE level prevents override at all lower levels for each feature"
    - "MostRestrictive cascade picks tightest policy across the chain for each feature"
    - "94 features classified correctly into Critical/PerOperation/Periodic/Background check frequency tiers"
  artifacts:
    - path: "DataWarehouse.Tests/Policy/PerFeatureMultiLevelTests.cs"
      provides: "Per-feature tests across all 5 policy levels for all feature categories"
      min_lines: 600
    - path: "DataWarehouse.Tests/Policy/FeaturePolicyMatrixTests.cs"
      provides: "Feature classification, fast-path tier, bloom filter integration tests"
      min_lines: 400
  key_links:
    - from: "DataWarehouse.Tests/Policy/PerFeatureMultiLevelTests.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs"
      via: "ResolveAsync per feature per level"
      pattern: "ResolveAsync.*featureId"
    - from: "DataWarehouse.Tests/Policy/FeaturePolicyMatrixTests.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs"
      via: "94-feature FrozenDictionary classification"
      pattern: "CheckClassification|CheckFrequency"
---

<objective>
Per-feature multi-level tests (~280 tests)

Purpose: Verify that each of the feature categories resolves correct effective policy at every PolicyLevel, and that the 94-feature classification table correctly maps features to check frequency tiers. This is INTG-02 coverage.

Output: Two test files covering per-feature multi-level resolution and feature classification matrix.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.Tests/Policy/CascadeResolutionTests.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
@DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyStore.cs
@DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyPersistence.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySkipOptimizer.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-feature multi-level resolution tests</name>
  <files>
    DataWarehouse.Tests/Policy/PerFeatureMultiLevelTests.cs
  </files>
  <action>
Create PerFeatureMultiLevelTests.cs (~200 tests) using [Theory] with [InlineData] to systematically test feature categories across all 5 levels.

Follow existing CascadeResolutionTests.cs pattern: InMemoryPolicyStore + PolicyResolutionEngine.

**Feature categories to test (group by domain, use representative feature IDs from CheckClassification's 94-feature table):**

1. **Security features** (~40 tests): encryption, access_control, auth_model, key_management, fips_mode
   - For each: set VDE-level policy, resolve at all 5 levels with Override cascade → Block override wins
   - For each: set VDE-level Enforce, attempt Block-level Override → VDE Enforce wins
   - For each: set VDE + Container with MostRestrictive → tightest wins
   - For each: set VDE with Inherit, no child explicit → child inherits VDE

2. **Performance features** (~30 tests): compression, caching, prefetch, deduplication, tiering
   - Same 4-pattern matrix (Override/Enforce/MostRestrictive/Inherit) per feature
   - Verify Speed profile produces high-intensity defaults for perf features
   - Verify Paranoid profile reduces perf features for security

3. **Storage features** (~30 tests): block_size, thin_provisioning, raid_level, replication_factor, snapshot_policy
   - 4-pattern matrix per feature
   - Storage features with Merge cascade: parent block_size + child thin_provisioning merged

4. **AI features** (~25 tests): ai_autonomy, recommendation_engine, anomaly_detection, cost_optimization, workload_prediction
   - 4-pattern matrix per feature
   - ManualOnly AI autonomy at VDE level enforced down to Block
   - AutoSilent only available in Speed profile

5. **Compliance features** (~25 tests): data_residency, retention_policy, audit_logging, gdpr_compliance, hipaa_compliance
   - 4-pattern matrix per feature
   - Compliance features default to MostRestrictive cascade (verify)
   - Strict/Paranoid profiles enforce compliance features

6. **Privacy features** (~20 tests): anonymization, pseudonymization, consent_management, data_masking, pii_detection
   - 4-pattern matrix per feature

7. **Observability features** (~15 tests): metrics_collection, trace_sampling, log_level, health_checks, alerting
   - 4-pattern matrix per feature

8. **Cross-level consistency** (~15 tests):
   - Set policies at all 5 levels simultaneously, verify resolution walks chain correctly
   - Resolve same feature at different paths, verify location-based resolution
   - [Theory] with all 5 CascadeStrategy values x 3 representative features = 15 combinations

Use [Theory] + [InlineData("encryption")] / [InlineData("compression")] etc. to parameterize feature IDs and reduce code duplication. Each [Theory] with N [InlineData] counts as N tests.
  </action>
  <verify>
    Run `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~PerFeatureMultiLevel" --no-build` after building. All tests pass.
  </verify>
  <done>
    PerFeatureMultiLevelTests.cs has 200+ parameterized tests covering all 7 feature categories across all 5 PolicyLevel values with all cascade strategies. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Feature classification matrix and fast-path tests</name>
  <files>
    DataWarehouse.Tests/Policy/FeaturePolicyMatrixTests.cs
  </files>
  <action>
Create FeaturePolicyMatrixTests.cs (~80 tests) covering the 94-feature classification table and performance fast-path:

1. **CheckClassification coverage** (~30 tests):
   - Verify all 94 features are present in the FrozenDictionary (iterate ModuleId enum, known feature lists)
   - Security features (encryption, access_control, auth_model, key_management, fips_mode) classified as Critical
   - Performance features classified as PerOperation or Periodic
   - Observability features classified as Background or Periodic
   - Unknown feature defaults to PerOperation (verify fallback)
   - [Theory] with all 94 feature IDs: each returns a valid CheckFrequency enum value

2. **BloomFilterSkipIndex** (~15 tests):
   - Add feature+level to bloom filter, query returns true (no false negatives guaranteed)
   - Query absent feature returns false (statistically, may have false positives — test with enough entries)
   - XxHash64 double-hashing produces consistent results
   - Thread-safe: Interlocked.Or bit-set from parallel threads
   - Rebuild after Remove (bloom filter NOT updated on remove)

3. **PolicySkipOptimizer** (~15 tests):
   - Skip optimization for features with no overrides at target level
   - No skip when HasOverrideAsync returns true
   - Companion to PolicyStore (not IPolicyStore impl itself)
   - Bloom filter integration: bloom says no → skip store lookup entirely

4. **FastPathPolicyEngine** (~10 tests):
   - Critical features always go through full resolution (no skip)
   - Background features use cached/materialized result when available
   - PerOperation features check bloom filter before store
   - Fast-path produces same result as full PolicyResolutionEngine for all cases

5. **Cross-feature independence** (~10 tests):
   - Setting policy for "encryption" does not affect "compression" resolution
   - Setting policy for "ai_autonomy" does not affect "access_control"
   - Bulk ResolveAllAsync returns independent results per feature
   - Different cascade strategies on different features in same resolution context
  </action>
  <verify>
    Run `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~FeaturePolicyMatrix" --no-build` after building. All tests pass.
  </verify>
  <done>
    FeaturePolicyMatrixTests.cs has 80+ tests covering the 94-feature classification table, bloom filter skip index, policy skip optimizer, fast-path engine, and cross-feature independence. Combined with Task 1's 200 tests, total per-feature tests exceed 280. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.Tests/DataWarehouse.Tests.csproj` completes with 0 errors
2. `dotnet test DataWarehouse.Tests/DataWarehouse.Tests.csproj --filter "FullyQualifiedName~PerFeatureMultiLevel|FullyQualifiedName~FeaturePolicyMatrix" --no-build` — all tests pass
3. Total per-feature test count exceeds 280
</verification>

<success_criteria>
- 280+ per-feature multi-level tests covering all 7 feature categories
- All 94 features verified in classification table
- All 5 PolicyLevel values tested per feature category
- All 5 CascadeStrategy values tested for representative features
- Fast-path engine produces identical results to full engine
- Zero test failures
</success_criteria>

<output>
After completion, create `.planning/phases/83-integration-testing/83-02-SUMMARY.md`
</output>
