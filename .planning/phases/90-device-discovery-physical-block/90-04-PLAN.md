---
phase: 90-device-discovery-physical-block
plan: 04
type: execute
wave: 2
depends_on: ["90-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DeviceTopologyMapper.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/NumaAwareIoScheduler.cs
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceTopology.cs
autonomous: true

must_haves:
  truths:
    - "DeviceTopologyMapper builds controller->bus->device tree from discovered devices"
    - "NumaAwareIoScheduler routes I/O to the CPU closest to the target device's NUMA node"
    - "NVMe namespace awareness: multiple namespaces on same controller are grouped correctly"
    - "Topology is queryable: find all devices on a controller, find NUMA node for a device, find sibling devices"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceTopology.cs"
      provides: "Topology tree node types"
      contains: "record TopologyNode"
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DeviceTopologyMapper.cs"
      provides: "Builds and queries the device topology tree"
      contains: "BuildTopologyAsync"
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/NumaAwareIoScheduler.cs"
      provides: "NUMA-aware I/O routing"
      contains: "ScheduleIoAsync"
  key_links:
    - from: "DeviceTopologyMapper"
      to: "PhysicalDeviceInfo"
      via: "uses ControllerPath and NumaNode from device info"
      pattern: "PhysicalDeviceInfo"
    - from: "NumaAwareIoScheduler"
      to: "DeviceTopologyMapper"
      via: "queries topology for NUMA affinity"
      pattern: "DeviceTopologyMapper"
---

<objective>
Build a device topology tree (controller -> bus -> device) from discovered physical devices, and implement NUMA-aware I/O scheduling that routes operations to the CPU closest to the target device.

Purpose: Topology awareness enables optimal I/O scheduling (avoid cross-NUMA traffic), failure domain isolation (controller failure affects known set of devices), and NVMe namespace grouping.
Output: SDK topology types plus mapper and NUMA-aware scheduler in UltimateFilesystem plugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md (Phase 90, success criteria 6: topology map, controller->bus->device, NUMA-aware I/O)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs (from 90-01)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/PhysicalDeviceInfo.cs (ControllerPath, NumaNode, NvmeNamespaceId from 90-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DeviceTopology SDK types</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceTopology.cs
  </files>
  <action>
Create in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Device topology tree types (BMDV-08)")]`
- `enum TopologyNodeType { Root, Controller, Bus, NvmeSubsystem, Device, NvmeNamespace }`
- `record TopologyNode` with:
  - `string NodeId` (unique within tree: "root", "ctrl:0000:00:1f.2", "bus:nvme", "dev:nvme0n1")
  - `TopologyNodeType NodeType`
  - `string DisplayName` (human-readable: "Intel NVMe Controller", "SATA Bus 0", "Samsung 990 Pro 1TB")
  - `int? NumaNode` (inherited from controller if device doesn't specify)
  - `IReadOnlyList<TopologyNode> Children` (empty list for leaf nodes)
  - `IReadOnlyDictionary<string, string> Properties` (extensible: PCIe address, bus number, slot, etc.)
- `record DeviceTopologyTree` with:
  - `TopologyNode Root` (the root node containing all controllers)
  - `int ControllerCount`
  - `int DeviceCount`
  - `int NumaNodeCount` (distinct NUMA nodes across all devices)
  - `DateTime BuiltUtc`
- `record NumaAffinityInfo` with: `int NumaNode`, `IReadOnlyList<string> DeviceIds` (devices on this NUMA node), `IReadOnlyList<int> CpuCores` (cores on this NUMA node, best-effort)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` and confirm zero errors.
  </verify>
  <done>
TopologyNode, DeviceTopologyTree, and NumaAffinityInfo types exist in SDK with correct hierarchy.
  </done>
</task>

<task type="auto">
  <name>Task 2: DeviceTopologyMapper and NumaAwareIoScheduler</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DeviceTopologyMapper.cs
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/NumaAwareIoScheduler.cs
  </files>
  <action>
**DeviceTopologyMapper.cs** - Sealed class, namespace DataWarehouse.Plugins.UltimateFilesystem.DeviceManagement:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Device topology mapping (BMDV-08)")]`
- `DeviceTopologyTree BuildTopology(IReadOnlyList<PhysicalDeviceInfo> devices)`:
  - Create Root TopologyNode
  - Group devices by ControllerPath (from PhysicalDeviceInfo.ControllerPath). Null controller = "unknown-controller"
  - For each controller group: create Controller TopologyNode with PCIe address in Properties
  - Within each controller, group by BusType: create Bus TopologyNode children
  - Within each bus, add Device TopologyNode for each device
  - Special NVMe handling: if multiple devices share same controller path but different NvmeNamespaceId, create NvmeSubsystem node under the controller, then NvmeNamespace nodes under that (one per namespace)
  - Inherit NumaNode: controller gets NUMA node from first device that reports it; devices without explicit NUMA inherit from controller
  - Set ControllerCount, DeviceCount, NumaNodeCount on the tree
- `IReadOnlyList<TopologyNode> GetDevicesByController(DeviceTopologyTree tree, string controllerNodeId)` -- find all device leaf nodes under a controller
- `TopologyNode? FindDeviceNode(DeviceTopologyTree tree, string deviceId)` -- DFS search for device node
- `IReadOnlyList<string> GetSiblingDevices(DeviceTopologyTree tree, string deviceId)` -- devices sharing same parent (controller or bus)
- `IReadOnlyList<NumaAffinityInfo> GetNumaAffinity(DeviceTopologyTree tree)`:
  - Group all device nodes by their NumaNode
  - For each NUMA node on Linux: try reading /sys/devices/system/node/node{N}/cpulist to get CPU cores
  - On Windows: try using GetLogicalProcessorInformationEx via P/Invoke (or return empty cores list)
  - Return NumaAffinityInfo per NUMA node

**NumaAwareIoScheduler.cs** - Sealed class, same namespace:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: NUMA-aware I/O scheduling (BMDV-09)")]`
- Constructor takes `DeviceTopologyTree topology`, `IReadOnlyList<NumaAffinityInfo> numaInfo`
- `BoundedDictionary<string, int>(500)` mapping DeviceId -> preferred NUMA node
- `record IoSchedulingResult` with: `int TargetNumaNode`, `int? PreferredCpuCore`, `bool IsCrossNuma` (true if calling thread is on different NUMA node)
- `IoSchedulingResult GetSchedulingHint(string deviceId)`:
  - Look up device's NUMA node
  - Determine calling thread's current NUMA node (via Thread.GetCurrentProcessorId() -> map to NUMA, or GetCurrentProcessorNumberEx on Windows)
  - If same NUMA node: return with IsCrossNuma=false
  - If different: return with IsCrossNuma=true, suggest preferred CPU core on target NUMA node (round-robin from available cores)
- `Task<T> ScheduleIoAsync<T>(string deviceId, Func<CancellationToken, Task<T>> ioOperation, CancellationToken ct = default)`:
  - Get scheduling hint
  - If not cross-NUMA or platform doesn't support affinity: just await ioOperation(ct)
  - If cross-NUMA and supported: use Task.Factory.StartNew with TaskCreationOptions.LongRunning on a thread that is affinitized to the target NUMA node's preferred core (on Linux via sched_setaffinity concept; on all platforms via ProcessThread.ProcessorAffinity as best-effort)
  - This is best-effort optimization -- if affinity cannot be set, run on current thread
- `IReadOnlyDictionary<string, IoSchedulingResult> GetAllHints()` -- cached hints for all known devices
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` and confirm zero errors. Grep for "BuildTopology" and "ScheduleIoAsync" to confirm both classes exist.
  </verify>
  <done>
DeviceTopologyMapper builds controller->bus->device tree with NVMe namespace grouping. NumaAwareIoScheduler provides scheduling hints and best-effort NUMA-affinitized I/O execution.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for SDK and UltimateFilesystem
- TopologyNode hierarchy: Root -> Controller -> Bus -> Device (with NvmeSubsystem variant)
- BuildTopology groups devices by ControllerPath and BusType
- NumaAwareIoScheduler detects cross-NUMA I/O and provides affinity hints
- NVMe namespaces on same controller are grouped under NvmeSubsystem node
</verification>

<success_criteria>
Device topology tree is queryable for controller failure domains, sibling devices, and NUMA affinity. I/O scheduling hints enable downstream consumers (CompoundBlockDevice in Phase 91) to minimize cross-NUMA traffic.
</success_criteria>

<output>
After completion, create `.planning/phases/90-device-discovery-physical-block/90-04-SUMMARY.md`
</output>
