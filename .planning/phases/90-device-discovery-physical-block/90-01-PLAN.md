---
phase: 90-device-discovery-physical-block
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/PhysicalDeviceInfo.cs
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceDiscoveryService.cs
autonomous: true

must_haves:
  truths:
    - "IPhysicalBlockDevice extends IBlockDevice with TrimAsync, aligned I/O contract, and physical device identity"
    - "DeviceDiscoveryService enumerates NVMe, SCSI, SATA, virtio, iSCSI, NVMe-oF devices on Linux via /sys/block"
    - "DeviceDiscoveryService enumerates devices on Windows via WMI/SetupAPI P/Invoke"
    - "PhysicalDeviceInfo carries serial number, media type, capacity, bus type, firmware version, sector sizes"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs"
      provides: "IPhysicalBlockDevice interface extending IBlockDevice"
      contains: "TrimAsync"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/PhysicalDeviceInfo.cs"
      provides: "Device metadata record and enums (MediaType, BusType, DeviceTransport)"
      contains: "record PhysicalDeviceInfo"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceDiscoveryService.cs"
      provides: "Cross-platform device enumeration"
      contains: "DiscoverDevicesAsync"
  key_links:
    - from: "IPhysicalBlockDevice"
      to: "IBlockDevice"
      via: "interface inheritance"
      pattern: "IPhysicalBlockDevice.*:.*IBlockDevice"
    - from: "DeviceDiscoveryService"
      to: "PhysicalDeviceInfo"
      via: "returns discovered device info"
      pattern: "IReadOnlyList<PhysicalDeviceInfo>"
---

<objective>
Define the IPhysicalBlockDevice interface that extends IBlockDevice with physical-device-specific operations (TrimAsync, aligned scatter-gather I/O, device identity), create PhysicalDeviceInfo metadata records, and implement DeviceDiscoveryService for cross-platform device enumeration.

Purpose: This is the foundational contract for Phase 90. All subsequent plans depend on IPhysicalBlockDevice and DeviceDiscoveryService.
Output: Three SDK files establishing the physical block device abstraction and discovery layer.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md (Phase 90 section, lines 2151-2173)
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs (existing IBlockDevice: BlockSize, BlockCount, ReadBlockAsync, WriteBlockAsync, FlushAsync)
@DataWarehouse.SDK/Contracts/StrategyBase.cs (AD-05: strategies are workers)
@DataWarehouse.SDK/VirtualDiskEngine/Allocation/AllocationGroup.cs (Phase 87 allocation groups)
</context>

<tasks>

<task type="auto">
  <name>Task 1: IPhysicalBlockDevice interface and PhysicalDeviceInfo records</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/PhysicalDeviceInfo.cs
  </files>
  <action>
Create two files in a new PhysicalDevice/ directory under VirtualDiskEngine/.

**IPhysicalBlockDevice.cs** - Interface in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:
- Extends `IBlockDevice` (from DataWarehouse.SDK.VirtualDiskEngine)
- Add `[SdkCompatibility("6.0.0", Notes = "Phase 90: Physical block device abstraction (BMDV-01)")]`
- Properties: `PhysicalDeviceInfo DeviceInfo { get; }`, `bool IsOnline { get; }`, `long PhysicalSectorSize { get; }` (512 or 4096), `long LogicalSectorSize { get; }`
- Methods:
  - `Task TrimAsync(long blockNumber, int blockCount, CancellationToken ct = default)` -- TRIM/UNMAP for SSDs
  - `Task<int> ReadScatterAsync(IReadOnlyList<(long blockNumber, Memory<byte> buffer)> operations, CancellationToken ct = default)` -- scatter-gather aligned read, returns completed count
  - `Task<int> WriteGatherAsync(IReadOnlyList<(long blockNumber, ReadOnlyMemory<byte> data)> operations, CancellationToken ct = default)` -- gather write, returns completed count
  - `Task<PhysicalDeviceHealth> GetHealthAsync(CancellationToken ct = default)` -- SMART health snapshot
- All I/O methods document alignment requirement: blockNumber * BlockSize must be aligned to PhysicalSectorSize

**PhysicalDeviceInfo.cs** - Records and enums in same namespace:
- `enum MediaType { NVMe, SSD, HDD, Tape, VirtIO, RAMDisk, Unknown }`
- `enum BusType { NVMe, SCSI, SATA, SAS, USB, VirtIO, iSCSI, NVMeOF, FibreChannel, Unknown }`
- `enum DeviceTransport { PCIe, SATA, SAS, USB, Network, Virtual, Unknown }`
- `record PhysicalDeviceInfo` with: `string DeviceId` (unique stable ID), `string DevicePath` (/dev/nvme0n1 or \\.\PhysicalDrive0), `string SerialNumber`, `string ModelNumber`, `string FirmwareVersion`, `MediaType MediaType`, `BusType BusType`, `DeviceTransport Transport`, `long CapacityBytes`, `int PhysicalSectorSize`, `int LogicalSectorSize`, `int OptimalIoSize` (for alignment), `bool SupportsTrim`, `bool SupportsVolatileWriteCache`, `int NvmeNamespaceId` (0 if not NVMe), `string? ControllerPath` (for topology), `int? NumaNode` (null if unknown)
- `record PhysicalDeviceHealth` with: `bool IsHealthy`, `double TemperatureCelsius`, `double WearLevelPercent` (0-100, SSD/NVMe only), `long TotalBytesWritten`, `long TotalBytesRead`, `long UncorrectableErrors`, `long ReallocatedSectors`, `int PowerOnHours`, `TimeSpan? EstimatedRemainingLife`, `IReadOnlyDictionary<string, string> RawSmartAttributes`
- All records have `[SdkCompatibility("6.0.0")]`
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` and confirm zero errors. Verify IPhysicalBlockDevice inherits IBlockDevice via grep.
  </verify>
  <done>
IPhysicalBlockDevice interface exists with TrimAsync + scatter-gather + GetHealthAsync. PhysicalDeviceInfo/PhysicalDeviceHealth records exist with all fields. SDK builds cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: DeviceDiscoveryService with Linux and Windows enumeration</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceDiscoveryService.cs
  </files>
  <action>
Create DeviceDiscoveryService as a sealed class in DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice namespace. Add `[SdkCompatibility("6.0.0", Notes = "Phase 90: Cross-platform device discovery (BMDV-01/BMDV-02)")]`.

**Public API:**
- `Task<IReadOnlyList<PhysicalDeviceInfo>> DiscoverDevicesAsync(DeviceDiscoveryOptions? options = null, CancellationToken ct = default)` -- main entry point, delegates to platform-specific implementation
- `Task<PhysicalDeviceInfo?> GetDeviceAsync(string devicePath, CancellationToken ct = default)` -- single device lookup
- `record DeviceDiscoveryOptions` with: `bool IncludeRemovable = false`, `bool IncludeVirtual = true`, `MediaType? FilterMediaType = null`, `BusType? FilterBusType = null`

**Linux implementation** (when RuntimeInformation.IsOSPlatform(OSPlatform.Linux)):
- Enumerate /sys/block/ directory entries, skip loop*, ram* devices
- For each block device, read from /sys/block/{dev}/:
  - `size` (blocks) * `queue/logical_block_size` = capacity
  - `device/model` = model number
  - `device/serial` (or via /dev/disk/by-id/) = serial number
  - `device/vendor` = vendor
  - `queue/physical_block_size` and `queue/logical_block_size` = sector sizes
  - `queue/optimal_io_size` = optimal I/O size
  - `queue/rotational` (0=SSD/NVMe, 1=HDD) = media type hint
  - `device/type` + path prefix (nvme=NVMe, sd=SCSI/SATA, vd=VirtIO) = bus type
  - `queue/discard_max_bytes` > 0 = supports TRIM
  - Parse /sys/devices/ symlink to find controller path and NUMA node from /sys/devices/.../numa_node
- For NVMe: read /sys/block/nvme*/device/firmware_rev, namespace from device name (nvme0n1 -> ns=1)
- For iSCSI: detect via /sys/class/iscsi_session/ presence
- For NVMe-oF: detect via /sys/class/nvme-fabrics/ or transport field in /sys/block/nvme*/device/transport

**Windows implementation** (when RuntimeInformation.IsOSPlatform(OSPlatform.Windows)):
- Use System.Management (WMI) to query Win32_DiskDrive:
  - DeviceID, SerialNumber, Model, FirmwareRevision, Size, BytesPerSector, MediaType, InterfaceType
- Map InterfaceType (IDE->SATA, SCSI->SAS/SCSI, USB->USB, 17->NVMe) to BusType
- Map MediaType string to MediaType enum
- Determine PhysicalSectorSize via Win32_PhysicalMedia or IOCTL_STORAGE_QUERY_PROPERTY (documented as alternative)
- Build DevicePath as \\.\PhysicalDriveN from DeviceID
- For SupportsTrim: check via IOCTL_STORAGE_QUERY_PROPERTY or assume true for SSD/NVMe

**Error handling:**
- Wrap all /sys/ reads in try-catch; skip devices that cannot be fully enumerated
- Wrap WMI queries in try-catch; return empty list if WMI is unavailable
- Log warnings for partial discovery (device found but some attributes unreadable)
- On unsupported platforms (macOS, etc.), return empty list with logged warning

All file reads use async I/O (File.ReadAllTextAsync). No blocking calls.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` and confirm zero errors. Verify the class contains both Linux (/sys/block) and Windows (WMI) code paths via grep for "OSPlatform.Linux" and "OSPlatform.Windows".
  </verify>
  <done>
DeviceDiscoveryService discovers devices on Linux via /sys/block and Windows via WMI. Returns PhysicalDeviceInfo list with serial, model, media type, bus type, sector sizes, TRIM support, NUMA node, and controller path for each device.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- IPhysicalBlockDevice extends IBlockDevice (verify with grep)
- DeviceDiscoveryService has platform-conditional code for Linux and Windows
- PhysicalDeviceInfo contains all required fields (DeviceId, SerialNumber, MediaType, BusType, CapacityBytes, etc.)
- PhysicalDeviceHealth contains SMART-related fields (TemperatureCelsius, WearLevelPercent, etc.)
</verification>

<success_criteria>
IPhysicalBlockDevice is the single contract for all physical device access. DeviceDiscoveryService enumerates real hardware on both Linux and Windows. PhysicalDeviceInfo carries all metadata needed by downstream plans (health monitoring, pool management, topology mapping).
</success_criteria>

<output>
After completion, create `.planning/phases/90-device-discovery-physical-block/90-01-SUMMARY.md`
</output>
