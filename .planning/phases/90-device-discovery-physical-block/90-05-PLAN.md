---
phase: 90-device-discovery-physical-block
plan: 05
type: execute
wave: 3
depends_on: ["90-02", "90-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/HotSwapManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/BaremetalBootstrap.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DeviceJournal.cs
autonomous: true

must_haves:
  truths:
    - "Hot-swap: adding a device to a pool is handled gracefully without data loss"
    - "Hot-swap: removing a device triggers automatic rebuild on remaining/spare devices"
    - "Bare-metal bootstrap: DW starts on raw devices without OS volume manager"
    - "Device journal tracks all device lifecycle events for crash recovery"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/HotSwapManager.cs"
      provides: "Graceful device add/remove with rebuild trigger"
      contains: "class HotSwapManager"
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/BaremetalBootstrap.cs"
      provides: "OS-free pool initialization from raw devices"
      contains: "BootstrapFromRawDevicesAsync"
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DeviceJournal.cs"
      provides: "Device lifecycle event journal for crash recovery"
      contains: "class DeviceJournal"
  key_links:
    - from: "HotSwapManager"
      to: "PhysicalDeviceManager"
      via: "subscribes to OnDeviceDiscovered/OnDeviceRemoved events"
      pattern: "OnDeviceDiscovered|OnDeviceRemoved"
    - from: "HotSwapManager"
      to: "DevicePoolManager"
      via: "calls AddDeviceToPoolAsync/RemoveDeviceFromPoolAsync"
      pattern: "DevicePoolManager"
    - from: "BaremetalBootstrap"
      to: "DevicePoolManager.ScanForPoolsAsync"
      via: "reconstructs pools from reserved sectors"
      pattern: "ScanForPoolsAsync"
    - from: "DeviceJournal"
      to: "IPhysicalBlockDevice"
      via: "writes journal entries to reserved device sectors"
      pattern: "IPhysicalBlockDevice"
---

<objective>
Implement hot-swap support for graceful device add/remove with automatic rebuild triggers, bare-metal bootstrap for starting DW on raw devices without any OS volume manager, and a device-level journal for crash recovery.

Purpose: Hot-swap enables zero-downtime hardware maintenance. Bare-metal bootstrap is the "no OS storage stack" requirement. The device journal ensures crash consistency for device lifecycle operations.
Output: Three files in UltimateFilesystem plugin handling dynamic device management and OS-free initialization.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md (Phase 90, success criteria 5 and 7: hot-swap, bare-metal bootstrap)
@.planning/phases/90-device-discovery-physical-block/90-02-SUMMARY.md (PhysicalDeviceManager with events)
@.planning/phases/90-device-discovery-physical-block/90-03-SUMMARY.md (DevicePoolManager with ScanForPoolsAsync)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs (from 90-01)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DevicePoolDescriptor.cs (from 90-03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DeviceJournal for crash-consistent lifecycle tracking</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DeviceJournal.cs
  </files>
  <action>
**DeviceJournal.cs** - Sealed class implementing IAsyncDisposable, namespace DataWarehouse.Plugins.UltimateFilesystem.DeviceManagement:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Device lifecycle journal (BMDV-10)")]`
- **Purpose**: Write-ahead journal for device lifecycle operations. Before any pool mutation (add device, remove device, create pool, delete pool), an intent record is journaled. After the mutation completes, a completion record is written. On crash recovery, incomplete intents are replayed or rolled back.
- **Journal storage**: Uses reserved sectors on pool member devices. Block 0 = pool metadata (from 90-03). Blocks 1-8 (32KB on 4K devices) = journal area.
- `enum JournalEntryType { PoolCreate, PoolDelete, DeviceAdd, DeviceRemove, RebuildStart, RebuildComplete, DeviceOnline, DeviceOffline }`
- `record JournalEntry` with: `long SequenceNumber`, `JournalEntryType Type`, `Guid PoolId`, `string? DeviceId`, `DateTime TimestampUtc`, `JournalEntryPhase Phase` (Intent/Committed/RolledBack), `byte[] Payload` (operation-specific data, e.g. serialized PoolMemberDescriptor for DeviceAdd)
- **Write path**:
  - `Task<long> WriteIntentAsync(JournalEntryType type, Guid poolId, string? deviceId, byte[]? payload, IPhysicalBlockDevice journalDevice, CancellationToken ct = default)` -- writes Intent entry, returns sequence number
  - `Task CommitAsync(long sequenceNumber, IPhysicalBlockDevice journalDevice, CancellationToken ct = default)` -- marks entry as Committed
  - `Task RollbackAsync(long sequenceNumber, IPhysicalBlockDevice journalDevice, CancellationToken ct = default)` -- marks entry as RolledBack
- **Read path**:
  - `Task<IReadOnlyList<JournalEntry>> ReadJournalAsync(IPhysicalBlockDevice journalDevice, CancellationToken ct = default)` -- reads all entries from journal area
  - `Task<IReadOnlyList<JournalEntry>> GetUncommittedIntentsAsync(IPhysicalBlockDevice journalDevice, CancellationToken ct = default)` -- entries with Phase=Intent (crash recovery candidates)
- **Journal format**: Each entry is fixed 256 bytes:
  - Bytes 0-7: SequenceNumber (int64 LE)
  - Bytes 8-8: EntryType (byte)
  - Bytes 9-9: Phase (byte)
  - Bytes 10-25: PoolId (Guid, 16 bytes)
  - Bytes 26-33: TimestampUtc ticks (int64 LE)
  - Bytes 34-35: DeviceId length (int16 LE, 0 if null)
  - Bytes 36-99: DeviceId (UTF-8, max 64 bytes)
  - Bytes 100-101: Payload length (int16 LE)
  - Bytes 102-249: Payload (max 148 bytes)
  - Bytes 250-253: CRC32 of bytes 0-249
  - Bytes 254-255: reserved (zero)
- Max 128 entries per journal area (128 * 256 = 32KB). Circular buffer: when full, oldest committed/rolled-back entries are overwritten.
- Thread-safe via SemaphoreSlim for write serialization
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` and confirm zero errors. Grep for "WriteIntentAsync" and "GetUncommittedIntentsAsync" to confirm journal API.
  </verify>
  <done>
DeviceJournal writes crash-consistent lifecycle events to reserved device sectors. Fixed 256-byte entries with CRC32 integrity. Supports intent/commit/rollback pattern for crash recovery.
  </done>
</task>

<task type="auto">
  <name>Task 2: HotSwapManager and BaremetalBootstrap</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/HotSwapManager.cs
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/BaremetalBootstrap.cs
  </files>
  <action>
**HotSwapManager.cs** - Sealed class implementing IAsyncDisposable, same namespace:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Hot-swap device management (BMDV-11)")]`
- **Dependencies** (constructor): `PhysicalDeviceManager deviceManager`, `DevicePoolManager poolManager`, `DeviceJournal journal`
- **Configuration**: `record HotSwapConfig` with: `bool AutoAddToDefaultPool = false`, `Guid? DefaultPoolId = null`, `bool AutoTriggerRebuild = true`, `int MaxConcurrentRebuilds = 2`
- **State**: `BoundedDictionary<string, RebuildState>(100)` tracking active rebuilds. `record RebuildState` with: `string DeviceId`, `Guid PoolId`, `DateTime StartedUtc`, `double ProgressPercent`, `RebuildPhase Phase` (Pending/Copying/Verifying/Complete/Failed)
- **Hot-add flow** (triggered by PhysicalDeviceManager.OnDeviceDiscovered callback):
  1. Check if device has existing pool metadata (read block 0 via PoolMetadataCodec) -- if so, it's a returning device, re-add to its pool
  2. If AutoAddToDefaultPool and DefaultPoolId set: journal DeviceAdd intent, add to pool, journal commit
  3. Otherwise: fire `OnNewDeviceAvailable` callback for external consumers to decide
- **Hot-remove flow** (triggered by PhysicalDeviceManager.OnDeviceRemoved callback):
  1. Find which pool the device belongs to (via reverse lookup)
  2. Journal DeviceRemove intent
  3. Mark device as Removed in pool (via DevicePoolManager.RemoveDeviceFromPoolAsync)
  4. Journal commit
  5. If AutoTriggerRebuild: fire `OnRebuildRequired` callback with pool ID and removed device ID
  6. Track rebuild state
- **Degradation flow** (triggered by PhysicalDeviceManager.OnStatusChange to Failing/Degraded):
  1. If device is in a pool and status is Failing: proactively trigger rebuild before complete failure
  2. Fire `OnDeviceDegraded` callback
- **Callbacks**:
  - `Action<PhysicalDeviceInfo>? OnNewDeviceAvailable`
  - `Action<Guid, string>? OnRebuildRequired` (poolId, removedDeviceId)
  - `Action<string, DeviceStatus>? OnDeviceDegraded`
  - `Action<string, RebuildState>? OnRebuildProgress`
- `Task StartAsync(CancellationToken ct = default)` -- subscribes to PhysicalDeviceManager events
- `Task StopAsync()` -- unsubscribes
- `Task<IReadOnlyList<RebuildState>> GetActiveRebuildsAsync()`

**BaremetalBootstrap.cs** - Sealed class, same namespace:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Bare-metal bootstrap (BMDV-12)")]`
- **Dependencies** (constructor): `DeviceDiscoveryService discoveryService`, `DevicePoolManager poolManager`, `DeviceJournal journal`, `PhysicalDeviceManager deviceManager`
- `record BootstrapResult` with: `bool Success`, `IReadOnlyList<DevicePoolDescriptor> RestoredPools`, `IReadOnlyList<PhysicalDeviceInfo> UnpooledDevices`, `IReadOnlyList<JournalEntry> RecoveredIntents`, `IReadOnlyList<string> Warnings`
- `Task<BootstrapResult> BootstrapFromRawDevicesAsync(CancellationToken ct = default)`:
  1. **Discover**: Call DeviceDiscoveryService.DiscoverDevicesAsync to find all physical devices
  2. **Register**: Register all discovered devices with PhysicalDeviceManager
  3. **Scan pools**: Call DevicePoolManager.ScanForPoolsAsync to read pool metadata from reserved sectors of each device
  4. **Recover journal**: For each pool's member devices, read journal via DeviceJournal.GetUncommittedIntentsAsync. For each uncommitted intent:
     - DeviceAdd with Intent phase: the add may have partially completed. Verify device is in pool metadata; if not, roll back the intent.
     - DeviceRemove with Intent phase: the remove didn't complete. Device is still in pool; re-mark as active.
     - RebuildStart with Intent phase: rebuild was interrupted. Queue for restart.
     - PoolCreate/PoolDelete with Intent phase: check if metadata was written; if partial, clean up.
  5. **Classify unpooled**: Devices without pool metadata -> add to UnpooledDevices list
  6. **Return**: BootstrapResult with restored pools, unpooled devices, recovered intents, warnings
- `Task<DevicePoolDescriptor> InitializeNewSystemAsync(string poolName, IReadOnlyList<IPhysicalBlockDevice> devices, StorageTier? tier = null, LocalityTag? locality = null, CancellationToken ct = default)`:
  - For first-time setup on raw devices: create initial pool, write metadata, initialize journal areas on each device
  - Journal PoolCreate intent, create pool via DevicePoolManager, journal commit
  - Return the new pool descriptor
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` and confirm zero errors. Grep for "BootstrapFromRawDevicesAsync" and "OnRebuildRequired" to confirm both classes.
  </verify>
  <done>
HotSwapManager handles graceful device add/remove with journal-backed crash consistency and automatic rebuild triggers. BaremetalBootstrap initializes DW on raw devices by scanning pool metadata from reserved sectors and recovering interrupted operations from the device journal.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for UltimateFilesystem plugin
- HotSwapManager subscribes to PhysicalDeviceManager events and journals all mutations
- BaremetalBootstrap discovers devices, scans pools, recovers journal, identifies unpooled devices
- DeviceJournal uses intent/commit/rollback pattern with CRC32 integrity
- Hot-add handles returning devices (existing pool metadata) and new devices
- Hot-remove triggers rebuild and fires OnRebuildRequired
</verification>

<success_criteria>
Adding/removing physical devices from pools is graceful and crash-consistent. DW can bootstrap on raw hardware with no OS volume manager by scanning reserved sectors. Interrupted operations are recovered from the device journal.
</success_criteria>

<output>
After completion, create `.planning/phases/90-device-discovery-physical-block/90-05-SUMMARY.md`
</output>
