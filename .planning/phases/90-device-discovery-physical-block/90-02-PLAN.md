---
phase: 90-device-discovery-physical-block
plan: 02
type: execute
wave: 2
depends_on: ["90-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/PhysicalDeviceManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/SmartMonitor.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/FailurePredictionEngine.cs
autonomous: true

must_haves:
  truths:
    - "PhysicalDeviceManager monitors SMART health, temperature, wear level, and error rate for each discovered device"
    - "FailurePredictionEngine predicts device failure with EWMA + configurable threshold, providing >=24hr warning"
    - "SmartMonitor reads SMART attributes from Linux (/sys/block) and Windows (WMI/IOCTL) periodically"
    - "Health alerts are raised via callback/event when thresholds are exceeded"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/PhysicalDeviceManager.cs"
      provides: "Central device lifecycle and health orchestrator"
      contains: "class PhysicalDeviceManager"
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/SmartMonitor.cs"
      provides: "Platform-specific SMART attribute reader"
      contains: "ReadSmartAttributesAsync"
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/FailurePredictionEngine.cs"
      provides: "EWMA-based failure prediction"
      contains: "PredictFailure"
  key_links:
    - from: "PhysicalDeviceManager"
      to: "DeviceDiscoveryService"
      via: "uses discovery to enumerate devices"
      pattern: "DeviceDiscoveryService"
    - from: "PhysicalDeviceManager"
      to: "SmartMonitor"
      via: "periodic health polling"
      pattern: "SmartMonitor"
    - from: "PhysicalDeviceManager"
      to: "FailurePredictionEngine"
      via: "feeds SMART data for prediction"
      pattern: "FailurePredictionEngine"
---

<objective>
Implement PhysicalDeviceManager that monitors registered physical devices for health (SMART attributes, temperature, wear level, error rates) and predicts failures using EWMA with configurable thresholds.

Purpose: Enables proactive failure detection with >=24hr warning, preventing data loss from degrading devices.
Output: Three files in UltimateFilesystem plugin providing device health monitoring and failure prediction.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md (Phase 90, success criteria 2: SMART health, temperature, wear, failure prediction)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs (from 90-01)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/PhysicalDeviceInfo.cs (PhysicalDeviceHealth record from 90-01)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DeviceDiscoveryService.cs (from 90-01)
@DataWarehouse.SDK/Contracts/StrategyBase.cs (AD-05 pattern)
@Plugins/DataWarehouse.Plugins.UltimateFilesystem/FilesystemStrategyBase.cs (strategy base pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: SmartMonitor and FailurePredictionEngine</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/SmartMonitor.cs
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/FailurePredictionEngine.cs
  </files>
  <action>
Create DeviceManagement/ directory under UltimateFilesystem plugin.

**SmartMonitor.cs** - Sealed class, namespace DataWarehouse.Plugins.UltimateFilesystem.DeviceManagement:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: SMART health monitoring (BMDV-03)")]`
- Constructor takes `ILogger?` (nullable for flexibility)
- `Task<PhysicalDeviceHealth> ReadSmartAttributesAsync(string devicePath, BusType busType, CancellationToken ct = default)`
- **Linux NVMe**: Read /sys/block/{dev}/device/smart_log or parse output concept from /sys/class/nvme/{ctrl}/hwmon{N}/temp{N}_input (temperature), /sys/block/{dev}/device/lifetime (wear). Actually read:
  - Temperature: /sys/class/hwmon/hwmon*/temp*_input (find one matching the device), or /sys/block/{dev}/device/hwmon*/temp1_input
  - Wear: /sys/block/{dev}/device/percentage_used for NVMe
  - Total bytes written/read: /sys/block/{dev}/stat (sectors read/written * sector size)
  - Error count: /sys/block/{dev}/device/error_count or /sys/block/{dev}/device/uevent parsing
- **Linux SATA/SCSI**: Read /sys/block/{dev}/device/error_cnt, /sys/block/{dev}/device/timeout_cnt, temperature from hwmon
- **Windows**: Use WMI MSStorageDriver_FailurePredictStatus, MSStorageDriver_FailurePredictData, Win32_DiskDrive for basic metrics. Parse SMART data structure from FailurePredictData byte array (standard ATA SMART attribute format: ID, flags, current, worst, raw values for attributes 1,5,9,12,187,188,194,197,198,199,241,242)
- Return `PhysicalDeviceHealth` record populated with best-effort data. Fields that cannot be read get safe defaults (0 for counts, -1 for unknown temperature, null for EstimatedRemainingLife).
- All file/WMI reads wrapped in try-catch; never throw on unreadable attributes.

**FailurePredictionEngine.cs** - Sealed class, same namespace:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: EWMA failure prediction (BMDV-04)")]`
- Maintains per-device EWMA state: `BoundedDictionary<string, DeviceEwmaState>(1000)` keyed by DeviceId
- `record DeviceEwmaState` (internal): `double EwmaTemperature`, `double EwmaErrorRate`, `double EwmaWearRate`, `DateTime LastUpdate`, `int SampleCount`
- `record FailurePrediction` with: `string DeviceId`, `bool IsAtRisk`, `TimeSpan? EstimatedTimeToFailure`, `string RiskLevel` (None/Low/Medium/High/Critical), `string[] RiskFactors`
- `record FailurePredictionConfig` with: `double EwmaAlpha = 0.3` (smoothing factor), `double TemperatureThresholdCelsius = 70.0`, `double WearLevelThresholdPercent = 90.0`, `double ErrorRateThresholdPerHour = 1.0`, `int MinSamplesForPrediction = 5`
- Constructor takes `FailurePredictionConfig? config = null` (uses defaults if null)
- `FailurePrediction UpdateAndPredict(string deviceId, PhysicalDeviceHealth health)`:
  - Update EWMA for temperature: ewma_new = alpha * current + (1-alpha) * ewma_old
  - Update EWMA for error rate: compute errors/hour delta since last sample
  - Update EWMA for wear rate: compute wear%/hour delta since last sample
  - Determine risk level: Critical if any EWMA exceeds 1.5x threshold, High if exceeds threshold, Medium if exceeds 0.8x threshold, Low if trending upward, None otherwise
  - Estimate time to failure: extrapolate from wear rate to 100% wear, or from error rate trend
  - Return FailurePrediction with risk factors listing which metrics are concerning
- `void Reset(string deviceId)` -- clear EWMA state for device
- `IReadOnlyDictionary<string, FailurePrediction> GetAllPredictions()` -- current state of all tracked devices
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` and confirm zero errors. Grep for "EwmaAlpha" and "ReadSmartAttributesAsync" to confirm both classes exist.
  </verify>
  <done>
SmartMonitor reads SMART attributes from Linux sysfs and Windows WMI. FailurePredictionEngine maintains per-device EWMA state and produces FailurePrediction with risk level and estimated time to failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: PhysicalDeviceManager orchestrating discovery, monitoring, and prediction</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/PhysicalDeviceManager.cs
  </files>
  <action>
**PhysicalDeviceManager.cs** - Sealed class implementing IAsyncDisposable, namespace DataWarehouse.Plugins.UltimateFilesystem.DeviceManagement:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Device lifecycle and health orchestration (BMDV-03/BMDV-04)")]`
- **Dependencies** (constructor injected): `DeviceDiscoveryService discoveryService`, `SmartMonitor smartMonitor`, `FailurePredictionEngine predictionEngine`
- **Configuration**: `record DeviceManagerConfig` with: `TimeSpan HealthPollInterval = TimeSpan.FromMinutes(5)`, `TimeSpan DiscoveryInterval = TimeSpan.FromMinutes(30)`, `bool AutoDiscoveryEnabled = true`, `FailurePredictionConfig PredictionConfig` (default)
- **State**: `BoundedDictionary<string, ManagedDevice>(500)` keyed by DeviceId. `record ManagedDevice` with: `PhysicalDeviceInfo Info`, `PhysicalDeviceHealth LastHealth`, `FailurePrediction LastPrediction`, `DateTime LastHealthCheck`, `DeviceStatus Status` (Online/Degraded/Failing/Offline/Removed)
- **Events** (Action callbacks, not C# events -- simpler, no subscription leaks):
  - `Action<string, PhysicalDeviceHealth>? OnHealthUpdate` -- called after each health poll per device
  - `Action<string, FailurePrediction>? OnFailurePrediction` -- called when risk level is Medium or above
  - `Action<string, DeviceStatus, DeviceStatus>? OnStatusChange` -- called when status transitions (deviceId, oldStatus, newStatus)
  - `Action<PhysicalDeviceInfo>? OnDeviceDiscovered` -- called when new device appears
  - `Action<string>? OnDeviceRemoved` -- called when device disappears between discovery cycles
- **Public API**:
  - `Task StartAsync(CancellationToken ct = default)` -- starts discovery + health polling via Timer/PeriodicTimer
  - `Task StopAsync()` -- stops timers, sets all devices Offline
  - `Task<IReadOnlyList<ManagedDevice>> GetDevicesAsync()` -- snapshot of all managed devices
  - `Task<ManagedDevice?> GetDeviceAsync(string deviceId)` -- single device lookup
  - `Task ForceHealthCheckAsync(string deviceId, CancellationToken ct = default)` -- immediate health check for one device
  - `Task ForceDiscoveryAsync(CancellationToken ct = default)` -- immediate re-discovery
  - `Task RegisterDeviceAsync(PhysicalDeviceInfo info)` -- manually register a device (for testing or remote devices)
  - `Task UnregisterDeviceAsync(string deviceId)` -- remove device from management
- **Health polling loop** (private, runs on PeriodicTimer):
  - For each managed device: call SmartMonitor.ReadSmartAttributesAsync, then FailurePredictionEngine.UpdateAndPredict
  - Update ManagedDevice.LastHealth, LastPrediction, LastHealthCheck
  - Transition status: if health.IsHealthy && prediction.RiskLevel==None/Low -> Online; Medium -> Degraded; High/Critical -> Failing; if ReadSmartAttributes throws -> Offline
  - Fire OnHealthUpdate, OnFailurePrediction (if Medium+), OnStatusChange (if changed)
- **Discovery loop** (private, runs on PeriodicTimer):
  - Call DeviceDiscoveryService.DiscoverDevicesAsync
  - Compare with current managed set: new devices -> add + fire OnDeviceDiscovered, missing devices -> mark Removed + fire OnDeviceRemoved
- All loops use try-catch to prevent crash from single device failure
- DisposeAsync cancels timers and clears state
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` and confirm zero errors. Grep for "OnFailurePrediction" and "PeriodicTimer" to confirm event system and polling loop exist.
  </verify>
  <done>
PhysicalDeviceManager orchestrates device discovery, periodic SMART health polling, EWMA failure prediction, and status transitions. Fires callbacks for health updates, failure predictions, status changes, and device appearance/removal.
  </done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` compiles with zero errors
- PhysicalDeviceManager uses DeviceDiscoveryService, SmartMonitor, and FailurePredictionEngine
- FailurePredictionEngine implements EWMA with configurable thresholds
- SmartMonitor has platform-specific code for Linux and Windows
- Health polling uses PeriodicTimer with configurable interval
</verification>

<success_criteria>
Every managed device has continuous health monitoring. Failure prediction produces risk levels (None/Low/Medium/High/Critical) with estimated time-to-failure. Status transitions (Online -> Degraded -> Failing) trigger callbacks that downstream consumers (DevicePoolManager in 90-03, hot-swap in 90-05) will use.
</success_criteria>

<output>
After completion, create `.planning/phases/90-device-discovery-physical-block/90-02-SUMMARY.md`
</output>
