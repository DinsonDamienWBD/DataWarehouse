---
phase: 90-device-discovery-physical-block
plan: 03
type: execute
wave: 2
depends_on: ["90-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DevicePoolManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/PoolMetadataCodec.cs
  - DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DevicePoolDescriptor.cs
autonomous: true

must_haves:
  truths:
    - "DevicePoolManager creates named pools from sets of physical devices"
    - "Pools are tiered by media type (NVMe/SSD/HDD/tape) with explicit tier classification"
    - "Pools carry locality tags (rack/datacenter/region) for placement-aware scheduling"
    - "Pool metadata is persisted on reserved sectors of member devices (survives OS reinstall)"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DevicePoolManager.cs"
      provides: "Pool lifecycle management"
      contains: "class DevicePoolManager"
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/PoolMetadataCodec.cs"
      provides: "Binary serialization of pool metadata to reserved device sectors"
      contains: "SerializePoolMetadata"
    - path: "DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DevicePoolDescriptor.cs"
      provides: "Pool and tier type definitions"
      contains: "record DevicePoolDescriptor"
  key_links:
    - from: "DevicePoolManager"
      to: "IPhysicalBlockDevice"
      via: "reads/writes reserved sectors on member devices"
      pattern: "IPhysicalBlockDevice"
    - from: "DevicePoolManager"
      to: "DevicePoolDescriptor"
      via: "creates and manages pool descriptors"
      pattern: "DevicePoolDescriptor"
    - from: "PoolMetadataCodec"
      to: "DevicePoolDescriptor"
      via: "serializes/deserializes pool metadata"
      pattern: "Serialize.*DevicePoolDescriptor"
---

<objective>
Implement DevicePoolManager for creating named device pools with tier classification and locality tags, plus PoolMetadataCodec for persisting pool metadata on reserved device sectors.

Purpose: Pools group physical devices into logical units that VDE can address. Tier classification enables automatic hot/warm/cold data placement. Reserved-sector persistence means pools survive OS reinstall.
Output: Pool management in UltimateFilesystem plugin plus SDK descriptor types.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md (Phase 90, success criteria 3 and 7)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/IPhysicalBlockDevice.cs (from 90-01)
@DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/PhysicalDeviceInfo.cs (MediaType, BusType from 90-01)
@DataWarehouse.SDK/VirtualDiskEngine/Allocation/AllocationGroup.cs (serialization pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DevicePoolDescriptor SDK types</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/PhysicalDevice/DevicePoolDescriptor.cs
  </files>
  <action>
Create in namespace DataWarehouse.SDK.VirtualDiskEngine.PhysicalDevice:

- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Device pool descriptors (BMDV-05/BMDV-06)")]`
- `enum StorageTier { Hot, Warm, Cold, Frozen, Archive }` -- maps to NVMe->Hot, SSD->Warm, HDD->Cold, Tape->Frozen/Archive
- `record LocalityTag` with: `string Rack = "default"`, `string Datacenter = "default"`, `string Region = "default"`, `string Zone = "default"` -- hierarchical locality for placement
- `record PoolMemberDescriptor` with: `string DeviceId`, `string DevicePath`, `MediaType MediaType`, `long CapacityBytes`, `long ReservedBytes` (for pool metadata), `bool IsActive`
- `record DevicePoolDescriptor` with:
  - `Guid PoolId` (globally unique, generated at creation)
  - `string PoolName` (user-given name, unique within a node)
  - `StorageTier Tier` (computed from member device media types, or explicitly set)
  - `LocalityTag Locality`
  - `IReadOnlyList<PoolMemberDescriptor> Members`
  - `long TotalCapacityBytes` (sum of member capacities minus reserved)
  - `long UsableCapacityBytes` (total minus metadata overhead)
  - `DateTime CreatedUtc`
  - `DateTime LastModifiedUtc`
  - `int MetadataVersion = 1` (for future format evolution)
  - `IReadOnlyDictionary<string, string> Properties` (extensible key-value for user config)
- `static class StorageTierClassifier` with `StorageTier ClassifyFromMediaType(MediaType mediaType)` that maps NVMe->Hot, SSD->Warm, HDD->Cold, Tape->Frozen, RAMDisk->Hot, others->Cold
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` and confirm zero errors.
  </verify>
  <done>
DevicePoolDescriptor, StorageTier, LocalityTag, PoolMemberDescriptor, and StorageTierClassifier exist in SDK with all required fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: PoolMetadataCodec and DevicePoolManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/PoolMetadataCodec.cs
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/DeviceManagement/DevicePoolManager.cs
  </files>
  <action>
**PoolMetadataCodec.cs** - Sealed class, namespace DataWarehouse.Plugins.UltimateFilesystem.DeviceManagement:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Pool metadata binary codec (BMDV-07)")]`
- Reserved sector layout: first 4KB of each member device (block 0) holds pool metadata
  - Bytes 0-3: Magic number `0x44575030` ("DWP0")
  - Bytes 4-7: Metadata version (int32 LE)
  - Bytes 8-11: Payload length (int32 LE)
  - Bytes 12-43: SHA-256 checksum of payload
  - Bytes 44-N: Payload (UTF-8 JSON of DevicePoolDescriptor)
  - Remaining: zero-padded to 4KB
- `byte[] SerializePoolMetadata(DevicePoolDescriptor pool)` -- produces the 4KB block
- `DevicePoolDescriptor? DeserializePoolMetadata(ReadOnlySpan<byte> data)` -- returns null if magic/checksum mismatch
- `bool ValidatePoolMetadata(ReadOnlySpan<byte> data)` -- quick check without full deserialization
- Uses System.Security.Cryptography.SHA256 for checksum
- Uses System.Text.Json for JSON serialization of the descriptor

**DevicePoolManager.cs** - Sealed class implementing IAsyncDisposable, same namespace:
- `[SdkCompatibility("6.0.0", Notes = "Phase 90: Device pool lifecycle management (BMDV-05/BMDV-06/BMDV-07)")]`
- **State**: `BoundedDictionary<Guid, DevicePoolDescriptor>(100)` for in-memory pool registry, `BoundedDictionary<string, Guid>(500)` mapping DeviceId -> PoolId for reverse lookup
- **Dependencies**: `PoolMetadataCodec codec` (constructor)
- **Public API**:
  - `Task<DevicePoolDescriptor> CreatePoolAsync(string poolName, StorageTier? explicitTier, LocalityTag? locality, IReadOnlyList<IPhysicalBlockDevice> devices, CancellationToken ct = default)`:
    - Validate: poolName unique, devices not already in another pool, devices are online
    - Auto-classify tier from majority media type if explicitTier is null (using StorageTierClassifier)
    - Reserve block 0 on each device for metadata (4KB = 1 block on 4K devices, 8 blocks on 512-byte devices)
    - Build DevicePoolDescriptor with new Guid, member list, computed capacity
    - Write metadata to block 0 of each member device via IPhysicalBlockDevice.WriteBlockAsync
    - Add to in-memory registry
    - Return descriptor
  - `Task<DevicePoolDescriptor?> GetPoolAsync(Guid poolId)` -- lookup by ID
  - `Task<DevicePoolDescriptor?> GetPoolByNameAsync(string poolName)` -- lookup by name
  - `Task<IReadOnlyList<DevicePoolDescriptor>> GetAllPoolsAsync()` -- all pools
  - `Task AddDeviceToPoolAsync(Guid poolId, IPhysicalBlockDevice device, CancellationToken ct = default)` -- expand pool, write metadata to new device + update existing members
  - `Task RemoveDeviceFromPoolAsync(Guid poolId, string deviceId, CancellationToken ct = default)` -- shrink pool, clear metadata on removed device, update remaining members
  - `Task DeletePoolAsync(Guid poolId, CancellationToken ct = default)` -- clear metadata from all member devices, remove from registry
  - `Task<IReadOnlyList<DevicePoolDescriptor>> ScanForPoolsAsync(IReadOnlyList<IPhysicalBlockDevice> devices, CancellationToken ct = default)` -- read block 0 from each device, deserialize, reconstruct pools from metadata (for bare-metal bootstrap)
  - `Task UpdatePoolLocalityAsync(Guid poolId, LocalityTag locality, CancellationToken ct = default)` -- update locality tags, re-persist
  - `Task<IReadOnlyList<DevicePoolDescriptor>> GetPoolsByTierAsync(StorageTier tier)` -- filter by tier
  - `Task<IReadOnlyList<DevicePoolDescriptor>> GetPoolsByLocalityAsync(string? rack = null, string? datacenter = null, string? region = null)` -- filter by locality
- **Metadata consistency**: when updating pool metadata, write to ALL member devices atomically (best-effort: write to all, if any fail mark that member as degraded but don't fail the operation)
- All mutations update LastModifiedUtc before persisting
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` and confirm zero errors. Grep for "ScanForPoolsAsync" and "0x44575030" to confirm bare-metal bootstrap scanning and magic number.
  </verify>
  <done>
DevicePoolManager creates/manages named pools with tier classification and locality tags. PoolMetadataCodec persists pool metadata on reserved device sectors with magic number, version, SHA-256 checksum. ScanForPoolsAsync enables bare-metal bootstrap by reading metadata from raw devices.
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds for both SDK and UltimateFilesystem projects
- Pool metadata format has magic number, version, checksum
- DevicePoolManager supports create/add/remove/delete/scan operations
- Tier classification works from MediaType
- Locality tags are hierarchical (rack/datacenter/region/zone)
- ScanForPoolsAsync reconstructs pools from reserved sectors (bare-metal bootstrap)
</verification>

<success_criteria>
Named device pools with tier classification and locality tags can be created, persisted to device sectors, and reconstructed from raw devices without any OS volume manager.
</success_criteria>

<output>
After completion, create `.planning/phases/90-device-discovery-physical-block/90-03-SUMMARY.md`
</output>
