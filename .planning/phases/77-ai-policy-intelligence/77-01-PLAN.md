---
phase: 77-ai-policy-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationPipeline.cs
  - DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationRingBuffer.cs
  - DataWarehouse.SDK/Infrastructure/Intelligence/OverheadThrottle.cs
autonomous: true

must_haves:
  truths:
    - "Observations emitted by plugins arrive at registered consumers asynchronously"
    - "Ring buffer is lock-free (no Monitor/lock/Mutex on write path)"
    - "CPU overhead from AI observation stays at or below configured maxCpuOverhead (default 1%)"
    - "Auto-throttle activates when overhead is exceeded, dropping observations gracefully"
    - "ObservationEmitter.EmitMetricAsync publishes to the ring buffer instead of being a no-op"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationRingBuffer.cs"
      provides: "Lock-free ring buffer for observation events"
      contains: "Interlocked.CompareExchange"
    - path: "DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationPipeline.cs"
      provides: "Async consumer that drains ring buffer and dispatches to advisors"
      contains: "class AiObservationPipeline"
    - path: "DataWarehouse.SDK/Infrastructure/Intelligence/OverheadThrottle.cs"
      provides: "CPU overhead monitoring and auto-throttle"
      contains: "maxCpuOverhead"
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Policy/IAiHook.cs"
      to: "DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationRingBuffer.cs"
      via: "ObservationEmitter writes to ring buffer"
      pattern: "RingBuffer.*Write|TryWrite"
    - from: "DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationPipeline.cs"
      to: "DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationRingBuffer.cs"
      via: "Pipeline drains ring buffer"
      pattern: "RingBuffer.*Read|TryRead|Drain"
---

<objective>
Build the AI observation pipeline foundation: a lock-free ring buffer for zero-hot-path-impact observation collection, an async consumer pipeline that drains observations and dispatches to advisor interfaces, and a CPU overhead throttle that auto-drops observations when the configured limit is exceeded.

Purpose: AIPI-01 and AIPI-10 -- the ring buffer is the backbone that all advisors (Plans 02-04) consume from. Without this, no AI observation data flows.
Output: Three production-ready classes in DataWarehouse.SDK/Infrastructure/Intelligence/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Contracts/Policy/IAiHook.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lock-free ring buffer and observation pipeline</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationRingBuffer.cs
    DataWarehouse.SDK/Infrastructure/Intelligence/AiObservationPipeline.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Intelligence/` directory with two files.

**AiObservationRingBuffer.cs:**
- Namespace: `DataWarehouse.SDK.Infrastructure.Intelligence`
- `[SdkCompatibility("6.0.0", Notes = "Phase 77: AI Policy Intelligence (AIPI-01)")]`
- `sealed class AiObservationRingBuffer` -- generic `AiObservationRingBuffer` or typed to `ObservationEvent`
- Define `ObservationEvent` record: `string PluginId`, `string MetricName`, `double Value`, `string? AnomalyType`, `string? Description`, `DateTimeOffset Timestamp`
- Use a power-of-two sized array (default 8192) with `long _head` and `long _tail` using `Interlocked.CompareExchange` for CAS-based lock-free writes
- `bool TryWrite(ObservationEvent evt)` -- returns false if buffer full (drop, don't block)
- `bool TryRead(out ObservationEvent evt)` -- single consumer reads from tail
- `int DrainTo(List<ObservationEvent> batch, int maxCount)` -- batch drain for the consumer
- NO `lock`, NO `Monitor`, NO `Mutex`, NO `SemaphoreSlim` on the write path
- Use `Volatile.Read`/`Volatile.Write` for head/tail visibility across threads

**AiObservationPipeline.cs:**
- `sealed class AiObservationPipeline : IAsyncDisposable`
- Constructor takes `AiObservationRingBuffer buffer`, `OverheadThrottle throttle`, `TimeSpan drainInterval` (default 100ms)
- `List<IAiAdvisor> Advisors` property for registering advisors (Plan 02-04 will add concrete ones)
- Define `IAiAdvisor` interface: `string AdvisorId { get; }`, `Task ProcessObservationsAsync(IReadOnlyList<ObservationEvent> batch, CancellationToken ct)`
- `StartAsync(CancellationToken ct)` -- starts a background Task that loops: drain buffer -> fan-out to advisors -> sleep for drainInterval
- `StopAsync()` -- cancels the background loop, drains remaining events
- The background loop checks `throttle.IsThrottled` before processing -- if throttled, skip the batch (drop)
- Catch all exceptions from advisors individually (one failing advisor does not block others)

Mark both classes with `[SdkCompatibility("6.0.0")]`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
  </verify>
  <done>
AiObservationRingBuffer uses Interlocked CAS for lock-free writes, AiObservationPipeline drains asynchronously and fans out to IAiAdvisor instances, throttle integration skips batches when overhead exceeded.
  </done>
</task>

<task type="auto">
  <name>Task 2: Overhead throttle and ObservationEmitter wiring</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Intelligence/OverheadThrottle.cs
    DataWarehouse.SDK/Contracts/Policy/IAiHook.cs
  </files>
  <action>
**OverheadThrottle.cs:**
- Namespace: `DataWarehouse.SDK.Infrastructure.Intelligence`
- `[SdkCompatibility("6.0.0", Notes = "Phase 77: AI Policy Intelligence (AIPI-10)")]`
- `sealed class OverheadThrottle`
- Constructor takes `double maxCpuOverheadPercent = 1.0` (default 1%)
- `bool IsThrottled { get; }` -- volatile bool
- `void UpdateCpuUsage(double currentCpuPercent)` -- called periodically by the pipeline
- Internal logic: track a sliding window of CPU samples (last 10 samples); if average exceeds `maxCpuOverheadPercent`, set `IsThrottled = true`; if average drops below 80% of threshold, set back to false (hysteresis to avoid flapping)
- `long DroppedObservations` -- Interlocked counter of how many observations were dropped due to throttling
- `void RecordDrop(int count)` -- increments dropped counter
- Use `Environment.ProcessorCount` and `System.Diagnostics.Process.GetCurrentProcess().TotalProcessorTime` delta over wall-clock delta to estimate CPU usage in `MeasureCpuUsage()` method
- `MeasureCpuUsage()` returns `double` (0-100 percent), called by the pipeline's background loop before each drain cycle

**Update IAiHook.cs -- ObservationEmitter:**
- Add a `private AiObservationRingBuffer? _ringBuffer` field
- Add internal method `void AttachRingBuffer(AiObservationRingBuffer buffer)` to wire the ring buffer
- Update `EmitMetricAsync` to write `new ObservationEvent(pluginId, metricName, value, null, null, DateTimeOffset.UtcNow)` to `_ringBuffer?.TryWrite(...)`. If buffer is null or full, return immediately (fire-and-forget, no exceptions). Keep return type as `Task` returning `Task.CompletedTask`.
- Update `EmitAnomalyAsync` similarly with `anomalyType` and `description` populated
- Add `using DataWarehouse.SDK.Infrastructure.Intelligence;` at top

This wires the existing no-op ObservationEmitter (Phase 68 placeholder) to the real ring buffer.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors. Grep for "Task.CompletedTask" in EmitMetricAsync should no longer be the sole body -- should see TryWrite.
  </verify>
  <done>
OverheadThrottle monitors CPU via process time deltas with hysteresis, ObservationEmitter writes to ring buffer instead of no-op, dropped observation counter tracks throttle events. AIPI-01 and AIPI-10 satisfied.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- No `lock` or `Monitor` keywords in AiObservationRingBuffer.cs (grep verification)
- `Interlocked` used in ring buffer write path
- ObservationEmitter.EmitMetricAsync no longer returns only Task.CompletedTask
- OverheadThrottle.IsThrottled uses volatile or Interlocked pattern
</verification>

<success_criteria>
1. Lock-free ring buffer compiles and uses CAS-based writes (AIPI-01)
2. Async pipeline drains buffer and dispatches to IAiAdvisor list
3. CPU overhead throttle with 1% default and hysteresis (AIPI-10)
4. ObservationEmitter wired to ring buffer (no longer no-op)
5. Full SDK build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/77-ai-policy-intelligence/77-01-SUMMARY.md`
</output>
