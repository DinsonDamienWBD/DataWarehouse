---
phase: 77-ai-policy-intelligence
plan: 04
type: execute
wave: 3
depends_on: ["77-02", "77-03"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Intelligence/PolicyAdvisor.cs
  - DataWarehouse.SDK/Infrastructure/Intelligence/AiAutonomyConfiguration.cs
autonomous: true

must_haves:
  truths:
    - "PolicyAdvisor produces PolicyRecommendation with a full rationale chain for every recommendation"
    - "AI autonomy is independently configurable per feature per level (up to 470 distinct configuration points)"
    - "Recommendations include confidence score, suggested policy, and required autonomy level"
    - "PolicyAdvisor consumes all 5 advisor outputs (hardware, workload, threat, cost, sensitivity)"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Intelligence/PolicyAdvisor.cs"
      provides: "Recommendation engine with rationale chain"
      contains: "class PolicyAdvisor"
    - path: "DataWarehouse.SDK/Infrastructure/Intelligence/AiAutonomyConfiguration.cs"
      provides: "Per-feature per-level autonomy configuration (470 config points)"
      contains: "class AiAutonomyConfiguration"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Intelligence/PolicyAdvisor.cs"
      to: "DataWarehouse.SDK/Infrastructure/Intelligence/HardwareProbe.cs"
      via: "reads CurrentSnapshot for hardware context"
      pattern: "HardwareProbe.*CurrentSnapshot|_hardwareProbe"
    - from: "DataWarehouse.SDK/Infrastructure/Intelligence/PolicyAdvisor.cs"
      to: "DataWarehouse.SDK/Infrastructure/Intelligence/ThreatDetector.cs"
      via: "reads CurrentAssessment for threat context"
      pattern: "ThreatDetector.*CurrentAssessment|_threatDetector"
    - from: "DataWarehouse.SDK/Infrastructure/Intelligence/PolicyAdvisor.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/IAiHook.cs"
      via: "produces PolicyRecommendation records"
      pattern: "PolicyRecommendation"
---

<objective>
Build the PolicyAdvisor recommendation engine that synthesizes outputs from all 5 advisors (hardware, workload, threat, cost, sensitivity) into PolicyRecommendation records with full rationale chains, and the AiAutonomyConfiguration that provides per-feature per-level autonomy control (94 features x 5 levels = 470 config points).

Purpose: AIPI-07 and AIPI-08 -- the core intelligence layer that generates actionable recommendations while respecting autonomy boundaries.
Output: PolicyAdvisor and AiAutonomyConfiguration classes
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-ai-policy-intelligence/77-01-SUMMARY.md
@.planning/phases/77-ai-policy-intelligence/77-02-SUMMARY.md
@.planning/phases/77-ai-policy-intelligence/77-03-SUMMARY.md
@DataWarehouse.SDK/Infrastructure/Intelligence/HardwareProbe.cs
@DataWarehouse.SDK/Infrastructure/Intelligence/WorkloadAnalyzer.cs
@DataWarehouse.SDK/Infrastructure/Intelligence/ThreatDetector.cs
@DataWarehouse.SDK/Infrastructure/Intelligence/CostAnalyzer.cs
@DataWarehouse.SDK/Infrastructure/Intelligence/DataSensitivityAnalyzer.cs
@DataWarehouse.SDK/Contracts/Policy/IAiHook.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: AiAutonomyConfiguration (470 config points)</name>
  <files>DataWarehouse.SDK/Infrastructure/Intelligence/AiAutonomyConfiguration.cs</files>
  <action>
Create `AiAutonomyConfiguration.cs`:

- Namespace: `DataWarehouse.SDK.Infrastructure.Intelligence`
- `[SdkCompatibility("6.0.0", Notes = "Phase 77: AI Policy Intelligence (AIPI-08)")]`

**AiAutonomyConfiguration sealed class:**
- Internal storage: `ConcurrentDictionary<string, AiAutonomyLevel>` with composite keys formatted as `{featureId}:{level}` (e.g., "encryption:VDE", "compression:Block")
- Constructor takes optional `AiAutonomyLevel defaultLevel = AiAutonomyLevel.Suggest` (default for unconfigured points)

**Per-feature per-level API:**
- `AiAutonomyLevel GetAutonomy(string featureId, PolicyLevel level)` -- looks up `{featureId}:{level}` key, returns default if not configured
- `void SetAutonomy(string featureId, PolicyLevel level, AiAutonomyLevel autonomy)` -- sets the config point
- `void SetAutonomyForFeature(string featureId, AiAutonomyLevel autonomy)` -- sets all 5 levels for a feature
- `void SetAutonomyForLevel(PolicyLevel level, AiAutonomyLevel autonomy)` -- sets all 94 features for a level

**Bulk configuration:**
- `void SetAutonomyForCategory(CheckTiming timing, AiAutonomyLevel autonomy)` -- uses CheckClassificationTable.GetFeaturesByTiming to set all features in a timing category (e.g., all ConnectTime features to ManualOnly for security-critical)
- `int ConfiguredPointCount` -- number of explicitly configured points
- `int TotalConfigPoints => 94 * 5` (470 -- the 94 features from CheckClassificationTable x 5 PolicyLevels)

**Serialization:**
- `Dictionary<string, AiAutonomyLevel> ExportConfiguration()` -- returns all configured points
- `void ImportConfiguration(IReadOnlyDictionary<string, AiAutonomyLevel> config)` -- bulk load

**Validation:**
- `bool IsFeatureKnown(string featureId)` -- checks against CheckClassificationTable
- If a featureId is unknown, still allow configuration (forward compatibility) but log a warning

The key insight is the composite key format `{featureId}:{PolicyLevel}` giving exactly 470 addressable config points for the 94 known features.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
  </verify>
  <done>
AiAutonomyConfiguration provides 470 individually addressable config points (94 features x 5 levels) with per-feature, per-level, and per-category bulk operations. AIPI-08 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: PolicyAdvisor recommendation engine</name>
  <files>DataWarehouse.SDK/Infrastructure/Intelligence/PolicyAdvisor.cs</files>
  <action>
Create `PolicyAdvisor.cs`:

- Namespace: `DataWarehouse.SDK.Infrastructure.Intelligence`
- `[SdkCompatibility("6.0.0", Notes = "Phase 77: AI Policy Intelligence (AIPI-07)")]`
- `sealed class PolicyAdvisor : IAiAdvisor`
- `string AdvisorId => "policy_advisor"`

**Constructor takes:**
- `HardwareProbe hardwareProbe`
- `WorkloadAnalyzer workloadAnalyzer`
- `ThreatDetector threatDetector`
- `CostAnalyzer costAnalyzer`
- `DataSensitivityAnalyzer sensitivityAnalyzer`
- `AiAutonomyConfiguration autonomyConfig`

**RationaleChain record:**
- `List<RationaleStep> Steps` -- ordered chain of reasoning
- `string Summary` -- one-line human-readable summary
- `double OverallConfidence` -- product of step confidences

**RationaleStep record:**
- `string AdvisorId` -- which advisor contributed this step
- `string Finding` -- what was observed (e.g., "Memory pressure at 92%")
- `string Implication` -- what it means (e.g., "Compression should be increased to reduce memory footprint")
- `double Confidence` -- confidence in this step (0.0-1.0)

**PolicyAdvisor.ProcessObservationsAsync:**
1. Read current state from all 5 advisors (snapshots/profiles/assessments)
2. For each of the 94 features (iterate CheckClassificationTable):
   a. Build rationale chain by querying each advisor:
      - Hardware: "CPU has AVX2, recommend AES-NI encryption" or "Low memory, recommend lighter compression"
      - Workload: "Peak hours detected, optimize for throughput" or "Off-peak, allow background maintenance"
      - Threat: "Threat level Elevated, tighten access_control to MostRestrictive"
      - Cost: "Algorithm X costs 3x more than Y with similar quality, recommend Y"
      - Sensitivity: "PII detected, mandate encryption and audit trail"
   b. Compute recommended policy changes based on combined context
   c. Check autonomy level: `autonomyConfig.GetAutonomy(featureId, PolicyLevel.VDE)` -- if ManualOnly, skip auto-application
   d. Create `PolicyRecommendation` with: FeatureId, full Rationale (from chain Summary), SuggestedPolicy, RequiredAutonomy (minimum level needed to auto-apply), ConfidenceScore (from chain), GeneratedAt

3. Only generate recommendations when something has actually changed (compare to last recommendation for that feature). Use a `ConcurrentDictionary<string, PolicyRecommendation>` to track last-emitted recommendations.

**Recommendation generation rules (simplified -- not all 94 features generate every cycle):**
- Only generate a recommendation if at least one advisor has a signal relevant to that feature
- Security features (encryption, access_control, auth_model, key_management, fips_mode): always check ThreatDetector + SensitivityAnalyzer
- Performance features (compression, cache_strategy, indexing): always check HardwareProbe + WorkloadAnalyzer + CostAnalyzer
- Other features: check all advisors but only emit if confidence > 0.5

**Public API:**
- `IReadOnlyList<PolicyRecommendation> PendingRecommendations { get; }` -- recommendations generated but not yet dispatched
- `PolicyRecommendation? GetRecommendation(string featureId)` -- latest recommendation for a specific feature
- `RationaleChain? GetRationale(string featureId)` -- full rationale chain for a feature's latest recommendation
- Store rationale chains in `ConcurrentDictionary<string, RationaleChain>` keyed by featureId
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors.
  </verify>
  <done>
PolicyAdvisor synthesizes all 5 advisor outputs into PolicyRecommendations with full rationale chains, respects per-feature autonomy levels, and only emits when state changes warrant a new recommendation. AIPI-07 satisfied.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- PolicyAdvisor references all 5 advisors (HardwareProbe, WorkloadAnalyzer, ThreatDetector, CostAnalyzer, DataSensitivityAnalyzer)
- AiAutonomyConfiguration supports composite key {featureId}:{level} pattern
- PolicyRecommendation record matches the existing definition in IAiHook.cs
- RationaleChain provides per-step reasoning from each advisor
</verification>

<success_criteria>
1. PolicyAdvisor produces PolicyRecommendation with rationale chain for all 94 features (AIPI-07)
2. AiAutonomyConfiguration provides 470 config points (AIPI-08)
3. Recommendations respect configured autonomy levels
4. All 5 advisor outputs are consumed by PolicyAdvisor
5. Full SDK build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/77-ai-policy-intelligence/77-04-SUMMARY.md`
</output>
