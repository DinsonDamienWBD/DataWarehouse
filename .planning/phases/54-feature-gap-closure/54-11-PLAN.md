---
phase: 54-feature-gap-closure
plan: 11
type: execute
wave: 3
depends_on: [54-08]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/SaaS/**
  - Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/Legacy/**
  - Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/IoT/**
  - Plugins/DataWarehouse.Plugins.UniversalObservability/Strategies/**
  - Plugins/DataWarehouse.Plugins.UniversalDashboards/**
autonomous: true

must_haves:
  truths:
    - "SaaS connectors (Salesforce, ServiceNow, SAP, Jira) have real API integrations"
    - "Observability RUM and synthetic monitoring strategies functional"
    - "Dashboard framework has persistence and real-time data transport"
    - "Remaining aspirational features have at least scaffolding implementations"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/SaaS/"
      provides: "Top SaaS connector integrations"
    - path: "Plugins/DataWarehouse.Plugins.UniversalDashboards/"
      provides: "Dashboard framework with persistence"
  key_links:
    - from: "UniversalDashboards"
      to: "storage.* bus topics"
      via: "dashboard data persistence"
      pattern: "storage\\.write|storage\\.read"
---

<objective>
Major Gaps: Remaining Connectors, Dashboards, Aspirational Features — final batch of metadata-only features.

Purpose: Close remaining major gaps that were not covered in Plans 09-10. SaaS/legacy/IoT connectors, dashboard framework, observability advanced features, and sustainability features. These represent the long tail of features that need at least functional implementations.

SCOPE LIMITATION: Focus on the next 50 most impactful features. Truly niche features (legacy mainframe, DNA backup, RTOS bridges) are deferred to Phase 54 follow-up plans if needed.

Output: ~50 additional features moved from <20% to functional implementations.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/42-feature-verification-matrix/domains-14-17-summary.md
@.planning/phases/42-feature-verification-matrix/domains-9-13-summary.md
@.planning/phases/54-feature-gap-closure/54-08-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SaaS/IoT/Legacy Connectors + Observability Advanced (30 features)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/SaaS/**
    Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/Legacy/**
    Plugins/DataWarehouse.Plugins.UltimateConnector/Strategies/IoT/**
    Plugins/DataWarehouse.Plugins.UniversalObservability/Strategies/**
  </files>
  <action>
Implement remaining high-value connectors and observability features.

**SaaS Connectors (10 — highest impact)**:
- Salesforce (5%): Use Salesforce REST API via SharedHttpClient. SOQL queries, CRUD on SObjects, bulk API for large data, streaming API (PushTopic/CDC), OAuth 2.0 JWT bearer flow.
- ServiceNow (5%): REST Table API via SharedHttpClient. CRUD on records, catalog management, incident/change request management, scripted REST APIs.
- SAP (5%): RFC/BAPI via P/Invoke to SAP .NET Connector (NCo) or OData via SharedHttpClient. Read/write to SAP tables, IDOC processing.
- Jira (5%): Use Jira REST API v3 via SharedHttpClient. Issue CRUD, JQL search, sprint management, webhook registration.
- Slack (5%): Use Slack Web API via SharedHttpClient. Post messages, channel management, file upload, interactive messages.
- GitHub (5%): Use Octokit.net NuGet. Repository CRUD, issue/PR management, webhook handling, API rate limiting.
- Twilio (5%): Use Twilio NuGet. SMS send, voice call initiation, webhook handling, phone number management.
- SendGrid (5%): Use SendGrid NuGet. Email send (single/batch), template management, webhook for events.
- Stripe (5%): Use Stripe.net NuGet. Customer/charge/subscription management, webhook signature verification.
- Snowflake (5%): Use Snowflake.Data NuGet. SQL execution, warehouse management, data loading (PUT/COPY).

**IoT Protocol Connectors (5)**:
- MQTT broker (complete): Full MQTT 3.1.1/5.0 broker capability via MQTTnet NuGet. Accept connections, manage subscriptions, QoS levels, retained messages.
- CoAP server (5%->60%): Implement CoAP message handling (CON/NON/ACK/RST), resource discovery (.well-known/core), observe pattern, block transfer.
- OPC-UA client (already in IoT): Verify integration with UltimateIoTIntegration, add server-side capability if missing.
- BLE gateway (5%->40%): BLE advertisement scanning, GATT service discovery, characteristic read/write. Platform: Windows.Devices.Bluetooth or BlueZ via D-Bus on Linux.
- LoRa gateway (5%->40%): LoRaWAN packet parsing, device activation (OTAA/ABP), downlink scheduling, ADR management.

**Legacy Connectors (5)**:
- ODBC (5%->80%): Use System.Data.Odbc. Connection via DSN or connection string, parameterized queries, bulk fetch.
- OLE DB (5%->60%): Use System.Data.OleDb. Connection to legacy data sources (Access, Excel via ACE provider).
- FTP/SFTP (5%->80%): Use SSH.NET NuGet for SFTP, FluentFTP NuGet for FTP. File upload/download, directory listing, recursive transfer.
- SMTP (5%->80%): Use MailKit NuGet. Send email with attachments, HTML body, configurable SMTP settings.
- LDAP (5%->70%): Use System.DirectoryServices.Protocols. Bind, search, modify, add/delete entries, paged results.

**Observability Advanced (10)**:
- RUM monitoring strategies (6 at 15-20%): Implement real API integrations for GA4 (Measurement Protocol), Amplitude (HTTP V2 API), Mixpanel (Track API). Event batching, session tracking, user identification.
- Synthetic monitoring (4 at 55%): Complete API integrations for Pingdom (check create/update), UptimeRobot (monitor CRUD), StatusCake (check management). Alert webhook registration.

Pattern: SaaS connectors should use SharedHttpClient pattern. All authentication delegates to UltimateAccessControl for OAuth/API key management. All connectors need retry with exponential backoff and circuit breaker.
  </action>
  <verify>
dotnet build DataWarehouse.slnx — zero errors
SaaS connectors: API calls structured correctly with auth delegation
ODBC/SFTP: connection management and file operations functional
Observability: RUM event ingestion operational
  </verify>
  <done>30 additional connectors and observability features implemented</done>
</task>

<task type="auto">
  <name>Task 2: Dashboard Framework + Sustainability + Remaining Aspirational (20 features)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UniversalDashboards/**
    Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/**
    Plugins/DataWarehouse.Plugins.AirGapBridge/**
  </files>
  <action>
Implement dashboard framework foundation and remaining critical gaps.

**Dashboard Framework (10 features)**:
The UniversalDashboards plugin needs a real framework, not just strategy stubs.

1. Dashboard data model: DashboardDefinition (id, name, owner, widgets[], layout, permissions), WidgetDefinition (id, type, data_source, config, position)
2. Widget types: ChartWidget (line, bar, pie, area — data points array), TableWidget (columns, rows, sorting, pagination), GaugeWidget (current, min, max, thresholds), LogWidget (log entries with severity filtering), MetricWidget (current value, trend, sparkline)
3. Data source abstraction: IDashboardDataSource with implementations — BusTopicDataSource (subscribe to observability bus topic), QueryDataSource (execute query via bus), StaticDataSource (configured values)
4. Persistence: Save/load dashboard definitions via storage bus topic (storage.write/storage.read with key prefix "dashboard::")
5. Real-time updates: Push model via bus subscription — when data source emits new data, dashboard receives notification
6. Multi-tenant isolation: Dashboard ownership scoped to tenant ID, shared dashboards via explicit grants
7. Dashboard templates: Pre-built templates for common use cases — Storage Overview, Security Audit, Replication Status, System Health
8. Export: Dashboard data export to JSON, CSV, PDF report format
9. Dashboard versioning: Version history for definition changes, rollback capability
10. Access control: Dashboard-level permissions via UltimateAccessControl bus delegation

**Sustainability (5 features at 15-20%)**:
- Carbon intensity tracking: WattTime API integration (or similar) for real-time grid carbon intensity. Region-level carbon data caching with TTL.
- Energy consumption estimation: Per-operation energy model (CPU time * TDP / cores, IOPS * watts_per_IOP, network bytes * watts_per_byte). Configurable power coefficients.
- Carbon budget enforcement: Configurable carbon budget per tenant/operation, budget tracking, alert on threshold breach, throttle on exceeded budget.
- Renewable routing preference: Route storage/compute to regions with highest renewable percentage (data from electricity maps API).
- GHG reporting: Scope 1 (direct), Scope 2 (electricity), Scope 3 (upstream) categorization, GHG Protocol-compliant report generation.

**Air-Gap Remaining (5 features at 50-75%)**:
- Classification labels (70%): Add label enforcement — data with higher classification cannot be transferred to lower-classification media
- Software update via physical media (60%): Package signing verification, rollback on failed update, update dependency resolution
- Tamper-evident packaging (75%): Add digital seal verification, chain-of-custody validation at each transfer point
- Offline catalog sync (70%): Bidirectional catalog merge with conflict resolution (LWW), compaction of old versions
- Transfer bandwidth estimation (60%): Calculate estimated transfer time based on media speed, data size, and encryption overhead

Pattern: Dashboard framework uses message bus for all data access. Sustainability uses external APIs with caching and fallback to static data when APIs unavailable.
  </action>
  <verify>
dotnet build DataWarehouse.slnx — zero errors
Dashboard: definition CRUD, widget types, persistence via bus
Sustainability: carbon tracking with API integration
Air-gap: classification enforcement, tamper-evident verification
  </verify>
  <done>Dashboard framework foundation + sustainability + air-gap features completed</done>
</task>

</tasks>

<verification>
- dotnet build DataWarehouse.slnx succeeds with 0 errors, 0 warnings
- dotnet test passes all existing tests
- Dashboard framework has persistence and real-time update capability
</verification>

<success_criteria>
- ~50 additional features implemented
- Dashboard framework functional with widget types and persistence
- Zero build errors or warnings
</success_criteria>

<output>
After completion, create `.planning/phases/54-feature-gap-closure/54-11-SUMMARY.md`
</output>
