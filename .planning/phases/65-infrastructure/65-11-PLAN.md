---
phase: 65-infrastructure
plan: 11
type: execute
wave: 2
depends_on: ["65-09", "65-10"]
files_modified:
  - DataWarehouse.SDK/Security/KeyManagement/CloudKmsProvider.cs
  - DataWarehouse.SDK/Security/KeyManagement/SecretsManagerKeyStore.cs
  - DataWarehouse.SDK/Security/SupplyChain/SlsaVerifier.cs
  - DataWarehouse.SDK/Security/SupplyChain/SlsaProvenanceGenerator.cs
autonomous: true

must_haves:
  truths:
    - "GCP KMS uses Application Default Credentials for key operations"
    - "AWS and GCP Secrets Managers can serve as KeyStore backends"
    - "SLSA Level 3 provenance metadata is generated for build artifacts"
  artifacts:
    - path: "DataWarehouse.SDK/Security/KeyManagement/CloudKmsProvider.cs"
      provides: "GCP KMS ADC integration + AWS KMS"
      min_lines: 150
    - path: "DataWarehouse.SDK/Security/KeyManagement/SecretsManagerKeyStore.cs"
      provides: "AWS Secrets Manager + GCP Secret Manager as IKeyStore"
      min_lines: 150
    - path: "DataWarehouse.SDK/Security/SupplyChain/SlsaProvenanceGenerator.cs"
      provides: "SLSA Level 3 provenance generation"
      min_lines: 100
  key_links:
    - from: "CloudKmsProvider"
      to: "IKeyStore"
      via: "interface implementation"
      pattern: "IKeyStore"
    - from: "SecretsManagerKeyStore"
      to: "IKeyStore"
      via: "interface implementation"
      pattern: "IKeyStore"
---

<objective>
Complete security posture with cloud KMS integration, secrets manager key stores, and SLSA Level 3 supply chain provenance.

Purpose: Security score 91 -> 100 requires: GCP KMS with ADC (not just AWS KMS), cloud secrets managers as KeyStore backends, and SLSA provenance for supply chain verification. These close the final security gaps for Tier 5-7 compliance.

Output: CloudKmsProvider, SecretsManagerKeyStore, SlsaProvenanceGenerator in SDK/Security/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/65-infrastructure/65-09-SUMMARY.md
@.planning/phases/65-infrastructure/65-10-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cloud KMS providers (GCP ADC + AWS)</name>
  <files>
    DataWarehouse.SDK/Security/KeyManagement/CloudKmsProvider.cs
    DataWarehouse.SDK/Security/KeyManagement/SecretsManagerKeyStore.cs
  </files>
  <action>
Create CloudKmsProvider.cs — implements cloud-based key management:

GcpKmsProvider : IKeyStore:
- Uses GCP KMS REST API (no SDK dependency — pure HttpClient)
- Authentication: Application Default Credentials (ADC) pattern
  - Check GOOGLE_APPLICATION_CREDENTIALS env var for service account JSON
  - Check gcloud CLI default credentials (~/.config/gcloud/application_default_credentials.json)
  - Check GCE metadata server (http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token)
  - Token refresh: cache OAuth2 token, refresh 5 min before expiry
- Operations: Encrypt(keyName, plaintext) via POST /v1/{keyName}:encrypt, Decrypt via :decrypt
- Key URL format: projects/{project}/locations/{location}/keyRings/{ring}/cryptoKeys/{key}
- Error handling: retry on 429/503 with exponential backoff, fail on 403 (permission denied)

AwsKmsProvider : IKeyStore (enhance existing if present):
- Uses AWS KMS REST API (Signature V4 signing, no SDK dependency)
- Authentication: default credential chain (env vars, ~/.aws/credentials, instance metadata IMDS v2)
- Operations: Encrypt/Decrypt via POST to kms.{region}.amazonaws.com
- Key ARN format: arn:aws:kms:{region}:{account}:key/{keyId}

Create SecretsManagerKeyStore.cs — cloud secrets managers as IKeyStore:

AwsSecretsManagerKeyStore : IKeyStore:
- Store/retrieve encryption keys from AWS Secrets Manager
- REST API: secretsmanager.{region}.amazonaws.com with SigV4
- GetKeyAsync(keyId) -> calls GetSecretValue, returns secret as byte[]
- StoreKeyAsync(keyId, keyBytes) -> calls CreateSecret or PutSecretValue
- Rotation support: secrets manager handles rotation, we just fetch latest version

GcpSecretManagerKeyStore : IKeyStore:
- Store/retrieve from GCP Secret Manager
- REST API: secretmanager.googleapis.com with OAuth2 bearer token (ADC)
- GetKeyAsync -> GET /v1/projects/{project}/secrets/{secret}/versions/latest:access
- StoreKeyAsync -> POST /v1/projects/{project}/secrets + addVersion

Both key stores:
- Cache secrets locally (in SecureString / pinned memory) with configurable TTL (default 5 min)
- CryptographicOperations.ZeroMemory on cache eviction
- Health check: test connection on startup, periodic revalidation
- Fallback: if cloud unavailable, use local IKeyStore (log warning)
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>GCP KMS (ADC), AWS KMS, AWS Secrets Manager, and GCP Secret Manager all implement IKeyStore with REST-only API calls</done>
</task>

<task type="auto">
  <name>Task 2: SLSA Level 3 provenance generation</name>
  <files>
    DataWarehouse.SDK/Security/SupplyChain/SlsaProvenanceGenerator.cs
    DataWarehouse.SDK/Security/SupplyChain/SlsaVerifier.cs
  </files>
  <action>
Create SlsaProvenanceGenerator.cs:

SLSA (Supply-chain Levels for Software Artifacts) Level 3 provenance:
- Generates in-toto attestation format (DSSE envelope)
- Provenance predicate per SLSA v1.0 spec:
  - buildDefinition: buildType (URI), externalParameters (source repo, branch, commit), internalParameters
  - runDetails: builder (id, version), metadata (invocationId, startedOn, finishedOn)
- Subjects: list of artifacts with digest (SHA-256)

IProvenanceGenerator interface:
- GenerateAsync(ProvenanceRequest request) -> SlsaProvenance
- ProvenanceRequest: ArtifactPaths (list), SourceRepo (Uri), Commit (string), Branch (string), BuilderId (string)
- SlsaProvenance record: Statement (in-toto Statement), Signature (byte[]?), SerializedJson (string)

SlsaProvenanceGenerator implementation:
- Compute SHA-256 digest of each artifact file
- Build in-toto Statement with predicateType "https://slsa.dev/provenance/v1"
- Sign with IKeyStore key if available (RSA-PSS SHA-256 signature)
- Output as JSON (DSSE envelope format)

Create SlsaVerifier.cs:
- IProvenanceVerifier: VerifyAsync(SlsaProvenance provenance, VerificationPolicy policy) -> VerificationResult
- VerificationPolicy: RequiredBuilderId, AllowedSourceRepos, MinSlsaLevel (1/2/3)
- Verification checks:
  - Level 1: provenance exists and is well-formed
  - Level 2: provenance is signed and signature verifies
  - Level 3: provenance builder is in allowed list, source matches allowed repos, no user-controlled build parameters
- VerificationResult: Level (1/2/3), Passed (bool), Findings (list of strings)

Integration: expose via message bus "security.supply-chain.provenance.generate" and "security.supply-chain.provenance.verify".
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>SLSA Level 3 provenance generation and verification exist; in-toto attestation format with DSSE envelope; signed provenance with IKeyStore keys</done>
</task>

</tasks>

<verification>
- Build passes with zero errors
- GcpKmsProvider and AwsKmsProvider implement IKeyStore
- SlsaProvenanceGenerator produces JSON with SLSA v1.0 predicate
- SlsaVerifier validates all 3 levels
</verification>

<success_criteria>
Cloud KMS (GCP ADC + AWS), cloud secrets managers as KeyStore, and SLSA Level 3 provenance complete the security posture to 100.
</success_criteria>

<output>
After completion, create `.planning/phases/65-infrastructure/65-11-SUMMARY.md`
</output>
