---
phase: 65-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Query/ISqlParser.cs
  - DataWarehouse.SDK/Contracts/Query/SqlAst.cs
  - DataWarehouse.SDK/Contracts/Query/SqlTokenizer.cs
  - DataWarehouse.SDK/Contracts/Query/SqlParserEngine.cs
autonomous: true

must_haves:
  truths:
    - "SQL SELECT/FROM/WHERE/JOIN/GROUP BY/ORDER BY/LIMIT/HAVING/DISTINCT can be parsed into a typed AST"
    - "Subqueries and CTEs (WITH) are supported at the AST level"
    - "SQL injection is impossible because the parser produces typed AST nodes, not string concatenation"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Query/ISqlParser.cs"
      provides: "ISqlParser interface with Parse(string sql) -> SqlStatement"
      exports: ["ISqlParser", "SqlStatement"]
    - path: "DataWarehouse.SDK/Contracts/Query/SqlAst.cs"
      provides: "Full AST node hierarchy: SelectStatement, JoinClause, WhereClause, GroupByClause, OrderByClause, Expression nodes"
      min_lines: 200
    - path: "DataWarehouse.SDK/Contracts/Query/SqlTokenizer.cs"
      provides: "Tokenizer that converts SQL text into token stream"
      min_lines: 150
    - path: "DataWarehouse.SDK/Contracts/Query/SqlParserEngine.cs"
      provides: "Recursive descent parser producing SqlStatement AST"
      min_lines: 400
  key_links:
    - from: "SqlParserEngine"
      to: "SqlTokenizer"
      via: "token stream consumption"
      pattern: "SqlTokenizer.*Tokenize"
    - from: "SqlParserEngine"
      to: "SqlAst"
      via: "AST node construction"
      pattern: "new.*SelectStatement|new.*JoinClause"
---

<objective>
Build a production-ready SQL parser in the SDK that converts SQL text into typed AST nodes.

Purpose: Foundation for the query engine. Every subsequent query plan (cost-based planner, columnar scan, federated queries) consumes the AST produced here. The existing SqlOverObjectPlugin has basic query support but lacks a proper parser -- it uses regex-based parsing. This replaces that with a real recursive-descent parser.

Output: ISqlParser contract + SqlTokenizer + SqlParserEngine + full SqlAst node hierarchy in DataWarehouse.SDK/Contracts/Query/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@Plugins/DataWarehouse.Plugins.Virtualization.SqlOverObject/SqlOverObjectPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL AST node hierarchy and ISqlParser contract</name>
  <files>
    DataWarehouse.SDK/Contracts/Query/ISqlParser.cs
    DataWarehouse.SDK/Contracts/Query/SqlAst.cs
  </files>
  <action>
Create DataWarehouse.SDK/Contracts/Query/ folder. Define ISqlParser interface:
- `SqlStatement Parse(string sql)` — throws SqlParseException on invalid SQL
- `bool TryParse(string sql, out SqlStatement? result, out string? error)`

Define SqlAst.cs with the full AST node hierarchy using C# records:
- SqlStatement (base: SelectStatement, InsertStatement, UpdateStatement, DeleteStatement — only SELECT needs full implementation now, others are placeholder records)
- SelectStatement: Distinct, Columns (list of SelectColumn), From (TableReference), Joins (list of JoinClause), Where (Expression?), GroupBy (list of Expression), Having (Expression?), OrderBy (list of OrderByItem), Limit (int?), Offset (int?), Ctes (list of CteDefinition)
- SelectColumn: Expression + Alias
- TableReference: TableName, Schema, Alias; SubqueryTableReference
- JoinClause: JoinType (Inner/Left/Right/Full/Cross), TableReference, OnCondition (Expression)
- Expression hierarchy: LiteralExpression (string/int/decimal/bool/null), ColumnReference (table, column), BinaryExpression (left, op, right), UnaryExpression, FunctionCallExpression (name, args, distinct), InExpression, BetweenExpression, LikeExpression, IsNullExpression, ExistsExpression, SubqueryExpression, CaseExpression, CastExpression
- OrderByItem: Expression, Ascending/Descending
- CteDefinition: Name, ColumnAliases, Query
- BinaryOperator enum: And, Or, Equals, NotEquals, LessThan, GreaterThan, LessOrEqual, GreaterOrEqual, Plus, Minus, Multiply, Divide, Modulo
- SqlParseException with Line, Column, Token context

Use records for immutability. All types in namespace DataWarehouse.SDK.Contracts.Query.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>ISqlParser interface exists, SqlAst.cs has 25+ record types covering full SQL SELECT syntax including CTEs and subqueries</done>
</task>

<task type="auto">
  <name>Task 2: SQL tokenizer and recursive-descent parser</name>
  <files>
    DataWarehouse.SDK/Contracts/Query/SqlTokenizer.cs
    DataWarehouse.SDK/Contracts/Query/SqlParserEngine.cs
  </files>
  <action>
Create SqlTokenizer.cs:
- SqlToken record: Type (enum: Keyword, Identifier, Number, String, Operator, Punctuation, Eof), Value (string), Line (int), Column (int)
- SqlTokenType enum covering all SQL keywords (SELECT, FROM, WHERE, JOIN, LEFT, RIGHT, INNER, FULL, CROSS, ON, GROUP, BY, ORDER, ASC, DESC, LIMIT, OFFSET, HAVING, DISTINCT, AS, AND, OR, NOT, IN, BETWEEN, LIKE, IS, NULL, EXISTS, CASE, WHEN, THEN, ELSE, END, CAST, WITH, UNION, ALL, INSERT, UPDATE, DELETE, SET, VALUES, INTO, TRUE, FALSE, COUNT, SUM, AVG, MIN, MAX)
- Tokenize(string sql) -> IReadOnlyList<SqlToken> — handles quoted identifiers ("table"), string literals ('value'), numeric literals (int/decimal), operators (=, <>, <, >, <=, >=, +, -, *, /, %), punctuation (., comma, parens, semicolon)
- Case-insensitive keyword matching

Create SqlParserEngine.cs implementing ISqlParser:
- Recursive descent parser consuming SqlToken stream
- ParseSelectStatement() — full SELECT with CTE support
- ParseExpression() with operator precedence (OR < AND < NOT < comparison < addition < multiplication < unary < primary)
- ParseJoinClause() — detects join type from keywords
- ParseGroupBy(), ParseOrderBy(), ParseHaving()
- ParseFunctionCall() — recognizes aggregate functions (COUNT, SUM, AVG, MIN, MAX) and arbitrary function names
- ParseSubquery() — subquery in FROM, WHERE, and SELECT
- ParseCte() — WITH name AS (select)
- Clear error messages with line/column: "Expected 'FROM' after column list at line 1, column 25"

Do NOT use regex for parsing — this must be a proper token-based parser. Use ReadOnlySpan<char> for the tokenizer hot path where possible.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors. Write a quick test: `new SqlParserEngine().Parse("SELECT a, b FROM t1 JOIN t2 ON t1.id = t2.id WHERE a > 5 GROUP BY a ORDER BY b DESC LIMIT 10")` produces correct AST</verify>
  <done>SqlParserEngine can parse SELECT/JOIN/WHERE/GROUP BY/ORDER BY/LIMIT/HAVING/DISTINCT/CTEs into typed AST nodes; SqlTokenizer handles all SQL token types</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- SqlParserEngine.Parse("SELECT * FROM t") returns SelectStatement with wildcard column and TableReference "t"
- SqlParserEngine.Parse("SELECT a FROM t1 INNER JOIN t2 ON t1.id = t2.id WHERE a > 5 GROUP BY a HAVING COUNT(*) > 1 ORDER BY a DESC LIMIT 10") produces correct full AST
- SqlParserEngine.Parse("WITH cte AS (SELECT id FROM t) SELECT * FROM cte") handles CTEs
- Invalid SQL produces SqlParseException with line/column info
</verification>

<success_criteria>
ISqlParser contract, SqlAst (25+ record types), SqlTokenizer, and SqlParserEngine exist in DataWarehouse.SDK/Contracts/Query/. Parser handles full ANSI SQL SELECT syntax. Build passes.
</success_criteria>

<output>
After completion, create `.planning/phases/65-infrastructure/65-01-SUMMARY.md`
</output>
