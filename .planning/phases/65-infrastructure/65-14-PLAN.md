---
phase: 65-infrastructure
plan: 14
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Interface/DynamicApiGenerator.cs
  - DataWarehouse.SDK/Contracts/Interface/OpenApiSpecGenerator.cs
  - DataWarehouse.SDK/Contracts/Interface/GrpcServiceGenerator.cs
  - DataWarehouse.SDK/Contracts/Interface/GraphQlSchemaGenerator.cs
  - DataWarehouse.SDK/Contracts/Interface/WebSocketApiGenerator.cs
autonomous: true

must_haves:
  truths:
    - "OpenAPI spec is auto-generated from registered plugin capabilities"
    - "gRPC service definitions are generated from capability metadata"
    - "GraphQL schema is generated from plugin data models"
    - "WebSocket API endpoints are generated for streaming capabilities"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Interface/DynamicApiGenerator.cs"
      provides: "Core API generation engine from capability registry"
      min_lines: 150
    - path: "DataWarehouse.SDK/Contracts/Interface/OpenApiSpecGenerator.cs"
      provides: "OpenAPI 3.1 spec generation"
      min_lines: 200
    - path: "DataWarehouse.SDK/Contracts/Interface/GrpcServiceGenerator.cs"
      provides: "gRPC .proto generation from capabilities"
      min_lines: 150
    - path: "DataWarehouse.SDK/Contracts/Interface/GraphQlSchemaGenerator.cs"
      provides: "GraphQL SDL generation from data models"
      min_lines: 150
  key_links:
    - from: "DynamicApiGenerator"
      to: "IPluginCapabilityRegistry"
      via: "capability consumption"
      pattern: "IPluginCapabilityRegistry|GetCapabilities"
    - from: "OpenApiSpecGenerator"
      to: "DynamicApiGenerator"
      via: "API model consumption"
      pattern: "DynamicApiModel|ApiEndpoint"
---

<objective>
Build dynamic API generation that auto-creates gRPC, GraphQL, WebSocket, and OpenAPI definitions from plugin capabilities.

Purpose: Phase 31 built DynamicCommandRegistry for CLI. This extends dynamic capability wiring to API protocols. When a plugin registers capabilities, corresponding gRPC services, GraphQL types, WebSocket channels, and OpenAPI paths are auto-generated — no manual API definition needed.

Output: DynamicApiGenerator + protocol-specific generators in SDK/Contracts/Interface/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.Shared/DynamicCommandRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dynamic API model and OpenAPI spec generator</name>
  <files>
    DataWarehouse.SDK/Contracts/Interface/DynamicApiGenerator.cs
    DataWarehouse.SDK/Contracts/Interface/OpenApiSpecGenerator.cs
  </files>
  <action>
Create DynamicApiGenerator.cs:
- Reads IPluginCapabilityRegistry to discover all registered capabilities
- Converts capabilities into DynamicApiModel:
  - DynamicApiModel: Endpoints (list of ApiEndpoint), DataTypes (list of ApiDataType)
  - ApiEndpoint: Path (string), Method (GET/POST/PUT/DELETE), PluginId, CapabilityName, Description, Parameters (list of ApiParameter), RequestBody (ApiDataType?), ResponseBody (ApiDataType?), IsStreaming (bool)
  - ApiParameter: Name, Type (string/int/bool/datetime), Required (bool), Description, In (path/query/header)
  - ApiDataType: Name, Properties (dict of ApiProperty), IsArray (bool)
  - ApiProperty: Name, Type, Nullable, Description
- Convention-based endpoint generation:
  - Storage plugin capabilities -> GET/POST/PUT/DELETE /api/v1/storage/{key}
  - Query capabilities -> POST /api/v1/query
  - Management capabilities -> GET/PUT /api/v1/manage/{plugin}/{capability}
  - Streaming capabilities -> WebSocket /ws/v1/{plugin}/{capability}
- Auto-update: subscribe to capability change events, regenerate model on changes

Create OpenApiSpecGenerator.cs:
- Takes DynamicApiModel, produces OpenAPI 3.1 JSON spec
- Spec structure:
  - openapi: "3.1.0"
  - info: title "DataWarehouse API", version from SDK version
  - servers: [{url: configured base URL}]
  - paths: generated from ApiEndpoints
  - components/schemas: generated from ApiDataTypes
  - security: Bearer JWT scheme
  - tags: one per plugin (grouped endpoints)
- Each path has: operationId, summary, description, parameters, requestBody, responses (200/400/401/404/500)
- Schema references: use $ref for shared types
- Output: string (JSON), served at /api/openapi.json
- Swagger UI integration hint: serve SwaggerUI static files at /api/docs (actual serving done by Launcher HTTP layer)
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>DynamicApiGenerator converts capabilities to API model; OpenApiSpecGenerator produces valid OpenAPI 3.1 JSON</done>
</task>

<task type="auto">
  <name>Task 2: gRPC, GraphQL, and WebSocket API generators</name>
  <files>
    DataWarehouse.SDK/Contracts/Interface/GrpcServiceGenerator.cs
    DataWarehouse.SDK/Contracts/Interface/GraphQlSchemaGenerator.cs
    DataWarehouse.SDK/Contracts/Interface/WebSocketApiGenerator.cs
  </files>
  <action>
Create GrpcServiceGenerator.cs:
- Takes DynamicApiModel, generates .proto file content (protobuf IDL)
- syntax = "proto3"; package datawarehouse.v1;
- For each plugin: generate a service with RPCs corresponding to capabilities
  - Storage: rpc Store(StoreRequest) returns (StoreResponse), rpc Retrieve(RetrieveRequest) returns (RetrieveResponse), rpc Delete(DeleteRequest) returns (DeleteResponse)
  - Query: rpc ExecuteQuery(QueryRequest) returns (stream QueryResultBatch) — server streaming for large results
  - Management: rpc GetCapabilities(Empty) returns (CapabilityList)
- Message types generated from ApiDataTypes -> protobuf messages
- Type mapping: string->string, int->int32, long->int64, bool->bool, byte[]->bytes, datetime->google.protobuf.Timestamp
- Output: GenerateProtoFile(DynamicApiModel model) -> string (.proto content)
- Also generate: GrpcServiceDescriptor for runtime reflection-based serving (no build-time codegen needed)

Create GraphQlSchemaGenerator.cs:
- Takes DynamicApiModel, generates GraphQL SDL (Schema Definition Language)
- Query type: read operations (Get, List, Search per capability)
- Mutation type: write operations (Store, Delete, Execute per capability)
- Subscription type: streaming capabilities (real-time events per plugin)
- Object types from ApiDataTypes
- Type mapping: string->String, int->Int, long->Int (or custom scalar BigInt), bool->Boolean, datetime->DateTime (custom scalar)
- Pagination: all list queries return Connection type (edges, pageInfo, totalCount)
- Output: GenerateSchema(DynamicApiModel model) -> string (SDL content)

Create WebSocketApiGenerator.cs:
- Takes DynamicApiModel, generates WebSocket channel definitions
- WebSocketChannelDefinition: Path (/ws/v1/{plugin}/{capability}), MessageType (JSON schema), Direction (ServerToClient/ClientToServer/Bidirectional)
- For streaming capabilities: server-to-client channels
- For command capabilities: bidirectional channels (send command, receive response)
- Message envelope: { "type": "event|command|response", "channel": "...", "payload": {...}, "correlationId": "..." }
- Output: GenerateChannelDefinitions(DynamicApiModel model) -> IReadOnlyList<WebSocketChannelDefinition>
- Also: GenerateClientSdkTypescript(IReadOnlyList<WebSocketChannelDefinition>) -> string — TypeScript type definitions for web clients
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>gRPC .proto generation, GraphQL SDL generation, and WebSocket channel definitions all auto-generated from plugin capabilities</done>
</task>

</tasks>

<verification>
- Build passes with zero errors
- OpenAPI spec contains paths for storage, query, management
- gRPC proto has service definitions with streaming RPCs
- GraphQL schema has Query, Mutation, Subscription types
</verification>

<success_criteria>
Dynamic API generation produces OpenAPI 3.1, gRPC .proto, GraphQL SDL, and WebSocket channel definitions from live plugin capabilities.
</success_criteria>

<output>
After completion, create `.planning/phases/65-infrastructure/65-14-SUMMARY.md`
</output>
