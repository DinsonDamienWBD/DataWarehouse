---
phase: 65-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["65-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/Query/IQueryPlanner.cs
  - DataWarehouse.SDK/Contracts/Query/QueryPlan.cs
  - DataWarehouse.SDK/Contracts/Query/CostBasedQueryPlanner.cs
  - DataWarehouse.SDK/Contracts/Query/QueryOptimizer.cs
autonomous: true

must_haves:
  truths:
    - "SQL AST is transformed into a physical query plan with cost estimates"
    - "Join ordering is optimized based on estimated cardinalities"
    - "Predicate pushdown moves filters as close to data sources as possible"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Query/IQueryPlanner.cs"
      provides: "IQueryPlanner interface"
      exports: ["IQueryPlanner"]
    - path: "DataWarehouse.SDK/Contracts/Query/QueryPlan.cs"
      provides: "Physical plan nodes: TableScan, IndexScan, Filter, HashJoin, NestedLoopJoin, Sort, Aggregate, Limit, Project"
      min_lines: 150
    - path: "DataWarehouse.SDK/Contracts/Query/CostBasedQueryPlanner.cs"
      provides: "Cost-based planner with cardinality estimation and join reordering"
      min_lines: 300
  key_links:
    - from: "CostBasedQueryPlanner"
      to: "SqlAst"
      via: "AST consumption"
      pattern: "SelectStatement|JoinClause"
    - from: "CostBasedQueryPlanner"
      to: "QueryPlan"
      via: "plan node construction"
      pattern: "new.*TableScan|new.*HashJoin"
---

<objective>
Build a cost-based query planner that transforms SQL AST into optimized physical execution plans.

Purpose: Without a planner, queries execute naively (e.g., scanning all data, wrong join order). The planner uses statistics (row counts, column cardinality, data size) to choose optimal execution strategies. This is the brain of the query engine.

Output: IQueryPlanner + QueryPlan node hierarchy + CostBasedQueryPlanner + QueryOptimizer in SDK/Contracts/Query/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/65-infrastructure/65-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Query plan nodes and IQueryPlanner contract</name>
  <files>
    DataWarehouse.SDK/Contracts/Query/IQueryPlanner.cs
    DataWarehouse.SDK/Contracts/Query/QueryPlan.cs
  </files>
  <action>
Create IQueryPlanner.cs:
- `QueryPlanNode Plan(SelectStatement statement, ITableStatisticsProvider? stats = null)` — transforms AST to physical plan
- `QueryPlanNode Optimize(QueryPlanNode plan)` — applies optimization rules to existing plan

Create ITableStatisticsProvider:
- `TableStatistics? GetStatistics(string tableName)` — returns row count, size, column cardinalities
- TableStatistics record: TableName, RowCount (long), SizeBytes (long), Columns (dict of ColumnStatistics)
- ColumnStatistics record: DistinctCount (long), NullCount (long), MinValue (object?), MaxValue (object?), AvgSize (int)

Create QueryPlan.cs with physical plan node hierarchy (abstract record QueryPlanNode with EstimatedRows, EstimatedCost):
- TableScanNode: TableName, Columns (projection list)
- IndexScanNode: TableName, IndexName, Columns, KeyRange
- FilterNode: Input (QueryPlanNode), Predicate (Expression)
- ProjectNode: Input, Columns
- HashJoinNode: Left, Right, LeftKey, RightKey, JoinType
- NestedLoopJoinNode: Left, Right, Condition, JoinType
- MergeJoinNode: Left, Right, LeftKey, RightKey (requires sorted input)
- SortNode: Input, OrderBy (list of OrderByItem)
- AggregateNode: Input, GroupByKeys, Aggregations (list of AggregateFunction)
- LimitNode: Input, Limit, Offset
- UnionNode: Inputs (list), All (bool)
- AggregateFunction record: FunctionName (COUNT/SUM/AVG/MIN/MAX), Argument (Expression), Alias

All nodes are C# records for immutability. Each has EstimatedRows and EstimatedCost (double) computed by the planner.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>IQueryPlanner, ITableStatisticsProvider, and 11 physical plan node types exist</done>
</task>

<task type="auto">
  <name>Task 2: Cost-based planner and optimizer rules</name>
  <files>
    DataWarehouse.SDK/Contracts/Query/CostBasedQueryPlanner.cs
    DataWarehouse.SDK/Contracts/Query/QueryOptimizer.cs
  </files>
  <action>
Create CostBasedQueryPlanner.cs implementing IQueryPlanner:
- Converts SelectStatement AST to initial logical plan (naive: full scan + filter + join in declaration order)
- Estimates cardinalities: without stats, assume 1000 rows per table; with stats, use actual row counts
- Selectivity estimation: equality = 1/distinct_count, range = 0.33, LIKE = 0.1, AND = product, OR = sum - product
- Join cost model: HashJoin cost = build_side_rows * hash_cost + probe_side_rows * probe_cost; NestedLoop = left * right; choose smaller side for hash build
- Join reordering: for 2-3 joins, enumerate all orderings and pick lowest cost; for 4+ joins, use greedy heuristic (always join smallest intermediate result next)
- Applies optimizer rules after initial plan

Create QueryOptimizer.cs with optimization rules:
- PredicatePushdown: move filter nodes below joins where possible (filter references only one join side)
- ProjectionPushdown: push column projections to table scans (avoid materializing unused columns)
- ConstantFolding: evaluate constant expressions at plan time (e.g., 1+1 -> 2, 'a' = 'a' -> true)
- JoinTypeSelection: choose HashJoin vs NestedLoop vs MergeJoin based on cost (NestedLoop for small right side < 100 rows, MergeJoin when both inputs pre-sorted, HashJoin default)
- RedundantFilterElimination: remove always-true filters, short-circuit always-false

Each rule is a Func<QueryPlanNode, QueryPlanNode> applied in sequence. The optimizer iterates until no rule changes the plan (fixed point) with max 10 iterations safety.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors. Verify: plan a SELECT with JOIN produces HashJoinNode with smaller table as build side</verify>
  <done>CostBasedQueryPlanner produces optimized plans with predicate pushdown, join reordering, and projection elimination; QueryOptimizer applies 5 rules</done>
</task>

</tasks>

<verification>
- Build passes with zero errors
- Planning "SELECT a FROM t1 JOIN t2 ON t1.id = t2.id WHERE t1.x > 5" produces: Filter pushed below join, projection includes only 'a' and join keys
- Join ordering with 3 tables picks cheapest order based on statistics
</verification>

<success_criteria>
Cost-based query planner in SDK/Contracts/Query/ transforms AST to optimized physical plans with cardinality estimation, predicate pushdown, and join reordering.
</success_criteria>

<output>
After completion, create `.planning/phases/65-infrastructure/65-02-SUMMARY.md`
</output>
