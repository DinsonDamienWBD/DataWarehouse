---
phase: 65-infrastructure
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.Transcoding.Media/**
  - DataWarehouse.SDK/VirtualDisk/**
  - DataWarehouse.SDK/Distributed/RaftConsensusEngine.cs
  - Plugins/DataWarehouse.Plugins.Raft/**
autonomous: true

must_haves:
  truths:
    - "PNG compression uses proper deflate (not placeholder)"
    - "VDE supports concurrent writes (not single SemaphoreSlim(1,1))"
    - "Raft log entries persist to disk (not just in-memory)"
    - "Multi-Raft supports multiple independent consensus groups"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.Transcoding.Media/"
      provides: "Fixed PNG compression"
    - path: "DataWarehouse.SDK/VirtualDisk/"
      provides: "Concurrent write support"
    - path: "DataWarehouse.SDK/Distributed/RaftConsensusEngine.cs"
      provides: "Persistent Raft log"
  key_links:
    - from: "RaftConsensusEngine"
      to: "IRaftLogStore"
      via: "log persistence"
      pattern: "IRaftLogStore|AppendLog|GetLog"
---

<objective>
Fix medium-impact performance issues: PNG compression bug, VDE write concurrency, Raft persistence, Multi-Raft groups.

Purpose: Phase 46 found VDE serializes ALL writes through SemaphoreSlim(1,1) — major bottleneck. Raft uses in-memory log (data loss on restart). PNG compression was identified as a bug in Phase 44. Multi-Raft was noted as single-group only in Phase 45. These fixes are needed for Tier 5-7 production readiness.

Output: Fixes across media, VDE, and distributed subsystems.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: PNG compression fix + VDE concurrent writes</name>
  <files>
    Plugins/DataWarehouse.Plugins.Transcoding.Media/**
    DataWarehouse.SDK/VirtualDisk/**
  </files>
  <action>
1. PNG compression fix (Phase 44 finding):
   - Find PNG-related code in Transcoding.Media plugin
   - The finding was "mock transcoding" and "PNG compression bug"
   - Ensure PNG encoding uses proper deflate compression via System.IO.Compression.DeflateStream
   - PNG format: magic bytes (8), IHDR chunk (width, height, bit depth, color type), IDAT chunks (deflate-compressed filtered scanlines), IEND chunk
   - Filter selection: use Sub filter (type 1) as default — simple, decent compression
   - CRC32 for each chunk (use System.IO.Hashing.Crc32 or manual implementation)
   - If existing code already handles PNG properly but has a specific bug, fix that bug instead

2. VDE concurrent write support (Phase 46 critical finding):
   - Find the SemaphoreSlim(1,1) write lock in VDE (likely in VirtualDiskEngine.cs or WriteAheadLog.cs)
   - Replace single write lock with per-block range locking:
     - Create BlockRangeLock class: dictionary of block_number -> SemaphoreSlim
     - AcquireBlockRange(long startBlock, long blockCount) — acquires locks for affected blocks only
     - ReleaseBlockRange(long startBlock, long blockCount) — releases locks
     - Writes to different blocks proceed in parallel
     - Writes to same block are serialized (correct behavior)
   - Keep WAL serialization for log append (WAL is append-only, single writer is correct)
   - BitmapAllocator: integrate ExtentTree for O(log N) allocation instead of O(N) bitmap scan
     - ExtentTree already exists per Phase 46 notes — it's just not wired into allocation path
     - Wire ExtentTree.FindFreeExtent() into BitmapAllocator.Allocate()
  </action>
  <verify>dotnet build — zero errors. Grep for "SemaphoreSlim(1, 1)" or "SemaphoreSlim(1,1)" in VDE to confirm single write lock removed from data path</verify>
  <done>PNG uses proper deflate compression, VDE uses per-block locking for concurrent writes, BitmapAllocator uses ExtentTree for O(log N) allocation</done>
</task>

<task type="auto">
  <name>Task 2: Raft log persistence + Multi-Raft groups</name>
  <files>
    DataWarehouse.SDK/Distributed/RaftConsensusEngine.cs
    Plugins/DataWarehouse.Plugins.Raft/**
  </files>
  <action>
1. Raft log persistence:
   - Create IRaftLogStore interface in SDK: AppendAsync(RaftLogEntry entry), GetAsync(long index) -> RaftLogEntry?, GetRangeAsync(long fromIndex, long toIndex) -> IReadOnlyList<RaftLogEntry>, TruncateFromAsync(long index), GetLastIndexAsync() -> long, GetLastTermAsync() -> long
   - Create FileRaftLogStore : IRaftLogStore — stores log entries as binary records in an append-only file
     - Format: [length:4 bytes][term:8 bytes][index:8 bytes][command:variable] per entry
     - Index file for O(1) lookup by log index: [offset:8 bytes] per entry
     - Uses FileStream with FileOptions.WriteThrough for durability
     - Truncate implemented by updating index file and marking data file truncation point
   - Create InMemoryRaftLogStore : IRaftLogStore — keeps existing in-memory behavior for testing/single-node
   - Update RaftConsensusEngine to accept IRaftLogStore via constructor injection
   - Default: InMemoryRaftLogStore (backward compat), FileRaftLogStore when persistence path configured
   - Also persist: currentTerm, votedFor (in separate metadata file, fsync on every write)

2. Multi-Raft group support:
   - Create MultiRaftManager class:
     - Dictionary<string, RaftConsensusEngine> groups — one Raft instance per group
     - CreateGroup(string groupId, RaftConfiguration config) -> RaftConsensusEngine
     - GetGroup(string groupId) -> RaftConsensusEngine?
     - RemoveGroup(string groupId)
   - Each group has independent leader election, log, and state machine
   - Group routing: use jump consistent hash (already exists per Phase 41.1 decision) to assign keys to groups
   - Shared transport layer: multiplex messages by prepending groupId header
   - Group creation is dynamic: new groups can be created at runtime
   - Default: single group named "default" for backward compatibility
  </action>
  <verify>dotnet build — zero errors. RaftConsensusEngine constructor accepts IRaftLogStore</verify>
  <done>Raft log persists to disk via FileRaftLogStore, MultiRaftManager supports multiple independent consensus groups, backward compatible with single-group default</done>
</task>

</tasks>

<verification>
- Full solution build passes
- IRaftLogStore interface and two implementations exist
- MultiRaftManager can create/get/remove groups
- VDE write path uses per-block locking
</verification>

<success_criteria>
Four performance/reliability fixes: PNG compression, VDE concurrency, Raft persistence, Multi-Raft groups.
</success_criteria>

<output>
After completion, create `.planning/phases/65-infrastructure/65-07-SUMMARY.md`
</output>
