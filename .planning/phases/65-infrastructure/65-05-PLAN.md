---
phase: 65-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["65-01", "65-02"]
files_modified:
  - DataWarehouse.SDK/Contracts/Query/FederatedQueryEngine.cs
  - DataWarehouse.SDK/Contracts/Query/IFederatedDataSource.cs
  - DataWarehouse.SDK/Contracts/Query/FederatedQueryPlanner.cs
autonomous: true

must_haves:
  truths:
    - "Queries can span multiple storage backends (SELECT from local JOIN from remote)"
    - "The federated planner pushes filters and projections to remote sources"
    - "Network cost is factored into plan optimization (prefer local scans over remote)"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Query/IFederatedDataSource.cs"
      provides: "Interface for remote/heterogeneous data sources"
      exports: ["IFederatedDataSource", "FederatedDataSourceInfo"]
    - path: "DataWarehouse.SDK/Contracts/Query/FederatedQueryEngine.cs"
      provides: "Federated query execution across multiple backends"
      min_lines: 250
    - path: "DataWarehouse.SDK/Contracts/Query/FederatedQueryPlanner.cs"
      provides: "Planner that accounts for data locality and network cost"
      min_lines: 200
  key_links:
    - from: "FederatedQueryEngine"
      to: "IFederatedDataSource"
      via: "remote data access"
      pattern: "IFederatedDataSource.*Execute"
    - from: "FederatedQueryPlanner"
      to: "CostBasedQueryPlanner"
      via: "extends base planner"
      pattern: "CostBasedQueryPlanner|IQueryPlanner"
---

<objective>
Build federated query support that allows SQL queries to span multiple heterogeneous storage backends.

Purpose: DataWarehouse manages 130+ storage backends. Users need to query across them seamlessly — join local NVMe data with S3 data with database records. The federated engine handles data source routing, remote filter pushdown, and network-aware cost optimization.

Output: IFederatedDataSource, FederatedQueryEngine, FederatedQueryPlanner in SDK/Contracts/Query/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/65-infrastructure/65-01-SUMMARY.md
@.planning/phases/65-infrastructure/65-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Federated data source abstraction</name>
  <files>
    DataWarehouse.SDK/Contracts/Query/IFederatedDataSource.cs
  </files>
  <action>
Create IFederatedDataSource.cs:

IFederatedDataSource interface:
- string SourceId { get; } — unique identifier (e.g., "s3-us-east", "local-nvme", "postgres-analytics")
- FederatedDataSourceInfo GetInfo() — capabilities and cost model
- Task<IAsyncEnumerable<ColumnarBatch>> ExecuteRemoteQueryAsync(string tableName, RemoteQueryRequest request, CancellationToken ct)
- Task<TableStatistics?> GetRemoteStatisticsAsync(string tableName, CancellationToken ct)

FederatedDataSourceInfo record:
- SourceId, SourceType (enum: Local, RemoteStorage, Database, ExternalApi, FederatedNode)
- LatencyMs (double) — estimated round-trip latency
- BandwidthMbps (double) — estimated bandwidth
- SupportsFilterPushdown (bool)
- SupportsProjectionPushdown (bool)
- SupportsAggregationPushdown (bool)
- SupportsJoinPushdown (bool)
- AvailableTables (IReadOnlyList<string>)
- CostMultiplier (double) — 1.0 for local, higher for remote (e.g., 5.0 for cross-region S3)

RemoteQueryRequest record:
- TableName, Columns (projection), Filters (list of Expression), Limit (int?), OrderBy
- This allows the federated source to handle as much as it can natively

IFederatedDataSourceRegistry:
- RegisterSource(IFederatedDataSource source)
- UnregisterSource(string sourceId)
- GetSource(string sourceId) -> IFederatedDataSource?
- GetAllSources() -> IReadOnlyList<IFederatedDataSource>
- ResolveTable(string tableName) -> (IFederatedDataSource source, string remoteTable)?
- Supports dotted table names: "s3_archive.events" resolves to source "s3_archive", table "events"

InMemoryFederatedDataSourceRegistry implementation with ConcurrentDictionary.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>IFederatedDataSource, FederatedDataSourceInfo, RemoteQueryRequest, IFederatedDataSourceRegistry exist with full capability declarations</done>
</task>

<task type="auto">
  <name>Task 2: Federated query planner and execution engine</name>
  <files>
    DataWarehouse.SDK/Contracts/Query/FederatedQueryPlanner.cs
    DataWarehouse.SDK/Contracts/Query/FederatedQueryEngine.cs
  </files>
  <action>
Create FederatedQueryPlanner.cs extending CostBasedQueryPlanner:
- Override cost estimation to include network costs: remote_cost = base_cost * source.CostMultiplier + estimated_rows * bytes_per_row / bandwidth + latency
- Remote filter pushdown: if source.SupportsFilterPushdown, include filter in RemoteQueryRequest instead of local FilterNode
- Remote projection pushdown: if source.SupportsProjectionPushdown, request only needed columns
- Remote aggregation pushdown: if source.SupportsAggregationPushdown AND the aggregation is the final operation, push entire aggregate to remote
- Cross-source join strategy: always pull data to local for joining (no distributed join — too complex for v1); choose which side to pull based on estimated sizes
- FederatedTableScanNode extends TableScanNode: adds SourceId, PushedFilters, PushedProjections

Create FederatedQueryEngine.cs:
- Constructor takes ISqlParser, FederatedQueryPlanner, IFederatedDataSourceRegistry
- ExecuteFederatedQueryAsync(string sql, CancellationToken ct) -> QueryResult
- For FederatedTableScanNode: call source.ExecuteRemoteQueryAsync with pushed filters/projections
- For local TableScanNode: use local IDataSourceProvider
- Parallel remote source execution: when multiple remote scans are independent, issue them concurrently using Task.WhenAll
- Timeout per remote source (configurable, default 30s) — if remote source times out, throw QueryExecutionException with source details
- Progress reporting: QueryProgress callback with (source, rows_fetched, bytes_fetched)
- Wire to message bus: publish "query.federated.execute" with source list and timing

Handle errors gracefully: if one remote source fails, the entire query fails with clear message indicating which source and why. Do NOT silently return partial results.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj — zero errors</verify>
  <done>FederatedQueryPlanner accounts for network costs and pushes operations to remote sources; FederatedQueryEngine executes cross-source queries with parallel remote fetching</done>
</task>

</tasks>

<verification>
- Build passes with zero errors
- FederatedQueryPlanner assigns higher cost to remote sources
- Remote filter pushdown produces RemoteQueryRequest with filters
- Cross-source join pulls smaller side locally
</verification>

<success_criteria>
Federated query infrastructure exists: data sources register with capabilities, planner accounts for network costs and pushes operations remotely, engine executes cross-source queries.
</success_criteria>

<output>
After completion, create `.planning/phases/65-infrastructure/65-05-SUMMARY.md`
</output>
