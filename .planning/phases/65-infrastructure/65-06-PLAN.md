---
phase: 65-infrastructure
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompression/**
  - DataWarehouse.SDK/Distributed/SwimClusterMembership.cs
  - DataWarehouse.SDK/Distributed/Networking/ConnectionPool.cs
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/**
autonomous: true

must_haves:
  truths:
    - "Brotli default quality is Q6 (not Q11) for balanced speed/ratio"
    - "SWIM GetMembers() does not allocate on every call"
    - "TCP and QUIC connections are reused via ConnectionPool"
    - "Reliable UDP has basic congestion control"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/"
      provides: "Brotli Q6 default"
    - path: "DataWarehouse.SDK/Distributed/SwimClusterMembership.cs"
      provides: "Cached member list for GetMembers()"
    - path: "DataWarehouse.SDK/Distributed/Networking/ConnectionPool.cs"
      provides: "Active connection pooling used by TCP/QUIC send methods"
  key_links:
    - from: "AdaptiveTransport TCP/QUIC send"
      to: "ConnectionPool"
      via: "connection reuse"
      pattern: "ConnectionPool.*Get|ConnectionPool.*Return"
---

<objective>
Fix the highest-impact performance issues identified in Phase 46 benchmarks: Brotli Q11 default, SWIM allocation, connection pool dead code, UDP congestion control.

Purpose: Phase 46 benchmarks identified specific bottlenecks. Brotli Q11 is 10-25x slower than needed for default compression. SWIM allocates on every GetMembers() call at 20x/sec. TCP/QUIC create new connections per send despite ConnectionPool existing. Reliable UDP lacks congestion control. These are the quick wins.

Output: Performance fixes across compression, distributed, and transport plugins.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Brotli Q6 default + SWIM member caching</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompression/**
    DataWarehouse.SDK/Distributed/SwimClusterMembership.cs
  </files>
  <action>
1. Brotli default quality fix:
   - Find the Brotli compression strategy in UltimateCompression plugin
   - Change default quality from Q11 (maximum compression, extremely slow) to Q6 (good compression, 10x faster)
   - Make quality configurable via strategy options/configuration (AllowUserToOverride pattern)
   - Add XML doc comment explaining Q6 rationale: "Q6 provides ~90% of Q11 compression ratio at 10-25x faster speed"
   - Verify any BrotliEncoder.Create or BrotliStream usage defaults to Q6

2. SWIM GetMembers() allocation fix:
   - In SwimClusterMembership.cs, find GetMembers() method
   - Currently allocates new collection on every call (20x/sec = 20 allocations/sec)
   - Cache the member list and invalidate only when membership changes (join/leave/suspect events)
   - Use volatile IReadOnlyList<ClusterMember> field, update atomically on change
   - GetMembers() returns cached reference (zero allocation)

3. Compression stats lock -> Interlocked:
   - Find compression statistics counters that use `lock` for thread safety
   - Replace with Interlocked.Increment/Add for counters (no lock needed for simple increments)
   - Keep lock only if there's a multi-field update that must be atomic
  </action>
  <verify>dotnet build — zero errors. Grep for BrotliCompressionLevel.Optimal or quality.*11 to confirm no Q11 defaults remain</verify>
  <done>Brotli defaults to Q6, SWIM GetMembers() is zero-allocation, compression stats use Interlocked</done>
</task>

<task type="auto">
  <name>Task 2: Connection pool integration + UDP congestion control</name>
  <files>
    DataWarehouse.SDK/Distributed/Networking/ConnectionPool.cs
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/**
  </files>
  <action>
1. Wire ConnectionPool into TCP/QUIC send methods:
   - Find TCP send method in AdaptiveTransport plugin (likely TcpTransportStrategy or similar)
   - Currently creates new TcpClient per send — replace with ConnectionPool.GetConnection/ReturnConnection
   - Same for QUIC: find QuicConnection creation per send, replace with pooled connections
   - ConnectionPool should already exist (Phase 46 noted it as "dead code") — verify its API (Get, Return, Dispose) and wire it in
   - Add connection health check: before returning a pooled connection, verify it's still connected (TcpClient.Connected / QuicConnection.Connected)
   - Set pool size: default 10 connections per endpoint, configurable
   - Implement connection eviction: idle connections closed after 60s

2. Reliable UDP congestion control:
   - Find ReliableUdp transport strategy in AdaptiveTransport
   - Currently sends without congestion control (burst amplifies congestion — Phase 46 finding)
   - Implement simple AIMD (Additive Increase Multiplicative Decrease) congestion control:
     - Congestion window starts at 4 segments
     - On ACK: window += 1/window (additive increase)
     - On timeout/loss: window = window / 2 (multiplicative decrease), minimum 1
     - Send rate limited to congestion window * segment_size / RTT
   - Track RTT using EWMA (exponentially weighted moving average): rtt_new = 0.875 * rtt_old + 0.125 * sample
   - This is simple congestion control — not full TCP Reno/Cubic, just enough to prevent burst flooding

3. Connection pool health check integration:
   - Add periodic health check (every 30s) that pings idle connections
   - Remove connections that fail health check
   - Log connection pool utilization at debug level
  </action>
  <verify>dotnet build — zero errors. Grep for "new TcpClient" and "new QuicConnection" to confirm no more per-send creation in hot path</verify>
  <done>TCP/QUIC use pooled connections, Reliable UDP has AIMD congestion control, ConnectionPool is actively used (not dead code)</done>
</task>

</tasks>

<verification>
- Full solution build passes
- No BrotliCompressionLevel.Optimal or Q11 defaults in compression code
- ConnectionPool referenced by TCP/QUIC strategies
- ReliableUdp has congestion window logic
</verification>

<success_criteria>
Four Phase 46 performance findings resolved: Brotli Q6, SWIM caching, connection pooling, UDP congestion control.
</success_criteria>

<output>
After completion, create `.planning/phases/65-infrastructure/65-06-SUMMARY.md`
</output>
