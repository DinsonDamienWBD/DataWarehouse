---
phase: 62-carbon-aware
plan: 05
type: execute
wave: 3
depends_on: ["62-01", "62-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/ColdDataCarbonMigrationStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringPolicyEngine.cs
autonomous: true

must_haves:
  truths:
    - "Cold data (not accessed for configurable period) is identified for green migration"
    - "Green tiering moves cold data to the lowest-carbon backend available"
    - "Migration respects carbon budgets -- won't migrate if tenant budget exhausted"
    - "Migration is batched and scheduled during low-carbon windows"
    - "Policies are configurable per tenant: cold threshold, migration schedule, target green score"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringStrategy.cs"
      provides: "Core green tiering logic: identify cold data, score backends, trigger migration"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/ColdDataCarbonMigrationStrategy.cs"
      provides: "Actual data migration from high-carbon to low-carbon backends"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringPolicyEngine.cs"
      provides: "Per-tenant policy configuration for green tiering"
      min_lines: 120
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringStrategy.cs"
      to: "message bus sustainability.placement.decision"
      via: "requests green scores from placement service"
      pattern: "sustainability\\.placement"
    - from: "Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/ColdDataCarbonMigrationStrategy.cs"
      to: "message bus storage.migrate"
      via: "triggers data migration via storage message bus"
      pattern: "storage\\.migrate"
    - from: "Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringStrategy.cs"
      to: "DataWarehouse.SDK/Contracts/Carbon/ICarbonBudget.cs"
      via: "checks budget before migration"
      pattern: "CanProceedAsync"
---

<objective>
Implement green tiering -- automatically move cold (infrequently accessed) data from high-carbon backends to the lowest-carbon storage available. Respects carbon budgets and schedules migrations during renewable energy windows.

Purpose: Most data becomes cold within days. Moving it to green backends provides the largest ongoing carbon reduction without affecting hot-path performance.

Output: Three strategy files implementing tiering detection, migration execution, and policy configuration.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/62-carbon-aware/62-01-SUMMARY.md
@.planning/phases/62-carbon-aware/62-03-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateSustainability/SustainabilityStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/CarbonAwareness/CarbonAwareSchedulingStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement green tiering policy engine and detection strategy</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringPolicyEngine.cs
    Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/GreenTieringStrategy.cs
  </files>
  <action>
**GreenTieringPolicyEngine.cs**:
- Per-tenant tiering policy stored in `ConcurrentDictionary<string, GreenTieringPolicy>`
- `GreenTieringPolicy` record:
  - `TenantId` (string)
  - `ColdThreshold` (TimeSpan, default 30 days -- data not accessed in this period is cold)
  - `TargetGreenScore` (double, default 80.0 -- minimum green score for target backend)
  - `MigrationSchedule` (GreenMigrationSchedule enum: Immediate, LowCarbonWindowOnly, DailyBatch, WeeklyBatch)
  - `MaxMigrationBatchSizeBytes` (long, default 10GB)
  - `MaxConcurrentMigrations` (int, default 5)
  - `RespectCarbonBudget` (bool, default true)
  - `Enabled` (bool, default true)
- `SetPolicy(string tenantId, GreenTieringPolicy policy)` -- validates and stores
- `GetPolicy(string tenantId)` -- returns policy or default policy for unknown tenants
- `GetEnabledTenants()` -> list of tenants with green tiering enabled
- Persist policies to JSON file at `{dataDir}/green-tiering-policies.json`
- `GreenMigrationSchedule` enum: Immediate, LowCarbonWindowOnly, DailyBatch, WeeklyBatch

**GreenTieringStrategy.cs** -- extends `SustainabilityStrategyBase`:
- Category: Scheduling, Capabilities: Scheduling | CarbonCalculation | ActiveControl
- Core green tiering orchestrator:
- `IdentifyColdDataAsync(string tenantId, CancellationToken ct)`:
  1. Send `storage.list` message on bus requesting all objects for tenant with last-access metadata
  2. Filter objects where `LastAccessed < UtcNow - policy.ColdThreshold`
  3. For each cold object, check current backend's green score
  4. If current green score < policy.TargetGreenScore, mark as migration candidate
  5. Return `IReadOnlyList<GreenMigrationCandidate>` with objectKey, currentBackend, currentGreenScore, size
- `PlanMigrationBatchAsync(IReadOnlyList<GreenMigrationCandidate> candidates, string tenantId, CancellationToken ct)`:
  1. Get available green backends via bus request to `sustainability.placement.scores`
  2. For each candidate, select best green backend (highest score, sufficient capacity)
  3. Estimate carbon cost of migration itself (transferring data consumes energy)
  4. If `RespectCarbonBudget`: check `sustainability.carbon.budget.evaluate` via bus -- skip if would exhaust budget
  5. Batch migrations up to `MaxMigrationBatchSizeBytes`
  6. Return `GreenMigrationBatch` with source/target pairs and estimated carbon impact
- `ShouldMigrateNowAsync(GreenMigrationSchedule schedule, CancellationToken ct)`:
  - Immediate: always true
  - LowCarbonWindowOnly: check current carbon intensity against 24h average (proceed if below average)
  - DailyBatch: check if current hour matches configured batch hour (default 02:00 UTC)
  - WeeklyBatch: check if current day is configured batch day (default Sunday) AND hour matches
- Background timer: every 15 minutes, runs `IdentifyColdDataAsync` for each enabled tenant, plans batches, and queues for migration
- `GreenMigrationCandidate` record: ObjectKey, CurrentBackendId, CurrentGreenScore, SizeBytes, LastAccessed, TenantId
- `GreenMigrationBatch` record: Candidates (list), TargetBackendId, TargetGreenScore, EstimatedCarbonCostGrams, EstimatedEnergyWh, ScheduledFor
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateSustainability/DataWarehouse.Plugins.UltimateSustainability.csproj --no-restore` compiles with 0 errors.</verify>
  <done>Green tiering policy engine and detection strategy compile. Cold data identified, green backends scored, migration batches planned with budget awareness.</done>
</task>

<task type="auto">
  <name>Task 2: Implement cold data carbon migration execution</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateSustainability/Strategies/GreenTiering/ColdDataCarbonMigrationStrategy.cs</files>
  <action>
**ColdDataCarbonMigrationStrategy.cs** -- extends `SustainabilityStrategyBase`:
- Category: Scheduling, Capabilities: ActiveControl | CarbonCalculation | Reporting
- Executes migration batches planned by GreenTieringStrategy
- `ExecuteBatchAsync(GreenMigrationBatch batch, CancellationToken ct)`:
  1. Validate target backend is still available and has capacity (via `storage.health` bus message)
  2. For each candidate in batch (up to MaxConcurrentMigrations in parallel using SemaphoreSlim):
     a. Publish `storage.migrate.request` message with: sourceBackendId, targetBackendId, objectKey, tenantId
     b. Wait for `storage.migrate.response` with success/failure
     c. On success: record carbon savings (difference between source and target backend carbon per byte)
     d. On failure: log, add to retry queue, continue with next
  3. After batch: publish `sustainability.green-tiering.batch.complete` with summary (count migrated, carbon saved, errors)
  4. Track total data migrated, total carbon saved, total errors in statistics
- `GetMigrationHistoryAsync(string? tenantId, int maxEntries)` -> returns recent migration records
- `MigrationRecord` record: ObjectKey, SourceBackendId, TargetBackendId, SizeBytes, CarbonSavedGrams, EnergySavedWh, Timestamp, Success, ErrorMessage?
- Store migration history in bounded `ConcurrentQueue<MigrationRecord>` (max 10,000 entries)
- Carbon savings calculation:
  - sourceCarbonPerByte = sourceGreenScore.CarbonIntensityGCO2ePerKwh * storageEnergyPerByteKwh
  - targetCarbonPerByte = targetGreenScore.CarbonIntensityGCO2ePerKwh * storageEnergyPerByteKwh
  - savings = (sourceCarbonPerByte - targetCarbonPerByte) * sizeBytes * estimatedLifetimeYears
  - Where storageEnergyPerByteKwh = 0.000000006 (6 nWh/byte/year for SSD at rest)
- Generate recommendations:
  - If migration queue growing faster than processing: "Increase MaxConcurrentMigrations"
  - If >50% of data is cold on high-carbon backends: "Consider changing default placement to green backend"
  - If carbon savings significant: report estimated annual savings
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateSustainability/DataWarehouse.Plugins.UltimateSustainability.csproj --no-restore` compiles with 0 errors.</verify>
  <done>Cold data migration strategy compiles, executes batched migrations with parallel execution, carbon savings tracking, and migration history.</done>
</task>

</tasks>

<verification>
- Full solution build passes: `dotnet build DataWarehouse.slnx` with 0 errors
- All 3 new files exist in Strategies/GreenTiering/
- Migration uses message bus (storage.migrate.*) not direct plugin references
- Carbon budget respected before migration
</verification>

<success_criteria>
Green tiering operational: cold data detected, batched for migration during low-carbon windows, migrated to greenest available backend with carbon savings tracked.
</success_criteria>

<output>
After completion, create `.planning/phases/62-carbon-aware/62-05-SUMMARY.md`
</output>
