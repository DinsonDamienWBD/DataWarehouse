---
phase: 69-policy-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceBase.cs
  - DataWarehouse.SDK/Infrastructure/Policy/PolicySerializationHelper.cs
  - DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceConfiguration.cs
autonomous: true

must_haves:
  truths:
    - "PolicyPersistenceBase provides reusable save/load/delete plumbing so implementations only override storage I/O"
    - "PolicySerializationHelper round-trips FeaturePolicy and OperationalProfile to JSON without data loss"
    - "PolicyPersistenceConfiguration selects persistence backend by enum and carries per-backend options"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceBase.cs"
      provides: "Abstract base class implementing IPolicyPersistence with template-method pattern"
      contains: "abstract class PolicyPersistenceBase"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/PolicySerializationHelper.cs"
      provides: "System.Text.Json serialization for FeaturePolicy and OperationalProfile"
      contains: "class PolicySerializationHelper"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceConfiguration.cs"
      provides: "Configuration record selecting backend + per-backend options"
      contains: "record PolicyPersistenceConfiguration"
  key_links:
    - from: "PolicyPersistenceBase"
      to: "IPolicyPersistence"
      via: "implements interface"
      pattern: "PolicyPersistenceBase.*:.*IPolicyPersistence"
    - from: "PolicySerializationHelper"
      to: "FeaturePolicy"
      via: "serializes/deserializes"
      pattern: "Serialize.*FeaturePolicy|Deserialize.*FeaturePolicy"
---

<objective>
Create the base infrastructure for all five IPolicyPersistence implementations: an abstract base class with template-method pattern, JSON serialization helpers for policy types, and a configuration model that selects which persistence backend to use.

Purpose: All five concrete implementations (InMemory, File, Database, TamperProof, Hybrid) will extend PolicyPersistenceBase. Centralizing serialization and key-generation prevents inconsistency across backends.
Output: Three SDK files establishing the persistence foundation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Infrastructure/InMemory/InMemoryAuditTrail.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PolicyPersistenceBase abstract class and serialization helper</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceBase.cs
    DataWarehouse.SDK/Infrastructure/Policy/PolicySerializationHelper.cs
  </files>
  <action>
Create directory `DataWarehouse.SDK/Infrastructure/Policy/`.

**PolicyPersistenceBase.cs** -- Abstract class implementing `IPolicyPersistence` with template-method pattern:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: Policy persistence base (PERS-01)")]`
- `public abstract class PolicyPersistenceBase : IPolicyPersistence`
- Implements all 6 IPolicyPersistence methods by delegating to protected abstract methods:
  - `LoadAllAsync` -> calls `protected abstract Task<IReadOnlyList<(string, PolicyLevel, string, FeaturePolicy)>> LoadAllCoreAsync(CancellationToken ct)`
  - `SaveAsync` -> validates inputs (featureId not null/empty, policy not null), generates composite key via `GenerateKey(featureId, level, path)`, then calls `protected abstract Task SaveCoreAsync(string key, string featureId, PolicyLevel level, string path, byte[] serializedPolicy, CancellationToken ct)`
  - `DeleteAsync` -> validates inputs, generates key, calls `protected abstract Task DeleteCoreAsync(string key, CancellationToken ct)`
  - `SaveProfileAsync` -> validates profile not null, calls `protected abstract Task SaveProfileCoreAsync(byte[] serializedProfile, CancellationToken ct)`
  - `LoadProfileAsync` -> calls `protected abstract Task<byte[]?> LoadProfileCoreAsync(CancellationToken ct)`, deserializes if non-null
  - `FlushAsync` -> calls `protected virtual Task FlushCoreAsync(CancellationToken ct)` (default no-op, override for batched backends)
- Protected helper: `static string GenerateKey(string featureId, PolicyLevel level, string path)` -> returns `$"{featureId}:{(int)level}:{path}"` (deterministic, sortable)
- Uses `PolicySerializationHelper` for all serialization/deserialization
- Full XML documentation on every member
- `using DataWarehouse.SDK.Contracts.Policy;`

**PolicySerializationHelper.cs** -- Static helper class:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: Policy serialization (PERS-01)")]`
- `public static class PolicySerializationHelper`
- Uses `System.Text.Json` with `JsonSerializerOptions` configured for: `PropertyNamingPolicy = JsonNamingPolicy.CamelCase`, `WriteIndented = false`, `Converters` including `JsonStringEnumConverter` for all policy enums
- Methods:
  - `public static byte[] SerializePolicy(FeaturePolicy policy)` -> JSON bytes
  - `public static FeaturePolicy DeserializePolicy(byte[] data)` -> throws `InvalidOperationException` if null result
  - `public static byte[] SerializeProfile(OperationalProfile profile)` -> JSON bytes
  - `public static OperationalProfile DeserializeProfile(byte[] data)` -> throws `InvalidOperationException` if null result
  - `public static byte[] SerializePolicies(IReadOnlyList<(string FeatureId, PolicyLevel Level, string Path, FeaturePolicy Policy)> policies)` -> JSON bytes (for bulk export)
  - `public static IReadOnlyList<(string FeatureId, PolicyLevel Level, string Path, FeaturePolicy Policy)> DeserializePolicies(byte[] data)` -> (for bulk import)
- Internal `JsonSerializerOptions` singleton created via `private static readonly JsonSerializerOptions s_options = CreateOptions();`
- For the tuple serialization, create a private `PolicyEntry` DTO record with FeatureId, Level, Path, Policy properties to make JSON clean
- Full XML documentation
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings. Both files exist under `DataWarehouse.SDK/Infrastructure/Policy/`.
  </verify>
  <done>PolicyPersistenceBase compiles with all 6 interface methods delegating to abstract Core methods. PolicySerializationHelper round-trips FeaturePolicy and OperationalProfile through JSON.</done>
</task>

<task type="auto">
  <name>Task 2: PolicyPersistenceConfiguration model</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceConfiguration.cs
  </files>
  <action>
**PolicyPersistenceConfiguration.cs** -- Configuration model:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: Policy persistence config (PERS-01)")]`

Create enum `PolicyPersistenceBackend`:
- `InMemory = 0` (testing/ephemeral)
- `File = 1` (single-node, VDE sidecar)
- `Database = 2` (multi-node with replication)
- `TamperProof = 3` (blockchain-backed immutable audit)
- `Hybrid = 4` (composite: policies in one backend, audit in another)
Add `[Description]` attributes matching the pattern from PolicyEnums.cs.

Create sealed record `PolicyPersistenceConfiguration`:
- `public PolicyPersistenceBackend Backend { get; init; }` -- which implementation to use
- `public string? ConnectionString { get; init; }` -- for Database backend
- `public string? SidecarDirectory { get; init; }` -- for File backend (null = adjacent to .dwvd)
- `public PolicyPersistenceBackend AuditBackend { get; init; }` -- for Hybrid: which backend stores audit (default TamperProof)
- `public PolicyPersistenceBackend PolicyBackend { get; init; }` -- for Hybrid: which backend stores policies (default Database)
- `public int MaxInMemoryEntries { get; init; } = 100_000` -- for InMemory: bounded capacity
- `public bool EnableReplication { get; init; }` -- for Database: multi-node replication
- `public string? BlockchainEndpoint { get; init; }` -- for TamperProof: blockchain service endpoint
- `public string[] ActiveComplianceFrameworks { get; init; } = Array.Empty<string>()` -- HIPAA, SOC2, GDPR etc. for compliance validation
- Factory methods: `public static PolicyPersistenceConfiguration InMemoryDefault()`, `public static PolicyPersistenceConfiguration FileDefault()`, `public static PolicyPersistenceConfiguration DatabaseDefault()`, `public static PolicyPersistenceConfiguration HybridDefault()`
- Full XML documentation on every member

This record is consumed by compliance validation in Plan 04 and by each implementation's constructor.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings. File exists with enum + record.
  </verify>
  <done>PolicyPersistenceBackend enum and PolicyPersistenceConfiguration record compile cleanly with all backend-specific options and factory methods.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- All 3 files exist under `DataWarehouse.SDK/Infrastructure/Policy/`
- PolicyPersistenceBase implements IPolicyPersistence
- PolicySerializationHelper uses System.Text.Json (NOT Newtonsoft)
- PolicyPersistenceConfiguration has factory methods for all 4 common backends
</verification>

<success_criteria>
- PolicyPersistenceBase abstract class ready for 5 concrete implementations to extend
- Serialization helper handles round-trip of all policy types
- Configuration model captures all backend-specific options
- Zero build errors, zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/69-policy-persistence/69-01-SUMMARY.md`
</output>
