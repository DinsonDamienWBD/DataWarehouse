---
phase: 69-policy-persistence
plan: 04
type: execute
wave: 3
depends_on: ["69-02", "69-03"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/HybridPolicyPersistence.cs
  - DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceComplianceValidator.cs
autonomous: true

must_haves:
  truths:
    - "HybridPolicyPersistence delegates policy storage to one backend and audit to TamperProof independently"
    - "Compliance validator rejects HIPAA config that uses file-only audit store with an actionable error message"
    - "Compliance validator checks GDPR and SOC2 store requirements in addition to HIPAA"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/HybridPolicyPersistence.cs"
      provides: "Composite persistence delegating policies and audit independently"
      contains: "class HybridPolicyPersistence"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceComplianceValidator.cs"
      provides: "Validates persistence config against compliance framework requirements"
      contains: "class PolicyPersistenceComplianceValidator"
  key_links:
    - from: "HybridPolicyPersistence"
      to: "IPolicyPersistence"
      via: "composes two inner implementations"
      pattern: "IPolicyPersistence.*_policyStore|IPolicyPersistence.*_auditStore"
    - from: "PolicyPersistenceComplianceValidator"
      to: "PolicyPersistenceConfiguration"
      via: "validates config against compliance rules"
      pattern: "PolicyPersistenceConfiguration.*config|ActiveComplianceFrameworks"
---

<objective>
Implement HybridPolicyPersistence (composes DB + TamperProof) and PolicyPersistenceComplianceValidator (rejects misconfigured stores for HIPAA/GDPR/SOC2).

Purpose: Hybrid persistence is the recommended production configuration -- policies in a fast database, audit trail in tamper-proof storage. Compliance validation prevents deployment with inadequate persistence for regulated environments.
Output: One composite persistence implementation and one compliance validator.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@.planning/phases/69-policy-persistence/69-01-SUMMARY.md
@.planning/phases/69-policy-persistence/69-02-SUMMARY.md
@.planning/phases/69-policy-persistence/69-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: HybridPolicyPersistence composite implementation</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/HybridPolicyPersistence.cs</files>
  <action>
Create `HybridPolicyPersistence` implementing `IPolicyPersistence` directly (NOT extending base -- same as TamperProof, this is a decorator/composite):
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: Hybrid policy persistence (PERS-06)")]`
- `public sealed class HybridPolicyPersistence : IPolicyPersistence`

Constructor: `public HybridPolicyPersistence(IPolicyPersistence policyStore, IPolicyPersistence auditStore)`
- `_policyStore` handles all CRUD operations for policies and profiles
- `_auditStore` receives a copy of every mutating operation for audit purposes
- Validate neither is null in constructor (throw `ArgumentNullException`)

Implement IPolicyPersistence:
- `LoadAllAsync`: Delegate to `_policyStore.LoadAllAsync(ct)` only. Audit store is write-only for policies.
- `SaveAsync`: First `await _policyStore.SaveAsync(featureId, level, path, policy, ct)`. Then `await _auditStore.SaveAsync(featureId, level, path, policy, ct)` (fire-and-forget pattern is NOT acceptable for compliance -- both must succeed). If audit store throws, the policy save already succeeded, so wrap in try/catch and throw `AggregateException` with both the success context and the audit failure.
- `DeleteAsync`: First `await _policyStore.DeleteAsync(...)`. Then `await _auditStore.DeleteAsync(...)` with same error handling.
- `SaveProfileAsync`: Delegate to both stores.
- `LoadProfileAsync`: Delegate to `_policyStore.LoadProfileAsync(ct)` only.
- `FlushAsync`: Flush both: `await Task.WhenAll(_policyStore.FlushAsync(ct), _auditStore.FlushAsync(ct))`.

The typical production setup: `policyStore = DatabasePolicyPersistence`, `auditStore = TamperProofPolicyPersistence(InMemoryPolicyPersistence)` -- or `TamperProofPolicyPersistence(FilePolicyPersistence)` for durable audit.

Full XML documentation explaining the dual-store pattern.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings.
  </verify>
  <done>HybridPolicyPersistence composes two IPolicyPersistence instances, routing CRUD to policy store and copies to audit store, with both-must-succeed semantics.</done>
</task>

<task type="auto">
  <name>Task 2: PolicyPersistenceComplianceValidator</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/PolicyPersistenceComplianceValidator.cs</files>
  <action>
Create `PolicyPersistenceComplianceValidator`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: Compliance validation (PERS-07)")]`
- `public sealed class PolicyPersistenceComplianceValidator`

Compliance result record:
```csharp
public sealed record ComplianceValidationResult
{
    public bool IsValid { get; init; }
    public IReadOnlyList<ComplianceViolation> Violations { get; init; } = Array.Empty<ComplianceViolation>();
}

public sealed record ComplianceViolation
{
    public required string Framework { get; init; }  // "HIPAA", "SOC2", "GDPR"
    public required string Rule { get; init; }        // e.g., "HIPAA-AUDIT-001"
    public required string Message { get; init; }     // Human-readable actionable error
    public required string Remediation { get; init; } // What to change
}
```

Main validation method:
`public static ComplianceValidationResult Validate(PolicyPersistenceConfiguration config)`

Compliance rules (hardcoded, production-ready):

**HIPAA:**
- HIPAA-AUDIT-001: If `ActiveComplianceFrameworks` contains "HIPAA" and `Backend` is `File` (or Hybrid with `AuditBackend == File`), violation: "HIPAA requires immutable audit trails. File-based audit storage does not provide tamper-proof guarantees." Remediation: "Change auditStore to TamperProof or use Hybrid backend with AuditBackend=TamperProof."
- HIPAA-AUDIT-002: If HIPAA and `Backend` is `InMemory`, violation: "HIPAA requires durable audit trails. In-memory storage does not survive restarts." Remediation: "Use Database, TamperProof, or Hybrid backend for production HIPAA deployments."

**SOC2:**
- SOC2-AUDIT-001: If `ActiveComplianceFrameworks` contains "SOC2" and `Backend` is `InMemory`, violation: "SOC2 requires durable, auditable policy storage." Remediation: "Use Database, File, TamperProof, or Hybrid backend."
- SOC2-AUDIT-002: If SOC2 and Hybrid but `AuditBackend` is `InMemory`, violation: "SOC2 requires durable audit trails." Remediation: "Change AuditBackend to TamperProof or Database."

**GDPR:**
- GDPR-POLICY-001: If `ActiveComplianceFrameworks` contains "GDPR" and `Backend` is `InMemory`, violation: "GDPR requires demonstrable policy enforcement records." Remediation: "Use a durable backend (Database, File, TamperProof, or Hybrid)."

**FedRAMP:**
- FEDRAMP-AUDIT-001: If "FedRAMP" and audit is not TamperProof (either direct or via Hybrid.AuditBackend), violation: "FedRAMP requires tamper-proof audit records." Remediation: "Use TamperProof backend or Hybrid with AuditBackend=TamperProof."

Helper: `private static bool HasFramework(PolicyPersistenceConfiguration config, string framework)` -- case-insensitive check on `ActiveComplianceFrameworks`.

Helper: `private static bool AuditIsTamperProof(PolicyPersistenceConfiguration config)` -- returns true if Backend is TamperProof, or Backend is Hybrid and AuditBackend is TamperProof.

Helper: `private static bool IsDurable(PolicyPersistenceBackend backend)` -- returns true for File, Database, TamperProof (not InMemory).

Full XML documentation with examples in remarks.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings.
  </verify>
  <done>PolicyPersistenceComplianceValidator.Validate() checks HIPAA/SOC2/GDPR/FedRAMP rules against persistence config and returns actionable violations with remediation steps.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- HybridPolicyPersistence implements IPolicyPersistence with dual-store writes
- ComplianceValidator rejects HIPAA + File audit (produces violation with remediation)
- ComplianceValidator rejects HIPAA + InMemory (produces violation with remediation)
- ComplianceValidator accepts HIPAA + TamperProof or Hybrid(AuditBackend=TamperProof)
</verification>

<success_criteria>
- HybridPolicyPersistence correctly routes CRUD to policy store and audit copies to audit store
- Compliance validator produces actionable errors for HIPAA, SOC2, GDPR, FedRAMP misconfigurations
- Both classes compile cleanly
- Success criteria 6 and 7 from phase definition are met
</success_criteria>

<output>
After completion, create `.planning/phases/69-policy-persistence/69-04-SUMMARY.md`
</output>
