---
phase: 69-policy-persistence
plan: 03
type: execute
wave: 2
depends_on: ["69-01"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/DatabasePolicyPersistence.cs
  - DataWarehouse.SDK/Infrastructure/Policy/TamperProofPolicyPersistence.cs
autonomous: true

must_haves:
  truths:
    - "DatabasePolicyPersistence stores policies in a SQL/NoSQL-abstracted storage layer with multi-node replication support"
    - "TamperProofPolicyPersistence produces a blockchain-backed immutable hash chain on every policy write"
    - "Both implementations extend PolicyPersistenceBase and are swappable via IPolicyPersistence"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/DatabasePolicyPersistence.cs"
      provides: "Database-backed persistence with replication support"
      contains: "class DatabasePolicyPersistence"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/TamperProofPolicyPersistence.cs"
      provides: "Blockchain-backed immutable audit persistence"
      contains: "class TamperProofPolicyPersistence"
  key_links:
    - from: "DatabasePolicyPersistence"
      to: "PolicyPersistenceBase"
      via: "extends abstract base"
      pattern: "DatabasePolicyPersistence.*:.*PolicyPersistenceBase"
    - from: "TamperProofPolicyPersistence"
      to: "PolicySerializationHelper"
      via: "serializes for hash chain"
      pattern: "PolicySerializationHelper\\.Serialize"
---

<objective>
Implement DatabasePolicyPersistence (multi-node with replication) and TamperProofPolicyPersistence (blockchain-backed immutable audit chain).

Purpose: Database persistence enables multi-node deployments. TamperProof persistence produces immutable audit records for compliance (HIPAA, SOC2). Both are required by HybridPolicyPersistence in Plan 04.
Output: Two concrete IPolicyPersistence implementations for production environments.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@.planning/phases/69-policy-persistence/69-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: DatabasePolicyPersistence with replication support</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/DatabasePolicyPersistence.cs</files>
  <action>
Create `DatabasePolicyPersistence` extending `PolicyPersistenceBase`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: Database policy persistence (PERS-04)")]`
- `public sealed class DatabasePolicyPersistence : PolicyPersistenceBase`

This is a production-ready implementation that abstracts the database via an internal storage interface, NOT a direct SQL dependency. The DataWarehouse project does not take direct database driver dependencies in SDK -- it uses the strategy pattern.

Constructor: `public DatabasePolicyPersistence(PolicyPersistenceConfiguration config)` -- extracts `ConnectionString`, `EnableReplication` from config.

Internal storage abstraction (private nested interface):
```csharp
private interface IDbPolicyStore
{
    Task<IReadOnlyList<DbPolicyRow>> GetAllAsync(CancellationToken ct);
    Task UpsertAsync(DbPolicyRow row, CancellationToken ct);
    Task DeleteAsync(string key, CancellationToken ct);
    Task<byte[]?> GetProfileAsync(CancellationToken ct);
    Task SetProfileAsync(byte[] data, CancellationToken ct);
}
```

Private nested record: `private sealed record DbPolicyRow(string Key, string FeatureId, int Level, string Path, byte[] Data, long Timestamp, string NodeId);`

Concrete inner implementation: `private sealed class ConcurrentDictionaryDbStore : IDbPolicyStore` -- uses ConcurrentDictionary internally, simulating database semantics. This is the production-ready in-process store. Real external database adapters will be wired via the plugin system (UltimateDatabaseStorage), not hardcoded here.

Replication support:
- `private readonly string _nodeId = Guid.NewGuid().ToString("N")[..8];` (identifies this node)
- `private readonly bool _enableReplication;`
- If `_enableReplication` is true, each save records a `Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()` and `NodeId` for conflict resolution (last-writer-wins by timestamp).
- `public event Action<string, byte[]>? OnPolicyReplicated;` -- raised after each save for replication subscribers to pick up changes
- `public Task ApplyReplicatedAsync(string key, string featureId, PolicyLevel level, string path, byte[] data, long timestamp, string sourceNodeId, CancellationToken ct)` -- accepts replicated data from another node; only applies if timestamp > existing (last-writer-wins). NOT on interface (replication-specific).

Override abstract Core methods:
- `LoadAllCoreAsync`: Delegate to `_store.GetAllAsync()`, deserialize each row's Data, return tuples.
- `SaveCoreAsync`: Create `DbPolicyRow` with current timestamp and nodeId, call `_store.UpsertAsync`, fire `OnPolicyReplicated` if replication enabled.
- `DeleteCoreAsync`: Delegate to `_store.DeleteAsync`.
- `SaveProfileCoreAsync`: Delegate to `_store.SetProfileAsync`.
- `LoadProfileCoreAsync`: Delegate to `_store.GetProfileAsync`.

Full XML documentation. The ConcurrentDictionary inner store makes this fully functional without external dependencies while maintaining the abstraction layer for future database plugin wiring.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings.
  </verify>
  <done>DatabasePolicyPersistence extends PolicyPersistenceBase with replication events, last-writer-wins conflict resolution, and node identification.</done>
</task>

<task type="auto">
  <name>Task 2: TamperProofPolicyPersistence with blockchain hash chain</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/TamperProofPolicyPersistence.cs</files>
  <action>
Create `TamperProofPolicyPersistence` extending `PolicyPersistenceBase`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: TamperProof policy persistence (PERS-05)")]`
- `public sealed class TamperProofPolicyPersistence : PolicyPersistenceBase`

This implementation wraps another IPolicyPersistence (decorator pattern) and adds blockchain-backed immutable audit on every write. The audit chain is local (no external blockchain service dependency).

Constructor: `public TamperProofPolicyPersistence(IPolicyPersistence innerPersistence)`

Hash chain model -- private nested record:
```csharp
private sealed record AuditBlock
{
    public required long SequenceNumber { get; init; }
    public required string PreviousHash { get; init; }
    public required string Operation { get; init; } // "Save", "Delete", "SaveProfile"
    public required string Key { get; init; }
    public required string DataHash { get; init; }
    public required DateTimeOffset Timestamp { get; init; }
    public required string BlockHash { get; init; } // SHA256(SequenceNumber + PreviousHash + Operation + Key + DataHash + Timestamp)
}
```

Internal state:
- `private readonly IPolicyPersistence _inner;`
- `private readonly ConcurrentQueue<AuditBlock> _auditChain = new();` -- append-only, never modified
- `private string _lastHash = "GENESIS";` -- genesis block hash
- `private long _sequenceNumber = 0;`
- `private readonly object _chainLock = new();` -- lock for atomic append (hash chain must be sequential)

Override abstract Core methods:
- `LoadAllCoreAsync`: Delegate to `_inner.LoadAllAsync(ct)`. No audit on reads.
- `SaveCoreAsync`: First delegate to `_inner.SaveAsync(featureId, level, path, policy, ct)` (passing original typed args, NOT calling Core). Then append audit block: compute `DataHash = Convert.ToHexString(SHA256.HashData(serializedPolicy))`, create AuditBlock with Operation="Save", compute BlockHash, append to chain under lock. Use `Interlocked.Increment(ref _sequenceNumber)`.
  - IMPORTANT: Since this class extends PolicyPersistenceBase, the base class calls SaveCoreAsync with serialized data. But we need to delegate to the inner IPolicyPersistence which expects the original typed parameters. Solution: override SaveAsync (the public interface method) directly instead of SaveCoreAsync. Mark SaveCoreAsync as `throw new NotSupportedException("Use SaveAsync directly")`. Same pattern for Delete, SaveProfile, LoadProfile, LoadAll.
  - Actually, cleaner approach: Do NOT extend PolicyPersistenceBase. Instead, implement IPolicyPersistence directly (decorator pattern). This avoids the double-serialization problem.
  - `public sealed class TamperProofPolicyPersistence : IPolicyPersistence` (implements interface directly, NOT base class)
- `SaveAsync`: Delegate to `_inner.SaveAsync(...)`. Then serialize the policy for hashing, create audit block, append.
- `DeleteAsync`: Delegate to `_inner.DeleteAsync(...)`. Append audit block with Operation="Delete", DataHash="DELETED".
- `SaveProfileAsync`: Delegate to `_inner.SaveProfileAsync(...)`. Append audit block with Key="profile", DataHash of profile bytes.
- `LoadProfileAsync`: Delegate to `_inner.LoadProfileAsync(...)`. No audit on reads.
- `LoadAllAsync`: Delegate to `_inner.LoadAllAsync(...)`. No audit on reads.
- `FlushAsync`: Delegate to `_inner.FlushAsync(...)`.

Public audit chain inspection (for compliance verification):
- `public IReadOnlyList<AuditBlock> GetAuditChain()` -- returns snapshot of the chain
- `public bool VerifyChainIntegrity()` -- walks the chain, verifies each block's hash matches recomputation and previousHash links. Returns true if all blocks valid.
- `public int AuditBlockCount => (int)Interlocked.Read(ref _sequenceNumber);`

Hash computation helper:
- `private static string ComputeBlockHash(long seq, string prevHash, string op, string key, string dataHash, DateTimeOffset ts)` -- concatenate all fields as UTF-8, SHA256, return hex string.

Full XML documentation emphasizing immutability guarantees.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings.
  </verify>
  <done>TamperProofPolicyPersistence implements IPolicyPersistence as a decorator, appending SHA256 hash-chained audit blocks on every mutating operation. VerifyChainIntegrity validates the complete chain.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- DatabasePolicyPersistence extends PolicyPersistenceBase with replication
- TamperProofPolicyPersistence implements IPolicyPersistence directly (decorator pattern)
- TamperProofPolicyPersistence uses SHA256 from System.Security.Cryptography (NOT external packages)
- Hash chain is append-only with sequential block numbering
</verification>

<success_criteria>
- DatabasePolicyPersistence supports multi-node replication via events and last-writer-wins
- TamperProofPolicyPersistence produces verifiable blockchain hash chain on every write
- VerifyChainIntegrity detects any tampering with the audit chain
- Both compile cleanly with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/69-policy-persistence/69-03-SUMMARY.md`
</output>
