---
phase: 69-policy-persistence
plan: 02
type: execute
wave: 2
depends_on: ["69-01"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyPersistence.cs
  - DataWarehouse.SDK/Infrastructure/Policy/FilePolicyPersistence.cs
autonomous: true

must_haves:
  truths:
    - "InMemoryPolicyPersistence stores and retrieves policies in a thread-safe ConcurrentDictionary bounded to configurable capacity"
    - "FilePolicyPersistence writes .dwvd.policy JSON sidecar files and reads them back with identical data"
    - "Both implementations are swappable via IPolicyPersistence without code changes"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyPersistence.cs"
      provides: "Thread-safe in-memory persistence for testing"
      contains: "class InMemoryPolicyPersistence"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/FilePolicyPersistence.cs"
      provides: "File-based persistence with VDE sidecar format"
      contains: "class FilePolicyPersistence"
  key_links:
    - from: "InMemoryPolicyPersistence"
      to: "PolicyPersistenceBase"
      via: "extends abstract base"
      pattern: "InMemoryPolicyPersistence.*:.*PolicyPersistenceBase"
    - from: "FilePolicyPersistence"
      to: "PolicySerializationHelper"
      via: "uses for JSON serialization"
      pattern: "PolicySerializationHelper\\.Serialize"
---

<objective>
Implement InMemoryPolicyPersistence (for testing/ephemeral use) and FilePolicyPersistence (single-node VDE sidecar).

Purpose: InMemory is used throughout v6.0 testing. File persistence enables single-node deployments where policies live alongside .dwvd files.
Output: Two concrete IPolicyPersistence implementations.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Contracts/Policy/IPolicyPersistence.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@.planning/phases/69-policy-persistence/69-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: InMemoryPolicyPersistence</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyPersistence.cs</files>
  <action>
Create `InMemoryPolicyPersistence` extending `PolicyPersistenceBase`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: In-memory policy persistence (PERS-02)")]`
- `public sealed class InMemoryPolicyPersistence : PolicyPersistenceBase`
- Constructor: `public InMemoryPolicyPersistence(int maxCapacity = 100_000)`

Internal storage:
- `private readonly ConcurrentDictionary<string, (string FeatureId, PolicyLevel Level, string Path, byte[] Data)> _policies = new();`
- `private byte[]? _profileData;`
- `private readonly int _maxCapacity;`

Override abstract Core methods:
- `LoadAllCoreAsync`: Iterate `_policies.Values`, deserialize each `Data` via `PolicySerializationHelper.DeserializePolicy`, return list of tuples. Return completed task (synchronous).
- `SaveCoreAsync(string key, string featureId, PolicyLevel level, string path, byte[] serializedPolicy, CancellationToken ct)`: Check `_policies.Count >= _maxCapacity` and if adding new key, throw `InvalidOperationException("InMemory persistence capacity exceeded ({_maxCapacity})")`. Use `_policies.AddOrUpdate`.
- `DeleteCoreAsync(string key, CancellationToken ct)`: `_policies.TryRemove(key, out _)`. No error if not found.
- `SaveProfileCoreAsync(byte[] serializedProfile, CancellationToken ct)`: `Interlocked.Exchange(ref _profileData, serializedProfile)`.
- `LoadProfileCoreAsync(CancellationToken ct)`: Return `_profileData` (may be null).

Additional public methods (for testing convenience, NOT on interface):
- `public int Count => _policies.Count;`
- `public void Clear() { _policies.Clear(); _profileData = null; }`

Follow the same pattern as `InMemoryAuditTrail` for bounded capacity and thread safety. Full XML documentation.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings.
  </verify>
  <done>InMemoryPolicyPersistence is thread-safe, bounded, and extends PolicyPersistenceBase with all Core methods implemented.</done>
</task>

<task type="auto">
  <name>Task 2: FilePolicyPersistence with VDE sidecar format</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/FilePolicyPersistence.cs</files>
  <action>
Create `FilePolicyPersistence` extending `PolicyPersistenceBase`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Policy`
- `[SdkCompatibility("6.0.0", Notes = "Phase 69: File policy persistence (PERS-03)")]`
- `public sealed class FilePolicyPersistence : PolicyPersistenceBase`
- Constructor: `public FilePolicyPersistence(string baseDirectory)` -- the directory where .dwvd files live (policies stored alongside)

File naming convention:
- Policies: `{baseDirectory}/{featureId}.{level}.policy.json` -- one file per (featureId, level, path) composite key
- Actually, use the composite key from base class: `{baseDirectory}/policies/{key-hash}.json` where key-hash is a filesystem-safe Base32/hex encoding of `GenerateKey(featureId, level, path)`. Simpler: use `Convert.ToHexString(SHA256.HashData(Encoding.UTF8.GetBytes(key)))[..16]` for a short unique filename. Store the full key inside the JSON.
- Profile: `{baseDirectory}/profile.json`
- Create a private wrapper record `PolicyFileEntry { string Key, string FeatureId, PolicyLevel Level, string Path, FeaturePolicy Policy }` for clean JSON serialization.

Override abstract Core methods:
- `LoadAllCoreAsync`: Read all `.json` files from `{baseDirectory}/policies/` directory, deserialize each as `PolicyFileEntry`, return list of tuples. If directory doesn't exist, return empty list.
- `SaveCoreAsync`: Create `{baseDirectory}/policies/` if not exists. Serialize a `PolicyFileEntry` to JSON, write to `{hash}.json`. Use `File.WriteAllBytesAsync` with a temp-file-then-rename pattern for atomic writes (write to `.tmp`, then `File.Move` with overwrite).
- `DeleteCoreAsync`: Compute hash, delete `{hash}.json` if exists. No error if missing.
- `SaveProfileCoreAsync`: Write to `{baseDirectory}/profile.json` using atomic temp-then-rename.
- `LoadProfileCoreAsync`: Read `{baseDirectory}/profile.json` if exists, return bytes. Return null if not found.
- `FlushCoreAsync`: No-op (each write is already durable).

Error handling:
- Wrap all I/O in try/catch, rethrow as `PolicyPersistenceException` (create inner class or use `InvalidOperationException` with clear message including file path).
- Use `Directory.CreateDirectory` defensively before writes.

Full XML documentation. Follow System.Text.Json (not Newtonsoft per project convention).
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors, 0 warnings.
  </verify>
  <done>FilePolicyPersistence writes per-policy JSON files and a profile.json in a sidecar directory with atomic write pattern.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- Both classes extend PolicyPersistenceBase
- InMemoryPolicyPersistence uses ConcurrentDictionary with bounded capacity
- FilePolicyPersistence uses atomic temp-file-then-rename writes
- Neither class uses Newtonsoft.Json
</verification>

<success_criteria>
- InMemoryPolicyPersistence thread-safe, bounded, usable in tests
- FilePolicyPersistence writes/reads sidecar files with atomic I/O
- Both are swappable via IPolicyPersistence without caller changes
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/69-policy-persistence/69-02-SUMMARY.md`
</output>
