---
phase: 57-compliance-sovereignty
plan: 09
type: execute
wave: 5
depends_on: ["57-07", "57-08"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportTagIntegrationStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyRoutingStrategy.cs
autonomous: true
must_haves:
  truths:
    - "Compliance passport IS a tag set (passport data stored as universal tags per Phase 55)"
    - "Sovereignty routing checks sovereignty constraints before allowing storage routing"
    - "Tag-based passport queries enable finding objects by compliance status"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportTagIntegrationStrategy.cs"
      provides: "Bridge between CompliancePassport and Universal Tag System (Phase 55)"
      min_lines: 250
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyRoutingStrategy.cs"
      provides: "Pre-routing sovereignty check for FederatedObjectStorage integration"
      min_lines: 200
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportTagIntegrationStrategy.cs"
      to: "DataWarehouse.SDK/Compliance/CompliancePassport.cs"
      via: "converts passport to/from tag representation"
      pattern: "CompliancePassport.*Tag|Tag.*CompliancePassport"
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyRoutingStrategy.cs"
      to: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyMeshOrchestratorStrategy.cs"
      via: "calls CheckSovereigntyAsync before routing"
      pattern: "CheckSovereigntyAsync|ISovereigntyMesh"
---

<objective>
Integrate compliance passports with Universal Tags (Phase 55) and sovereignty checks with storage routing.

Purpose: Phase 55 defines the Universal Tag System. Compliance passports ARE tag sets -- passport data should be stored as tags on the object, enabling tag-based compliance queries. Sovereignty routing integrates with FederatedObjectStorage so sovereignty is checked BEFORE data is routed to a storage backend. These two integrations complete the end-to-end flow.

Output: Tag integration for passports and pre-routing sovereignty check strategy.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/57-compliance-sovereignty/57-01-SUMMARY.md
@.planning/phases/57-compliance-sovereignty/57-07-SUMMARY.md
@.planning/phases/57-compliance-sovereignty/57-08-SUMMARY.md
@DataWarehouse.SDK/Compliance/CompliancePassport.cs
@DataWarehouse.SDK/Compliance/ISovereigntyMesh.cs
@DataWarehouse.SDK/Compliance/PassportEnums.cs
@Plugins/DataWarehouse.Plugins.UltimateCompliance/IComplianceStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PassportTagIntegrationStrategy</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportTagIntegrationStrategy.cs</files>
  <action>
Create `PassportTagIntegrationStrategy.cs` extending `ComplianceStrategyBase`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.Passport`.

Strategy properties:
- StrategyId: "passport-tag-integration"
- StrategyName: "Passport Tag Integration"
- Framework: "CompliancePassport"

This strategy bridges CompliancePassport and the Universal Tag System (Phase 55). Since Phase 55 may not be implemented yet, use a tag abstraction that can be wired later.

**Tag namespace:** `compliance.passport.` prefix for all passport-related tags.

**PassportToTags(CompliancePassport passport) -> IReadOnlyDictionary<string, object>:**
Converts a passport to a flat tag dictionary:
- `compliance.passport.id` -> passport.PassportId
- `compliance.passport.status` -> passport.Status.ToString()
- `compliance.passport.scope` -> passport.Scope.ToString()
- `compliance.passport.issued_at` -> passport.IssuedAt.ToString("O")
- `compliance.passport.expires_at` -> passport.ExpiresAt.ToString("O")
- `compliance.passport.issuer` -> passport.IssuerId
- `compliance.passport.valid` -> passport.IsValid().ToString()
- For each entry: `compliance.passport.regulation.{regulationId}.status` -> entry.Status
- For each entry: `compliance.passport.regulation.{regulationId}.score` -> entry.ComplianceScore
- For each entry: `compliance.passport.regulation.{regulationId}.assessed_at` -> entry.AssessedAt
- `compliance.passport.evidence_count` -> passport.EvidenceChain.Count
- `compliance.passport.signature_present` -> (passport.DigitalSignature != null).ToString()

**TagsToPassport(IReadOnlyDictionary<string, object> tags) -> CompliancePassport?:**
Reconstructs a CompliancePassport from tags:
- Parse all `compliance.passport.*` tags
- Reconstruct PassportEntry list from `compliance.passport.regulation.*` tags
- Return null if required tags missing

**GetPassportTagsForObject(string objectId) -> IReadOnlyDictionary<string, object>:**
- Retrieves passport tags for an object from internal cache
- Returns empty dict if no passport exists

**SetPassportTagsForObject(string objectId, CompliancePassport passport):**
- Converts passport to tags and stores in internal ConcurrentDictionary
- This is the cache; actual persistence comes from Phase 55's tag storage

**Query helpers:**
- `FindObjectsByRegulation(string regulationId)` -> IReadOnlyList<string> objectIds
- `FindObjectsByStatus(PassportStatus status)` -> IReadOnlyList<string> objectIds
- `FindObjectsExpiringSoon(TimeSpan within)` -> IReadOnlyList<string> objectIds
- `FindNonCompliantObjects()` -> IReadOnlyList<string> objectIds (any with score < 0.8)

All queries scan the internal tag cache. In production with Phase 55, these would use tag indexes.

Override `CheckComplianceCoreAsync` to check if object has valid passport tags.

Thread-safe. No stubs. The tag abstraction is production-ready; Phase 55 adds the persistence/indexing layer.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>PassportTagIntegrationStrategy converts passports to/from tag dictionaries, caches tags per object, and provides query helpers for compliance-based object discovery.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SovereigntyRoutingStrategy</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyRoutingStrategy.cs</files>
  <action>
Create `SovereigntyRoutingStrategy.cs` extending `ComplianceStrategyBase`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.SovereigntyMesh`.

Strategy properties:
- StrategyId: "sovereignty-routing"
- StrategyName: "Sovereignty-Aware Routing"
- Framework: "SovereigntyMesh"

This strategy sits between the kernel's routing layer and FederatedObjectStorage. Before data is routed to any storage backend, sovereignty is checked.

**RoutingDecision** sealed record:
- `bool Allowed` (required)
- `string? RecommendedLocation` (if original location denied, suggest compliant alternative)
- `IReadOnlyList<string>? BlockedLocations` (locations that sovereignty denies)
- `IReadOnlyList<string>? AllowedLocations` (locations that sovereignty allows)
- `string? Reason`
- `ZoneEnforcementResult? EnforcementResult`

**CheckRoutingAsync(string objectId, string intendedDestination, IReadOnlyDictionary<string, object> objectTags, CancellationToken ct) -> RoutingDecision:**
1. Extract passport from objectTags (using PassportTagIntegrationStrategy's tag format)
2. Determine source jurisdiction from objectTags["data.location"] or system default
3. Determine destination jurisdiction from intendedDestination (map storage backend to jurisdiction)
4. If same jurisdiction: return Allowed
5. Create sovereignty mesh orchestrator (or use injected instance)
6. Call CheckSovereigntyAsync
7. Based on result:
   - Allowed: return RoutingDecision(Allowed=true)
   - Denied: return RoutingDecision(Allowed=false, suggest alternative from allowed list)
   - Conditional: return RoutingDecision(Allowed=true, RequiredActions=conditions)

**MapStorageBackendToJurisdiction(string backendId) -> string:**
Pre-configured mapping (extensible via Configuration):
- Backends starting with "s3-us-" or "azure-us-" -> "US"
- Backends starting with "s3-eu-" or "azure-eu-" -> "EU" (then specific country from suffix)
- Backends starting with "gcs-" -> based on region
- Backends with "cn-" -> "CN"
- Custom mappings from Configuration["StorageJurisdictionMap"]
- Default: system's home jurisdiction

**GetCompliantStorageLocations(string objectId, IReadOnlyDictionary<string, object> objectTags, CancellationToken ct) -> IReadOnlyList<string>:**
- Evaluates all known storage backends against sovereignty rules
- Returns list of backends where the object CAN be stored

**SovereigntyRoutingCache** (ConcurrentDictionary with TTL):
- Cache key: "{objectId}:{destination}"
- TTL: 10 minutes
- Avoids repeated sovereignty checks for the same object-destination pair

**Statistics:** routing checks total, allowed, denied, redirected, cache hits via Interlocked.

Override `CheckComplianceCoreAsync` to check routing compliance.

Thread-safe. No stubs.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>SovereigntyRoutingStrategy checks sovereignty before routing, maps storage backends to jurisdictions, suggests compliant alternatives, and caches decisions.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj` passes with 0 errors
- Passport-to-tag conversion is bidirectional and lossless
- Tag-based queries find objects by regulation, status, expiration
- Sovereignty routing blocks non-compliant storage destinations
- Routing suggests compliant alternatives when destination is denied
</verification>

<success_criteria>
- Passport serializes to/from 15+ `compliance.passport.*` tags
- Tag queries: by regulation, status, expiring-soon, non-compliant
- Routing maps storage backends to jurisdictions
- Routing blocks denied destinations and suggests alternatives
- 10-minute routing cache with TTL
- Build: 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/57-compliance-sovereignty/57-09-SUMMARY.md`
</output>
