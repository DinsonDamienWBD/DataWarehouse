---
phase: 57-compliance-sovereignty
plan: 04
type: execute
wave: 3
depends_on: ["57-02", "57-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/ZoneEnforcerStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyEnforcementInterceptor.cs
autonomous: true
must_haves:
  truths:
    - "Zone enforcer checks sovereignty BEFORE routing allows data movement"
    - "Enforcement interceptor sits in the write/read pipeline and blocks sovereignty violations"
    - "Cross-zone transfers require both source and destination zone approval"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/ZoneEnforcerStrategy.cs"
      provides: "IZoneEnforcer implementation evaluating cross-zone data movement"
      min_lines: 250
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyEnforcementInterceptor.cs"
      provides: "Pipeline interceptor checking sovereignty before storage routing"
      min_lines: 200
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/ZoneEnforcerStrategy.cs"
      to: "DataWarehouse.SDK/Compliance/ISovereigntyMesh.cs"
      via: "implements IZoneEnforcer"
      pattern: "IZoneEnforcer"
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/ZoneEnforcerStrategy.cs"
      to: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/DeclarativeZoneRegistry.cs"
      via: "queries zone registry"
      pattern: "DeclarativeZoneRegistry|GetZone"
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyEnforcementInterceptor.cs"
      to: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/ZoneEnforcerStrategy.cs"
      via: "calls EnforceAsync"
      pattern: "EnforceAsync"
---

<objective>
Implement sovereignty enforcement that blocks unauthorized cross-zone data movement.

Purpose: This is the enforcement layer. The zone enforcer evaluates whether data can move from one zone to another. The enforcement interceptor integrates into the write/read pipeline so sovereignty is checked BEFORE FederatedObjectStorage routes data. Without this, sovereignty zones are just metadata.

Output: Zone enforcer and pipeline interceptor that actively prevent sovereignty violations.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/57-compliance-sovereignty/57-01-SUMMARY.md
@.planning/phases/57-compliance-sovereignty/57-02-SUMMARY.md
@.planning/phases/57-compliance-sovereignty/57-03-SUMMARY.md
@DataWarehouse.SDK/Compliance/ISovereigntyMesh.cs
@DataWarehouse.SDK/Compliance/CompliancePassport.cs
@DataWarehouse.SDK/Compliance/PassportEnums.cs
@Plugins/DataWarehouse.Plugins.UltimateCompliance/IComplianceStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ZoneEnforcerStrategy (IZoneEnforcer)</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/ZoneEnforcerStrategy.cs</files>
  <action>
Create `ZoneEnforcerStrategy.cs` extending `ComplianceStrategyBase`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.SovereigntyMesh`.

Strategy properties:
- StrategyId: "sovereignty-zone-enforcer"
- StrategyName: "Sovereignty Zone Enforcer"
- Framework: "SovereigntyMesh"

Implements `IZoneEnforcer` (from SDK) alongside ComplianceStrategyBase.

Internal dependencies:
- Takes `DeclarativeZoneRegistry` via constructor injection or lazy initialization
- ConcurrentDictionary<string, ZoneEnforcementResult> for enforcement result caching (TTL: 5 minutes)
- ConcurrentDictionary<string, List<EnforcementAuditEntry>> for audit trail

**EnforceAsync implementation:**
1. Resolve source and destination zones from registry using jurisdiction codes
2. If source and destination are in the SAME zone: Allow (intra-zone movement is always ok)
3. If data is leaving a zone:
   a. Evaluate source zone's rules against object's tags (from context)
   b. Check if passport covers source zone's required regulations
   c. If source zone denies egress: return Denied with reason
4. If data is entering a zone:
   a. Evaluate destination zone's rules
   b. Check if passport covers destination zone's required regulations
   c. If destination zone requires actions: include in RequiredActions
5. If both zones allow: return Allowed
6. If either zone has conditions: return the most restrictive result
7. Log enforcement decision to audit trail

**GetZonesForJurisdictionAsync:** Delegates to DeclarativeZoneRegistry.
**GetZoneAsync:** Delegates to DeclarativeZoneRegistry.
**RegisterZoneAsync:** Delegates to DeclarativeZoneRegistry.
**DeactivateZoneAsync:** Delegates to DeclarativeZoneRegistry.

**EnforcementAuditEntry** internal record:
- ObjectId, SourceZoneId, DestZoneId, Decision (ZoneAction), PassportId, Timestamp, Details

**GetEnforcementAuditAsync(string objectId)** public method for audit retrieval.

Override `CheckComplianceCoreAsync` to run enforcement check and return compliance result.

Cache key: "{objectId}:{sourceZone}:{destZone}:{passportId}". Cache entries expire after 5 minutes.

Thread-safe. No stubs.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>ZoneEnforcerStrategy implements IZoneEnforcer with bi-directional zone evaluation, passport awareness, caching, and audit trail.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SovereigntyEnforcementInterceptor</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyEnforcementInterceptor.cs</files>
  <action>
Create `SovereigntyEnforcementInterceptor.cs` extending `ComplianceStrategyBase`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.SovereigntyMesh`.

Strategy properties:
- StrategyId: "sovereignty-enforcement-interceptor"
- StrategyName: "Sovereignty Enforcement Interceptor"
- Framework: "SovereigntyMesh"

This strategy acts as a pipeline interceptor that sits in the write/read path.

**InterceptWriteAsync(string objectId, string destinationLocation, CompliancePassport? passport, IReadOnlyDictionary<string, object> context, CancellationToken ct)**:
1. Determine source jurisdiction from context["SourceLocation"] or default to system's home jurisdiction
2. Determine destination jurisdiction from destinationLocation
3. If source == destination: Allow (no cross-border)
4. Call ZoneEnforcerStrategy.EnforceAsync with source/dest zones
5. Based on result:
   - Allowed: return InterceptionResult.Proceed
   - Denied: return InterceptionResult.Block with reason
   - RequireEncryption: return InterceptionResult.ProceedWithCondition("encrypt")
   - RequireApproval: return InterceptionResult.PendApproval
   - RequireAnonymization: return InterceptionResult.ProceedWithCondition("anonymize")
   - Quarantine: return InterceptionResult.Quarantine

**InterceptReadAsync(string objectId, string requestorLocation, CompliancePassport? passport, IReadOnlyDictionary<string, object> context, CancellationToken ct)**:
1. Determine where data currently resides from context["DataLocation"]
2. Determine requestor's jurisdiction from requestorLocation
3. If same jurisdiction: Allow
4. Call ZoneEnforcerStrategy.EnforceAsync
5. Return appropriate InterceptionResult

**InterceptionResult** sealed record:
- InterceptionAction Action (Proceed, Block, ProceedWithCondition, PendApproval, Quarantine)
- string? Reason
- IReadOnlyList<string>? Conditions
- ZoneEnforcementResult? EnforcementDetail
- DateTimeOffset Timestamp

**InterceptionAction** enum: Proceed, Block, ProceedWithCondition, PendApproval, Quarantine

**Statistics tracking:**
- InterceptionsTotal, InterceptionsBlocked, InterceptionsAllowed, InterceptionsConditional
- All via Interlocked operations

Override `CheckComplianceCoreAsync` to run interception check and return compliance result.

Thread-safe. Production-ready.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>SovereigntyEnforcementInterceptor intercepts write/read operations, checks sovereignty via ZoneEnforcer, and returns Block/Proceed/Conditional decisions with statistics.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj` passes with 0 errors
- ZoneEnforcerStrategy blocks unauthorized cross-zone transfers
- SovereigntyEnforcementInterceptor intercepts write/read paths
- Both produce audit-worthy decision records
</verification>

<success_criteria>
- Zone enforcer evaluates both source egress and destination ingress rules
- Enforcement interceptor sits in write/read pipeline with Block/Proceed/Conditional outcomes
- Same-zone and same-jurisdiction transfers always allowed
- Passport coverage reduces enforcement severity
- Full audit trail for all enforcement decisions
- Build: 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/57-compliance-sovereignty/57-04-SUMMARY.md`
</output>
