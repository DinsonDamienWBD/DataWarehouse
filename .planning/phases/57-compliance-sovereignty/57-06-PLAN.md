---
phase: 57-compliance-sovereignty
plan: 06
type: execute
wave: 3
depends_on: ["57-02"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/ZeroKnowledgePassportVerificationStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportVerificationApiStrategy.cs
autonomous: true
must_haves:
  truths:
    - "Zero-knowledge passport verification proves compliance without revealing passport contents"
    - "Verification API validates passport authenticity, signatures, entry currency, and zone compliance"
    - "Third parties can verify compliance status without accessing sensitive compliance details"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/ZeroKnowledgePassportVerificationStrategy.cs"
      provides: "Zero-knowledge proof generation and verification for passport claims"
      min_lines: 250
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportVerificationApiStrategy.cs"
      provides: "Comprehensive passport verification with signature, expiry, and entry checks"
      min_lines: 200
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/ZeroKnowledgePassportVerificationStrategy.cs"
      to: "DataWarehouse.SDK/Compliance/CompliancePassport.cs"
      via: "generates proofs from CompliancePassport"
      pattern: "CompliancePassport"
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportVerificationApiStrategy.cs"
      to: "DataWarehouse.SDK/Compliance/CompliancePassport.cs"
      via: "returns PassportVerificationResult"
      pattern: "PassportVerificationResult"
---

<objective>
Implement zero-knowledge passport verification and the comprehensive verification API.

Purpose: Third parties need to verify compliance status without seeing sensitive compliance details. ZK proofs let a verifier confirm "this object is GDPR-compliant" without revealing the full passport. The verification API provides complete passport validation including signatures, expiry, entry currency, and zone compatibility.

Output: ZK verification strategy and comprehensive verification API strategy.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/57-compliance-sovereignty/57-01-SUMMARY.md
@.planning/phases/57-compliance-sovereignty/57-02-SUMMARY.md
@DataWarehouse.SDK/Compliance/CompliancePassport.cs
@DataWarehouse.SDK/Compliance/ISovereigntyMesh.cs
@DataWarehouse.SDK/Compliance/PassportEnums.cs
@Plugins/DataWarehouse.Plugins.UltimateCompliance/IComplianceStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ZeroKnowledgePassportVerificationStrategy</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/ZeroKnowledgePassportVerificationStrategy.cs</files>
  <action>
Create `ZeroKnowledgePassportVerificationStrategy.cs` extending `ComplianceStrategyBase`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.Passport`.

Strategy properties:
- StrategyId: "passport-zk-verification"
- StrategyName: "Zero-Knowledge Passport Verification"
- Framework: "CompliancePassport"

Implements a commitment-based zero-knowledge proof system for passport claims:

**Core types:**

`ZkPassportProof` sealed record:
- `string ProofId` (required)
- `string PassportId` (required, the passport being proved)
- `string Claim` (required, e.g. "covers:GDPR", "status:Active", "score:>=0.8")
- `byte[] Commitment` (required, cryptographic commitment)
- `byte[] Challenge` (required)
- `byte[] Response` (required)
- `DateTimeOffset GeneratedAt`
- `DateTimeOffset ExpiresAt`

`ZkVerificationResult` sealed record:
- `bool IsValid` (required)
- `string Claim` (required)
- `string? FailureReason`
- `DateTimeOffset VerifiedAt`

**Proof generation (Schnorr-like protocol using HMAC):**

`GenerateProofAsync(CompliancePassport passport, string claim, CancellationToken ct)`:
1. Parse claim type:
   - "covers:{regulation}" -> check if passport has entry for regulation
   - "status:{status}" -> check if passport status matches
   - "score:>={threshold}" -> check if all entries have score >= threshold
   - "valid" -> check IsValid()
   - "zone:{zoneId}" -> check if passport covers zone's regulations
2. Evaluate claim against passport -> bool claimIsTrue
3. If claim is false, throw (cannot prove false claims)
4. Generate commitment:
   - Create random nonce (32 bytes via RandomNumberGenerator)
   - Compute commitment = HMAC-SHA256(nonce, passport.PassportId + claim)
5. Generate challenge:
   - challenge = SHA256(commitment + passport.PassportId + claim + timestamp)
6. Generate response:
   - response = HMAC-SHA256(signingKey, nonce + challenge)
   - This binds: the passport, the claim, the nonce, and the challenge
7. Return ZkPassportProof

`VerifyProofAsync(ZkPassportProof proof, CancellationToken ct)`:
1. Check proof not expired
2. Recompute challenge from commitment + passportId + claim + timestamp
3. Verify response matches HMAC-SHA256(signingKey, extractedNonce + challenge)
4. Note: This is a simplified ZK scheme suitable for passport verification. The verifier learns ONLY that the claim is true, not the passport contents.
5. Return ZkVerificationResult

`GenerateBatchProofsAsync(CompliancePassport passport, IReadOnlyList<string> claims, CancellationToken ct)`:
- Generates proofs for multiple claims at once
- Returns IReadOnlyList<ZkPassportProof>

**Proof cache:** ConcurrentDictionary<string, ZkPassportProof> keyed by "{passportId}:{claim}". Proofs cached for 1 hour.

Override `CheckComplianceCoreAsync` to check if a valid proof exists for the object.

Thread-safe. No stubs. Uses System.Security.Cryptography only.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>ZeroKnowledgePassportVerificationStrategy generates and verifies Schnorr-like ZK proofs for passport claims without revealing passport contents.</done>
</task>

<task type="auto">
  <name>Task 2: Implement PassportVerificationApiStrategy</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/PassportVerificationApiStrategy.cs</files>
  <action>
Create `PassportVerificationApiStrategy.cs` extending `ComplianceStrategyBase`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.Passport`.

Strategy properties:
- StrategyId: "passport-verification-api"
- StrategyName: "Passport Verification API"
- Framework: "CompliancePassport"

Comprehensive passport verification:

**VerifyPassportAsync(CompliancePassport passport, CancellationToken ct) -> PassportVerificationResult:**
1. **Signature check:** Re-compute HMAC-SHA256 of passport content and compare with DigitalSignature
2. **Status check:** Verify Status == Active
3. **Expiry check:** Verify ExpiresAt > DateTimeOffset.UtcNow
4. **Entry currency check:** For each PassportEntry, verify AssessedAt is within its regulation's assessment period
5. **Evidence chain check:** Verify at least one EvidenceLink exists and all have valid ContentHash
6. **Completeness check:** All required fields are non-null

Collect all failure reasons into a list. Return PassportVerificationResult with:
- IsValid = failureReasons.Count == 0
- SignatureValid = signature check passed
- AllEntriesCurrent = all entries within assessment period
- FailureReasons = collected reasons

**VerifyPassportForZoneAsync(CompliancePassport passport, string zoneId, IReadOnlyList<string> zoneRegulations, CancellationToken ct) -> PassportVerificationResult:**
1. Run all checks from VerifyPassportAsync
2. Additionally check that passport covers ALL required regulations for the zone
3. If any zone regulation is missing: add "Missing regulation coverage: {reg}" to failure reasons

**VerifyPassportChainAsync(IReadOnlyList<CompliancePassport> passportChain, CancellationToken ct) -> PassportVerificationResult:**
1. Verify each passport individually
2. Verify chain integrity: each passport's ObjectId matches
3. Verify temporal ordering: each passport issued after the previous one expired
4. Return aggregate result

**Statistics:** verifications total, valid, invalid, by failure reason (ConcurrentDictionary<string, long>)

Override `CheckComplianceCoreAsync` to run full verification on passport from context.

Thread-safe. No stubs.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>PassportVerificationApiStrategy provides comprehensive passport verification including signature, expiry, entry currency, evidence chain, zone compatibility, and chain verification.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj` passes with 0 errors
- ZK proofs can be generated and verified without revealing passport contents
- Verification API checks signature, expiry, entries, evidence, and zone compatibility
- Both strategies maintain statistics
</verification>

<success_criteria>
- ZK proof generation uses HMAC-SHA256 commitment scheme
- ZK verification confirms claim truth without revealing passport
- Verification API checks 6 dimensions: signature, status, expiry, entry currency, evidence, completeness
- Zone-specific verification confirms regulation coverage
- Chain verification for passport succession
- Build: 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/57-compliance-sovereignty/57-06-SUMMARY.md`
</output>
