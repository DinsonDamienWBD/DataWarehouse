---
phase: 57-compliance-sovereignty
plan: 05
type: execute
wave: 3
depends_on: ["57-02", "57-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/CrossBorderTransferProtocolStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/TransferAgreementManagerStrategy.cs
autonomous: true
must_haves:
  truths:
    - "Cross-border transfers require negotiated agreements with legal basis"
    - "Transfer agreements specify conditions (encryption, anonymization, consent)"
    - "All transfers are logged with full provenance chain"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/CrossBorderTransferProtocolStrategy.cs"
      provides: "ICrossBorderProtocol implementation with negotiation and logging"
      min_lines: 300
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/TransferAgreementManagerStrategy.cs"
      provides: "Transfer agreement lifecycle management with pre-configured agreements"
      min_lines: 250
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/CrossBorderTransferProtocolStrategy.cs"
      to: "DataWarehouse.SDK/Compliance/ISovereigntyMesh.cs"
      via: "implements ICrossBorderProtocol"
      pattern: "ICrossBorderProtocol"
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/CrossBorderTransferProtocolStrategy.cs"
      to: "DataWarehouse.SDK/Compliance/CompliancePassport.cs"
      via: "uses CompliancePassport in negotiation"
      pattern: "CompliancePassport"
---

<objective>
Implement the Cross-Border Transfer Protocol with agreement negotiation and provenance logging.

Purpose: Cross-border data transfers are the most legally sensitive operation in data governance. This plan creates the protocol that negotiates transfer agreements based on legal mechanisms (SCC, BCR, Adequacy Decisions), evaluates transfers against agreements, and maintains a complete audit log with provenance. Integrates with the existing CrossBorderTransferControlStrategy but adds agreement lifecycle and passport awareness.

Output: Transfer protocol implementation and agreement manager with pre-configured bilateral agreements.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/57-compliance-sovereignty/57-01-SUMMARY.md
@.planning/phases/57-compliance-sovereignty/57-02-SUMMARY.md
@.planning/phases/57-compliance-sovereignty/57-03-SUMMARY.md
@DataWarehouse.SDK/Compliance/ISovereigntyMesh.cs
@DataWarehouse.SDK/Compliance/CompliancePassport.cs
@Plugins/DataWarehouse.Plugins.UltimateCompliance/IComplianceStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/SovereigntyMesh/SovereigntyMeshStrategies.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CrossBorderTransferProtocolStrategy</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/CrossBorderTransferProtocolStrategy.cs</files>
  <action>
Create `CrossBorderTransferProtocolStrategy.cs` extending `ComplianceStrategyBase` and implementing `ICrossBorderProtocol`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.Passport`.

Strategy properties:
- StrategyId: "cross-border-transfer-protocol"
- StrategyName: "Cross-Border Transfer Protocol"
- Framework: "CompliancePassport"

Internal storage:
- ConcurrentDictionary<string, TransferAgreementRecord> _agreements (keyed by "source:dest")
- ConcurrentDictionary<string, List<CrossBorderTransferLog>> _transferLogs (keyed by objectId)
- ConcurrentDictionary<string, TransferNegotiation> _pendingNegotiations

**NegotiateTransferAsync implementation:**
1. Check if an active agreement exists for source->dest pair
2. If exists and not expired: return existing agreement
3. If no agreement: start negotiation:
   a. Determine legal basis options based on jurisdiction pair:
      - EU -> Adequate country: LegalBasis = "AdequacyDecision"
      - EU -> Non-adequate: LegalBasis = "SCC" (Standard Contractual Clauses)
      - Within same region: LegalBasis = "IntraRegional"
      - BCR-eligible: LegalBasis = "BCR" (Binding Corporate Rules)
      - APEC CBPR members: LegalBasis = "CBPR"
      - Default: LegalBasis = "Derogation"
   b. Check passport covers source jurisdiction's regulations
   c. Determine conditions:
      - If passport covers all regs: fewer conditions
      - Always include "audit_logging" condition
      - Add "encryption_required" if either jurisdiction requires it
      - Add "data_minimization" for GDPR/PIPL transfers
      - Add "purpose_limitation" for GDPR transfers
   d. Create TransferAgreementRecord
4. Return agreement

**EvaluateTransferAsync implementation:**
1. Look up transfer's agreement
2. Verify agreement is active and not expired
3. Check all conditions are met (from context attributes)
4. Return TransferDecision:
   - Approved: all conditions met, agreement valid
   - Denied: no agreement or agreement expired
   - ConditionalApproval: agreement valid but some conditions not yet verified
   - PendingAgreement: negotiation in progress
   - EscalationRequired: high-risk transfer needing human review

**LogTransferAsync:** Append log to _transferLogs[objectId]. Include timestamp, decision, agreement reference.

**GetTransferHistoryAsync:** Return logs for objectId, sorted by timestamp descending, limited by count.

**AdequacyDecisionRegistry** private helper:
- Pre-configured list of EU-adequate countries: JP, KR, NZ, UK, CH, IL, AR, UY, CA (commercial), AD, FO, GG, IM, JE
- Method: `IsAdequate(string fromJurisdiction, string toJurisdiction) -> bool`

**TransferNegotiation** internal record:
- NegotiationId, SourceJurisdiction, DestJurisdiction, RequestedAt, Status (Pending/Complete/Failed), LegalBasisOptions

Override `CheckComplianceCoreAsync` to verify that the transfer in context has a valid agreement.

Thread-safe. No stubs.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>CrossBorderTransferProtocolStrategy negotiates agreements with appropriate legal basis, evaluates transfers, and logs complete provenance.</done>
</task>

<task type="auto">
  <name>Task 2: Implement TransferAgreementManagerStrategy</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateCompliance/Strategies/Passport/TransferAgreementManagerStrategy.cs</files>
  <action>
Create `TransferAgreementManagerStrategy.cs` extending `ComplianceStrategyBase`. Namespace: `DataWarehouse.Plugins.UltimateCompliance.Strategies.Passport`.

Strategy properties:
- StrategyId: "transfer-agreement-manager"
- StrategyName: "Transfer Agreement Manager"
- Framework: "CompliancePassport"

Manages the lifecycle of transfer agreements:

**Pre-configured agreements on InitializeAsync:**

EU Internal (auto-approved, no conditions beyond GDPR compliance):
- EU <-> EU: AdequacyDecision, no additional conditions

EU -> Adequate countries:
- EU -> UK: AdequacyDecision, conditions: ["uk_gdpr_compliance"]
- EU -> JP: AdequacyDecision, conditions: ["appi_supplementary_rules"]
- EU -> KR: AdequacyDecision, conditions: ["pipa_compliance"]
- EU -> CH: AdequacyDecision, conditions: ["fadp_compliance"]

US Internal (sectoral):
- US -> US: IntraRegional, conditions: ["sector_specific_compliance"]

APEC CBPR:
- APEC members -> APEC members: CBPR, conditions: ["cbpr_certification"]

**Agreement lifecycle methods:**
1. `CreateAgreementAsync(string sourceJurisdiction, string destJurisdiction, string legalBasis, IReadOnlyList<string> conditions, TimeSpan validity, CancellationToken ct)` -> TransferAgreementRecord
2. `RenewAgreementAsync(string agreementId, TimeSpan extension, CancellationToken ct)` -> TransferAgreementRecord
3. `RevokeAgreementAsync(string agreementId, string reason, CancellationToken ct)` -> void
4. `GetAgreementAsync(string sourceJurisdiction, string destJurisdiction, CancellationToken ct)` -> TransferAgreementRecord?
5. `GetAllAgreementsAsync(CancellationToken ct)` -> IReadOnlyList<TransferAgreementRecord>
6. `GetExpiredAgreementsAsync(CancellationToken ct)` -> IReadOnlyList<TransferAgreementRecord>
7. `ValidateAgreementAsync(string agreementId, CancellationToken ct)` -> bool (checks expiry, revocation)

**AgreementAuditEntry** internal record tracking all agreement changes.

**Statistics:** agreements created/renewed/revoked/expired counts via Interlocked.

Override `CheckComplianceCoreAsync` to check if source->dest has valid agreement.

Thread-safe. No stubs.
  </action>
  <verify>Build: `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj --no-restore 2>&1 | tail -5`</verify>
  <done>TransferAgreementManagerStrategy manages agreement lifecycle with pre-configured bilateral agreements, renewal, revocation, and audit tracking.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj` passes with 0 errors
- Transfer negotiation selects correct legal basis per jurisdiction pair
- Pre-configured agreements cover EU internal, EU-adequate, US internal, APEC CBPR
- Transfer logs maintain full provenance chain
</verification>

<success_criteria>
- Legal basis auto-selected: AdequacyDecision, SCC, BCR, CBPR, IntraRegional, Derogation
- EU adequacy registry covers 14 adequate countries
- Transfer evaluation checks agreement validity and condition satisfaction
- Agreement lifecycle: create, renew, revoke with audit trail
- Build: 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/57-compliance-sovereignty/57-05-SUMMARY.md`
</output>
