---
phase: 27-plugin-migration-decoupling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/AedsPluginBases.cs
  - DataWarehouse.SDK/Contracts/ActiveStoragePluginBases.cs
  - DataWarehouse.SDK/Contracts/FeaturePluginInterfaces.cs
  - DataWarehouse.SDK/Contracts/InfrastructurePluginBases.cs
  - DataWarehouse.SDK/Contracts/HypervisorPluginBases.cs
  - DataWarehouse.SDK/Contracts/HardwareAccelerationPluginBases.cs
  - DataWarehouse.SDK/Contracts/CarbonAwarePluginBases.cs
  - DataWarehouse.SDK/Contracts/ComplianceAutomationPluginBases.cs
  - DataWarehouse.SDK/Contracts/LowLatencyPluginBases.cs
  - DataWarehouse.SDK/Contracts/TamperProof/IAccessLogProvider.cs
  - DataWarehouse.SDK/Contracts/TamperProof/IBlockchainProvider.cs
  - DataWarehouse.SDK/Contracts/TamperProof/ITamperProofProvider.cs
  - DataWarehouse.SDK/Contracts/TamperProof/IIntegrityProvider.cs
  - DataWarehouse.SDK/Contracts/TamperProof/IWormStorageProvider.cs
  - DataWarehouse.SDK/Contracts/DataConnectorPluginBases.cs
  - DataWarehouse.SDK/Contracts/ExabyteScalePluginBases.cs
  - DataWarehouse.SDK/Contracts/MilitarySecurityPluginBases.cs
  - DataWarehouse.SDK/Contracts/MultiMasterPluginBases.cs
  - DataWarehouse.SDK/Contracts/OrchestrationInterfaces.cs
autonomous: true

must_haves:
  truths:
    - "All SDK intermediate plugin bases inherit from the new Hierarchy branch (DataPipelinePluginBase or FeaturePluginBase) instead of LegacyFeaturePluginBase"
    - "All concrete plugins that inherit these intermediate bases automatically gain IntelligenceAwarePluginBase in their chain without any plugin code changes"
    - "SecurityProviderPluginBase and StorageProviderPluginBase are re-parented from bare PluginBase to appropriate Hierarchy branches"
    - "The old InterfacePluginBase name collision is resolved"
    - "Solution builds with zero new errors (only pre-existing CS1729/CS0234 allowed)"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/AedsPluginBases.cs"
      provides: "AEDS transport bases re-parented to Hierarchy"
      contains: "InterfacePluginBase|OrchestrationPluginBase|SecurityPluginBase|ComputePluginBase"
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "Old intermediate bases re-parented"
      contains: "Hierarchy"
    - path: "DataWarehouse.SDK/Contracts/InfrastructurePluginBases.cs"
      provides: "Infrastructure bases re-parented"
      contains: "Hierarchy"
  key_links:
    - from: "SDK intermediate bases"
      to: "Hierarchy domain bases"
      via: "inheritance re-parenting"
      pattern: ":\\s*(SecurityPluginBase|InterfacePluginBase|ComputePluginBase|InfrastructurePluginBase|OrchestrationPluginBase|DataManagementPluginBase|ObservabilityPluginBase|StreamingPluginBase|MediaPluginBase|PlatformPluginBase|StoragePluginBase|ReplicationPluginBase|IntegrityPluginBase)"
---

<objective>
Re-parent all ~60 SDK intermediate plugin bases from LegacyFeaturePluginBase (and bare PluginBase) to the appropriate new Hierarchy domain bases created in Phase 24.

Purpose: This is the highest-leverage change in Phase 27. By changing the SDK intermediate bases themselves, all concrete plugins inheriting them (AEDS transport, hardware acceleration, hypervisor, TamperProof, compliance automation, exabyte scale, military security, orchestration, low-latency, feature interfaces) automatically migrate to the new hierarchy WITHOUT any plugin code changes. This covers ~60 intermediate bases and their ~30+ concrete plugin consumers.

Output: All SDK intermediate bases on Hierarchy branches; solution compiles with zero new errors.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-plugin-migration-decoupling/27-RESEARCH.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Re-parent all SDK intermediate plugin bases from LegacyFeaturePluginBase to Hierarchy domain bases</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Contracts/AedsPluginBases.cs
    DataWarehouse.SDK/Contracts/ActiveStoragePluginBases.cs
    DataWarehouse.SDK/Contracts/FeaturePluginInterfaces.cs
    DataWarehouse.SDK/Contracts/InfrastructurePluginBases.cs
    DataWarehouse.SDK/Contracts/HypervisorPluginBases.cs
    DataWarehouse.SDK/Contracts/HardwareAccelerationPluginBases.cs
    DataWarehouse.SDK/Contracts/CarbonAwarePluginBases.cs
    DataWarehouse.SDK/Contracts/ComplianceAutomationPluginBases.cs
    DataWarehouse.SDK/Contracts/LowLatencyPluginBases.cs
    DataWarehouse.SDK/Contracts/TamperProof/IAccessLogProvider.cs
    DataWarehouse.SDK/Contracts/TamperProof/IBlockchainProvider.cs
    DataWarehouse.SDK/Contracts/TamperProof/ITamperProofProvider.cs
    DataWarehouse.SDK/Contracts/TamperProof/IIntegrityProvider.cs
    DataWarehouse.SDK/Contracts/TamperProof/IWormStorageProvider.cs
    DataWarehouse.SDK/Contracts/DataConnectorPluginBases.cs
    DataWarehouse.SDK/Contracts/ExabyteScalePluginBases.cs
    DataWarehouse.SDK/Contracts/MilitarySecurityPluginBases.cs
    DataWarehouse.SDK/Contracts/MultiMasterPluginBases.cs
    DataWarehouse.SDK/Contracts/OrchestrationInterfaces.cs
  </files>
  <action>
    Re-parent every SDK intermediate plugin base from `LegacyFeaturePluginBase` (or bare `PluginBase`) to the correct new Hierarchy domain base. Add `using DataWarehouse.SDK.Contracts.Hierarchy;` to each file that needs it.

    **CRITICAL: Preserve all existing interface implementations and abstract/virtual members.** Only the base class declaration changes. All existing members, constructors, and interface implementations MUST stay exactly as they are (AD-08 zero regression).

    **Mapping (LegacyFeaturePluginBase -> new Hierarchy base):**

    In `AedsPluginBases.cs`:
    - `ControlPlaneTransportPluginBase : LegacyFeaturePluginBase` -> `: InterfacePluginBase` (Hierarchy.Feature)
    - `DataPlaneTransportPluginBase : LegacyFeaturePluginBase` -> `: InterfacePluginBase` (Hierarchy.Feature)
    - `ServerDispatcherPluginBase : LegacyFeaturePluginBase` -> `: OrchestrationPluginBase` (Hierarchy.Feature)
    - `ClientSentinelPluginBase : LegacyFeaturePluginBase` -> `: SecurityPluginBase` (Hierarchy.Feature)
    - `ClientExecutorPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)

    For each of these, implement any new abstract members from the Hierarchy base:
    - InterfacePluginBase requires: `abstract string Protocol { get; }` -- provide sensible default like `"ControlPlane"`, `"DataPlane"`, `"gRPC"`, etc.
    - OrchestrationPluginBase requires: `abstract string OrchestrationMode { get; }` -- provide `"ServerDispatch"`
    - SecurityPluginBase requires: `abstract string SecurityDomain { get; }` -- provide `"ClientSentinel"`
    - ComputePluginBase requires: `abstract string RuntimeType { get; }` AND `abstract Task<Dictionary<string, object>> ExecuteWorkloadAsync(...)` -- provide abstract RuntimeType and override ExecuteWorkloadAsync as virtual (not abstract) with NotSupportedException to avoid forcing concrete implementations to add methods they don't have

    **WAIT** -- these are abstract intermediate bases, not sealed concrete plugins. When the Hierarchy base has abstract members, the intermediate base can either:
    (a) Implement them concretely (if a sensible default exists), or
    (b) Leave them abstract (pass-through to concrete plugins), or
    (c) Implement as `virtual` with a default

    **Preferred approach: Leave Hierarchy abstract members abstract in intermediate bases** so concrete plugins must implement them. But ONLY if concrete plugins won't break. Since most intermediate bases have their own concrete subclasses that were already abstract-member-implementing, this needs care.

    **Practical approach:** For intermediate bases that are themselves abstract, just let the Hierarchy abstract members flow through (they remain abstract). The concrete plugin classes will need to implement them -- but that's handled in Plans 27-02 through 27-04. For now, just verify the SDK itself compiles.

    In `ActiveStoragePluginBases.cs`:
    - `WasmFunctionPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)
    - `DataVirtualizationPluginBase : LegacyFeaturePluginBase` -> `: InterfacePluginBase` (Hierarchy.Feature)
    - `MediaTranscodingPluginBase : LegacyFeaturePluginBase` -> `: MediaPluginBase` (Hierarchy.Feature)

    In `FeaturePluginInterfaces.cs`:
    - `DeduplicationPluginBase : LegacyFeaturePluginBase` -> `: DataManagementPluginBase` (Hierarchy.Feature)
    - `VersioningPluginBase : LegacyFeaturePluginBase` -> `: DataManagementPluginBase` (Hierarchy.Feature)
    - `SnapshotPluginBase : LegacyFeaturePluginBase` -> `: DataManagementPluginBase` (Hierarchy.Feature)
    - `TelemetryPluginBase : LegacyFeaturePluginBase` -> `: ObservabilityPluginBase` (Hierarchy.Feature)
    - `ThreatDetectionPluginBase : LegacyFeaturePluginBase` -> `: SecurityPluginBase` (Hierarchy.Feature)
    - `BackupPluginBase : LegacyFeaturePluginBase` -> `: DataManagementPluginBase` (Hierarchy.Feature)
    - `OperationsPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)

    In `InfrastructurePluginBases.cs`:
    - `HealthProviderPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `RateLimiterPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `CircuitBreakerPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `TransactionManagerPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `RaidProviderPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `ErasureCodingPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `ComplianceProviderPluginBase : LegacyFeaturePluginBase` -> `: SecurityPluginBase` (Hierarchy.Feature)
    - `IAMProviderPluginBase : LegacyFeaturePluginBase` -> `: SecurityPluginBase` (Hierarchy.Feature)

    In `HypervisorPluginBases.cs`:
    - `HypervisorDetectorPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)
    - `BalloonDriverPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)
    - `VmSnapshotProviderPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)
    - `BackupApiPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)

    In `HardwareAccelerationPluginBases.cs`:
    - `HardwareAcceleratorPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)
    - `Tpm2ProviderPluginBase : LegacyFeaturePluginBase` -> `: SecurityPluginBase` (Hierarchy.Feature)
    - `HsmProviderPluginBase : LegacyFeaturePluginBase` -> `: SecurityPluginBase` (Hierarchy.Feature)

    In `CarbonAwarePluginBases.cs`:
    - All 5 CarbonAware bases (`CarbonIntensityProviderPluginBase`, `CarbonAwareSchedulerPluginBase`, `CarbonReporterPluginBase`, `GreenRegionSelectorPluginBase`, `CarbonOffsetProviderPluginBase`) -> `: InfrastructurePluginBase` (Hierarchy.Feature)

    In `ComplianceAutomationPluginBases.cs`:
    - All 3 ComplianceAutomation bases (`ComplianceAutomationPluginBase`, `DataSubjectRightsPluginBase`, `ComplianceAuditPluginBase`) -> `: SecurityPluginBase` (Hierarchy.Feature)

    In `LowLatencyPluginBases.cs`:
    - `RdmaTransportPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `IoUringProviderPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `NumaAllocatorPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `LowLatencyStoragePluginBase : StorageProviderPluginBase` -> This inherits from `StorageProviderPluginBase` (which is on bare `PluginBase`). Leave for Task 2.

    In `TamperProof/*.cs`:
    - `AccessLogProviderPluginBase : LegacyFeaturePluginBase` -> `: IntegrityPluginBase` (Hierarchy.DataPipeline)
    - `BlockchainProviderPluginBase : LegacyFeaturePluginBase` -> `: IntegrityPluginBase` (Hierarchy.DataPipeline)
    - `TamperProofProviderPluginBase : LegacyFeaturePluginBase` -> `: IntegrityPluginBase` (Hierarchy.DataPipeline)
    - `IntegrityProviderPluginBase : LegacyFeaturePluginBase` -> `: IntegrityPluginBase` (Hierarchy.DataPipeline)
    - `WormStorageProviderPluginBase : LegacyFeaturePluginBase` -> `: IntegrityPluginBase` (Hierarchy.DataPipeline)

    In `DataConnectorPluginBases.cs`:
    - `DataConnectorPluginBase : LegacyFeaturePluginBase` -> `: InterfacePluginBase` (Hierarchy.Feature)

    In `ExabyteScalePluginBases.cs`:
    - `ShardManagerPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `DistributedMetadataIndexPluginBase : LegacyFeaturePluginBase` -> `: DataManagementPluginBase` (Hierarchy.Feature)
    - `DistributedCachePluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)

    In `MilitarySecurityPluginBases.cs`:
    - All 4 military bases (`MandatoryAccessControlPluginBase`, `MultiLevelSecurityPluginBase`, `TwoPersonIntegrityPluginBase`, `SecureDestructionPluginBase`) inherit from `SecurityProviderPluginBase` (which is on bare `PluginBase`). Leave for Task 2.

    In `MultiMasterPluginBases.cs`:
    - `MultiMasterReplicationPluginBase : LegacyFeaturePluginBase` -> `: ReplicationPluginBase` (Hierarchy.DataPipeline)

    In `OrchestrationInterfaces.cs`:
    - `SearchOrchestratorPluginBase : LegacyFeaturePluginBase` -> `: OrchestrationPluginBase` (Hierarchy.Feature)
    - `SearchProviderPluginBase : LegacyFeaturePluginBase` -> `: InterfacePluginBase` (Hierarchy.Feature)
    - `ContentProcessorPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)
    - `WriteFanOutOrchestratorPluginBase : LegacyFeaturePluginBase` -> `: OrchestrationPluginBase` (Hierarchy.Feature)
    - `WriteDestinationPluginBase : LegacyFeaturePluginBase` -> `: InterfacePluginBase` (Hierarchy.Feature)

    In `PluginBase.cs` (old intermediate bases):
    - `InterfacePluginBase : LegacyFeaturePluginBase` (line ~1492) -- **NAME COLLISION**: This old InterfacePluginBase conflicts with `DataWarehouse.SDK.Contracts.Hierarchy.InterfacePluginBase`. Resolution: Mark old one `[Obsolete]` and add `using HierarchyInterfacePluginBase = DataWarehouse.SDK.Contracts.Hierarchy.InterfacePluginBase;` where needed, then re-parent old `InterfacePluginBase` to inherit from the new Hierarchy `InterfacePluginBase`. Use fully-qualified name: `DataWarehouse.SDK.Contracts.Hierarchy.InterfacePluginBase`.
    - `ConsensusPluginBase : LegacyFeaturePluginBase` -> `: InfrastructurePluginBase` (Hierarchy.Feature)
    - `RealTimePluginBase : LegacyFeaturePluginBase` -> `: StreamingPluginBase` (Hierarchy.Feature)
    - `ReplicationPluginBase : LegacyFeaturePluginBase` (old, line ~2303) -- **NAME COLLISION** with `DataWarehouse.SDK.Contracts.Hierarchy.ReplicationPluginBase`. Same resolution: mark old one `[Obsolete]`, re-parent to inherit from Hierarchy ReplicationPluginBase.
    - `ContainerManagerPluginBase : LegacyFeaturePluginBase` -> `: ComputePluginBase` (Hierarchy.Feature)

    **Lifecycle mapping concern:** The old LegacyFeaturePluginBase required `StartAsync(CancellationToken)` and `StopAsync()`. The new Hierarchy bases use `InitializeAsync/ShutdownAsync`. Since these intermediate bases are ABSTRACT, and most don't implement StartAsync/StopAsync themselves (they leave it abstract for concrete plugins), this should not cause compile errors at the SDK level. The compile errors will surface at the concrete plugin level (Plans 27-02 through 27-04) where plugins implement `StartAsync` which won't be required by the new base.

    **IIntelligenceAware interface removal:** Many intermediate bases implement `IIntelligenceAware` explicitly (e.g., `ShardManagerPluginBase : LegacyFeaturePluginBase, IIntelligenceAware`). Since the new Hierarchy bases already go through `IntelligenceAwarePluginBase`, the explicit `IIntelligenceAware` implementation is now redundant. KEEP IT for now (it's harmless and removing it would be extra risk). It can be cleaned in Phase 28.

    After all re-parenting, run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` to verify the SDK itself compiles. Fix any abstract member compilation errors by implementing required Hierarchy abstract members as `abstract` in the intermediate base (pass-through) or as `virtual` with sensible defaults.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile with zero new errors.
    Grep for `LegacyFeaturePluginBase` in all SDK .cs files to count remaining references (should only be the class definition itself and any [Obsolete] pointers).
  </verify>
  <done>All SDK intermediate plugin bases inherit from new Hierarchy domain bases. SDK project compiles. Only the `LegacyFeaturePluginBase` class definition and [Obsolete] attributes remain.</done>
</task>

<task type="auto">
  <name>Task 2: Re-parent bare-PluginBase intermediate bases (StorageProviderPluginBase, SecurityProviderPluginBase) and build-verify full solution</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Contracts/LowLatencyPluginBases.cs
    DataWarehouse.SDK/Contracts/MilitarySecurityPluginBases.cs
  </files>
  <action>
    Re-parent the two intermediate bases that inherit from bare `PluginBase` (not LegacyFeaturePluginBase):

    1. `StorageProviderPluginBase : PluginBase, IStorageProvider` (PluginBase.cs line ~1208)
       -> Change to `: DataPipelinePluginBase, IStorageProvider` (using `DataWarehouse.SDK.Contracts.Hierarchy`)
       This is the old storage base. It provides IStorageProvider interface which is different from the new Hierarchy StoragePluginBase's key-based model. Keep IStorageProvider interface implementation. DataPipelinePluginBase adds IntelligenceAware to the chain.
       NOTE: `ListableStoragePluginBase : StorageProviderPluginBase` and `LowLatencyStoragePluginBase : StorageProviderPluginBase` will automatically get re-parented.

    2. `SecurityProviderPluginBase : PluginBase` (PluginBase.cs line ~1402)
       -> Change to `: SecurityPluginBase` (using `DataWarehouse.SDK.Contracts.Hierarchy`)
       This already has security methods. SecurityPluginBase (Hierarchy) requires `abstract string SecurityDomain { get; }` -- add this as abstract in SecurityProviderPluginBase so concrete subclasses must implement it.
       NOTE: `AccessControlPluginBase : SecurityProviderPluginBase`, `KeyStorePluginBase : SecurityProviderPluginBase`, and all 4 MilitarySecurityPluginBases will automatically get re-parented.

    After re-parenting, run full solution build: `dotnet build DataWarehouse.slnx`

    Fix any compilation errors in plugins caused by:
    - New abstract members flowing down (add implementations or mark abstract in intermediate bases)
    - Member hiding (add `new` keyword where needed)
    - Missing `using` directives for Hierarchy namespace
    - Lifecycle method conflicts (StartAsync/StopAsync vs InitializeAsync/ShutdownAsync)

    **Handling StartAsync/StopAsync:** When plugins on LegacyFeaturePluginBase had `override Task StartAsync(CancellationToken ct)` and `override Task StopAsync()`, and the new Hierarchy base doesn't have these methods, the compiler will either:
    - Error with "no suitable method to override" -- fix by changing `override` to a regular method, or mapping to InitializeAsync/ShutdownAsync
    - Just work (if PluginBase has these as virtual/abstract) -- verify

    Check PluginBase for StartAsync/StopAsync -- if these exist as virtual/abstract on PluginBase itself, the override chain is fine. If they only existed on LegacyFeaturePluginBase, we need to handle the transition.

    The build output will guide what needs fixing. Fix all errors, targeting zero new errors (pre-existing CS1729/CS0234 in UltimateCompression and AedsCore are acceptable).
  </action>
  <verify>
    Run `dotnet build DataWarehouse.slnx` -- must show zero new errors beyond pre-existing.
    Grep `LegacyFeaturePluginBase` across entire codebase to verify only class definition, [Obsolete] markers, and concrete plugin files remain (concrete plugins are migrated in plans 27-02 through 27-04).
  </verify>
  <done>StorageProviderPluginBase and SecurityProviderPluginBase are on the new Hierarchy. Full solution builds with zero new errors. All intermediate SDK bases are migrated.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.slnx` passes with only pre-existing errors
- `grep -r "LegacyFeaturePluginBase" DataWarehouse.SDK/` shows only the class definition and [Obsolete] attributes
- All ~60 intermediate SDK bases now inherit from Hierarchy domain bases
- No concrete plugin code was changed (only SDK files)
</verification>

<success_criteria>
1. All SDK intermediate plugin bases inherit from new Hierarchy branch (DataPipelinePluginBase/FeaturePluginBase subtypes)
2. StorageProviderPluginBase and SecurityProviderPluginBase re-parented from bare PluginBase to Hierarchy
3. Full solution builds with zero new compilation errors
4. Zero concrete plugin files modified (all changes are SDK-internal)
</success_criteria>

<output>
After completion, create `.planning/phases/27-plugin-migration-decoupling/27-01-SUMMARY.md`
</output>
