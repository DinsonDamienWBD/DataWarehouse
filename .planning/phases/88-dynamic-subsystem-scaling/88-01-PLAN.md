---
phase: 88-dynamic-subsystem-scaling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
  - DataWarehouse.SDK/Contracts/Scaling/IBackpressureAware.cs
  - DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
  - DataWarehouse.SDK/Contracts/Scaling/ScalingModels.cs
autonomous: true

must_haves:
  truths:
    - "BoundedCache<TKey,TValue> provides O(1) get/put with LRU, ARC, and TTL eviction"
    - "IPersistentBackingStore implementations exist for file, VDE-region, and database backing"
    - "IScalableSubsystem unifies scaling contract across all plugins"
    - "IBackpressureAware supports drop-oldest, block-producer, shed-load, degrade-quality strategies"
    - "All Max* limits are runtime-reconfigurable via IScalingPolicy hierarchy"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs"
      provides: "IScalableSubsystem interface combining BoundedCache + IPersistentBackingStore + IScalingPolicy + IBackpressureAware"
      exports: ["IScalableSubsystem"]
    - path: "DataWarehouse.SDK/Contracts/Scaling/IBackpressureAware.cs"
      provides: "Backpressure contract with strategy enum and metrics"
      exports: ["IBackpressureAware", "BackpressureStrategy", "BackpressureMetrics"]
    - path: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      provides: "Generic bounded cache with LRU/ARC/TTL eviction, ghost list, auto-sizing"
      exports: ["BoundedCache<TKey,TValue>", "EvictionPolicy", "CacheEvictionEventArgs"]
    - path: "DataWarehouse.SDK/Contracts/Scaling/ScalingModels.cs"
      provides: "ScalingLimits, SubsystemScalingPolicy, ScalingHierarchyLevel models"
      exports: ["ScalingLimits", "SubsystemScalingPolicy", "ScalingHierarchyLevel"]
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      to: "DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs"
      via: "lazy-load on cache miss delegates to backing store"
      pattern: "IPersistentBackingStore.*ReadAsync"
    - from: "DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "IScalableSubsystem exposes BoundedCache instances"
      pattern: "BoundedCache"
---

<objective>
Create the SDK scaling contract foundation that all 60 plugins will use to replace unbounded in-memory state with bounded, persistent, backpressure-aware caches.

Purpose: This is the foundation for Phase 88 -- every other plan depends on these contracts and the BoundedCache implementation. Without this, no plugin can migrate to bounded state.

Output: Four SDK files providing IScalableSubsystem, IBackpressureAware, BoundedCache<TKey,TValue>, and scaling models.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs
@DataWarehouse.SDK/Contracts/Distributed/IAutoScaler.cs
@DataWarehouse.SDK/Utilities/BoundedDictionary.cs
@DataWarehouse.SDK/Contracts/ICacheableStorage.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IScalableSubsystem, IBackpressureAware, and ScalingModels</name>
  <files>
    DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
    DataWarehouse.SDK/Contracts/Scaling/IBackpressureAware.cs
    DataWarehouse.SDK/Contracts/Scaling/ScalingModels.cs
  </files>
  <action>
Create three files in a new `DataWarehouse.SDK/Contracts/Scaling/` directory:

**IScalableSubsystem.cs** -- the unifying interface:
- `[SdkCompatibility("6.0.0")]` attribute on all public types
- Namespace: `DataWarehouse.SDK.Contracts.Scaling`
- Interface `IScalableSubsystem` with:
  - `IReadOnlyDictionary<string, object> GetScalingMetrics()` -- current cache sizes, hit rates, backpressure state
  - `Task ReconfigureLimitsAsync(ScalingLimits limits, CancellationToken ct = default)` -- runtime limit changes
  - `ScalingLimits CurrentLimits { get; }` -- current effective limits
  - `BackpressureState CurrentBackpressureState { get; }` -- current backpressure state

**IBackpressureAware.cs** -- backpressure contract:
- `BackpressureStrategy` enum: `DropOldest`, `BlockProducer`, `ShedLoad`, `DegradeQuality`, `Adaptive`
- `BackpressureState` enum: `Normal`, `Warning`, `Critical`, `Shedding`
- Interface `IBackpressureAware`:
  - `BackpressureStrategy Strategy { get; set; }` -- runtime-changeable
  - `BackpressureState CurrentState { get; }`
  - `event Action<BackpressureStateChangedEventArgs>? OnBackpressureChanged`
  - `Task ApplyBackpressureAsync(BackpressureContext context, CancellationToken ct = default)`
- `BackpressureStateChangedEventArgs` record with `PreviousState`, `CurrentState`, `SubsystemName`, `Timestamp`
- `BackpressureContext` record with `CurrentLoad`, `MaxCapacity`, `QueueDepth`, `LatencyP99`

**ScalingModels.cs** -- shared models:
- `ScalingLimits` record: `MaxCacheEntries` (int), `MaxMemoryBytes` (long), `MaxConcurrentOperations` (int), `MaxQueueDepth` (int), all with sensible defaults
- `SubsystemScalingPolicy` record: `InstanceLimits` (ScalingLimits), `TenantLimits` (ScalingLimits?), `UserLimits` (ScalingLimits?), `AutoSizeFromRam` (bool, default true), `RamPercentage` (double, default 0.1)
- `ScalingHierarchyLevel` enum: `Instance`, `Tenant`, `User`
- `ScalingReconfiguredEventArgs` record with `SubsystemName`, `OldLimits`, `NewLimits`, `Timestamp`

All types must have full XML documentation. Use `required` keyword on init properties where appropriate.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile with 0 errors. Grep for `IScalableSubsystem` to confirm it exists in the expected path.
  </verify>
  <done>IScalableSubsystem, IBackpressureAware, BackpressureStrategy, ScalingLimits, SubsystemScalingPolicy all compile and are in the SDK Contracts/Scaling directory with full XML docs and [SdkCompatibility("6.0.0")] attributes.</done>
</task>

<task type="auto">
  <name>Task 2: Create BoundedCache with LRU/ARC/TTL eviction and backing store integration</name>
  <files>
    DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
  </files>
  <action>
Create `BoundedCache<TKey, TValue>` in `DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs`. This is a more advanced version of the existing `BoundedDictionary<TKey,TValue>` in `DataWarehouse.SDK/Utilities/BoundedDictionary.cs`.

Key differences from existing BoundedDictionary:
- Supports **three eviction policies**: LRU (linked list), ARC (adaptive replacement with ghost lists T1/T2/B1/B2 per the ARC paper), and TTL (time-based expiry with lazy cleanup + background timer)
- **Ghost list adaptation** for ARC: maintains B1/B2 ghost lists that track recently evicted keys to auto-tune the T1/T2 split point
- **Auto-sizing from RAM**: constructor accepts `autoSizeFromRam: true` + `ramPercentage: 0.1` to compute max entries from `GC.GetGCMemoryInfo().TotalAvailableMemoryBytes`
- **Persistent backing store integration**: accepts `IPersistentBackingStore` + serialization delegates. On cache miss, calls `_backingStore.ReadAsync(path)` and deserializes. On eviction (if write-through enabled), calls `_backingStore.WriteAsync(path, serialized)`.
- **Thread-safe** using `ReaderWriterLockSlim` (same pattern as BoundedDictionary)
- **O(1) get/put** for LRU and ARC modes

`[SdkCompatibility("6.0.0")]` attribute.

Public API:
- Constructor: `BoundedCache(BoundedCacheOptions<TKey, TValue> options)`
- `BoundedCacheOptions<TKey, TValue>` class: `MaxEntries` (int), `EvictionPolicy` (CacheEvictionMode enum: LRU/ARC/TTL), `DefaultTtl` (TimeSpan?), `AutoSizeFromRam` (bool), `RamPercentage` (double), `BackingStore` (IPersistentBackingStore?), `BackingStorePath` (string?), `Serializer` (Func<TValue, byte[]>?), `Deserializer` (Func<byte[], TValue>?), `KeyToString` (Func<TKey, string>?), `WriteThrough` (bool)
- `TValue? GetOrDefault(TKey key)` -- sync get, returns default on miss (no backing store hit)
- `Task<TValue?> GetAsync(TKey key, CancellationToken ct = default)` -- async get with backing store fallback
- `void Put(TKey key, TValue value)` -- sync put
- `Task PutAsync(TKey key, TValue value, CancellationToken ct = default)` -- async put with write-through
- `bool TryRemove(TKey key, out TValue? value)`
- `bool ContainsKey(TKey key)`
- `int Count { get; }`
- `long EstimatedMemoryBytes { get; }` -- approximate memory usage
- `CacheStatistics GetStatistics()` -- reuse existing CacheStatistics from ICacheableStorage.cs
- `event Action<TKey, TValue>? OnEvicted`
- Implements `IEnumerable<KeyValuePair<TKey, TValue>>`, `IDisposable`, `IAsyncDisposable`

Do NOT deprecate or modify the existing `BoundedDictionary` -- it remains for backward compatibility. New code should use `BoundedCache`.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile with 0 errors. Verify BoundedCache has LRU, ARC, TTL modes by grepping for `CacheEvictionMode`.
  </verify>
  <done>BoundedCache compiles with LRU/ARC/TTL eviction, ghost-list ARC adaptation, auto-sizing from RAM, IPersistentBackingStore integration for lazy-load on miss and write-through on eviction, thread-safe O(1) operations, full XML docs, [SdkCompatibility("6.0.0")].</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- All four files exist in `DataWarehouse.SDK/Contracts/Scaling/`
- `IScalableSubsystem`, `IBackpressureAware`, `BoundedCache<,>`, `ScalingLimits`, `SubsystemScalingPolicy` all present
- No modifications to existing `BoundedDictionary` or `IPersistentBackingStore`
</verification>

<success_criteria>
SDK scaling contracts compile, BoundedCache supports LRU/ARC/TTL with backing store integration, all types have [SdkCompatibility("6.0.0")] and XML docs. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md`
</output>
