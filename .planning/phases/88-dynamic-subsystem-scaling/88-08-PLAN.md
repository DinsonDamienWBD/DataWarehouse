---
phase: 88-dynamic-subsystem-scaling
plan: 08
type: execute
wave: 3
depends_on: ["88-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Scaling/CatalogScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Scaling/GovernanceScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/Scaling/LineageScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataMesh/Scaling/DataMeshScalingManager.cs
autonomous: true

must_haves:
  truths:
    - "DataCatalog assets, relationships, and glossary persist across restarts"
    - "Governance policies, ownership, and classifications persist across restarts"
    - "Lineage graph persists with configurable max traversal depth"
    - "DataMesh domains, products, consumers, shares, and policies persist"
    - "All four plugins use BoundedCache with LRU/TTL eviction"
    - "Listing operations support pagination"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Scaling/CatalogScalingManager.cs"
      provides: "Persistent catalog store, LRU cache, paginated listings, IScalableSubsystem"
      exports: ["CatalogScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Scaling/GovernanceScalingManager.cs"
      provides: "Persistent governance store, TTL cache, parallel strategy evaluation, IScalableSubsystem"
      exports: ["GovernanceScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataLineage/Scaling/LineageScalingManager.cs"
      provides: "Persistent graph store, graph partitioning, paginated lineage queries, IScalableSubsystem"
      exports: ["LineageScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataMesh/Scaling/DataMeshScalingManager.cs"
      provides: "Persistent mesh store, cross-domain federation, bounded caches, IScalableSubsystem"
      exports: ["DataMeshScalingManager"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Scaling/CatalogScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "BoundedCache for asset/relationship/glossary caches"
      pattern: "BoundedCache"
    - from: "Plugins/DataWarehouse.Plugins.UltimateDataLineage/Scaling/LineageScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs"
      via: "Graph adjacency lists persist through backing store"
      pattern: "IPersistentBackingStore"
---

<objective>
Add persistence, bounded caches, and pagination to DataCatalog, DataGovernance, DataLineage, and DataMesh plugins so no data is lost on restart and memory is bounded.

Purpose: DSCL-13/14/15/16 -- all four data intelligence plugins currently store entity state in unbounded in-memory dictionaries. On restart, all state is lost. Under load, memory grows without bound.

Output: Four new scaling manager files, one per plugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateDataCatalog/
@Plugins/DataWarehouse.Plugins.UltimateDataGovernance/
@Plugins/DataWarehouse.Plugins.UltimateDataLineage/
@Plugins/DataWarehouse.Plugins.UltimateDataMesh/
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
@DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CatalogScalingManager and GovernanceScalingManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Scaling/CatalogScalingManager.cs
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Scaling/GovernanceScalingManager.cs
  </files>
  <action>
**CatalogScalingManager** implementing `IScalableSubsystem`:
1. Replace unbounded asset/relationship/glossary dictionaries with `BoundedCache<string, T>` (LRU, default 100K assets, 500K relationships, 50K glossary terms). Write-through to `IPersistentBackingStore`.
2. Pagination for `ListAssets`, `ListRelationships`, `SearchGlossary`: accept `(int offset, int limit)` params, return `PagedResult<T>` with `Items`, `TotalCount`, `HasMore`.
3. Sharding for large catalogs: partition assets by namespace prefix. Each shard has its own BoundedCache instance. Shard count auto-scales (1 shard per 100K assets, max 256 shards).
4. Wire into UltimateDataCatalogPlugin.InitializeAsync.

**GovernanceScalingManager** implementing `IScalableSubsystem`:
1. Replace unbounded policy/ownership/classification dictionaries with `BoundedCache<string, T>` (TTL 15 min, default 50K policies, 100K ownerships, 100K classifications). Write-through to `IPersistentBackingStore`.
2. Parallel strategy evaluation: when checking compliance across multiple governance frameworks, evaluate in parallel using `Task.WhenAll` with configurable `MaxConcurrentEvaluations` (default: `Environment.ProcessorCount`). Use `SemaphoreSlim` to limit concurrency.
3. TTL cache refresh: on cache miss, load from backing store. On TTL expiry, refresh in background (stale-while-revalidate pattern to avoid latency spikes).
4. Wire into UltimateDataGovernancePlugin.InitializeAsync.

Both: `[SdkCompatibility("6.0.0")]`. Full XML docs. `GetScalingMetrics()` returns cache sizes, hit rates, backing store operation counts.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj && dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj` compiles with 0 errors.
  </verify>
  <done>DataCatalog persists assets/relationships/glossary with LRU cache, pagination, and auto-sharding. Governance persists policies/ownership/classifications with TTL cache and parallel evaluation. Both implement IScalableSubsystem.</done>
</task>

<task type="auto">
  <name>Task 2: Create LineageScalingManager and DataMeshScalingManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataLineage/Scaling/LineageScalingManager.cs
    Plugins/DataWarehouse.Plugins.UltimateDataMesh/Scaling/DataMeshScalingManager.cs
  </files>
  <action>
**LineageScalingManager** implementing `IScalableSubsystem`:
1. Persistent graph store: Serialize adjacency lists (node -> edges) to `IPersistentBackingStore`. Key format: `dw://internal/lineage/{nodeId}`. Each node stores its outgoing edges.
2. Graph partitioning: Partition nodes by consistent hash into N partitions (default 16). Each partition has its own BoundedCache (LRU, default 50K nodes per partition). Hot partitions auto-expand.
3. Paginated lineage queries: `TraceLineage(nodeId, direction, maxDepth, offset, limit)` returns `PagedResult<LineageNode>`. Configurable `MaxTraversalDepth` (default 50) prevents runaway graph walks. Traversal uses BFS with visited set.
4. Wire into UltimateDataLineagePlugin.InitializeAsync.

**DataMeshScalingManager** implementing `IScalableSubsystem`:
1. Persistent store for domains, data products, consumers, data shares, and mesh policies. Each collection uses `BoundedCache<string, T>` with write-through to `IPersistentBackingStore`. Defaults: 1K domains, 10K products, 50K consumers, 10K shares, 5K policies.
2. Cross-domain federation: For multi-instance deployments, publish domain/product changes to `dw.mesh.federation.events` via message bus. Subscribe to receive remote domain changes. Merge remote catalog entries into local BoundedCache with last-writer-wins by timestamp.
3. Bounded caches for all entity stores. No unbounded ConcurrentDictionary in DataMesh.
4. Wire into UltimateDataMeshPlugin.InitializeAsync.

Both: `[SdkCompatibility("6.0.0")]`. Full XML docs. `GetScalingMetrics()` returns node counts, partition sizes, cache hit rates, federation sync lag.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateDataLineage/DataWarehouse.Plugins.UltimateDataLineage.csproj && dotnet build Plugins/DataWarehouse.Plugins.UltimateDataMesh/DataWarehouse.Plugins.UltimateDataMesh.csproj` compiles with 0 errors.
  </verify>
  <done>Lineage uses persistent graph store with partitioned BoundedCaches, paginated BFS traversal, and configurable max depth. DataMesh persists all entity stores with cross-domain federation via message bus. Both implement IScalableSubsystem.</done>
</task>

</tasks>

<verification>
- All four plugins build with 0 errors
- Each plugin has BoundedCache for entity stores (not raw ConcurrentDictionary)
- IPersistentBackingStore used for write-through persistence
- Pagination support visible in catalog and lineage code
- Governance parallel evaluation uses Task.WhenAll with SemaphoreSlim
</verification>

<success_criteria>
All four data intelligence plugins persist entity state, use bounded caches with eviction, support pagination, and implement IScalableSubsystem. No data loss on restart, no memory exhaustion under load. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-08-SUMMARY.md`
</output>
