---
phase: 88-dynamic-subsystem-scaling
plan: 10
type: execute
wave: 4
depends_on: ["88-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompute/Scaling/WasmScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateWorkflow/Scaling/PipelineScalingManager.cs
autonomous: true

must_haves:
  truths:
    - "WASM MaxPages is configurable per-module (not hardcoded 256)"
    - "WASM MaxConcurrentExecutions adjusts dynamically based on system load"
    - "WASM module state persists across restarts with warm instance pooling"
    - "Pipeline has configurable maximum depth and concurrent transaction limits"
    - "Pipeline CapturedState has size limits per stage"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompute/Scaling/WasmScalingManager.cs"
      provides: "Configurable WASM limits, dynamic execution scaling, instance pooling, state persistence, IScalableSubsystem"
      exports: ["WasmScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateWorkflow/Scaling/PipelineScalingManager.cs"
      provides: "Pipeline depth limits, concurrent transactions, state size limits, parallel rollback, IScalableSubsystem"
      exports: ["PipelineScalingManager"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompute/Scaling/WasmScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs"
      via: "Implements IScalableSubsystem for WASM runtime"
      pattern: "IScalableSubsystem"
    - from: "Plugins/DataWarehouse.Plugins.UltimateWorkflow/Scaling/PipelineScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "BoundedCache for pipeline state snapshots"
      pattern: "BoundedCache"
---

<objective>
Scale WASM runtime with configurable per-module limits, dynamic execution scaling, and instance pooling. Scale pipeline with depth limits, concurrent transactions, state size limits, and parallel rollback.

Purpose: DSCL-06/23 -- WASM has hardcoded limits and no instance reuse. Pipeline has no depth/concurrency protection and unlimited state capture.

Output: Two new scaling manager files for compute and pipeline plugins.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateCompute/UltimateComputePlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateWorkflow/UltimateWorkflowPlugin.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WasmScalingManager with dynamic limits and instance pooling</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompute/Scaling/WasmScalingManager.cs
  </files>
  <action>
Create `WasmScalingManager` implementing `IScalableSubsystem`:

1. **Configurable MaxPages per-module**: Replace hardcoded 256 page limit with per-module configuration stored in `BoundedCache<string, WasmModuleConfig>`. Default 256, configurable up to 65536 (4GB). Modules can request specific limits via metadata. Configuration persists via `IPersistentBackingStore`.

2. **Dynamic MaxConcurrentExecutions**: Monitor system load (CPU usage via `Environment.ProcessorCount` and thread pool stats, memory via `GC.GetGCMemoryInfo()`). When load is low (<50% CPU), increase max concurrent (up to `2 * ProcessorCount`). When load is high (>80% CPU), decrease (down to `ProcessorCount / 2`). Adjustment interval: 10s. Use exponential moving average for smooth transitions.

3. **Module state persistence**: Serialize WASM module linear memory to `IPersistentBackingStore` on suspension. Restore on next invocation. Key: `dw://internal/wasm-state/{moduleId}`. Only persist if module opts in via metadata flag.

4. **Warm instance pooling**: Maintain pool of pre-initialized WASM instances per module type. Pool size: `BoundedCache<string, Queue<WasmInstance>>` with LRU eviction of least-used module types. On execution request: dequeue from pool (or create new if empty). On completion: reset instance state, enqueue back to pool. Max pool size per module: configurable (default 10).

5. Wire into `UltimateComputePlugin.InitializeAsync`. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateCompute/DataWarehouse.Plugins.UltimateCompute.csproj` compiles with 0 errors. Grep for hardcoded `256` in the compute plugin -- should not appear as a page limit (only in comments or unrelated contexts).
  </verify>
  <done>WASM MaxPages configurable per-module. MaxConcurrentExecutions adjusts dynamically from system load. Module state persists via backing store. Warm instance pooling reduces cold-start latency. Implements IScalableSubsystem.</done>
</task>

<task type="auto">
  <name>Task 2: Create PipelineScalingManager with depth limits and parallel rollback</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateWorkflow/Scaling/PipelineScalingManager.cs
  </files>
  <action>
Create `PipelineScalingManager` implementing `IScalableSubsystem`:

1. **Configurable maximum pipeline depth**: Reject pipeline configurations deeper than `MaxPipelineDepth` (default 50 stages). Configurable at runtime via `ReconfigureLimitsAsync`. Prevents infinite or excessively deep pipelines that exhaust stack/memory.

2. **Concurrent transaction limits**: Use `SemaphoreSlim` to limit concurrent pipeline executions. Default: `Environment.ProcessorCount * 2`. Configurable via `ScalingLimits.MaxConcurrentOperations`. Queued pipelines wait (with configurable timeout, default 30s) or are rejected with backpressure signal.

3. **CapturedState size limits per stage**: Each pipeline stage can capture state for rollback. Limit captured state to `MaxStateBytes` per stage (default 10MB). If state exceeds limit, spill to `IPersistentBackingStore` (key: `dw://internal/pipeline-state/{pipelineId}/{stageIndex}`). On rollback, load from backing store.

4. **Parallel rollback for independent stages**: When rolling back, identify independent stages (no data dependencies between them) and rollback in parallel using `Task.WhenAll`. Dependent stages rollback sequentially in reverse order.

5. Wire into `UltimateWorkflowPlugin.InitializeAsync`. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateWorkflow/DataWarehouse.Plugins.UltimateWorkflow.csproj` compiles with 0 errors. Grep for `MaxPipelineDepth` in PipelineScalingManager to confirm depth limiting.
  </verify>
  <done>Pipeline enforces max depth, concurrent transaction limits, per-stage state size limits with spill-to-disk, and parallel rollback of independent stages. Implements IScalableSubsystem.</done>
</task>

</tasks>

<verification>
- Both plugins build with 0 errors
- WASM MaxPages is per-module configurable (not hardcoded)
- Instance pool uses BoundedCache
- Pipeline depth limit enforced
- CapturedState spills to IPersistentBackingStore when oversized
</verification>

<success_criteria>
WASM runtime scales with dynamic per-module limits, instance pooling, and state persistence. Pipeline scales with depth limits, concurrent transaction bounds, state size limits, and parallel rollback. Both implement IScalableSubsystem. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-10-SUMMARY.md`
</output>
