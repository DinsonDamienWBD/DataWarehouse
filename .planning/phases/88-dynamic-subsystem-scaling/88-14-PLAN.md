---
phase: 88-dynamic-subsystem-scaling
plan: 14
type: execute
wave: 5
depends_on: ["88-13"]
files_modified:
  - Tests/DataWarehouse.Tests/Scaling/BoundedCacheTests.cs
  - Tests/DataWarehouse.Tests/Scaling/BackpressureTests.cs
  - Tests/DataWarehouse.Tests/Scaling/SubsystemScalingIntegrationTests.cs
autonomous: true

must_haves:
  truths:
    - "BoundedCache LRU/ARC/TTL eviction verified under load"
    - "Backpressure engages at configured thresholds"
    - "Persistence survives simulated kill/restart"
    - "Runtime limit reconfiguration takes effect without restart"
    - "No subsystem exhausts memory at 10x design load"
  artifacts:
    - path: "Tests/DataWarehouse.Tests/Scaling/BoundedCacheTests.cs"
      provides: "Unit tests for BoundedCache eviction policies, backing store integration, auto-sizing"
      exports: ["BoundedCacheTests"]
    - path: "Tests/DataWarehouse.Tests/Scaling/BackpressureTests.cs"
      provides: "Tests for backpressure strategies and state transitions"
      exports: ["BackpressureTests"]
    - path: "Tests/DataWarehouse.Tests/Scaling/SubsystemScalingIntegrationTests.cs"
      provides: "Integration tests for subsystem scaling, persistence, reconfiguration"
      exports: ["SubsystemScalingIntegrationTests"]
  key_links:
    - from: "Tests/DataWarehouse.Tests/Scaling/BoundedCacheTests.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "Tests BoundedCache directly with various eviction modes"
      pattern: "BoundedCache"
    - from: "Tests/DataWarehouse.Tests/Scaling/SubsystemScalingIntegrationTests.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs"
      via: "Tests IScalableSubsystem implementations across plugins"
      pattern: "IScalableSubsystem"
---

<objective>
Create integration tests verifying that dynamic scaling works correctly: BoundedCache eviction, backpressure engagement, persistence survival, runtime reconfiguration, and memory bounds under load.

Purpose: Phase 88 success criterion 14: "No subsystem exhausts memory when handling 10x its design load -- backpressure engages gracefully." Tests prove the scaling infrastructure works.

Output: Three test files covering cache, backpressure, and integration scenarios.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
@DataWarehouse.SDK/Contracts/Scaling/IBackpressureAware.cs
@DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BoundedCache and Backpressure unit tests</name>
  <files>
    Tests/DataWarehouse.Tests/Scaling/BoundedCacheTests.cs
    Tests/DataWarehouse.Tests/Scaling/BackpressureTests.cs
  </files>
  <action>
**BoundedCacheTests.cs** -- comprehensive tests for BoundedCache:
1. **LRU eviction**: Insert N+1 items into cache of size N, verify oldest item evicted, newest retained. Verify access promotes item (not evicted next).
2. **ARC eviction**: Verify ghost list adaptation -- access pattern that favors recency should increase T1, frequency pattern should increase T2. Verify T1/T2 split adapts over time.
3. **TTL eviction**: Insert item with 100ms TTL, verify available immediately, verify gone after 150ms. Verify background cleanup removes expired items.
4. **Backing store integration**: Create BoundedCache with in-memory IPersistentBackingStore. Insert items, evict from cache, verify backing store contains evicted items. Access evicted item, verify loaded from backing store (cache miss -> backing store hit).
5. **Write-through**: Enable write-through mode. Put item, verify immediately in backing store. Verify write-through on every put (not just eviction).
6. **Auto-sizing**: Create cache with `autoSizeFromRam: true`, verify max entries > 0 and proportional to available RAM.
7. **Thread safety**: Run 100 concurrent tasks doing random get/put/remove, verify no exceptions, consistent state at end.
8. **Statistics**: Verify hit/miss counts increment correctly. Verify eviction count matches expected.
9. **OnEvicted event**: Subscribe to event, fill cache, verify event fires with correct key/value.

**BackpressureTests.cs** -- tests for IBackpressureAware:
1. **State transitions**: Verify Normal -> Warning -> Critical -> Shedding transitions at correct thresholds.
2. **Event firing**: Verify OnBackpressureChanged fires with correct previous/current state.
3. **DropOldest**: Fill queue, verify oldest items dropped, newest retained.
4. **BlockProducer**: Fill to capacity, verify next publish blocks until space available.
5. **ShedLoad**: Exceed capacity, verify rejects with error.
6. **Adaptive**: Apply load patterns, verify strategy auto-switches appropriately.

Use xUnit (consistent with existing test suite). All tests deterministic (no flaky timing-dependent tests -- use controllable clocks/thresholds).
  </action>
  <verify>
`dotnet test Tests/DataWarehouse.Tests/ --filter "FullyQualifiedName~Scaling.BoundedCache|FullyQualifiedName~Scaling.Backpressure"` -- all tests pass with 0 failures.
  </verify>
  <done>BoundedCache tested for LRU/ARC/TTL eviction, backing store lazy-load, write-through, auto-sizing, thread safety, and statistics. Backpressure tested for state transitions, all strategies, and adaptive behavior. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create subsystem scaling integration tests</name>
  <files>
    Tests/DataWarehouse.Tests/Scaling/SubsystemScalingIntegrationTests.cs
  </files>
  <action>
Create integration tests that verify the scaling infrastructure works end-to-end:

1. **Persistence survival**: Create a BoundedCache with file-backed IPersistentBackingStore. Insert 1000 items. Dispose cache (simulating restart). Create new cache with same backing store path. Verify all 1000 items recoverable via GetAsync (lazy-loaded from backing store on miss).

2. **Runtime reconfiguration**: Create IScalableSubsystem implementation (use a test double or the simplest real one like CatalogScalingManager). Set initial MaxCacheEntries=100. Insert 200 items (100 evicted). Call ReconfigureLimitsAsync with MaxCacheEntries=500. Insert 300 more. Verify cache now holds up to 500.

3. **Memory ceiling under load**: Create BoundedCache with MaxEntries=10000. In a loop, insert 100,000 items (10x over capacity). Measure memory before and after. Verify memory increase is bounded (not 10x -- should be roughly proportional to MaxEntries, not total inserts).

4. **Backpressure engagement**: Create message bus or streaming subsystem with low capacity (100 items). Publish 1000 items rapidly. Verify backpressure state transitions from Normal -> Warning -> Critical. Verify either items are dropped (DropOldest), producer is blocked (BlockProducer), or publishes are rejected (ShedLoad) depending on configured strategy.

5. **IScalableSubsystem metrics**: Create any IScalableSubsystem implementation. Exercise it. Call GetScalingMetrics(). Verify returned dictionary contains expected keys (cache sizes, hit rates, etc.) with reasonable values.

6. **Concurrent scaling reconfiguration**: Start 10 concurrent writers. While writing, reconfigure limits 5 times. Verify no exceptions, no data corruption, limits eventually converge.

Use xUnit. Tests should complete in under 30 seconds total (no long stress tests in unit test suite -- those belong in manual verification).
  </action>
  <verify>
`dotnet test Tests/DataWarehouse.Tests/ --filter "FullyQualifiedName~Scaling.SubsystemScaling"` -- all tests pass with 0 failures.
  </verify>
  <done>Integration tests verify persistence survival, runtime reconfiguration, memory ceiling, backpressure engagement, metrics reporting, and concurrent reconfiguration. All tests pass in under 30 seconds.</done>
</task>

</tasks>

<verification>
- All tests compile and pass: `dotnet test Tests/DataWarehouse.Tests/ --filter "FullyQualifiedName~Scaling"`
- BoundedCache tests cover LRU, ARC, TTL, backing store, thread safety
- Backpressure tests cover all strategies and state transitions
- Integration tests verify persistence, reconfiguration, memory bounds
- No flaky tests (deterministic, no real timers in assertions)
</verification>

<success_criteria>
Comprehensive test suite proves BoundedCache eviction correctness, backpressure engagement, persistence survival, runtime reconfigurability, and memory bounds. All tests pass. Test execution under 30 seconds.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-14-SUMMARY.md`
</output>
