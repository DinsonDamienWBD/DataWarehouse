---
phase: 88-dynamic-subsystem-scaling
plan: 12
type: execute
wave: 4
depends_on: ["88-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Scaling/CompressionScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/Scaling/EncryptionScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Scaling/SearchScalingManager.cs
autonomous: true

must_haves:
  truths:
    - "Compression buffer sizes adapt based on input size and available memory"
    - "Encryption hardware capabilities are re-detected at runtime for containers"
    - "Search uses proper inverted index (not ConcurrentDictionary iteration)"
    - "Search results support pagination and streaming"
    - "Vector index supports horizontal sharding"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Scaling/CompressionScalingManager.cs"
      provides: "Adaptive buffers, parallel chunk compression, per-request quality, IScalableSubsystem"
      exports: ["CompressionScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/Scaling/EncryptionScalingManager.cs"
      provides: "Runtime hardware re-detection, dynamic migrations, per-algorithm parallelism, IScalableSubsystem"
      exports: ["EncryptionScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Scaling/SearchScalingManager.cs"
      provides: "Inverted index, paginated search, vector sharding, IScalableSubsystem"
      exports: ["SearchScalingManager"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateStorage/Scaling/SearchScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "BoundedCache for inverted index posting lists and vector index segments"
      pattern: "BoundedCache"
---

<objective>
Scale compression (adaptive buffers, parallel chunks), encryption (hardware re-detection, dynamic migrations), and search (inverted index, pagination, vector sharding).

Purpose: DSCL-17/18/19 -- compression uses static buffers, encryption can't re-detect hardware in containers, and search iterates dictionaries instead of using proper index structures.

Output: Three new scaling manager files for compression, encryption, and search.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateCompression/UltimateCompressionPlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateStorage/UltimateStoragePlugin.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CompressionScalingManager and EncryptionScalingManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompression/Scaling/CompressionScalingManager.cs
    Plugins/DataWarehouse.Plugins.UltimateEncryption/Scaling/EncryptionScalingManager.cs
  </files>
  <action>
**CompressionScalingManager** implementing `IScalableSubsystem`:
1. **Adaptive buffer sizing**: Calculate buffer size from input size and available memory. Small inputs (<1MB): buffer = input size. Medium (1MB-100MB): buffer = min(input/4, available_ram * 0.05). Large (>100MB): stream with fixed 4MB buffers. All thresholds configurable via `ScalingLimits`.
2. **Parallel chunk compression**: For large inputs, split into chunks and compress in parallel. Chunk size: configurable (default 4MB). Max parallel chunks: `Math.Min(Environment.ProcessorCount, input_chunks)`. Use `SemaphoreSlim` for concurrency control. Reassemble compressed chunks in order.
3. **Per-request QualityLevel**: Accept `QualityLevel` parameter (Fast/Balanced/Best) per compression request. Maps to algorithm-specific parameters (e.g., Zstd level 1/10/22). Configurable default via `ScalingLimits`.
4. Wire into plugin. `[SdkCompatibility("6.0.0")]`. Full XML docs.

**EncryptionScalingManager** implementing `IScalableSubsystem`:
1. **Runtime hardware capability re-detection**: Periodically (configurable, default 5min) re-probe CPU features: AES-NI, AVX2/AVX-512, SHA extensions. For container environments where CPU features can change on live migration. Switch crypto implementation (hardware-accelerated vs software) based on detected capabilities. Use `System.Runtime.Intrinsics.X86.Aes.IsSupported` etc.
2. **Dynamically adjustable MaxConcurrentMigrations**: Key migration and algorithm rotation operations limited by `SemaphoreSlim`. Default: 2. Configurable via `ScalingLimits.MaxConcurrentOperations`. Increase when system is idle, decrease under load.
3. **Per-algorithm parallelism**: Different encryption algorithms have different parallelism profiles. AES-GCM: highly parallelizable (use max cores). ChaCha20-Poly1305: moderately parallel. Post-quantum (ML-KEM): single-threaded per operation. Store per-algorithm concurrency limits in `BoundedCache<string, int>`.
4. Wire into plugin. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateCompression/DataWarehouse.Plugins.UltimateCompression.csproj && dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj` compiles with 0 errors.
  </verify>
  <done>Compression adapts buffer sizes from input/memory, parallelizes chunk compression, and supports per-request quality levels. Encryption re-detects hardware at runtime, dynamically adjusts migration concurrency, and configures per-algorithm parallelism. Both implement IScalableSubsystem.</done>
</task>

<task type="auto">
  <name>Task 2: Create SearchScalingManager with inverted index and vector sharding</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateStorage/Scaling/SearchScalingManager.cs
  </files>
  <action>
Create `SearchScalingManager` implementing `IScalableSubsystem`:

1. **Proper inverted index**: Replace `ConcurrentDictionary` iteration for text search with a proper inverted index structure:
   - Posting list per term: `BoundedCache<string, PostingList>` where `PostingList` contains sorted document IDs with frequency data
   - Term dictionary: sorted array or trie for prefix queries
   - Index updates: batch writes (configurable flush interval, default 1s) with WAL for durability
   - Tokenizer: configurable (whitespace, n-gram, analyzer chain)
   - Boolean query support: AND/OR/NOT via posting list intersection/union/difference

2. **Search result pagination**: `Search(query, offset, limit)` returns `PagedSearchResult` with `Items`, `TotalHits`, `HasMore`, `ContinuationToken`. Internal: skip first `offset` results during posting list iteration (efficient skip via block-based posting lists).

3. **Streaming results**: `SearchStream(query)` returns `IAsyncEnumerable<SearchHit>` for unbounded result sets. Materializes results lazily from posting list iterators.

4. **Vector index sharding**: Partition vector space into N shards (default: `Environment.ProcessorCount`). Each shard contains a subset of vectors assigned by ID hash. Search queries fan out to all shards in parallel, merge results by score. Shard size bounded by `ScalingLimits.MaxCacheEntries`.

5. **Metrics**: index size, term count, search latency p50/p95/p99, cache hit rate, shard distribution.

Wire into `UltimateStoragePlugin`. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj` compiles with 0 errors. Grep for `PostingList` in SearchScalingManager to confirm inverted index structure.
  </verify>
  <done>Search uses proper inverted index with posting lists, boolean queries, pagination, streaming results, and sharded vector index. No ConcurrentDictionary iteration for search. Implements IScalableSubsystem.</done>
</task>

</tasks>

<verification>
- All three plugins build with 0 errors
- Compression buffer size adapts based on input size (not static)
- Encryption hardware detection uses System.Runtime.Intrinsics probes
- Search has PostingList-based inverted index (not dictionary iteration)
- Vector sharding distributes across ProcessorCount shards
</verification>

<success_criteria>
Compression, encryption, and search scale with adaptive resources, proper index structures, pagination, and hardware-aware configuration. All implement IScalableSubsystem. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-12-SUMMARY.md`
</output>
