---
phase: 88-dynamic-subsystem-scaling
plan: 11
type: execute
wave: 4
depends_on: ["88-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDatabaseStorage/Scaling/DatabaseStorageScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateFilesystem/Scaling/FilesystemScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataProtection/Scaling/BackupScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/Scaling/FabricScalingManager.cs
autonomous: true

must_haves:
  truths:
    - "Database HandleRetrieveAsync streams data (not MemoryStream.ToArray())"
    - "Database query results support pagination and streaming"
    - "Filesystem has dynamic I/O scheduling with configurable queue depths"
    - "Backup MaxConcurrentJobs adjusts dynamically based on I/O capacity"
    - "DataFabric MaxNodes per topology is runtime-configurable with dynamic topology switching"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDatabaseStorage/Scaling/DatabaseStorageScalingManager.cs"
      provides: "Streaming retrieval, paginated queries, parallel health checks, IScalableSubsystem"
      exports: ["DatabaseStorageScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateFilesystem/Scaling/FilesystemScalingManager.cs"
      provides: "Dynamic I/O scheduling, queue depths, kernel bypass re-detection, IScalableSubsystem"
      exports: ["FilesystemScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataProtection/Scaling/BackupScalingManager.cs"
      provides: "Dynamic MaxConcurrentJobs, crash recovery, retention management, IScalableSubsystem"
      exports: ["BackupScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/Scaling/FabricScalingManager.cs"
      provides: "Runtime MaxNodes, dynamic topology switching, health-based node management, IScalableSubsystem"
      exports: ["FabricScalingManager"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateDatabaseStorage/Scaling/DatabaseStorageScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs"
      via: "Implements IScalableSubsystem for database storage"
      pattern: "IScalableSubsystem"
---

<objective>
Scale database storage (streaming retrieval, pagination), filesystem (I/O scheduling), backup (dynamic concurrency, crash recovery), and DataFabric (runtime topology) plugins.

Purpose: DSCL-20/21/22/24 -- database uses MemoryStream.ToArray() (OOM on large objects), filesystem has static I/O, backup has hardcoded concurrency, and DataFabric has static topology limits.

Output: Four new scaling manager files for storage and I/O plugins.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateDatabaseStorage/
@Plugins/DataWarehouse.Plugins.UltimateFilesystem/
@Plugins/DataWarehouse.Plugins.UltimateDataProtection/
@Plugins/DataWarehouse.Plugins.UniversalFabric/
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DatabaseStorageScalingManager and FilesystemScalingManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDatabaseStorage/Scaling/DatabaseStorageScalingManager.cs
    Plugins/DataWarehouse.Plugins.UltimateFilesystem/Scaling/FilesystemScalingManager.cs
  </files>
  <action>
**DatabaseStorageScalingManager** implementing `IScalableSubsystem`:
1. **Fix HandleRetrieveAsync**: Replace `MemoryStream.ToArray()` with streaming: return `Stream` directly (or `IAsyncEnumerable<byte[]>` for chunked transfer). For database reads, use `DbDataReader.GetStream()` where available. For strategies without streaming support, use bounded buffer (configurable max, default 64MB) with backpressure when buffer fills.
2. **Query result pagination**: Add `(int offset, int limit)` support to query operations. Return `PagedQueryResult<T>` with `Items`, `TotalCount`, `HasMore`, `ContinuationToken`. For streaming results, return `IAsyncEnumerable<T>`.
3. **Parallel health checks**: When multiple database strategies are registered, health check all in parallel. Use `Task.WhenAll` with configurable timeout per strategy (default 5s). Report unhealthy strategies to observability.
4. Wire into plugin. `[SdkCompatibility("6.0.0")]`. Full XML docs.

**FilesystemScalingManager** implementing `IScalableSubsystem`:
1. **Dynamic I/O scheduling**: Priority queue for I/O operations (high/normal/low). Queue depth configurable via `ScalingLimits.MaxQueueDepth` (default 1024). When queue is full, apply backpressure via `IBackpressureAware`.
2. **Configurable queue depths**: Per-strategy I/O queue depths. NVMe: high depth (128). SSD: medium (32). HDD: low (8). Configurable at runtime.
3. **Runtime kernel bypass re-detection**: For container environments where hardware capabilities change, periodically re-detect (configurable interval, default 5min) whether io_uring/direct I/O is available. Switch I/O path without restart.
4. **ResourceManager integration**: Track I/O quota per caller via existing ResourceManager. Throttle I/O when quota exceeded.
5. Wire into plugin. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateDatabaseStorage/DataWarehouse.Plugins.UltimateDatabaseStorage.csproj && dotnet build Plugins/DataWarehouse.Plugins.UltimateFilesystem/DataWarehouse.Plugins.UltimateFilesystem.csproj` compiles with 0 errors. Grep for `MemoryStream.ToArray` in DatabaseStorageScalingManager -- should not appear.
  </verify>
  <done>Database retrieval streams data without ToArray(). Query pagination returns PagedQueryResult. Filesystem has dynamic I/O scheduling with priority queues and kernel bypass re-detection. Both implement IScalableSubsystem.</done>
</task>

<task type="auto">
  <name>Task 2: Create BackupScalingManager and FabricScalingManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataProtection/Scaling/BackupScalingManager.cs
    Plugins/DataWarehouse.Plugins.UniversalFabric/Scaling/FabricScalingManager.cs
  </files>
  <action>
**BackupScalingManager** implementing `IScalableSubsystem`:
1. **Dynamic MaxConcurrentJobs**: Replace hardcoded `4` with dynamic calculation based on I/O capacity. Monitor disk throughput and queue depth. When I/O utilization < 60%, increase concurrent jobs (up to `4 * disk_count`). When > 80%, decrease. Use EMA for smooth transitions. Configurable via `ScalingLimits.MaxConcurrentOperations`.
2. **Backup operation persistence**: Persist in-progress backup metadata to `IPersistentBackingStore` (key: `dw://internal/backup/{jobId}`). On crash recovery, detect incomplete backups and resume or restart them. Mark corrupted partial backups for cleanup.
3. **Backup chain management**: Track backup chains (full + incrementals) in `BoundedCache<string, BackupChain>`. Configurable retention policy: by count (keep last N), by age (keep last N days), by size (keep under N GB). Background task enforces retention.
4. Wire into plugin. `[SdkCompatibility("6.0.0")]`. Full XML docs.

**FabricScalingManager** implementing `IScalableSubsystem`:
1. **Runtime-configurable MaxNodes**: Replace static `Star=1000/Mesh=500/Federated=10000` limits with `BoundedCache<string, int>` mapping topology type to max nodes. Configurable via `ReconfigureLimitsAsync`. Changes take effect immediately.
2. **Dynamic topology switching**: Monitor node count. When Star topology exceeds threshold, recommend or auto-switch to Mesh. When Mesh exceeds threshold, recommend or auto-switch to Federated. Configurable auto-switch thresholds and whether switching is automatic or recommendation-only.
3. **Health-based node management**: Monitor node health via heartbeat (configurable interval, default 15s). Auto-remove nodes after N missed heartbeats (default 3). Auto-add discovered nodes. Maintain `BoundedCache<string, NodeHealth>` for health state.
4. Wire into plugin. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateDataProtection/DataWarehouse.Plugins.UltimateDataProtection.csproj && dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj` compiles with 0 errors. Grep for hardcoded `= 4` near `MaxConcurrentJobs` in the backup plugin -- should not appear.
  </verify>
  <done>Backup dynamically adjusts concurrent jobs from I/O metrics with crash recovery and retention management. DataFabric has runtime-configurable topology limits with dynamic switching and health-based node management. Both implement IScalableSubsystem.</done>
</task>

</tasks>

<verification>
- All four plugins build with 0 errors
- Database retrieval uses streaming (no ToArray on large objects)
- Filesystem I/O queue depth is configurable
- Backup MaxConcurrentJobs is dynamic (not hardcoded 4)
- DataFabric topology limits are runtime-configurable
</verification>

<success_criteria>
Database, filesystem, backup, and fabric plugins scale with streaming retrieval, dynamic I/O scheduling, adaptive concurrency, and runtime-configurable topology limits. All implement IScalableSubsystem. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-11-SUMMARY.md`
</output>
