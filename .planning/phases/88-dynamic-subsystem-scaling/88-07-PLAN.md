---
phase: 88-dynamic-subsystem-scaling
plan: 07
type: execute
wave: 3
depends_on: ["88-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateReplication/Scaling/ReplicationScalingManager.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Scaling/AedsScalingManager.cs
autonomous: true

must_haves:
  truths:
    - "Replication supports per-key and per-namespace strategy selection (not single global)"
    - "Replication queue is WAL-backed for durability across restarts"
    - "Streaming conflict comparison replaces full-blob SequenceEqual"
    - "AEDS caches are bounded with LRU eviction and per-collection locks"
    - "AEDS job queues are partitioned for parallel processing"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateReplication/Scaling/ReplicationScalingManager.cs"
      provides: "Per-namespace strategy, WAL queue, streaming conflict comparison, IScalableSubsystem"
      exports: ["ReplicationScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Scaling/AedsScalingManager.cs"
      provides: "Bounded AEDS caches, partitioned jobs, per-collection locks, IScalableSubsystem"
      exports: ["AedsScalingManager"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateReplication/Scaling/ReplicationScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Distributed/IReplicationSync.cs"
      via: "Extends replication with per-namespace routing"
      pattern: "IReplicationSync"
    - from: "Plugins/DataWarehouse.Plugins.AedsCore/Scaling/AedsScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "Replaces unbounded AEDS dictionaries with BoundedCache"
      pattern: "BoundedCache"
---

<objective>
Scale replication with per-namespace strategies, WAL-backed queues, and streaming conflict comparison. Scale AEDS with bounded caches, partitioned job queues, and per-collection locking.

Purpose: DSCL-05 and DSCL-09 -- replication uses a single global strategy and in-memory queue (state lost on restart). AEDS uses unbounded dictionaries and a single SemaphoreSlim. Both need production-level scaling.

Output: Two new files for replication and AEDS scaling managers.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateReplication/UltimateReplicationPlugin.cs
@Plugins/DataWarehouse.Plugins.AedsCore/
@DataWarehouse.SDK/Contracts/Distributed/IReplicationSync.cs
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReplicationScalingManager with per-namespace strategy and WAL queue</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateReplication/Scaling/ReplicationScalingManager.cs
  </files>
  <action>
Create `ReplicationScalingManager` implementing `IScalableSubsystem`:

1. **Per-key/per-namespace strategy selection**: Replace the single global active replication strategy with a routing table: `BoundedCache<string, string>` mapping namespace patterns (glob) to strategy names. Default strategy for unmatched namespaces. Configuration via `ReconfigureLimitsAsync` or message bus topic `dw.replication.strategy-routing`.

2. **WAL-backed replication queue**: Replace in-memory replication queue with append-only WAL. Each replication event (key, namespace, operation, payload reference, timestamp) appended to WAL. Consumer offset per replica tracks progress. On restart, replay from last offset. Retention: configurable (default 48h or until all replicas confirm). Use `IPersistentBackingStore` for WAL storage.

3. **Streaming conflict comparison**: Replace full-blob `SequenceEqual` in conflict detection with streaming comparison:
   - Compare in 64KB chunks using `ReadOnlySpan<byte>.SequenceEqual`
   - Short-circuit on first difference (don't read entire objects)
   - For large objects, use content-addressable hash comparison first (SHA-256 of chunks)
   - Only fall back to byte-by-byte when hashes differ

4. **Dynamic replica discovery**: Subscribe to `dw.cluster.membership.changed` message bus topic. Auto-add/remove replicas. Health check replicas on configurable interval (default 30s). Mark unhealthy replicas as inactive after 3 consecutive failures.

5. **IScalableSubsystem**: metrics include replica count, replication lag per replica, WAL size, conflict rate, strategy routing table size.

Wire into `UltimateReplicationPlugin.InitializeAsync`. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateReplication/DataWarehouse.Plugins.UltimateReplication.csproj` compiles with 0 errors. Grep for `SequenceEqual` in the replication plugin -- should appear only in the streaming comparison context (chunk-based), not as full-blob comparison.
  </verify>
  <done>Replication routes per-namespace to different strategies. WAL-backed queue survives restart. Streaming conflict comparison short-circuits on first difference. Dynamic replica discovery via message bus.</done>
</task>

<task type="auto">
  <name>Task 2: Create AedsScalingManager with bounded caches and partitioned jobs</name>
  <files>
    Plugins/DataWarehouse.Plugins.AedsCore/Scaling/AedsScalingManager.cs
  </files>
  <action>
Create `AedsScalingManager` implementing `IScalableSubsystem`:

1. **Bounded LRU caches**: Replace all `ConcurrentDictionary` instances in AEDS for manifests, validations, jobs, clients, and channels with `BoundedCache<TKey, TValue>` using LRU eviction. Default sizes: manifests 10K, validations 50K, jobs 100K, clients 10K, channels 1K. All configurable via `ScalingLimits`.

2. **Per-collection locks**: Replace the single `SemaphoreSlim` with per-collection `SemaphoreSlim` instances. Operations on different AEDS collections (manifests vs jobs vs clients) proceed concurrently. Use `ConcurrentDictionary<string, SemaphoreSlim>` keyed by collection name. Lazy-create locks on first access.

3. **Dynamically adjustable MaxConcurrentChunks and ChunkSizeBytes**: Read from `ScalingLimits`. Auto-adjust `MaxConcurrentChunks` based on available memory (`GC.GetGCMemoryInfo()`) and CPU count. Auto-adjust `ChunkSizeBytes` based on network bandwidth estimation (track throughput over sliding window).

4. **Partitioned job queues**: Split the single job queue into N partitions (default: `Environment.ProcessorCount`). Jobs routed to partitions by hash of job ID. Each partition processed by its own worker task. Results aggregated by the scaling manager.

5. **IScalableSubsystem**: metrics include cache sizes, hit rates per cache, lock contention, job queue depths per partition, chunk throughput.

Wire into AEDS plugin initialization. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.AedsCore/DataWarehouse.Plugins.AedsCore.csproj` compiles with 0 errors. Grep for `ConcurrentDictionary` in AedsScalingManager -- should not appear (all replaced with BoundedCache).
  </verify>
  <done>AEDS uses BoundedCache for all collections. Per-collection locks enable concurrent access. Job queues partitioned for parallel processing. MaxConcurrentChunks and ChunkSizeBytes auto-adjust based on system resources.</done>
</task>

</tasks>

<verification>
- Full solution builds with 0 errors
- Replication WAL queue uses IPersistentBackingStore
- Streaming conflict comparison uses chunk-based ReadOnlySpan
- AEDS caches use BoundedCache (no raw ConcurrentDictionary for entity state)
- Per-collection locks visible in AEDS code
</verification>

<success_criteria>
Replication scales with per-namespace routing, WAL durability, and streaming comparison. AEDS scales with bounded caches, partitioned jobs, and per-collection locks. Both implement IScalableSubsystem. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-07-SUMMARY.md`
</output>
