---
phase: 88-dynamic-subsystem-scaling
plan: 09
type: execute
wave: 4
depends_on: ["88-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateAccessControl/Scaling/AclScalingManager.cs
  - Plugins/DataWarehouse.Plugins.TamperProof/Scaling/TamperProofScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompliance/Scaling/ComplianceScalingManager.cs
autonomous: true

must_haves:
  truths:
    - "ACL audit log uses ring buffer or externalized store (not unbounded List)"
    - "ACL strategy evaluation can run in parallel"
    - "TamperProof uses per-tier locks (not single SemaphoreSlim)"
    - "TamperProof caches are bounded with configurable RAID shard counts"
    - "Compliance checks run in parallel with TTL-cached results"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateAccessControl/Scaling/AclScalingManager.cs"
      provides: "Ring buffer audit log, parallel evaluation, configurable thresholds, IScalableSubsystem"
      exports: ["AclScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.TamperProof/Scaling/TamperProofScalingManager.cs"
      provides: "Per-tier locks, bounded caches, configurable RAID shards, background scan throttling, IScalableSubsystem"
      exports: ["TamperProofScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Scaling/ComplianceScalingManager.cs"
      provides: "Parallel compliance checks, TTL result cache, configurable concurrent limits, IScalableSubsystem"
      exports: ["ComplianceScalingManager"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateAccessControl/Scaling/AclScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "Ring buffer for audit log, BoundedCache for policy decisions"
      pattern: "BoundedCache"
    - from: "Plugins/DataWarehouse.Plugins.UltimateCompliance/Scaling/ComplianceScalingManager.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "TTL cache for compliance check results"
      pattern: "BoundedCache.*TTL"
---

<objective>
Scale ACL, TamperProof, and Compliance plugins with bounded audit logs, per-tier locking, parallel evaluation, and TTL caching.

Purpose: DSCL-11/25/26 -- ACL audit log grows without bound, TamperProof uses a single lock bottleneck, and Compliance checks are sequential. These fixes make the security stack production-ready at scale.

Output: Three new scaling manager files, one per plugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateAccessControl/UltimateAccessControlPlugin.cs
@Plugins/DataWarehouse.Plugins.TamperProof/TamperProofPlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateCompliance/UltimateCompliancePlugin.cs
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AclScalingManager with ring buffer audit and parallel evaluation</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateAccessControl/Scaling/AclScalingManager.cs
  </files>
  <action>
Create `AclScalingManager` implementing `IScalableSubsystem`:

1. **Ring buffer audit log**: Replace `List<PolicyAccessDecision> _auditLog` with a fixed-size circular buffer. Default capacity: 1M entries. When full, oldest entries are overwritten. For long-term retention, optionally drain to `IPersistentBackingStore` in background (configurable: enabled/disabled, drain interval, retention period).

2. **Parallel strategy evaluation**: When multiple ACL strategies are registered (e.g., RBAC + ABAC + trust score), evaluate them in parallel using `Task.WhenAll`. Combine results with configurable weighted threshold (default: all must pass). `MaxConcurrentEvaluations` configurable via `ScalingLimits.MaxConcurrentOperations`.

3. **Configurable behavior analysis thresholds**: All threat detection thresholds (failed auth rate, anomaly scores, trust score decay rates) configurable at runtime via `ReconfigureLimitsAsync`. Stored in `BoundedCache<string, double>` for fast lookup.

4. **Policy decision cache**: Cache recent policy decisions using `BoundedCache<string, PolicyAccessDecision>` with TTL (default 30s). Cache key: hash of (principal, resource, action). Invalidate on policy change via message bus subscription.

5. Wire into `UltimateAccessControlPlugin.InitializeAsync`. `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateAccessControl/DataWarehouse.Plugins.UltimateAccessControl.csproj` compiles with 0 errors. Grep for `List<PolicyAccessDecision>` in the ACL plugin -- should not appear as a field type.
  </verify>
  <done>ACL audit log uses ring buffer with optional persistence drain. Strategy evaluation parallelized with configurable weighted threshold. All thresholds runtime-reconfigurable. Policy decisions cached with TTL.</done>
</task>

<task type="auto">
  <name>Task 2: Create TamperProofScalingManager and ComplianceScalingManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.TamperProof/Scaling/TamperProofScalingManager.cs
    Plugins/DataWarehouse.Plugins.UltimateCompliance/Scaling/ComplianceScalingManager.cs
  </files>
  <action>
**TamperProofScalingManager** implementing `IScalableSubsystem`:
1. **Per-tier locks**: Replace single `SemaphoreSlim` with `ConcurrentDictionary<string, SemaphoreSlim>` keyed by tier (WORM, hot, warm, cold, archive). Operations on different tiers proceed concurrently. Each tier's semaphore has configurable max concurrent (default: `Environment.ProcessorCount / tierCount`).
2. **Bounded caches**: Replace unbounded hash/manifest/verification caches with `BoundedCache<string, T>` instances. Hash cache: LRU, 500K entries. Manifest cache: LRU, 50K entries. Verification cache: TTL 10 min, 100K entries.
3. **Configurable RAID shard counts**: Shard count for tamper-proof RAID based on data size (small: 3 shards, medium: 6, large: 12). Configurable via `ScalingLimits`.
4. **Background scan throttling**: Integrity scan runs in background with configurable throughput limit (default: 100 MB/s). Respects `IBackpressureAware` -- throttles further when system is under pressure.
5. Wire into `TamperProofPlugin.InitializeAsync`.

**ComplianceScalingManager** implementing `IScalableSubsystem`:
1. **Parallel CheckAllComplianceAsync**: Evaluate compliance across all registered frameworks (GDPR, HIPAA, SOC2, etc.) in parallel using `Task.WhenAll`. Configurable `MaxConcurrentChecks` (default: `Environment.ProcessorCount`). Use `SemaphoreSlim` for concurrency control.
2. **TTL result cache**: Cache compliance check results in `BoundedCache<string, ComplianceResult>` with configurable TTL (default 5 min). Cache key: hash of (resource, framework, timestamp-bucket). Invalidate on policy change.
3. **Configurable concurrent check limits**: Via `ScalingLimits.MaxConcurrentOperations`. Different from parallel evaluation -- this limits total concurrent compliance operations across all callers.
4. Wire into `UltimateCompliancePlugin.InitializeAsync`.

Both: `[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.TamperProof/DataWarehouse.Plugins.TamperProof.csproj && dotnet build Plugins/DataWarehouse.Plugins.UltimateCompliance/DataWarehouse.Plugins.UltimateCompliance.csproj` compiles with 0 errors.
  </verify>
  <done>TamperProof uses per-tier locks, bounded caches, configurable RAID shards, and throttled background scans. Compliance checks run in parallel with TTL-cached results and configurable concurrency limits. Both implement IScalableSubsystem.</done>
</task>

</tasks>

<verification>
- All three plugins build with 0 errors
- ACL audit log is ring buffer (not List)
- TamperProof per-tier locks visible in code
- Compliance parallel evaluation uses Task.WhenAll
- All caches are BoundedCache (no unbounded dictionaries for entity state)
</verification>

<success_criteria>
ACL, TamperProof, and Compliance scale with bounded data structures, parallel evaluation, per-tier locking, and TTL caching. All implement IScalableSubsystem. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-09-SUMMARY.md`
</output>
