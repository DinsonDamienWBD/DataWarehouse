---
phase: 88-dynamic-subsystem-scaling
plan: 13
type: execute
wave: 5
depends_on: ["88-02", "88-03", "88-04", "88-05", "88-06", "88-07", "88-08", "88-09", "88-10", "88-11", "88-12"]
files_modified:
  - DataWarehouse.SDK/Contracts/Scaling/PluginScalingMigrationHelper.cs
  - Plugins/DataWarehouse.Plugins.UltimateIntelligence/Scaling/IntelligenceScalingMigration.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataTransit/Scaling/TransitScalingMigration.cs
autonomous: true

must_haves:
  truths:
    - "All 60 plugins use BoundedCache for entity state (no unbounded ConcurrentDictionary)"
    - "All Max* limits are reconfigurable at runtime via ScalingLimits"
    - "No plugin loses state on restart (all entity stores backed by IPersistentBackingStore)"
    - "Plugins not covered by plans 02-12 are migrated using PluginScalingMigrationHelper"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Scaling/PluginScalingMigrationHelper.cs"
      provides: "Reusable helper that wraps ConcurrentDictionary patterns with BoundedCache + backing store"
      exports: ["PluginScalingMigrationHelper"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateIntelligence/Scaling/IntelligenceScalingMigration.cs"
      provides: "BoundedCache migration for Intelligence plugin's knowledge stores, model caches"
      exports: ["IntelligenceScalingMigration"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataTransit/Scaling/TransitScalingMigration.cs"
      provides: "BoundedCache migration for DataTransit plugin's transfer state, route caches"
      exports: ["TransitScalingMigration"]
  key_links:
    - from: "DataWarehouse.SDK/Contracts/Scaling/PluginScalingMigrationHelper.cs"
      to: "DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs"
      via: "Factory method creates pre-configured BoundedCache instances"
      pattern: "BoundedCache"
    - from: "DataWarehouse.SDK/Contracts/Scaling/PluginScalingMigrationHelper.cs"
      to: "DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs"
      via: "Configures write-through persistence for migrated caches"
      pattern: "IPersistentBackingStore"
---

<objective>
Migrate all remaining plugins (not covered by plans 02-12) from unbounded ConcurrentDictionary entity stores to BoundedCache + IPersistentBackingStore. Create a reusable migration helper to standardize the pattern.

Purpose: DSCL-27 -- this is the universal migration plan. Plans 02-12 handled specific plugins with custom scaling needs. This plan covers the remaining ~40 plugins with a standardized migration pattern, ensuring zero unbounded entity stores remain.

Output: Migration helper in SDK, plus representative migration files for Intelligence and DataTransit. All other plugins modified in-place to use the helper.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/Scaling/BoundedCache.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
@DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs
@DataWarehouse.SDK/Utilities/BoundedDictionary.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PluginScalingMigrationHelper</name>
  <files>
    DataWarehouse.SDK/Contracts/Scaling/PluginScalingMigrationHelper.cs
  </files>
  <action>
Create `PluginScalingMigrationHelper` as a static utility class in SDK:

1. **Factory methods**:
   - `CreateBoundedEntityStore<TKey, TValue>(string pluginId, string storeName, BoundedCacheOptions<TKey, TValue>? options = null)`: Creates a pre-configured BoundedCache with write-through to `IPersistentBackingStore`, LRU eviction, default 50K entries, auto-sized from RAM. Returns `BoundedCache<TKey, TValue>`.
   - `CreateBoundedEntityStore<TKey, TValue>(string pluginId, string storeName, int maxEntries, CacheEvictionMode mode = CacheEvictionMode.LRU)`: Simplified overload with explicit size.
   - `MigrateConcurrentDictionary<TKey, TValue>(ConcurrentDictionary<TKey, TValue> source, BoundedCache<TKey, TValue> target)`: Copies all entries from an existing ConcurrentDictionary into a BoundedCache (for hot migration during initialization).

2. **Default configuration resolution**: Read `ScalingLimits` from plugin configuration if available. Fall back to sensible defaults per plugin type:
   - Storage plugins: 100K entries
   - Security plugins: 50K entries
   - Data intelligence plugins: 100K entries
   - Compute plugins: 10K entries
   - All others: 50K entries

3. **Serialization helpers**: Default JSON serializer/deserializer for `byte[]` conversion. Override with custom serializer for performance-critical paths.

4. **Audit trail**: When `MigrateConcurrentDictionary` is called, log: plugin ID, store name, entries migrated, time taken. Useful for verifying all plugins have migrated.

`[SdkCompatibility("6.0.0")]`. Full XML docs.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors. Grep for `PluginScalingMigrationHelper` to confirm it exists.
  </verify>
  <done>PluginScalingMigrationHelper provides factory methods for creating pre-configured BoundedCache instances with write-through persistence, default sizes per plugin type, hot migration from ConcurrentDictionary, and audit logging.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate remaining plugins to BoundedCache</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateIntelligence/Scaling/IntelligenceScalingMigration.cs
    Plugins/DataWarehouse.Plugins.UltimateDataTransit/Scaling/TransitScalingMigration.cs
  </files>
  <action>
Migrate ALL remaining plugins not already handled by plans 02-12. This task creates dedicated migration files for the two most complex remaining plugins (Intelligence and DataTransit) and modifies the others in-place.

**IntelligenceScalingMigration.cs**: Migrate UltimateIntelligence plugin's knowledge stores, model caches, provider caches, and vector operation caches to BoundedCache using PluginScalingMigrationHelper. Wire into InitializeAsync.

**TransitScalingMigration.cs**: Migrate UltimateDataTransit plugin's transfer state, route caches, QoS state, and cost routing tables to BoundedCache using PluginScalingMigrationHelper. Wire into InitializeAsync.

**For all other remaining plugins** (approximately 35-40), modify their main plugin files to:
1. Find all `ConcurrentDictionary<TKey, TValue>` field declarations used for entity state storage
2. Replace with `BoundedCache<TKey, TValue>` created via `PluginScalingMigrationHelper.CreateBoundedEntityStore(PluginId, "storeName")`
3. Update all `.TryGetValue`, `.TryAdd`, `.AddOrUpdate`, `[]` access patterns to use BoundedCache equivalents (`GetOrDefault`, `Put`, `GetAsync`)
4. Ensure `Max*` config values read from `ScalingLimits` where they exist

Plugins to migrate include (but not limited to): UltimateRAID, UltimateKeyManagement, UltimateDeployment, UltimateDocGen, UltimateEdgeComputing, UltimateInterface, UltimateIoTIntegration, UltimateMicroservices, UltimateMultiCloud, UltimateResourceManager, UltimateRTOSBridge, UltimateSDKPorts, UltimateServerless, UltimateStorageProcessing, UltimateSustainability, UltimateDataFormat, UltimateDataIntegration, UltimateDataIntegrity, UltimateDataLake, UltimateDataManagement, UltimateDataPrivacy, UltimateDataQuality, UltimateConnector, UltimateDatabaseProtocol, UniversalObservability, SemanticSync, ApplicationPlatform, PluginMarketplace, AedsControlPlane, AedsDataPlane, AedsExtensions.

Note: Some plugins already use `BoundedDictionary` from v5.0 work. Those are acceptable as-is (BoundedDictionary already has LRU and persistence). Only unbounded `ConcurrentDictionary` fields for entity state need migration. Config dictionaries, lookup tables, and strategy registries that are bounded by design (small, fixed sets) do NOT need migration.

`[SdkCompatibility("6.0.0")]` on new public types. Full XML docs.
  </action>
  <verify>
`dotnet build` (full solution) compiles with 0 errors. Run: `grep -r "ConcurrentDictionary" Plugins/ --include="*.cs" -l | wc -l` -- the count of files using ConcurrentDictionary for entity state should be significantly reduced. Any remaining uses should be for strategy registries, config lookups, or other bounded-by-design collections (not entity stores).
  </verify>
  <done>All 60 plugins use BoundedCache or BoundedDictionary for entity state. No unbounded ConcurrentDictionary for entity stores remains. All Max* limits are configurable via ScalingLimits. State persists across restarts via IPersistentBackingStore write-through.</done>
</task>

</tasks>

<verification>
- Full solution builds with 0 errors
- PluginScalingMigrationHelper exists in SDK with factory methods
- IntelligenceScalingMigration and TransitScalingMigration compile
- Audit: grep for ConcurrentDictionary entity stores -- should be near zero
- Spot-check 5 random plugins to verify BoundedCache usage
</verification>

<success_criteria>
All 60 plugins migrated from unbounded ConcurrentDictionary entity stores to BoundedCache + IPersistentBackingStore. Migration helper standardizes the pattern. All Max* limits runtime-reconfigurable. No state loss on restart. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-13-SUMMARY.md`
</output>
