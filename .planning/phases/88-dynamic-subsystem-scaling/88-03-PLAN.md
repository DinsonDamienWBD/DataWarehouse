---
phase: 88-dynamic-subsystem-scaling
plan: 03
type: execute
wave: 2
depends_on: ["88-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/ResilienceScalingManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/AdaptiveResilienceThresholds.cs
autonomous: true

must_haves:
  truths:
    - "ExecuteWithResilienceAsync actually applies circuit breaker logic from the active strategy"
    - "Bulkhead isolation limits concurrent operations per strategy"
    - "Circuit breaker thresholds adapt based on observed error rates and latency"
    - "Distributed circuit breaker state can be shared across nodes"
    - "All resilience limits are runtime-reconfigurable without restart"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/ResilienceScalingManager.cs"
      provides: "Fixed ExecuteWithResilienceAsync that applies real resilience logic, implements IScalableSubsystem"
      exports: ["ResilienceScalingManager"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/AdaptiveResilienceThresholds.cs"
      provides: "Adaptive threshold computation from observed metrics, distributed state sharing"
      exports: ["AdaptiveResilienceThresholds"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/ResilienceScalingManager.cs"
      to: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryCircuitBreaker.cs"
      via: "Wraps real circuit breaker with strategy-driven configuration"
      pattern: "InMemoryCircuitBreaker|ICircuitBreaker"
    - from: "Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/ResilienceScalingManager.cs"
      to: "DataWarehouse.SDK/Infrastructure/InMemory/InMemoryBulkheadIsolation.cs"
      via: "Applies bulkhead limits from strategy configuration"
      pattern: "InMemoryBulkheadIsolation|IBulkheadIsolation"
---

<objective>
Fix the critical resilience bug: ExecuteWithResilienceAsync currently does not apply the strategy's resilience logic. Make circuit breaker, bulkhead, and retry actually work, with adaptive thresholds and distributed state.

Purpose: DSCL-12 -- resilience is broken. Strategies define resilience parameters but they are never applied during execution. This fix makes resilience production-ready.

Output: Two new files providing resilience scaling manager (with fixed ExecuteWithResilienceAsync) and adaptive threshold computation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-dynamic-subsystem-scaling/88-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateResilience/UltimateResiliencePlugin.cs
@DataWarehouse.SDK/Infrastructure/InMemory/InMemoryCircuitBreaker.cs
@DataWarehouse.SDK/Infrastructure/InMemory/InMemoryBulkheadIsolation.cs
@DataWarehouse.SDK/Contracts/Scaling/IScalableSubsystem.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix ExecuteWithResilienceAsync and implement ResilienceScalingManager</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/ResilienceScalingManager.cs
  </files>
  <action>
Create `ResilienceScalingManager` implementing `IScalableSubsystem`:

1. **Fix ExecuteWithResilienceAsync**: The current implementation in UltimateResiliencePlugin calls strategies but does not actually wrap execution in circuit breaker/bulkhead/retry. The fix:
   - Read the active strategy's `CircuitBreakerOptions` (failure threshold, reset timeout, half-open max)
   - Create/retrieve a per-strategy `ICircuitBreaker` instance from `InMemoryCircuitBreaker` or injected implementation
   - Read the active strategy's `BulkheadOptions` (max concurrent, max queue)
   - Create/retrieve a per-strategy `IBulkheadIsolation` from `InMemoryBulkheadIsolation` or injected implementation
   - Read the active strategy's `RetryOptions` (max retries, backoff type, jitter)
   - Wrap the actual operation execution in: bulkhead acquire -> circuit breaker check -> retry loop -> execute -> record success/failure -> release bulkhead

2. **Runtime reconfiguration**: Expose all circuit breaker thresholds, bulkhead limits, and retry parameters through `IScalableSubsystem.ReconfigureLimitsAsync`. Map `ScalingLimits.MaxConcurrentOperations` to bulkhead max concurrent.

3. **Distributed circuit breaker state**: Add an optional `IFederatedMessageBus` dependency. When available, publish circuit breaker state changes (open/half-open/closed transitions) to topic `dw.resilience.circuit-breaker.state`. Subscribe to the same topic to receive remote state changes. Use last-writer-wins with lamport timestamp for conflict resolution.

4. **Metrics**: `GetScalingMetrics()` returns: active circuit breakers (count, states), bulkhead utilization (concurrent/max per strategy), retry rates, success/failure rates, p50/p95/p99 latencies.

5. Wire into `UltimateResiliencePlugin.InitializeAsync` -- replace the existing `ExecuteWithResilienceAsync` implementation with one that delegates through `ResilienceScalingManager`.

`[SdkCompatibility("6.0.0")]` on all public types. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateResilience/DataWarehouse.Plugins.UltimateResilience.csproj` compiles with 0 errors. Grep for `CircuitBreaker` and `BulkheadIsolation` in ResilienceScalingManager to confirm they are actually used (not just referenced).
  </verify>
  <done>ExecuteWithResilienceAsync wraps operations in bulkhead -> circuit breaker -> retry pipeline. Per-strategy instances track state independently. All parameters runtime-reconfigurable. Distributed state sharing via message bus.</done>
</task>

<task type="auto">
  <name>Task 2: Implement AdaptiveResilienceThresholds</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateResilience/Scaling/AdaptiveResilienceThresholds.cs
  </files>
  <action>
Create `AdaptiveResilienceThresholds` that computes optimal circuit breaker and bulkhead parameters from observed metrics:

1. **Sliding window metrics**: Track error rate and latency over configurable windows (default: 1min, 5min, 15min). Use circular buffer of timestamped observations, not growing lists.

2. **Adaptive circuit breaker thresholds**:
   - Increase failure threshold when error rate is below 1% (system is healthy, allow more tolerance)
   - Decrease failure threshold when error rate spikes above 5% (trip faster to protect)
   - Adjust reset timeout based on recovery time pattern: if recovery is typically fast (<5s), use shorter timeout
   - Clamp all values within configurable min/max bounds

3. **Adaptive bulkhead sizing**:
   - Track p99 latency per strategy
   - When p99 drops, increase max concurrent (system can handle more)
   - When p99 rises, decrease max concurrent (protect from overload)
   - Use exponential moving average for smooth transitions (no oscillation)

4. **Configurable behavior analysis thresholds**: All adaptation parameters (error rate thresholds, latency triggers, adjustment factors, EMA alpha, clamping bounds) configurable via `ScalingLimits` at runtime.

5. Integrate with `ResilienceScalingManager`: the manager calls `AdaptiveResilienceThresholds.ComputeOptimalThresholds()` on a configurable interval (default: 30s) and applies the results.

`[SdkCompatibility("6.0.0")]` on all public types. Full XML docs.
  </action>
  <verify>
`dotnet build Plugins/DataWarehouse.Plugins.UltimateResilience/DataWarehouse.Plugins.UltimateResilience.csproj` compiles with 0 errors. Verify adaptive logic exists by grepping for `ExponentialMovingAverage` or `EMA` in the file.
  </verify>
  <done>Adaptive thresholds compute optimal circuit breaker and bulkhead params from sliding window metrics. EMA smoothing prevents oscillation. All adaptation params runtime-configurable. Integrates with ResilienceScalingManager on 30s interval.</done>
</task>

</tasks>

<verification>
- Full solution builds with 0 errors
- ExecuteWithResilienceAsync in ResilienceScalingManager actually creates and uses circuit breaker + bulkhead instances
- Adaptive thresholds use sliding windows with bounded memory (circular buffer, not growing list)
- Distributed state sharing publishes to message bus topic
</verification>

<success_criteria>
ExecuteWithResilienceAsync applies real circuit breaker/bulkhead/retry logic from strategy configuration. Thresholds adapt from observed metrics. Distributed state sharing works via message bus. All limits runtime-reconfigurable. Solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/88-dynamic-subsystem-scaling/88-03-SUMMARY.md`
</output>
