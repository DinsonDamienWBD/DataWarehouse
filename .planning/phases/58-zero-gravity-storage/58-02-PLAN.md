---
phase: 58-zero-gravity-storage
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs
  - DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/SimdBitmapScanner.cs
autonomous: true

must_haves:
  truths:
    - "BitmapAllocator uses SIMD-accelerated scanning for O(1) amortized free-block lookup"
    - "FindNextFreeBlock uses BitOperations.TrailingZeroCount instead of bit-by-bit iteration"
    - "Existing BitmapAllocator API contract unchanged (no breaking changes)"
    - "Contiguous extent search is also SIMD-accelerated"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/SimdBitmapScanner.cs"
      provides: "Static SIMD helper for word-at-a-time bitmap scanning"
      exports: ["SimdBitmapScanner"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs"
      provides: "Updated BitmapAllocator with SIMD scanning internals"
      contains: "BitOperations.TrailingZeroCount"
  key_links:
    - from: "BitmapAllocator.FindNextFreeBlock"
      to: "SimdBitmapScanner"
      via: "delegates word-level scanning to SIMD helper"
      pattern: "SimdBitmapScanner\\.FindFirstZeroBit"
---

<objective>
Accelerate BitmapAllocator's free-block scanning with SIMD intrinsics (System.Numerics.BitOperations). Replace the O(n) bit-by-bit FindNextFreeBlock with O(n/64) word-at-a-time scanning using TrailingZeroCount.

Purpose: Current BitmapAllocator.FindNextFreeBlock (line 350) iterates bit-by-bit. For large disks (millions of blocks), this is unacceptably slow. BitOperations.TrailingZeroCount processes 64 bits per operation using hardware BSF/TZCNT instructions.
Output: Updated BitmapAllocator + new SimdBitmapScanner helper class.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs
@DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/FreeSpaceManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SimdBitmapScanner and Upgrade BitmapAllocator</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/SimdBitmapScanner.cs
    DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs
  </files>
  <action>
**SimdBitmapScanner.cs** — Static helper, namespace `DataWarehouse.SDK.VirtualDiskEngine.BlockAllocation`:

```csharp
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[SdkCompatibility("5.0.0", Notes = "Phase 58: SIMD-accelerated bitmap scanning")]
public static class SimdBitmapScanner
{
    /// Finds first zero bit in bitmap starting from startBit.
    /// Returns -1 if no zero bit found.
    /// Uses 64-bit word scanning with BitOperations.TrailingZeroCount.
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long FindFirstZeroBit(byte[] bitmap, long totalBits, long startBit)
    {
        // Phase 1: Handle partial first byte (align to byte boundary)
        long byteIndex = startBit / 8;
        int bitOffset = (int)(startBit % 8);
        long totalBytes = (totalBits + 7) / 8;

        if (bitOffset != 0 && byteIndex < totalBytes)
        {
            // Check remaining bits in the starting byte
            byte b = bitmap[byteIndex];
            byte masked = (byte)(b | ((1 << bitOffset) - 1)); // mask out bits before startBit
            if (masked != 0xFF)
            {
                int zeroBit = BitOperations.TrailingZeroCount((byte)~masked);
                long result = byteIndex * 8 + zeroBit;
                if (result < totalBits) return result;
            }
            byteIndex++;
        }

        // Phase 2: Scan 8 bytes (ulong) at a time
        long ulongStart = byteIndex;
        // Align to 8-byte boundary
        while (ulongStart % 8 != 0 && ulongStart < totalBytes)
        {
            if (bitmap[ulongStart] != 0xFF)
            {
                int zeroBit = BitOperations.TrailingZeroCount((byte)~bitmap[ulongStart]);
                long result = ulongStart * 8 + zeroBit;
                if (result < totalBits) return result;
            }
            ulongStart++;
        }

        // Scan as ulong (64 bits at a time)
        ReadOnlySpan<byte> span = bitmap.AsSpan();
        long ulongEnd = totalBytes - (totalBytes % 8);
        for (long i = ulongStart; i < ulongEnd; i += 8)
        {
            ulong word = MemoryMarshal.Read<ulong>(span.Slice((int)i, 8));
            if (word != ulong.MaxValue) // has at least one zero bit
            {
                ulong inverted = ~word;
                int trailingZeros = BitOperations.TrailingZeroCount(inverted);
                long result = i * 8 + trailingZeros;
                if (result < totalBits) return result;
            }
        }

        // Phase 3: Handle remaining bytes
        for (long i = Math.Max(ulongEnd, ulongStart); i < totalBytes; i++)
        {
            if (bitmap[i] != 0xFF)
            {
                int zeroBit = BitOperations.TrailingZeroCount((byte)~bitmap[i]);
                long result = i * 8 + zeroBit;
                if (result < totalBits) return result;
            }
        }

        return -1;
    }

    /// Finds first contiguous run of zeroBits of length >= minRun.
    /// Returns start bit index, or -1 if not found.
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long FindContiguousZeroBits(byte[] bitmap, long totalBits, int minRun)
    {
        long runStart = -1;
        int currentRun = 0;
        long totalBytes = (totalBits + 7) / 8;

        // Fast skip: scan ulong-at-a-time for fully-allocated words
        ReadOnlySpan<byte> span = bitmap.AsSpan();
        long ulongEnd = totalBytes - (totalBytes % 8);

        for (long byteIdx = 0; byteIdx < totalBytes; )
        {
            // Try ulong fast path
            if (currentRun == 0 && byteIdx % 8 == 0 && byteIdx + 8 <= totalBytes)
            {
                ulong word = MemoryMarshal.Read<ulong>(span.Slice((int)byteIdx, 8));
                if (word == ulong.MaxValue)
                {
                    byteIdx += 8; // skip 64 fully-allocated bits
                    continue;
                }
            }

            byte b = bitmap[byteIdx];
            for (int bit = 0; bit < 8; bit++)
            {
                long bitIndex = byteIdx * 8 + bit;
                if (bitIndex >= totalBits) break;

                if ((b & (1 << bit)) == 0) // free
                {
                    if (currentRun == 0) runStart = bitIndex;
                    currentRun++;
                    if (currentRun >= minRun) return runStart;
                }
                else
                {
                    currentRun = 0;
                    runStart = -1;
                }
            }
            byteIdx++;
        }

        return -1;
    }

    /// Counts total zero bits (free blocks) using PopCount.
    public static long CountZeroBits(byte[] bitmap, long totalBits)
    {
        long totalBytes = (totalBits + 7) / 8;
        long setBits = 0;
        ReadOnlySpan<byte> span = bitmap.AsSpan();
        long ulongEnd = totalBytes - (totalBytes % 8);

        for (long i = 0; i < ulongEnd; i += 8)
        {
            ulong word = MemoryMarshal.Read<ulong>(span.Slice((int)i, 8));
            setBits += BitOperations.PopCount(word);
        }

        for (long i = ulongEnd; i < totalBytes; i++)
        {
            setBits += BitOperations.PopCount(bitmap[i]);
        }

        // Subtract extra bits in last byte beyond totalBits
        int extraBits = (int)((totalBytes * 8) - totalBits);
        if (extraBits > 0)
        {
            byte lastByte = bitmap[totalBytes - 1];
            for (int bit = (int)(totalBits % 8); bit < 8; bit++)
            {
                if ((lastByte & (1 << bit)) != 0) setBits--;
            }
        }

        return totalBits - setBits;
    }
}
```

**BitmapAllocator.cs** — Modify these methods (preserve all public API, change internals only):

1. `FindNextFreeBlock(long startBlock)` — Replace the bit-by-bit loop (lines 350-361) with:
   ```csharp
   private long FindNextFreeBlock(long startBlock)
   {
       long result = SimdBitmapScanner.FindFirstZeroBit(_bitmap, _totalBlocks, startBlock);
       return result;
   }
   ```

2. `FindContiguousFreeBlocks(int count)` — Replace the bit-by-bit loop with:
   ```csharp
   private long FindContiguousFreeBlocks(int count)
   {
       return SimdBitmapScanner.FindContiguousZeroBits(_bitmap, _totalBlocks, count);
   }
   ```

3. Update the private constructor's free-block counting (lines 50-57) to use:
   ```csharp
   _freeBlockCount = SimdBitmapScanner.CountZeroBits(bitmap, totalBlocks);
   ```

4. Add `using System.Numerics;` and `using System.Runtime.InteropServices;` to BitmapAllocator imports.

Do NOT change any public method signatures. The only changes are internal implementation swaps.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>BitmapAllocator.FindNextFreeBlock uses SimdBitmapScanner.FindFirstZeroBit. FindContiguousFreeBlocks uses SimdBitmapScanner.FindContiguousZeroBits. BitOperations.TrailingZeroCount appears in SimdBitmapScanner. All existing tests still pass.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds
- `grep -n "BitOperations.TrailingZeroCount" DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/SimdBitmapScanner.cs` returns matches
- `grep -n "SimdBitmapScanner" DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs` returns matches
- `dotnet test DataWarehouse.Tests/ --filter VDE --verbosity quiet` passes
</verification>

<success_criteria>
SIMD-accelerated bitmap scanning replaces bit-by-bit iteration. BitmapAllocator public API unchanged. Scans 64 bits per operation via BitOperations.TrailingZeroCount.
</success_criteria>

<output>
After completion, create `.planning/phases/58-zero-gravity-storage/58-02-SUMMARY.md`
</output>
