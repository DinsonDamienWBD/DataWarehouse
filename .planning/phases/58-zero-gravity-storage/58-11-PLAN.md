---
phase: 58-zero-gravity-storage
plan: 11
type: execute
wave: 3
depends_on: ["58-08", "58-09"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityMessageBusWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/AiEnhanced/GravityAwarePlacementIntegration.cs
autonomous: true

must_haves:
  truths:
    - "Rebalance events are published on message bus for observability"
    - "Cost optimization events are published on message bus"
    - "Data management plugin can consume gravity scores for placement decisions"
    - "Message bus follows existing topic patterns from PLUGIN-CATALOG"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityMessageBusWiring.cs"
      provides: "Message bus event publishing for zero-gravity events"
      exports: ["ZeroGravityMessageBusWiring"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/AiEnhanced/GravityAwarePlacementIntegration.cs"
      provides: "Integration of gravity scores into data management decisions"
      exports: ["GravityAwarePlacementIntegration"]
  key_links:
    - from: "ZeroGravityMessageBusWiring"
      to: "AutonomousRebalancer"
      via: "subscribes to rebalance events and publishes to bus"
      pattern: "IMessageBus.*PublishAsync"
    - from: "GravityAwarePlacementIntegration"
      to: "IPlacementOptimizer"
      via: "uses gravity scoring for data management placement"
      pattern: "IPlacementOptimizer.*ComputeGravityAsync"
---

<objective>
Wire zero-gravity storage into the DataWarehouse message bus for cross-plugin observability and integrate gravity-aware placement into the data management plugin's existing cost-aware placement strategy.

Purpose: Without message bus wiring, zero-gravity storage operates in isolation. This plan connects rebalance/cost events to the observability pipeline and enables the data management plugin to make gravity-aware placement decisions.
Output: Message bus wiring class + data management gravity integration.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PLUGIN-CATALOG.md
@.planning/phases/58-zero-gravity-storage/58-08-SUMMARY.md
@.planning/phases/58-zero-gravity-storage/58-09-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/AiEnhanced/CostAwareDataPlacementStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ZeroGravityMessageBusWiring</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityMessageBusWiring.cs</files>
  <action>
Create ZeroGravityMessageBusWiring.cs — namespace `DataWarehouse.Plugins.UltimateStorage.Strategies.ZeroGravity`:

This class bridges zero-gravity storage events to the DataWarehouse message bus. Check the existing message bus pattern in the codebase (look at how other plugins publish events — likely through `IMessageBus` from the SDK).

```csharp
using DataWarehouse.SDK.Storage.Placement;
using DataWarehouse.SDK.Storage.Billing;
using System.Text.Json;

/// Wires zero-gravity storage events to the DataWarehouse message bus.
/// Published topics follow the naming convention: storage.zerogravity.{event}
///
/// Events published:
/// - storage.zerogravity.rebalance.started — Rebalance job started
/// - storage.zerogravity.rebalance.completed — Rebalance job completed
/// - storage.zerogravity.rebalance.failed — Rebalance job failed
/// - storage.zerogravity.migration.progress — Migration progress update
/// - storage.zerogravity.cost.report — Cost optimization report generated
/// - storage.zerogravity.cost.savings — Savings opportunity identified
/// - storage.zerogravity.placement.computed — Placement decision made
/// - storage.zerogravity.gravity.scored — Object gravity score computed
public sealed class ZeroGravityMessageBusWiring : IDisposable
{
    private readonly IMessageBus _messageBus; // SDK IMessageBus interface
    private readonly string _topicPrefix;
    private bool _disposed;

    public ZeroGravityMessageBusWiring(IMessageBus messageBus, string topicPrefix = "storage.zerogravity")
    {
        _messageBus = messageBus ?? throw new ArgumentNullException(nameof(messageBus));
        _topicPrefix = topicPrefix;
    }

    /// Publish rebalance job started event.
    public async Task PublishRebalanceStartedAsync(RebalanceJob job, CancellationToken ct = default)
    {
        await PublishAsync($"{_topicPrefix}.rebalance.started", new
        {
            job.JobId,
            job.TotalMoves,
            EstimatedDuration = job.Plan.EstimatedDurationSeconds,
            EstimatedCost = job.Plan.EstimatedCost,
            Timestamp = DateTimeOffset.UtcNow
        }, ct);
    }

    /// Publish rebalance job completed event.
    public async Task PublishRebalanceCompletedAsync(RebalanceJob job, CancellationToken ct = default)
    {
        await PublishAsync($"{_topicPrefix}.rebalance.completed", new
        {
            job.JobId,
            job.CompletedMoves,
            job.FailedMoves,
            DurationSeconds = job.CompletedUtc.HasValue && job.StartedUtc.HasValue
                ? (job.CompletedUtc.Value - job.StartedUtc.Value).TotalSeconds : 0,
            Timestamp = DateTimeOffset.UtcNow
        }, ct);
    }

    /// Publish rebalance job failed event.
    public async Task PublishRebalanceFailedAsync(RebalanceJob job, string? reason = null, CancellationToken ct = default)
    {
        await PublishAsync($"{_topicPrefix}.rebalance.failed", new
        {
            job.JobId,
            job.CompletedMoves,
            job.FailedMoves,
            Reason = reason ?? "Unknown failure",
            Timestamp = DateTimeOffset.UtcNow
        }, ct);
    }

    /// Publish cost optimization report.
    public async Task PublishCostReportAsync(OptimizationPlan plan, CancellationToken ct = default)
    {
        await PublishAsync($"{_topicPrefix}.cost.report", new
        {
            plan.PlanId,
            CurrentMonthlyCost = plan.Summary.CurrentMonthlyCost,
            ProjectedMonthlyCost = plan.Summary.ProjectedMonthlyCost,
            EstimatedSavings = plan.Summary.EstimatedMonthlySavings,
            SavingsPercent = plan.Summary.SavingsPercent,
            TotalRecommendations = plan.Summary.TotalRecommendations,
            Timestamp = DateTimeOffset.UtcNow
        }, ct);
    }

    /// Publish savings opportunity identified.
    public async Task PublishSavingsOpportunityAsync(
        string category, decimal monthlySavings, string description, CancellationToken ct = default)
    {
        await PublishAsync($"{_topicPrefix}.cost.savings", new
        {
            Category = category,
            MonthlySavings = monthlySavings,
            Description = description,
            Timestamp = DateTimeOffset.UtcNow
        }, ct);
    }

    /// Publish placement decision event.
    public async Task PublishPlacementComputedAsync(PlacementDecision decision, CancellationToken ct = default)
    {
        await PublishAsync($"{_topicPrefix}.placement.computed", new
        {
            decision.PlacementRuleId,
            PrimaryNode = decision.PrimaryNode.NodeId,
            ReplicaCount = decision.ReplicaNodes.Count,
            decision.Deterministic,
            Timestamp = DateTimeOffset.UtcNow
        }, ct);
    }

    /// Publish gravity score event.
    public async Task PublishGravityScoredAsync(DataGravityScore score, CancellationToken ct = default)
    {
        await PublishAsync($"{_topicPrefix}.gravity.scored", new
        {
            score.ObjectKey,
            score.CurrentNode,
            score.CompositeScore,
            score.AccessFrequency,
            score.ColocatedDependencies,
            score.EgressCostPerGB,
            Timestamp = DateTimeOffset.UtcNow
        }, ct);
    }

    private async Task PublishAsync(string topic, object payload, CancellationToken ct)
    {
        try
        {
            var json = JsonSerializer.Serialize(payload);
            var message = new MessageBusMessage
            {
                Topic = topic,
                Payload = System.Text.Encoding.UTF8.GetBytes(json),
                Timestamp = DateTimeOffset.UtcNow
            };
            await _messageBus.PublishAsync(message, ct);
        }
        catch
        {
            // Message bus failures should not break storage operations
        }
    }

    public void Dispose()
    {
        _disposed = true;
    }
}
```

NOTE: The exact `IMessageBus` interface and `MessageBusMessage` type come from the SDK. Check the actual interface: look for `IMessageBus` in the SDK and adapt the PublishAsync call to match its signature. The common pattern in this codebase is `PublishAsync(string topic, byte[] payload, CancellationToken ct)` or a message wrapper type. Adapt accordingly.
  </action>
  <verify>dotnet build "Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj" --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>ZeroGravityMessageBusWiring compiles. Publishes 7 event types to message bus following topic naming convention.</done>
</task>

<task type="auto">
  <name>Task 2: GravityAwarePlacementIntegration in DataManagement Plugin</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataManagement/Strategies/AiEnhanced/GravityAwarePlacementIntegration.cs</files>
  <action>
Create GravityAwarePlacementIntegration.cs — namespace `DataWarehouse.Plugins.UltimateDataManagement.Strategies.AiEnhanced`:

This class extends the existing CostAwareDataPlacementStrategy by adding gravity awareness. Check the existing strategy's base class and pattern.

```csharp
using DataWarehouse.SDK.Storage.Placement;
using DataWarehouse.SDK.Storage.Billing;

/// Extends data management with gravity-aware placement intelligence.
/// Integrates zero-gravity storage gravity scores into the data management
/// lifecycle decisions: tiering, archiving, deletion, and migration.
///
/// Subscribes to:
/// - storage.zerogravity.gravity.scored — uses scores for tiering decisions
/// - storage.zerogravity.cost.report — uses cost data for budget-aware decisions
///
/// Publishes:
/// - datamanagement.gravity.tiering — tier transition recommendations based on gravity
public sealed class GravityAwarePlacementIntegration
{
    private readonly IPlacementOptimizer? _optimizer;
    private readonly GravityScoringWeights _weights;

    public GravityAwarePlacementIntegration(
        IPlacementOptimizer? optimizer = null,
        GravityScoringWeights? weights = null)
    {
        _optimizer = optimizer;
        _weights = weights ?? GravityScoringWeights.Default;
    }

    /// Compute a tiering recommendation based on gravity score.
    /// Low gravity + low access = candidate for cold/archive tier.
    /// High gravity + high access = must stay on hot tier.
    public async Task<TieringRecommendation> ComputeTieringRecommendationAsync(
        string objectKey, CancellationToken ct = default)
    {
        if (_optimizer == null)
        {
            return new TieringRecommendation
            {
                ObjectKey = objectKey,
                RecommendedAction = TieringAction.None,
                Reason = "Gravity optimizer not configured"
            };
        }

        var gravity = await _optimizer.ComputeGravityAsync(objectKey, ct);

        TieringAction action;
        string reason;

        if (gravity.CompositeScore < 0.2 && gravity.AccessFrequency < 1.0)
        {
            action = TieringAction.MoveToArchive;
            reason = $"Very low gravity ({gravity.CompositeScore:F2}) and access ({gravity.AccessFrequency:F1}/hr). Safe to archive.";
        }
        else if (gravity.CompositeScore < 0.4 && gravity.AccessFrequency < 10.0)
        {
            action = TieringAction.MoveToCold;
            reason = $"Low gravity ({gravity.CompositeScore:F2}). Infrequent access suitable for cold tier.";
        }
        else if (gravity.CompositeScore > 0.8)
        {
            action = TieringAction.KeepOnHot;
            reason = $"High gravity ({gravity.CompositeScore:F2}). Data is actively used and colocated.";
        }
        else
        {
            action = TieringAction.None;
            reason = $"Medium gravity ({gravity.CompositeScore:F2}). Current placement is acceptable.";
        }

        return new TieringRecommendation
        {
            ObjectKey = objectKey,
            GravityScore = gravity.CompositeScore,
            AccessFrequency = gravity.AccessFrequency,
            RecommendedAction = action,
            Reason = reason
        };
    }

    /// Batch analysis: compute tiering recommendations for multiple objects.
    public async Task<IReadOnlyList<TieringRecommendation>> ComputeBatchTieringAsync(
        IReadOnlyList<string> objectKeys, CancellationToken ct = default)
    {
        var tasks = objectKeys.Select(key => ComputeTieringRecommendationAsync(key, ct));
        return (await Task.WhenAll(tasks)).ToList();
    }

    /// Determine if an object should be protected from deletion based on gravity.
    public async Task<bool> ShouldProtectFromDeletionAsync(
        string objectKey, double protectionThreshold = 0.7, CancellationToken ct = default)
    {
        if (_optimizer == null) return false;
        var gravity = await _optimizer.ComputeGravityAsync(objectKey, ct);
        return gravity.CompositeScore >= protectionThreshold || gravity.ComplianceWeight > 0;
    }
}

/// Tiering action recommendations.
public enum TieringAction
{
    None,
    MoveToHot,
    MoveToWarm,
    MoveToCold,
    MoveToArchive,
    KeepOnHot,
    Delete
}

/// Tiering recommendation based on gravity analysis.
public sealed record TieringRecommendation
{
    public string ObjectKey { get; init; } = "";
    public double GravityScore { get; init; }
    public double AccessFrequency { get; init; }
    public TieringAction RecommendedAction { get; init; }
    public string Reason { get; init; } = "";
}
```
  </action>
  <verify>dotnet build "Plugins/DataWarehouse.Plugins.UltimateDataManagement/DataWarehouse.Plugins.UltimateDataManagement.csproj" --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>GravityAwarePlacementIntegration compiles in DataManagement plugin. Provides tiering recommendations based on gravity scores. Batch analysis and deletion protection work.</done>
</task>

</tasks>

<verification>
- Both plugins build successfully
- Message bus wiring publishes 7 event types
- Gravity integration provides tiering recommendations
- No cross-plugin references (both use only SDK types)
</verification>

<success_criteria>
Zero-gravity storage is wired into the message bus for observability. Data management plugin can leverage gravity scores for tiering decisions. Cross-plugin communication flows through SDK interfaces only.
</success_criteria>

<output>
After completion, create `.planning/phases/58-zero-gravity-storage/58-11-SUMMARY.md`
</output>
