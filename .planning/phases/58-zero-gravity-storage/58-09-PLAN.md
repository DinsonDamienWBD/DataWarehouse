---
phase: 58-zero-gravity-storage
plan: 09
type: execute
wave: 3
depends_on: ["58-06"]
files_modified:
  - DataWarehouse.SDK/Storage/Billing/StorageCostOptimizer.cs
  - DataWarehouse.SDK/Storage/Billing/CostOptimizationTypes.cs
autonomous: true

must_haves:
  truths:
    - "Cost optimizer identifies savings opportunities across spot, reserved, and tier transitions"
    - "Spot storage recommendations consider interruption risk"
    - "Reserved capacity recommendations calculate break-even periods"
    - "Tier transition recommendations use access pattern analysis"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/Billing/StorageCostOptimizer.cs"
      provides: "Cross-provider cost optimization engine"
      exports: ["StorageCostOptimizer"]
    - path: "DataWarehouse.SDK/Storage/Billing/CostOptimizationTypes.cs"
      provides: "Optimization result types and savings summaries"
      exports: ["OptimizationPlan", "SavingsSummary"]
  key_links:
    - from: "StorageCostOptimizer"
      to: "IBillingProvider"
      via: "fetches pricing from all configured providers"
      pattern: "IBillingProvider.*GetSpotPricingAsync"
    - from: "StorageCostOptimizer"
      to: "IPlacementOptimizer"
      via: "uses gravity scores to identify movable data"
      pattern: "IPlacementOptimizer.*ComputeGravityAsync"
---

<objective>
Build a storage cost optimizer that analyzes billing data from all configured cloud providers and identifies savings opportunities through spot storage, reserved capacity commitments, tier transitions, and cross-provider arbitrage.

Purpose: Cloud storage costs grow unpredictably. The cost optimizer continuously analyzes pricing across providers and recommends (or executes) optimizations: move cold data to cheaper tiers, commit to reserved capacity for stable workloads, use spot storage for temporary/reproducible data, and arbitrage price differences between providers.
Output: StorageCostOptimizer + CostOptimizationTypes.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/58-zero-gravity-storage/58-06-SUMMARY.md
@DataWarehouse.SDK/Storage/Billing/IBillingProvider.cs
@DataWarehouse.SDK/Storage/Billing/BillingTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CostOptimizationTypes</name>
  <files>DataWarehouse.SDK/Storage/Billing/CostOptimizationTypes.cs</files>
  <action>
Create CostOptimizationTypes.cs — namespace `DataWarehouse.SDK.Storage.Billing`:

```csharp
[SdkCompatibility("5.0.0", Notes = "Phase 58: Storage cost optimizer")]
public sealed record OptimizationPlan
{
    public string PlanId { get; init; } = Guid.NewGuid().ToString("N")[..8];
    public DateTimeOffset GeneratedUtc { get; init; } = DateTimeOffset.UtcNow;
    public SavingsSummary Summary { get; init; } = new();
    public IReadOnlyList<SpotStorageRecommendation> SpotRecommendations { get; init; } = Array.Empty<SpotStorageRecommendation>();
    public IReadOnlyList<ReservedCapacityRecommendation> ReservedRecommendations { get; init; } = Array.Empty<ReservedCapacityRecommendation>();
    public IReadOnlyList<TierTransitionRecommendation> TierRecommendations { get; init; } = Array.Empty<TierTransitionRecommendation>();
    public IReadOnlyList<CrossProviderArbitrageRecommendation> ArbitrageRecommendations { get; init; } = Array.Empty<CrossProviderArbitrageRecommendation>();
}

[SdkCompatibility("5.0.0")]
public sealed record SavingsSummary
{
    public decimal CurrentMonthlyCost { get; init; }
    public decimal ProjectedMonthlyCost { get; init; }
    public decimal EstimatedMonthlySavings { get; init; }
    public double SavingsPercent { get; init; }
    public decimal ImplementationCost { get; init; } // one-time migration/transition cost
    public int BreakEvenDays { get; init; }
    public int TotalRecommendations { get; init; }
    public int HighConfidenceRecommendations { get; init; }
}

[SdkCompatibility("5.0.0")]
public sealed record SpotStorageRecommendation
{
    public CloudProvider Provider { get; init; }
    public string Region { get; init; } = "";
    public string StorageClass { get; init; } = "";
    public long DataSizeGB { get; init; }
    public decimal CurrentCostPerGBMonth { get; init; }
    public decimal SpotCostPerGBMonth { get; init; }
    public decimal MonthlySavings { get; init; }
    public double InterruptionRisk { get; init; } // 0.0-1.0
    public bool RequiresReproducibleData { get; init; } = true;
    public double ConfidenceScore { get; init; }
}

[SdkCompatibility("5.0.0")]
public sealed record ReservedCapacityRecommendation
{
    public CloudProvider Provider { get; init; }
    public string Region { get; init; } = "";
    public string StorageClass { get; init; } = "";
    public long CommitGB { get; init; }
    public int TermMonths { get; init; }
    public decimal OnDemandCostPerGBMonth { get; init; }
    public decimal ReservedCostPerGBMonth { get; init; }
    public decimal MonthlySavings { get; init; }
    public int BreakEvenMonths { get; init; }
    public double UtilizationConfidence { get; init; } // probability storage will be used for full term
}

[SdkCompatibility("5.0.0")]
public sealed record TierTransitionRecommendation
{
    public string ObjectKeyPattern { get; init; } = "";
    public long AffectedObjectCount { get; init; }
    public long AffectedSizeGB { get; init; }
    public string CurrentTier { get; init; } = "";
    public string RecommendedTier { get; init; } = "";
    public double AccessFrequencyPerDay { get; init; }
    public int DaysSinceLastAccess { get; init; }
    public decimal CurrentCostPerGBMonth { get; init; }
    public decimal RecommendedCostPerGBMonth { get; init; }
    public decimal TransitionCost { get; init; } // one-time cost
    public decimal MonthlySavings { get; init; }
    public int BreakEvenDays { get; init; }
}

[SdkCompatibility("5.0.0")]
public sealed record CrossProviderArbitrageRecommendation
{
    public CloudProvider SourceProvider { get; init; }
    public CloudProvider TargetProvider { get; init; }
    public string DataCategory { get; init; } = "";
    public long DataSizeGB { get; init; }
    public decimal SourceCostPerGBMonth { get; init; }
    public decimal TargetCostPerGBMonth { get; init; }
    public decimal EgressCost { get; init; }
    public decimal MonthlySavings { get; init; }
    public int BreakEvenDays { get; init; }
    public double LatencyImpactMs { get; init; }
    public string RiskAssessment { get; init; } = "";
}
```
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>All cost optimization types compile. OptimizationPlan aggregates 4 recommendation categories with savings summary.</done>
</task>

<task type="auto">
  <name>Task 2: StorageCostOptimizer Implementation</name>
  <files>DataWarehouse.SDK/Storage/Billing/StorageCostOptimizer.cs</files>
  <action>
Create StorageCostOptimizer.cs — namespace `DataWarehouse.SDK.Storage.Billing`:

```csharp
/// Cross-provider storage cost optimizer.
/// Analyzes billing data from all configured providers and generates actionable optimization plans.
///
/// Optimization strategies:
/// 1. SPOT: Move reproducible/temporary data to spot storage for 60-90% savings
/// 2. RESERVED: Commit stable workloads to reserved capacity for 20-60% savings
/// 3. TIER: Transition cold data to cheaper tiers (e.g., S3 Standard -> Glacier)
/// 4. ARBITRAGE: Move data between providers when price differences > egress cost
[SdkCompatibility("5.0.0", Notes = "Phase 58: Storage cost optimizer")]
public sealed class StorageCostOptimizer
{
    private readonly IReadOnlyList<IBillingProvider> _providers;
    private readonly StorageCostOptimizerOptions _options;

    public StorageCostOptimizer(
        IReadOnlyList<IBillingProvider> providers,
        StorageCostOptimizerOptions? options = null)
    {
        _providers = providers ?? throw new ArgumentNullException(nameof(providers));
        _options = options ?? new StorageCostOptimizerOptions();
    }

    /// Generate a comprehensive optimization plan analyzing all providers.
    public async Task<OptimizationPlan> GenerateOptimizationPlanAsync(CancellationToken ct = default)
    {
        // Gather billing data from all providers in parallel
        var billingTasks = _providers.Select(p =>
            p.GetBillingReportAsync(
                DateTimeOffset.UtcNow.AddDays(-30),
                DateTimeOffset.UtcNow, ct));
        var billingReports = await Task.WhenAll(billingTasks);

        var spotTasks = _providers.Select(p => p.GetSpotPricingAsync(ct: ct));
        var spotPricing = (await Task.WhenAll(spotTasks)).SelectMany(s => s).ToList();

        var reservedTasks = _providers.Select(p => p.GetReservedCapacityAsync(ct));
        var reservedCapacity = (await Task.WhenAll(reservedTasks)).SelectMany(r => r).ToList();

        // Generate recommendations
        var spotRecs = GenerateSpotRecommendations(billingReports, spotPricing);
        var reservedRecs = GenerateReservedRecommendations(billingReports, reservedCapacity);
        var tierRecs = GenerateTierRecommendations(billingReports);
        var arbitrageRecs = GenerateArbitrageRecommendations(billingReports, spotPricing);

        // Calculate savings summary
        decimal currentMonthlyCost = billingReports.Sum(r => r.TotalCost);
        decimal spotSavings = spotRecs.Sum(r => r.MonthlySavings);
        decimal reservedSavings = reservedRecs.Sum(r => r.MonthlySavings);
        decimal tierSavings = tierRecs.Sum(r => r.MonthlySavings);
        decimal arbitrageSavings = arbitrageRecs.Sum(r => r.MonthlySavings);
        decimal totalSavings = spotSavings + reservedSavings + tierSavings + arbitrageSavings;
        decimal implementationCost = tierRecs.Sum(r => r.TransitionCost) + arbitrageRecs.Sum(r => r.EgressCost);

        return new OptimizationPlan
        {
            Summary = new SavingsSummary
            {
                CurrentMonthlyCost = currentMonthlyCost,
                ProjectedMonthlyCost = currentMonthlyCost - totalSavings,
                EstimatedMonthlySavings = totalSavings,
                SavingsPercent = currentMonthlyCost > 0 ? (double)(totalSavings / currentMonthlyCost * 100) : 0,
                ImplementationCost = implementationCost,
                BreakEvenDays = totalSavings > 0 ? (int)Math.Ceiling(implementationCost / (totalSavings / 30m)) : 0,
                TotalRecommendations = spotRecs.Count + reservedRecs.Count + tierRecs.Count + arbitrageRecs.Count,
                HighConfidenceRecommendations = spotRecs.Count(r => r.ConfidenceScore > 0.8)
                    + reservedRecs.Count(r => r.UtilizationConfidence > 0.8)
            },
            SpotRecommendations = spotRecs,
            ReservedRecommendations = reservedRecs,
            TierRecommendations = tierRecs,
            ArbitrageRecommendations = arbitrageRecs
        };
    }

    private IReadOnlyList<SpotStorageRecommendation> GenerateSpotRecommendations(
        BillingReport[] reports, IReadOnlyList<SpotPricing> spotPricing)
    {
        var recs = new List<SpotStorageRecommendation>();
        foreach (var spot in spotPricing.Where(s => s.SavingsPercent > _options.MinSpotSavingsPercent))
        {
            if (spot.InterruptionProbability > _options.MaxSpotInterruptionRisk)
                continue;

            recs.Add(new SpotStorageRecommendation
            {
                Provider = spot.Provider,
                Region = spot.Region,
                StorageClass = spot.StorageClass,
                DataSizeGB = spot.AvailableCapacityGB,
                CurrentCostPerGBMonth = spot.CurrentPricePerGBMonth,
                SpotCostPerGBMonth = spot.SpotPricePerGBMonth,
                MonthlySavings = (spot.CurrentPricePerGBMonth - spot.SpotPricePerGBMonth) * spot.AvailableCapacityGB,
                InterruptionRisk = spot.InterruptionProbability,
                ConfidenceScore = 1.0 - spot.InterruptionProbability
            });
        }
        return recs.OrderByDescending(r => r.MonthlySavings).ToList();
    }

    private IReadOnlyList<ReservedCapacityRecommendation> GenerateReservedRecommendations(
        BillingReport[] reports, IReadOnlyList<ReservedCapacity> existing)
    {
        var recs = new List<ReservedCapacityRecommendation>();

        // Analyze stable storage usage patterns from billing reports
        foreach (var report in reports)
        {
            var storageCosts = report.Breakdown
                .Where(b => b.Category == CostCategory.Storage)
                .ToList();

            foreach (var cost in storageCosts)
            {
                // Check if already reserved
                bool alreadyReserved = existing.Any(r =>
                    r.Provider == report.Provider && r.Region == cost.Region);
                if (alreadyReserved) continue;

                // Estimate stable GB from cost
                decimal estimatedGB = cost.Quantity > 0 ? (decimal)cost.Quantity : 0;
                if (estimatedGB < _options.MinReservedCapacityGB) continue;

                // Calculate 1-year reserved savings (typical: 30-40% discount)
                decimal onDemandMonthly = cost.Amount;
                decimal reservedMonthly = onDemandMonthly * 0.65m; // typical 35% discount
                decimal monthlySavings = onDemandMonthly - reservedMonthly;

                if (monthlySavings < _options.MinMonthlySavings) continue;

                recs.Add(new ReservedCapacityRecommendation
                {
                    Provider = report.Provider,
                    Region = cost.Region ?? "unknown",
                    StorageClass = cost.ServiceName,
                    CommitGB = (long)estimatedGB,
                    TermMonths = 12,
                    OnDemandCostPerGBMonth = estimatedGB > 0 ? onDemandMonthly / estimatedGB : 0,
                    ReservedCostPerGBMonth = estimatedGB > 0 ? reservedMonthly / estimatedGB : 0,
                    MonthlySavings = monthlySavings,
                    BreakEvenMonths = 0, // reserved starts saving immediately
                    UtilizationConfidence = 0.85 // 30 days of stable usage = good confidence
                });
            }
        }
        return recs.OrderByDescending(r => r.MonthlySavings).ToList();
    }

    private IReadOnlyList<TierTransitionRecommendation> GenerateTierRecommendations(BillingReport[] reports)
    {
        var recs = new List<TierTransitionRecommendation>();

        // Tier transition analysis based on access patterns in billing data
        foreach (var report in reports)
        {
            var storageCosts = report.Breakdown.Where(b => b.Category == CostCategory.Storage);
            var operationCosts = report.Breakdown.Where(b => b.Category == CostCategory.Operations);

            foreach (var storage in storageCosts)
            {
                // High storage cost + low operation count = candidate for cold tier
                var relatedOps = operationCosts.FirstOrDefault(o => o.Region == storage.Region);
                double opsPerDay = relatedOps?.Quantity ?? 0 / 30.0;

                if (opsPerDay < _options.ColdTierAccessThresholdPerDay && storage.Amount > _options.MinMonthlySavings)
                {
                    decimal coldTierCost = storage.Amount * 0.25m; // cold tier is typically 75% cheaper
                    decimal transitionCost = storage.Amount * 0.05m; // one-time transition fee estimate

                    recs.Add(new TierTransitionRecommendation
                    {
                        ObjectKeyPattern = $"{storage.Region}/{storage.ServiceName}/*",
                        AffectedSizeGB = (long)Math.Max(1, storage.Quantity),
                        CurrentTier = "Standard",
                        RecommendedTier = "Cold/Archive",
                        AccessFrequencyPerDay = opsPerDay,
                        CurrentCostPerGBMonth = (long)storage.Quantity > 0 ? storage.Amount / (decimal)storage.Quantity : 0,
                        RecommendedCostPerGBMonth = (long)storage.Quantity > 0 ? coldTierCost / (decimal)storage.Quantity : 0,
                        TransitionCost = transitionCost,
                        MonthlySavings = storage.Amount - coldTierCost,
                        BreakEvenDays = (storage.Amount - coldTierCost) > 0
                            ? (int)Math.Ceiling(transitionCost / ((storage.Amount - coldTierCost) / 30m))
                            : int.MaxValue
                    });
                }
            }
        }
        return recs.OrderByDescending(r => r.MonthlySavings).ToList();
    }

    private IReadOnlyList<CrossProviderArbitrageRecommendation> GenerateArbitrageRecommendations(
        BillingReport[] reports, IReadOnlyList<SpotPricing> spotPricing)
    {
        var recs = new List<CrossProviderArbitrageRecommendation>();
        if (reports.Length < 2) return recs; // need at least 2 providers

        // Compare storage costs across providers
        for (int i = 0; i < reports.Length; i++)
        {
            for (int j = i + 1; j < reports.Length; j++)
            {
                var expensive = reports[i].TotalCost > reports[j].TotalCost ? reports[i] : reports[j];
                var cheaper = reports[i].TotalCost > reports[j].TotalCost ? reports[j] : reports[i];

                decimal priceDiff = expensive.TotalCost - cheaper.TotalCost;
                if (priceDiff < _options.MinMonthlySavings) continue;

                // Estimate egress cost (typical $0.09/GB)
                decimal totalGB = expensive.Breakdown
                    .Where(b => b.Category == CostCategory.Storage)
                    .Sum(b => (decimal)b.Quantity);
                decimal egressCost = totalGB * 0.09m;

                if (priceDiff <= egressCost / 3) continue; // need 3 months to break even minimum

                recs.Add(new CrossProviderArbitrageRecommendation
                {
                    SourceProvider = expensive.Provider,
                    TargetProvider = cheaper.Provider,
                    DataCategory = "Storage",
                    DataSizeGB = (long)totalGB,
                    SourceCostPerGBMonth = totalGB > 0 ? expensive.TotalCost / totalGB : 0,
                    TargetCostPerGBMonth = totalGB > 0 ? cheaper.TotalCost / totalGB : 0,
                    EgressCost = egressCost,
                    MonthlySavings = priceDiff,
                    BreakEvenDays = priceDiff > 0 ? (int)Math.Ceiling(egressCost / (priceDiff / 30m)) : int.MaxValue,
                    RiskAssessment = priceDiff > expensive.TotalCost * 0.3m ? "Low" : "Medium"
                });
            }
        }
        return recs.OrderByDescending(r => r.MonthlySavings).ToList();
    }
}

/// Configuration for cost optimizer thresholds.
[SdkCompatibility("5.0.0")]
public sealed record StorageCostOptimizerOptions
{
    /// Minimum spot savings percentage to recommend (default 20%).
    public double MinSpotSavingsPercent { get; init; } = 20.0;

    /// Maximum acceptable spot interruption risk (default 10%).
    public double MaxSpotInterruptionRisk { get; init; } = 0.10;

    /// Minimum GB for reserved capacity recommendation.
    public long MinReservedCapacityGB { get; init; } = 100;

    /// Minimum monthly savings to generate a recommendation.
    public decimal MinMonthlySavings { get; init; } = 10.00m;

    /// Access frequency threshold for cold tier transition (per day).
    public double ColdTierAccessThresholdPerDay { get; init; } = 1.0;
}
```
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>StorageCostOptimizer compiles. Generates 4 categories of recommendations: spot, reserved, tier, and cross-provider arbitrage. Savings summary with break-even analysis.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds
- StorageCostOptimizer produces OptimizationPlan with 4 recommendation types
- SavingsSummary includes break-even analysis
- All types have [SdkCompatibility] attribute
</verification>

<success_criteria>
Cost optimizer analyzes multi-cloud billing data and generates actionable savings recommendations across spot, reserved, tier, and arbitrage strategies with break-even analysis.
</success_criteria>

<output>
After completion, create `.planning/phases/58-zero-gravity-storage/58-09-SUMMARY.md`
</output>
