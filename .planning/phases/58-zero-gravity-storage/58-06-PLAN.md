---
phase: 58-zero-gravity-storage
plan: 06
type: execute
wave: 2
depends_on: ["58-01"]
files_modified:
  - DataWarehouse.SDK/Storage/Billing/AwsCostExplorerProvider.cs
  - DataWarehouse.SDK/Storage/Billing/AzureCostManagementProvider.cs
  - DataWarehouse.SDK/Storage/Billing/GcpBillingProvider.cs
  - DataWarehouse.SDK/Storage/Billing/BillingProviderFactory.cs
autonomous: true

must_haves:
  truths:
    - "AWS Cost Explorer billing integration retrieves real billing data via REST API"
    - "Azure Cost Management billing integration retrieves real billing data via REST API"
    - "GCP Cloud Billing integration retrieves real billing data via REST API"
    - "All providers implement IBillingProvider with credential validation"
    - "Factory creates providers from configuration"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/Billing/AwsCostExplorerProvider.cs"
      provides: "AWS Cost Explorer API integration"
      exports: ["AwsCostExplorerProvider"]
    - path: "DataWarehouse.SDK/Storage/Billing/AzureCostManagementProvider.cs"
      provides: "Azure Cost Management API integration"
      exports: ["AzureCostManagementProvider"]
    - path: "DataWarehouse.SDK/Storage/Billing/GcpBillingProvider.cs"
      provides: "GCP Cloud Billing API integration"
      exports: ["GcpBillingProvider"]
    - path: "DataWarehouse.SDK/Storage/Billing/BillingProviderFactory.cs"
      provides: "Factory for creating billing providers by cloud type"
      exports: ["BillingProviderFactory"]
  key_links:
    - from: "AwsCostExplorerProvider"
      to: "IBillingProvider"
      via: "implements interface"
      pattern: "class AwsCostExplorerProvider : IBillingProvider"
    - from: "BillingProviderFactory"
      to: "IBillingProvider"
      via: "creates and returns providers"
      pattern: "IBillingProvider Create"
---

<objective>
Implement billing API integrations for AWS Cost Explorer, Azure Cost Management, and GCP Cloud Billing. Each provider implements IBillingProvider with real REST API calls using HttpClient.

Purpose: Cost visibility is essential for zero-gravity storage cost optimization. These providers fetch actual billing data, spot pricing, and reserved capacity information that drive the cost optimizer (Plan 09).
Output: 3 cloud billing providers + factory class.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/58-zero-gravity-storage/58-01-SUMMARY.md
@DataWarehouse.SDK/Storage/Billing/IBillingProvider.cs
@DataWarehouse.SDK/Storage/Billing/BillingTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: AWS, Azure, GCP Billing Providers</name>
  <files>
    DataWarehouse.SDK/Storage/Billing/AwsCostExplorerProvider.cs
    DataWarehouse.SDK/Storage/Billing/AzureCostManagementProvider.cs
    DataWarehouse.SDK/Storage/Billing/GcpBillingProvider.cs
  </files>
  <action>
Each provider follows the same pattern: HttpClient-based REST API integration with credential handling, proper error handling, and response parsing using System.Text.Json.

**AwsCostExplorerProvider.cs** — namespace `DataWarehouse.SDK.Storage.Billing`:
- Implements `IBillingProvider` with `Provider => CloudProvider.AWS`
- Constructor takes: `HttpClient httpClient`, `string accessKeyId`, `string secretAccessKey`, `string region = "us-east-1"`
- `GetBillingReportAsync`: Calls AWS Cost Explorer API (`POST https://ce.{region}.amazonaws.com/`) with `GetCostAndUsage` action. Uses AWS Signature V4 signing (implement a minimal `SignV4` helper that computes HMAC-SHA256 signature chain: `DateKey -> DateRegionKey -> DateRegionServiceKey -> SigningKey -> Signature`). Parse JSON response grouping by `SERVICE` dimension into CostBreakdown items.
- `GetSpotPricingAsync`: Calls EC2 `DescribeSpotPriceHistory` API for storage-relevant instance types. Transform into SpotPricing records with current vs spot pricing.
- `GetReservedCapacityAsync`: Calls `DescribeReservedInstances` for active reservations. Map to ReservedCapacity records.
- `ForecastCostAsync`: Calls `GetCostForecast` with `MONTHLY` granularity. Return CostForecast with projected cost and confidence.
- `ValidateCredentialsAsync`: Calls `GetCallerIdentity` (STS). Returns true if 200, false otherwise.
- All API calls: proper error handling with HttpRequestException, retry on 429/5xx (exponential backoff, max 3 retries), CancellationToken passed through.

**AzureCostManagementProvider.cs**:
- Implements `IBillingProvider` with `Provider => CloudProvider.Azure`
- Constructor takes: `HttpClient httpClient`, `string tenantId`, `string clientId`, `string clientSecret`, `string subscriptionId`
- Token acquisition: POST to `https://login.microsoftonline.com/{tenantId}/oauth2/v2.0/token` with client_credentials grant, scope `https://management.azure.com/.default`. Cache token until expiry.
- `GetBillingReportAsync`: POST to `https://management.azure.com/subscriptions/{subId}/providers/Microsoft.CostManagement/query?api-version=2023-11-01` with timeframe query. Parse column-based response into CostBreakdown.
- `GetSpotPricingAsync`: GET `https://prices.azure.com/api/retail/prices?$filter=serviceFamily eq 'Storage'` — parse retail pricing and map.
- `GetReservedCapacityAsync`: GET reserved instances from `https://management.azure.com/subscriptions/{subId}/providers/Microsoft.Capacity/reservationOrders?api-version=2022-11-01`.
- `ForecastCostAsync`: POST to Cost Management forecast API.
- `ValidateCredentialsAsync`: Attempt token acquisition, return success/failure.

**GcpBillingProvider.cs**:
- Implements `IBillingProvider` with `Provider => CloudProvider.GCP`
- Constructor takes: `HttpClient httpClient`, `string serviceAccountJson` (JSON key file content), `string projectId`
- JWT creation: Build JWT with `iss=client_email`, `scope=https://www.googleapis.com/auth/cloud-billing.readonly`, sign with RS256 using private_key from service account JSON. Exchange JWT for access token at `https://oauth2.googleapis.com/token`.
- `GetBillingReportAsync`: GET `https://cloudbilling.googleapis.com/v1/billingAccounts/{accountId}/billingInfo` and BigQuery export if configured. Use simplified billing info endpoint for basic reporting.
- `GetSpotPricingAsync`: GET `https://cloudbilling.googleapis.com/v1/services` and SKUs for storage services.
- `GetReservedCapacityAsync`: GET committed use discounts from `https://compute.googleapis.com/compute/v1/projects/{project}/aggregated/commitments`.
- `ForecastCostAsync`: Use billing budget API forecasts.
- `ValidateCredentialsAsync`: Attempt token acquisition, return success/failure.

For ALL providers: Do NOT add NuGet package dependencies for cloud SDKs. Use raw HttpClient + System.Text.Json. This keeps the SDK dependency-free. Use `System.Security.Cryptography` for signing (HMAC-SHA256 for AWS, RSA for GCP). Handle credential env var fallback: if constructor params are null, try environment variables (AWS_ACCESS_KEY_ID, AZURE_CLIENT_ID, GOOGLE_APPLICATION_CREDENTIALS).
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>All 3 providers compile. Each implements IBillingProvider. AWS uses SigV4 signing. Azure uses OAuth2 client_credentials. GCP uses JWT/RS256. No external NuGet dependencies added.</done>
</task>

<task type="auto">
  <name>Task 2: BillingProviderFactory</name>
  <files>DataWarehouse.SDK/Storage/Billing/BillingProviderFactory.cs</files>
  <action>
Create BillingProviderFactory.cs — namespace `DataWarehouse.SDK.Storage.Billing`:

```csharp
/// Factory for creating billing providers from configuration.
[SdkCompatibility("5.0.0", Notes = "Phase 58: Billing API integration")]
public static class BillingProviderFactory
{
    /// Creates a billing provider for the specified cloud provider.
    /// Credentials are loaded from environment variables if not provided in config.
    public static IBillingProvider Create(CloudProvider provider, HttpClient? httpClient = null, IDictionary<string, string>? config = null)
    {
        var client = httpClient ?? new HttpClient();
        config ??= new Dictionary<string, string>();

        return provider switch
        {
            CloudProvider.AWS => new AwsCostExplorerProvider(
                client,
                GetConfig(config, "AccessKeyId", "AWS_ACCESS_KEY_ID"),
                GetConfig(config, "SecretAccessKey", "AWS_SECRET_ACCESS_KEY"),
                GetConfigOptional(config, "Region", "AWS_REGION") ?? "us-east-1"),

            CloudProvider.Azure => new AzureCostManagementProvider(
                client,
                GetConfig(config, "TenantId", "AZURE_TENANT_ID"),
                GetConfig(config, "ClientId", "AZURE_CLIENT_ID"),
                GetConfig(config, "ClientSecret", "AZURE_CLIENT_SECRET"),
                GetConfig(config, "SubscriptionId", "AZURE_SUBSCRIPTION_ID")),

            CloudProvider.GCP => new GcpBillingProvider(
                client,
                GetConfig(config, "ServiceAccountJson", "GOOGLE_APPLICATION_CREDENTIALS"),
                GetConfig(config, "ProjectId", "GCP_PROJECT_ID")),

            _ => throw new NotSupportedException($"Billing provider not available for {provider}")
        };
    }

    /// Creates all available billing providers (those with valid credentials).
    public static async Task<IReadOnlyList<IBillingProvider>> CreateAllAvailableAsync(
        HttpClient? httpClient = null, CancellationToken ct = default)
    {
        var providers = new List<IBillingProvider>();
        foreach (var cloudProvider in new[] { CloudProvider.AWS, CloudProvider.Azure, CloudProvider.GCP })
        {
            try
            {
                var provider = Create(cloudProvider, httpClient);
                if (await provider.ValidateCredentialsAsync(ct))
                    providers.Add(provider);
            }
            catch { /* Skip providers without credentials */ }
        }
        return providers;
    }

    private static string GetConfig(IDictionary<string, string> config, string key, string envVar)
    {
        if (config.TryGetValue(key, out var value) && !string.IsNullOrWhiteSpace(value))
            return value;

        var envValue = Environment.GetEnvironmentVariable(envVar);
        if (!string.IsNullOrWhiteSpace(envValue))
        {
            // For GCP, if GOOGLE_APPLICATION_CREDENTIALS points to a file, read it
            if (envVar == "GOOGLE_APPLICATION_CREDENTIALS" && File.Exists(envValue))
                return File.ReadAllText(envValue);
            return envValue;
        }

        throw new InvalidOperationException(
            $"Billing configuration '{key}' not found. Set via config or environment variable '{envVar}'.");
    }

    private static string? GetConfigOptional(IDictionary<string, string> config, string key, string envVar)
    {
        if (config.TryGetValue(key, out var value) && !string.IsNullOrWhiteSpace(value))
            return value;
        return Environment.GetEnvironmentVariable(envVar);
    }
}
```
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>BillingProviderFactory compiles. Create() supports AWS, Azure, GCP with env var fallback. CreateAllAvailableAsync() probes all providers. No external NuGet dependencies.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds
- 4 files exist in DataWarehouse.SDK/Storage/Billing/
- Each provider implements IBillingProvider
- No new NuGet package references added to SDK csproj
</verification>

<success_criteria>
All 3 cloud billing providers compile and implement IBillingProvider. Factory creates providers with credential resolution from config or environment variables. Zero external SDK dependencies.
</success_criteria>

<output>
After completion, create `.planning/phases/58-zero-gravity-storage/58-06-SUMMARY.md`
</output>
