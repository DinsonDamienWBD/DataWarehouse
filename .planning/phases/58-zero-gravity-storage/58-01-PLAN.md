---
phase: 58-zero-gravity-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Storage/Placement/PlacementTypes.cs
  - DataWarehouse.SDK/Storage/Placement/IPlacementAlgorithm.cs
  - DataWarehouse.SDK/Storage/Placement/IPlacementOptimizer.cs
  - DataWarehouse.SDK/Storage/Placement/IRebalancer.cs
  - DataWarehouse.SDK/Storage/Billing/IBillingProvider.cs
  - DataWarehouse.SDK/Storage/Billing/BillingTypes.cs
  - DataWarehouse.SDK/Storage/Migration/IMigrationEngine.cs
  - DataWarehouse.SDK/Storage/Migration/MigrationTypes.cs
autonomous: true

must_haves:
  truths:
    - "All zero-gravity storage subsystems have SDK-level contracts"
    - "Contracts are plugin-agnostic (SDK only, no plugin references)"
    - "Placement, billing, migration, and rebalancing concerns are decoupled via interfaces"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/Placement/PlacementTypes.cs"
      provides: "PlacementTarget, PlacementDecision, PlacementConstraint, NodeDescriptor, StorageClass, DataGravityScore records"
    - path: "DataWarehouse.SDK/Storage/Placement/IPlacementAlgorithm.cs"
      provides: "Interface for deterministic placement (CRUSH-equivalent)"
      exports: ["IPlacementAlgorithm"]
    - path: "DataWarehouse.SDK/Storage/Placement/IPlacementOptimizer.cs"
      provides: "Interface for gravity-aware multi-dimensional scoring"
      exports: ["IPlacementOptimizer"]
    - path: "DataWarehouse.SDK/Storage/Placement/IRebalancer.cs"
      provides: "Interface for autonomous rebalancing service"
      exports: ["IRebalancer", "RebalanceJob", "RebalancePlan"]
    - path: "DataWarehouse.SDK/Storage/Billing/IBillingProvider.cs"
      provides: "Interface for cloud billing API integration"
      exports: ["IBillingProvider"]
    - path: "DataWarehouse.SDK/Storage/Billing/BillingTypes.cs"
      provides: "BillingReport, CostBreakdown, SpotPricing, ReservedCapacity records"
    - path: "DataWarehouse.SDK/Storage/Migration/IMigrationEngine.cs"
      provides: "Interface for zero-downtime background migration"
      exports: ["IMigrationEngine"]
    - path: "DataWarehouse.SDK/Storage/Migration/MigrationTypes.cs"
      provides: "MigrationJob, MigrationPlan, ReadForwardingEntry, MigrationStatus records"
  key_links:
    - from: "IPlacementAlgorithm"
      to: "PlacementTypes"
      via: "uses PlacementTarget, NodeDescriptor, PlacementDecision"
      pattern: "PlacementDecision.*ComputePlacement"
    - from: "IRebalancer"
      to: "IPlacementOptimizer"
      via: "optimizer scores drive rebalance decisions"
      pattern: "IPlacementOptimizer.*ScorePlacement"
---

<objective>
Define all SDK-level contracts for zero-gravity storage: placement algorithm interface, placement optimizer interface, rebalancer interface, billing provider interface, and migration engine interface with all supporting types.

Purpose: Establish the contract surface that all subsequent plans implement against. Ensures plugin isolation (all implementations reference only these SDK types).
Output: 8 new files in DataWarehouse.SDK/Storage/ subdirectories.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/StoragePluginBase.cs
@DataWarehouse.SDK/Federation/Topology/NodeTopology.cs
@DataWarehouse.SDK/Federation/Routing/StorageRequest.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Placement and Rebalancer SDK Contracts</name>
  <files>
    DataWarehouse.SDK/Storage/Placement/PlacementTypes.cs
    DataWarehouse.SDK/Storage/Placement/IPlacementAlgorithm.cs
    DataWarehouse.SDK/Storage/Placement/IPlacementOptimizer.cs
    DataWarehouse.SDK/Storage/Placement/IRebalancer.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Storage/Placement/` directory with 4 files:

**PlacementTypes.cs** — All value types for placement:
- `NodeDescriptor` record: NodeId (string), Zone (string), Rack (string), Host (string), Tags (IReadOnlyDictionary string,string), StorageClasses (IReadOnlyList StorageClass), CapacityBytes (long), UsedBytes (long), Weight (double, default 1.0)
- `StorageClass` enum: Hot, Warm, Cool, Cold, Archive, NVMe, SSD, HDD, Tape, DNA, Holographic
- `PlacementTarget` record: ObjectKey (string), ObjectSize (long), ReplicaCount (int), RequiredStorageClass (StorageClass?), RequiredZones (IReadOnlyList string?), RequiredTags (IReadOnlyDictionary string,string?), ComplianceRegions (IReadOnlyList string?)
- `PlacementDecision` record: TargetNodes (IReadOnlyList NodeDescriptor), PrimaryNode (NodeDescriptor), ReplicaNodes (IReadOnlyList NodeDescriptor), PlacementRuleId (string), Deterministic (bool), Timestamp (DateTimeOffset)
- `PlacementConstraint` record: ConstraintType (enum: Zone, Rack, Host, Tag, StorageClass, Compliance), Key (string), Value (string), Required (bool)
- `DataGravityScore` record: ObjectKey (string), CurrentNode (string), AccessFrequency (double), LastAccessUtc (DateTimeOffset), ColocatedDependencies (int), EgressCostPerGB (decimal), LatencyMs (double), ComplianceWeight (double), CompositeScore (double) — higher = more gravity (harder to move)
- `RebalanceJob` record: JobId (string), Plan (RebalancePlan), Status (RebalanceStatus enum: Pending/Running/Paused/Completed/Failed), CreatedUtc (DateTimeOffset), StartedUtc (DateTimeOffset?), CompletedUtc (DateTimeOffset?), TotalMoves (int), CompletedMoves (int), FailedMoves (int)
- `RebalancePlan` record: Moves (IReadOnlyList RebalanceMove), EstimatedDurationSeconds (double), EstimatedEgressBytes (long), EstimatedCost (decimal)
- `RebalanceMove` record: ObjectKey (string), SourceNode (string), TargetNode (string), SizeBytes (long), Priority (int)

**IPlacementAlgorithm.cs** — Deterministic CRUSH-equivalent:
```csharp
public interface IPlacementAlgorithm
{
    PlacementDecision ComputePlacement(PlacementTarget target, IReadOnlyList<NodeDescriptor> clusterMap, IReadOnlyList<PlacementConstraint>? constraints = null);
    PlacementDecision RecomputeOnNodeChange(PlacementTarget target, IReadOnlyList<NodeDescriptor> newClusterMap, PlacementDecision previousDecision);
    double EstimateMovementOnResize(IReadOnlyList<NodeDescriptor> currentMap, IReadOnlyList<NodeDescriptor> newMap);
}
```
Methods are synchronous because CRUSH is a pure math function (no I/O). Must be deterministic: same inputs always produce same outputs.

**IPlacementOptimizer.cs** — Gravity-aware scoring:
```csharp
public interface IPlacementOptimizer
{
    Task<DataGravityScore> ComputeGravityAsync(string objectKey, CancellationToken ct = default);
    Task<IReadOnlyList<DataGravityScore>> ComputeGravityBatchAsync(IReadOnlyList<string> objectKeys, CancellationToken ct = default);
    Task<PlacementDecision> OptimizePlacementAsync(PlacementTarget target, IReadOnlyList<NodeDescriptor> clusterMap, DataGravityScore gravity, CancellationToken ct = default);
    Task<RebalancePlan> GenerateRebalancePlanAsync(IReadOnlyList<NodeDescriptor> clusterMap, RebalanceOptions options, CancellationToken ct = default);
}
```
Add `RebalanceOptions` record: MaxMoves (int), MaxEgressBytes (long), MaxCostBudget (decimal), MinGravityThreshold (double), DryRun (bool)

**IRebalancer.cs** — Background rebalance service:
```csharp
public interface IRebalancer
{
    Task<RebalanceJob> StartRebalanceAsync(RebalancePlan plan, CancellationToken ct = default);
    Task PauseRebalanceAsync(string jobId, CancellationToken ct = default);
    Task ResumeRebalanceAsync(string jobId, CancellationToken ct = default);
    Task CancelRebalanceAsync(string jobId, CancellationToken ct = default);
    Task<RebalanceJob> GetStatusAsync(string jobId, CancellationToken ct = default);
    Task<IReadOnlyList<RebalanceJob>> ListJobsAsync(CancellationToken ct = default);
    IAsyncEnumerable<RebalanceJob> MonitorAsync(string jobId, CancellationToken ct = default);
}
```

All types in namespace `DataWarehouse.SDK.Storage.Placement`. Use `[SdkCompatibility("5.0.0", Notes = "Phase 58: Zero-Gravity Storage")]` on all public types.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>4 files exist in SDK/Storage/Placement/, all compile, no warnings. IPlacementAlgorithm has 3 sync methods. IPlacementOptimizer has 4 async methods. IRebalancer has 7 async methods.</done>
</task>

<task type="auto">
  <name>Task 2: Billing and Migration SDK Contracts</name>
  <files>
    DataWarehouse.SDK/Storage/Billing/IBillingProvider.cs
    DataWarehouse.SDK/Storage/Billing/BillingTypes.cs
    DataWarehouse.SDK/Storage/Migration/IMigrationEngine.cs
    DataWarehouse.SDK/Storage/Migration/MigrationTypes.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Storage/Billing/` and `DataWarehouse.SDK/Storage/Migration/` directories:

**BillingTypes.cs** — namespace `DataWarehouse.SDK.Storage.Billing`:
- `CloudProvider` enum: AWS, Azure, GCP, Oracle, Alibaba, OnPremise, Custom
- `BillingReport` record: ProviderId (string), Provider (CloudProvider), PeriodStart (DateTimeOffset), PeriodEnd (DateTimeOffset), TotalCost (decimal), Currency (string, default "USD"), Breakdown (IReadOnlyList CostBreakdown)
- `CostBreakdown` record: Category (CostCategory enum), ServiceName (string), Amount (decimal), Unit (string), Quantity (double), Region (string?)
- `CostCategory` enum: Storage, Compute, Egress, Operations, Transfer, ReservedCapacity, SpotInstance, Other
- `SpotPricing` record: Provider (CloudProvider), Region (string), StorageClass (string), CurrentPricePerGBMonth (decimal), SpotPricePerGBMonth (decimal), SavingsPercent (double), AvailableCapacityGB (long), InterruptionProbability (double)
- `ReservedCapacity` record: Provider (CloudProvider), Region (string), StorageClass (string), CommittedGB (long), ReservedPricePerGBMonth (decimal), OnDemandPricePerGBMonth (decimal), SavingsPercent (double), TermMonths (int), ExpiresUtc (DateTimeOffset)
- `CostForecast` record: Provider (CloudProvider), ForecastPeriodDays (int), ProjectedCost (decimal), ConfidencePercent (double), Recommendations (IReadOnlyList CostRecommendation)
- `CostRecommendation` record: Type (RecommendationType enum: MoveToSpot/ReserveCapacity/TierTransition/RegionChange/ProviderSwitch), Description (string), EstimatedMonthlySavings (decimal), ImplementationEffort (string), RiskLevel (string)

**IBillingProvider.cs**:
```csharp
public interface IBillingProvider
{
    CloudProvider Provider { get; }
    Task<BillingReport> GetBillingReportAsync(DateTimeOffset from, DateTimeOffset to, CancellationToken ct = default);
    Task<IReadOnlyList<SpotPricing>> GetSpotPricingAsync(string? region = null, CancellationToken ct = default);
    Task<IReadOnlyList<ReservedCapacity>> GetReservedCapacityAsync(CancellationToken ct = default);
    Task<CostForecast> ForecastCostAsync(int days, CancellationToken ct = default);
    Task<bool> ValidateCredentialsAsync(CancellationToken ct = default);
}
```

**MigrationTypes.cs** — namespace `DataWarehouse.SDK.Storage.Migration`:
- `MigrationStatus` enum: Pending, Preparing, InProgress, ReadForwarding, Completing, Completed, Failed, Cancelled, Paused
- `MigrationJob` record: JobId (string), Description (string), Plan (MigrationPlan), Status (MigrationStatus), CreatedUtc (DateTimeOffset), StartedUtc (DateTimeOffset?), CompletedUtc (DateTimeOffset?), TotalObjects (long), MigratedObjects (long), FailedObjects (long), BytesMigrated (long), CurrentThroughputBytesPerSec (double)
- `MigrationPlan` record: SourceNode (string), TargetNode (string), Objects (IReadOnlyList MigrationObject), ThrottleBytesPerSec (long?), EnableReadForwarding (bool), ZeroDowntime (bool), ValidateChecksums (bool)
- `MigrationObject` record: ObjectKey (string), SizeBytes (long), SourceLocation (string), TargetLocation (string), Priority (int)
- `ReadForwardingEntry` record: ObjectKey (string), OriginalNode (string), NewNode (string), ExpiresUtc (DateTimeOffset), Hops (int)
- `MigrationCheckpoint` record: JobId (string), LastProcessedKey (string), ProcessedCount (long), TimestampUtc (DateTimeOffset)

**IMigrationEngine.cs**:
```csharp
public interface IMigrationEngine
{
    Task<MigrationJob> StartMigrationAsync(MigrationPlan plan, CancellationToken ct = default);
    Task PauseMigrationAsync(string jobId, CancellationToken ct = default);
    Task ResumeMigrationAsync(string jobId, CancellationToken ct = default);
    Task CancelMigrationAsync(string jobId, CancellationToken ct = default);
    Task<MigrationJob> GetStatusAsync(string jobId, CancellationToken ct = default);
    Task<IReadOnlyList<MigrationJob>> ListJobsAsync(MigrationStatus? statusFilter = null, CancellationToken ct = default);
    IAsyncEnumerable<MigrationJob> MonitorAsync(string jobId, CancellationToken ct = default);
    Task<ReadForwardingEntry?> GetForwardingEntryAsync(string objectKey, CancellationToken ct = default);
}
```

Use `[SdkCompatibility("5.0.0", Notes = "Phase 58: Zero-Gravity Storage")]` on all public types.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>4 files exist in SDK/Storage/Billing/ and SDK/Storage/Migration/, all compile. IBillingProvider has 5 async methods + Provider property. IMigrationEngine has 8 methods including IAsyncEnumerable monitor.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with 0 errors
- All 8 new files exist under DataWarehouse.SDK/Storage/
- No references to any plugin namespace
- All public types have [SdkCompatibility] attribute
</verification>

<success_criteria>
All SDK contracts for Phase 58 compile and are available for Wave 2 plans to implement against. Zero plugin references in SDK.
</success_criteria>

<output>
After completion, create `.planning/phases/58-zero-gravity-storage/58-01-SUMMARY.md`
</output>
