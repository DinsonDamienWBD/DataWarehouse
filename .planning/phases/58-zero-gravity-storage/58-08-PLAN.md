---
phase: 58-zero-gravity-storage
plan: 08
type: execute
wave: 3
depends_on: ["58-04", "58-05", "58-07"]
files_modified:
  - DataWarehouse.SDK/Storage/Placement/AutonomousRebalancer.cs
  - DataWarehouse.SDK/Storage/Placement/RebalancerOptions.cs
autonomous: true

must_haves:
  truths:
    - "Rebalancer runs as continuous background service"
    - "Uses CRUSH + gravity optimizer to generate rebalance plans"
    - "Delegates actual data movement to migration engine"
    - "Respects configurable thresholds (imbalance tolerance, max concurrent moves)"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/Placement/AutonomousRebalancer.cs"
      provides: "Continuous rebalancing service"
      exports: ["AutonomousRebalancer"]
      contains: "IRebalancer"
    - path: "DataWarehouse.SDK/Storage/Placement/RebalancerOptions.cs"
      provides: "Configuration for rebalancer behavior"
      exports: ["RebalancerOptions"]
  key_links:
    - from: "AutonomousRebalancer"
      to: "GravityAwarePlacementOptimizer"
      via: "generates rebalance plans using gravity scores"
      pattern: "_optimizer\\.GenerateRebalancePlanAsync"
    - from: "AutonomousRebalancer"
      to: "BackgroundMigrationEngine"
      via: "creates migration jobs to execute moves"
      pattern: "_migrationEngine\\.StartMigrationAsync"
    - from: "AutonomousRebalancer"
      to: "CrushPlacementAlgorithm"
      via: "computes ideal placement for imbalanced objects"
      pattern: "_crushAlgorithm\\.ComputePlacement"
---

<objective>
Build an autonomous rebalancer that continuously monitors cluster balance and triggers data migrations to optimize placement. Combines CRUSH algorithm (for ideal placement), gravity optimizer (for movement cost), and migration engine (for actual data transfer).

Purpose: Without continuous rebalancing, cluster imbalance grows over time as nodes are added/removed and access patterns change. The autonomous rebalancer detects imbalance, generates minimal-disruption migration plans, and executes them in the background.
Output: AutonomousRebalancer implementing IRebalancer + RebalancerOptions configuration.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/58-zero-gravity-storage/58-04-SUMMARY.md
@.planning/phases/58-zero-gravity-storage/58-05-SUMMARY.md
@.planning/phases/58-zero-gravity-storage/58-07-SUMMARY.md
@DataWarehouse.SDK/Storage/Placement/IRebalancer.cs
@DataWarehouse.SDK/Storage/Placement/IPlacementAlgorithm.cs
@DataWarehouse.SDK/Storage/Placement/IPlacementOptimizer.cs
@DataWarehouse.SDK/Storage/Migration/IMigrationEngine.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: RebalancerOptions Configuration</name>
  <files>DataWarehouse.SDK/Storage/Placement/RebalancerOptions.cs</files>
  <action>
Create RebalancerOptions.cs — namespace `DataWarehouse.SDK.Storage.Placement`:

```csharp
/// Configuration for the autonomous rebalancer's behavior.
[SdkCompatibility("5.0.0", Notes = "Phase 58: Autonomous rebalancer")]
public sealed record RebalancerOptions
{
    /// How often to check for imbalance (default: every 5 minutes).
    public TimeSpan CheckInterval { get; init; } = TimeSpan.FromMinutes(5);

    /// Imbalance threshold before triggering rebalance.
    /// Ratio of (max_used - min_used) / total_capacity. Default 0.10 (10%).
    public double ImbalanceThreshold { get; init; } = 0.10;

    /// Maximum concurrent migration jobs.
    public int MaxConcurrentMigrations { get; init; } = 3;

    /// Maximum moves per rebalance cycle.
    public int MaxMovesPerCycle { get; init; } = 1000;

    /// Maximum egress bytes per rebalance cycle (prevents cost runaway).
    public long MaxEgressBytesPerCycle { get; init; } = 10L * 1024 * 1024 * 1024; // 10 GB

    /// Maximum cost budget per rebalance cycle.
    public decimal MaxCostPerCycle { get; init; } = 100.00m;

    /// Minimum gravity score to protect an object from rebalancing.
    /// Objects with gravity >= this threshold are never moved.
    public double GravityProtectionThreshold { get; init; } = 0.9;

    /// Throttle for data movement (bytes per second per migration).
    public long ThrottleBytesPerSec { get; init; } = 50 * 1024 * 1024; // 50 MB/s

    /// Enable read forwarding during migrations.
    public bool EnableReadForwarding { get; init; } = true;

    /// Enable checksum validation after migration.
    public bool ValidateChecksums { get; init; } = true;

    /// Quiet hours: skip rebalancing during peak traffic.
    /// Format: (StartHourUtc, EndHourUtc). Null = no quiet hours.
    public (int StartHour, int EndHour)? QuietHours { get; init; }

    /// Scoring weights for gravity computation.
    public GravityScoringWeights ScoringWeights { get; init; } = GravityScoringWeights.Default;

    /// Default options for balanced behavior.
    public static RebalancerOptions Default => new();

    /// Aggressive rebalancing for maintenance windows.
    public static RebalancerOptions Aggressive => new()
    {
        CheckInterval = TimeSpan.FromMinutes(1),
        ImbalanceThreshold = 0.05,
        MaxConcurrentMigrations = 10,
        MaxMovesPerCycle = 10000,
        ThrottleBytesPerSec = 200 * 1024 * 1024
    };

    /// Conservative rebalancing for production.
    public static RebalancerOptions Conservative => new()
    {
        CheckInterval = TimeSpan.FromMinutes(30),
        ImbalanceThreshold = 0.20,
        MaxConcurrentMigrations = 1,
        MaxMovesPerCycle = 100,
        ThrottleBytesPerSec = 10 * 1024 * 1024
    };
}
```
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>RebalancerOptions compiles with all threshold/limit fields. 3 presets available: Default, Aggressive, Conservative.</done>
</task>

<task type="auto">
  <name>Task 2: AutonomousRebalancer Implementation</name>
  <files>DataWarehouse.SDK/Storage/Placement/AutonomousRebalancer.cs</files>
  <action>
Create AutonomousRebalancer.cs — namespace `DataWarehouse.SDK.Storage.Placement`:

Implements IRebalancer with continuous background monitoring. Key design:

1. **Monitor loop**: Timer-based check every `CheckInterval`. Computes cluster imbalance ratio. If above threshold, generates rebalance plan.

2. **Plan generation**: Uses gravity optimizer to score all objects on imbalanced nodes, sorts by gravity (low first), selects top N moves that stay within budget.

3. **Execution**: Creates MigrationPlan and delegates to IMigrationEngine. Tracks job lifecycle.

```csharp
[SdkCompatibility("5.0.0", Notes = "Phase 58: Autonomous rebalancer")]
public sealed class AutonomousRebalancer : IRebalancer, IAsyncDisposable
{
    private readonly IPlacementAlgorithm _crushAlgorithm;
    private readonly IPlacementOptimizer _optimizer;
    private readonly IMigrationEngine _migrationEngine;
    private readonly RebalancerOptions _options;
    private readonly ConcurrentDictionary<string, RebalanceJob> _jobs = new();
    private readonly Timer _monitorTimer;
    private bool _disposed;
    private int _isRunning; // 0 = idle, 1 = running (interlocked)

    // Cluster state provider (injected by host)
    public Func<CancellationToken, Task<IReadOnlyList<NodeDescriptor>>>? ClusterMapProvider { get; set; }
    public Func<string, CancellationToken, Task<IReadOnlyList<string>>>? ObjectEnumeratorByNode { get; set; }

    public AutonomousRebalancer(
        IPlacementAlgorithm crushAlgorithm,
        IPlacementOptimizer optimizer,
        IMigrationEngine migrationEngine,
        RebalancerOptions? options = null)
    {
        _crushAlgorithm = crushAlgorithm;
        _optimizer = optimizer;
        _migrationEngine = migrationEngine;
        _options = options ?? RebalancerOptions.Default;

        _monitorTimer = new Timer(
            async _ => await CheckAndRebalanceAsync(CancellationToken.None),
            null,
            _options.CheckInterval,
            _options.CheckInterval);
    }

    public async Task<RebalanceJob> StartRebalanceAsync(RebalancePlan plan, CancellationToken ct = default)
    {
        var jobId = $"rebal-{Guid.NewGuid():N}"[..16];
        var job = new RebalanceJob
        {
            JobId = jobId,
            Plan = plan,
            Status = RebalanceStatus.Running,
            CreatedUtc = DateTimeOffset.UtcNow,
            StartedUtc = DateTimeOffset.UtcNow,
            TotalMoves = plan.Moves.Count,
            CompletedMoves = 0,
            FailedMoves = 0
        };
        _jobs[jobId] = job;

        // Execute moves via migration engine
        _ = Task.Run(async () =>
        {
            int completed = 0, failed = 0;
            try
            {
                // Group moves by source->target pair for batch migration
                var moveGroups = plan.Moves.GroupBy(m => (m.SourceNode, m.TargetNode));
                var activeMigrations = new List<Task>();

                foreach (var group in moveGroups)
                {
                    // Respect max concurrent migrations
                    while (activeMigrations.Count(t => !t.IsCompleted) >= _options.MaxConcurrentMigrations)
                    {
                        await Task.WhenAny(activeMigrations.Where(t => !t.IsCompleted));
                    }

                    ct.ThrowIfCancellationRequested();
                    if (_jobs.TryGetValue(jobId, out var current) && current.Status == RebalanceStatus.Paused)
                    {
                        while (current.Status == RebalanceStatus.Paused && !ct.IsCancellationRequested)
                            await Task.Delay(500, ct);
                    }

                    var migrationPlan = new MigrationPlan
                    {
                        SourceNode = group.Key.SourceNode,
                        TargetNode = group.Key.TargetNode,
                        Objects = group.Select(m => new MigrationObject
                        {
                            ObjectKey = m.ObjectKey,
                            SizeBytes = m.SizeBytes,
                            SourceLocation = m.SourceNode,
                            TargetLocation = m.TargetNode,
                            Priority = m.Priority
                        }).ToList(),
                        ThrottleBytesPerSec = _options.ThrottleBytesPerSec,
                        EnableReadForwarding = _options.EnableReadForwarding,
                        ZeroDowntime = true,
                        ValidateChecksums = _options.ValidateChecksums
                    };

                    var migrationTask = _migrationEngine.StartMigrationAsync(migrationPlan, ct)
                        .ContinueWith(async t =>
                        {
                            if (t.IsCompletedSuccessfully)
                            {
                                var migJob = t.Result;
                                // Monitor until complete
                                await foreach (var status in _migrationEngine.MonitorAsync(migJob.JobId, ct))
                                {
                                    if (status.Status == MigrationStatus.Completed)
                                    {
                                        Interlocked.Add(ref completed, (int)status.MigratedObjects);
                                        break;
                                    }
                                    if (status.Status == MigrationStatus.Failed)
                                    {
                                        Interlocked.Add(ref failed, (int)status.FailedObjects);
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                Interlocked.Add(ref failed, group.Count());
                            }

                            _jobs[jobId] = _jobs[jobId] with
                            {
                                CompletedMoves = completed,
                                FailedMoves = failed
                            };
                        }, ct).Unwrap();

                    activeMigrations.Add(migrationTask);
                }

                await Task.WhenAll(activeMigrations);
                _jobs[jobId] = _jobs[jobId] with
                {
                    Status = RebalanceStatus.Completed,
                    CompletedUtc = DateTimeOffset.UtcNow,
                    CompletedMoves = completed,
                    FailedMoves = failed
                };
            }
            catch (OperationCanceledException)
            {
                _jobs[jobId] = _jobs[jobId] with { Status = RebalanceStatus.Failed };
            }
        }, ct);

        return job;
    }

    public Task PauseRebalanceAsync(string jobId, CancellationToken ct = default)
    {
        if (_jobs.TryGetValue(jobId, out var job))
            _jobs[jobId] = job with { Status = RebalanceStatus.Paused };
        return Task.CompletedTask;
    }

    public Task ResumeRebalanceAsync(string jobId, CancellationToken ct = default)
    {
        if (_jobs.TryGetValue(jobId, out var job))
            _jobs[jobId] = job with { Status = RebalanceStatus.Running };
        return Task.CompletedTask;
    }

    public Task CancelRebalanceAsync(string jobId, CancellationToken ct = default)
    {
        if (_jobs.TryGetValue(jobId, out var job))
            _jobs[jobId] = job with { Status = RebalanceStatus.Failed };
        return Task.CompletedTask;
    }

    public Task<RebalanceJob> GetStatusAsync(string jobId, CancellationToken ct = default)
    {
        if (_jobs.TryGetValue(jobId, out var job))
            return Task.FromResult(job);
        throw new KeyNotFoundException($"Rebalance job {jobId} not found.");
    }

    public Task<IReadOnlyList<RebalanceJob>> ListJobsAsync(CancellationToken ct = default)
    {
        return Task.FromResult<IReadOnlyList<RebalanceJob>>(_jobs.Values.ToList());
    }

    public async IAsyncEnumerable<RebalanceJob> MonitorAsync(
        string jobId, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
    {
        while (!ct.IsCancellationRequested)
        {
            if (_jobs.TryGetValue(jobId, out var job))
            {
                yield return job;
                if (job.Status is RebalanceStatus.Completed or RebalanceStatus.Failed)
                    yield break;
            }
            else yield break;
            await Task.Delay(1000, ct);
        }
    }

    private async Task CheckAndRebalanceAsync(CancellationToken ct)
    {
        if (Interlocked.CompareExchange(ref _isRunning, 1, 0) != 0)
            return; // Already running

        try
        {
            // Quiet hours check
            if (_options.QuietHours.HasValue)
            {
                int currentHour = DateTime.UtcNow.Hour;
                var (start, end) = _options.QuietHours.Value;
                if (start <= end ? (currentHour >= start && currentHour < end) : (currentHour >= start || currentHour < end))
                    return;
            }

            if (ClusterMapProvider == null || ObjectEnumeratorByNode == null)
                return;

            var clusterMap = await ClusterMapProvider(ct);
            if (clusterMap.Count < 2) return;

            // Calculate imbalance
            double totalCapacity = clusterMap.Sum(n => (double)n.CapacityBytes);
            if (totalCapacity == 0) return;

            double maxUsageRatio = clusterMap.Max(n => n.CapacityBytes > 0 ? (double)n.UsedBytes / n.CapacityBytes : 0);
            double minUsageRatio = clusterMap.Min(n => n.CapacityBytes > 0 ? (double)n.UsedBytes / n.CapacityBytes : 0);
            double imbalance = maxUsageRatio - minUsageRatio;

            if (imbalance < _options.ImbalanceThreshold)
                return; // Cluster is balanced

            // Generate and execute rebalance plan
            var rebalanceOptions = new RebalanceOptions
            {
                MaxMoves = _options.MaxMovesPerCycle,
                MaxEgressBytes = _options.MaxEgressBytesPerCycle,
                MaxCostBudget = _options.MaxCostPerCycle,
                MinGravityThreshold = _options.GravityProtectionThreshold,
                DryRun = false
            };

            var plan = await _optimizer.GenerateRebalancePlanAsync(clusterMap, rebalanceOptions, ct);
            if (plan.Moves.Count > 0)
            {
                await StartRebalanceAsync(plan, ct);
            }
        }
        finally
        {
            Interlocked.Exchange(ref _isRunning, 0);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (!_disposed)
        {
            _disposed = true;
            await _monitorTimer.DisposeAsync();
        }
    }
}
```
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>AutonomousRebalancer compiles, implements IRebalancer. Has continuous monitoring, imbalance detection, gravity-aware plan generation, migration execution. Pause/resume/cancel lifecycle works. Quiet hours supported.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds
- AutonomousRebalancer implements all 7 IRebalancer methods
- Uses IPlacementOptimizer for plan generation and IMigrationEngine for execution
- Imbalance threshold and gravity protection threshold respected
</verification>

<success_criteria>
Autonomous rebalancer continuously monitors cluster balance and triggers gravity-aware migrations. Respects quiet hours, cost budgets, and gravity protection thresholds. Migration lifecycle (start/pause/resume/cancel/monitor) fully functional.
</success_criteria>

<output>
After completion, create `.planning/phases/58-zero-gravity-storage/58-08-SUMMARY.md`
</output>
