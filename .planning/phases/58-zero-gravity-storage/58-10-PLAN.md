---
phase: 58-zero-gravity-storage
plan: 10
type: execute
wave: 3
depends_on: ["58-04", "58-05", "58-06", "58-07", "58-08"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityStorageStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityStorageOptions.cs
autonomous: true

must_haves:
  truths:
    - "Zero-gravity strategy is accessible through the existing UltimateStorage plugin"
    - "Strategy wires CRUSH, gravity optimizer, rebalancer, and migration engine together"
    - "Strategy follows SDK base class pattern (extends StorageStrategyBase or equivalent)"
    - "Plugin references only SDK types (no cross-plugin references)"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityStorageStrategy.cs"
      provides: "UltimateStorage strategy integrating all zero-gravity components"
      exports: ["ZeroGravityStorageStrategy"]
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityStorageOptions.cs"
      provides: "Configuration options for zero-gravity storage"
      exports: ["ZeroGravityStorageOptions"]
  key_links:
    - from: "ZeroGravityStorageStrategy"
      to: "CrushPlacementAlgorithm"
      via: "computes placement for store operations"
      pattern: "CrushPlacementAlgorithm"
    - from: "ZeroGravityStorageStrategy"
      to: "AutonomousRebalancer"
      via: "starts rebalancer as background service"
      pattern: "AutonomousRebalancer"
    - from: "ZeroGravityStorageStrategy"
      to: "BackgroundMigrationEngine"
      via: "provides migration capability for rebalancer"
      pattern: "BackgroundMigrationEngine"
---

<objective>
Create the UltimateStorage plugin strategy that integrates all zero-gravity components (CRUSH, gravity optimizer, rebalancer, migration engine, billing, cost optimizer) into a single cohesive strategy accessible through the existing plugin system.

Purpose: All SDK-level components built in Plans 01-09 need a plugin-level entry point. This strategy is how the DataWarehouse kernel activates zero-gravity storage — registered via the existing UltimateStorage plugin infrastructure.
Output: ZeroGravityStorageStrategy + ZeroGravityStorageOptions in UltimateStorage plugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PLUGIN-CATALOG.md
@.planning/phases/58-zero-gravity-storage/58-04-SUMMARY.md
@.planning/phases/58-zero-gravity-storage/58-05-SUMMARY.md
@.planning/phases/58-zero-gravity-storage/58-06-SUMMARY.md
@.planning/phases/58-zero-gravity-storage/58-07-SUMMARY.md
@.planning/phases/58-zero-gravity-storage/58-08-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateStorage/UltimateStoragePlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateStorage/Features/CostBasedSelectionFeature.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ZeroGravityStorageOptions</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityStorageOptions.cs</files>
  <action>
Create `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/` directory.

Create ZeroGravityStorageOptions.cs — namespace `DataWarehouse.Plugins.UltimateStorage.Strategies.ZeroGravity`:

```csharp
using DataWarehouse.SDK.Storage.Placement;
using DataWarehouse.SDK.Storage.Billing;

/// Configuration for the zero-gravity storage strategy.
public sealed record ZeroGravityStorageOptions
{
    /// Enable autonomous rebalancing.
    public bool EnableRebalancing { get; init; } = true;

    /// Enable cost optimization recommendations.
    public bool EnableCostOptimization { get; init; } = true;

    /// Enable billing API integration (requires cloud credentials).
    public bool EnableBillingIntegration { get; init; } = false;

    /// Rebalancer behavior configuration.
    public RebalancerOptions RebalancerOptions { get; init; } = RebalancerOptions.Default;

    /// Gravity scoring weights.
    public GravityScoringWeights GravityWeights { get; init; } = GravityScoringWeights.Default;

    /// CRUSH stripe count for write parallelism.
    public int CrushStripeCount { get; init; } = 64;

    /// Default replica count for stored objects.
    public int DefaultReplicaCount { get; init; } = 3;

    /// Migration checkpoint directory.
    public string CheckpointDirectory { get; init; } = Path.Combine(Path.GetTempPath(), "dw-migration-checkpoints");

    /// Cost optimizer thresholds.
    public StorageCostOptimizerOptions CostOptimizerOptions { get; init; } = new();

    /// Message bus topic for rebalance events.
    public string RebalanceEventTopic { get; init; } = "storage.zerogravity.rebalance";

    /// Message bus topic for cost optimization events.
    public string CostEventTopic { get; init; } = "storage.zerogravity.cost";
}
```
  </action>
  <verify>dotnet build "Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj" --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>ZeroGravityStorageOptions compiles with all configuration knobs for rebalancing, cost optimization, billing, and message bus topics.</done>
</task>

<task type="auto">
  <name>Task 2: ZeroGravityStorageStrategy</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/ZeroGravity/ZeroGravityStorageStrategy.cs</files>
  <action>
Create ZeroGravityStorageStrategy.cs — namespace `DataWarehouse.Plugins.UltimateStorage.Strategies.ZeroGravity`.

Look at how existing strategies in UltimateStorage are structured (check the plugin's base class and strategy registration pattern). The strategy should extend the appropriate base class from the SDK.

```csharp
using DataWarehouse.SDK.Storage.Placement;
using DataWarehouse.SDK.Storage.Billing;
using DataWarehouse.SDK.Storage.Migration;
using System.Collections.Concurrent;

/// Zero-Gravity Storage Strategy — eliminates data gravity through deterministic placement,
/// autonomous rebalancing, and cost-aware optimization.
///
/// This strategy integrates:
/// - CRUSH deterministic placement (no central lookup)
/// - Gravity-aware placement optimization (multi-dimensional scoring)
/// - Autonomous rebalancer (continuous background optimization)
/// - Background migration engine (zero-downtime data movement)
/// - Billing API integration (AWS/Azure/GCP cost visibility)
/// - Cost optimizer (spot/reserved/tier/arbitrage recommendations)
///
/// Registered as strategy "zero-gravity" in UltimateStorage plugin.
public sealed class ZeroGravityStorageStrategy : StorageStrategyBase
{
    private readonly ZeroGravityStorageOptions _options;
    private CrushPlacementAlgorithm? _crushAlgorithm;
    private GravityAwarePlacementOptimizer? _gravityOptimizer;
    private AutonomousRebalancer? _rebalancer;
    private BackgroundMigrationEngine? _migrationEngine;
    private ReadForwardingTable? _forwardingTable;
    private StorageCostOptimizer? _costOptimizer;
    private IReadOnlyList<NodeDescriptor>? _clusterMap;

    public override string StrategyId => "zero-gravity";
    public override string StrategyName => "Zero-Gravity Storage";
    public override string Category => "ZeroGravity";

    public ZeroGravityStorageStrategy() : this(new ZeroGravityStorageOptions()) { }

    public ZeroGravityStorageStrategy(ZeroGravityStorageOptions options)
    {
        _options = options ?? throw new ArgumentNullException(nameof(options));
    }

    // Override whatever initialization method the base class provides (InitializeAsync or similar)
    // Initialize all subsystems
    public async Task InitializeSubsystemsAsync(
        IReadOnlyList<NodeDescriptor> clusterMap,
        IReadOnlyList<IBillingProvider>? billingProviders = null,
        CancellationToken ct = default)
    {
        _clusterMap = clusterMap;
        _crushAlgorithm = new CrushPlacementAlgorithm();

        _gravityOptimizer = new GravityAwarePlacementOptimizer(
            _crushAlgorithm,
            _options.GravityWeights);

        _forwardingTable = new ReadForwardingTable();
        var checkpointStore = new MigrationCheckpointStore(_options.CheckpointDirectory);
        _migrationEngine = new BackgroundMigrationEngine(_forwardingTable, checkpointStore);

        if (_options.EnableRebalancing)
        {
            _rebalancer = new AutonomousRebalancer(
                _crushAlgorithm,
                _gravityOptimizer,
                _migrationEngine,
                _options.RebalancerOptions);
        }

        if (_options.EnableCostOptimization && billingProviders != null && billingProviders.Count > 0)
        {
            _costOptimizer = new StorageCostOptimizer(billingProviders, _options.CostOptimizerOptions);
        }
    }

    /// Compute deterministic placement for an object.
    public PlacementDecision ComputePlacement(string objectKey, long objectSize)
    {
        if (_crushAlgorithm == null || _clusterMap == null)
            throw new InvalidOperationException("Zero-gravity storage not initialized. Call InitializeSubsystemsAsync first.");

        var target = new PlacementTarget
        {
            ObjectKey = objectKey,
            ObjectSize = objectSize,
            ReplicaCount = _options.DefaultReplicaCount
        };

        return _crushAlgorithm.ComputePlacement(target, _clusterMap);
    }

    /// Compute gravity-aware placement.
    public async Task<PlacementDecision> ComputeGravityAwarePlacementAsync(
        string objectKey, long objectSize, CancellationToken ct = default)
    {
        if (_gravityOptimizer == null || _clusterMap == null)
            throw new InvalidOperationException("Zero-gravity storage not initialized.");

        var gravity = await _gravityOptimizer.ComputeGravityAsync(objectKey, ct);

        var target = new PlacementTarget
        {
            ObjectKey = objectKey,
            ObjectSize = objectSize,
            ReplicaCount = _options.DefaultReplicaCount
        };

        return await _gravityOptimizer.OptimizePlacementAsync(target, _clusterMap, gravity, ct);
    }

    /// Check if a read should be forwarded (object is being migrated).
    public ReadForwardingEntry? CheckForwarding(string objectKey)
    {
        return _forwardingTable?.Lookup(objectKey);
    }

    /// Get cost optimization recommendations.
    public async Task<OptimizationPlan?> GetCostOptimizationPlanAsync(CancellationToken ct = default)
    {
        return _costOptimizer != null
            ? await _costOptimizer.GenerateOptimizationPlanAsync(ct)
            : null;
    }

    /// Get rebalancer status.
    public IRebalancer? Rebalancer => _rebalancer;

    /// Get migration engine.
    public IMigrationEngine? MigrationEngine => _migrationEngine;

    // Override the characteristics/capabilities method if the base class has one
    // This provides metadata about the strategy to the plugin system
}
```

IMPORTANT: Check the actual base class pattern in UltimateStorage. Look at:
1. `StorageStrategyBase` — what abstract/virtual members must be overridden
2. How other strategies in UltimateStorage register themselves
3. The plugin's strategy registration mechanism

Adapt the class to match exactly. If StorageStrategyBase requires specific overrides (like `ExecuteAsync`, `GetCharacteristics`, etc.), implement them. The key requirement is that this strategy integrates naturally with the existing plugin infrastructure — don't invent new patterns.
  </action>
  <verify>dotnet build "Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj" --no-restore --verbosity quiet 2>&1 | tail -3</verify>
  <done>ZeroGravityStorageStrategy compiles in UltimateStorage plugin. Integrates CRUSH, gravity optimizer, rebalancer, migration engine, billing, and cost optimizer. Follows existing plugin strategy patterns.</done>
</task>

</tasks>

<verification>
- Plugin builds: `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj` succeeds
- Strategy references only SDK types
- Strategy ID is "zero-gravity"
- All subsystems wired in InitializeSubsystemsAsync
</verification>

<success_criteria>
Zero-gravity storage strategy is accessible through UltimateStorage plugin system. Integrates all Phase 58 components. Follows existing plugin conventions.
</success_criteria>

<output>
After completion, create `.planning/phases/58-zero-gravity-storage/58-10-SUMMARY.md`
</output>
