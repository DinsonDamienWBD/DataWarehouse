---
phase: 13-data-governance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/LivingCatalog/LivingCatalogStrategies.cs
  - Metadata/TODO.md
autonomous: true
must_haves:
  truths:
    - "5 living catalog strategies (B2.1-B2.5) compile and are discoverable by DataCatalogStrategyRegistry"
    - "Each strategy extends DataCatalogStrategyBase with unique StrategyId and production-ready metadata"
    - "SelfLearningCatalogStrategy provides feedback-loop learning that improves catalog accuracy over time"
    - "AutoTaggingStrategy assigns tags using keyword extraction and frequency analysis"
    - "RelationshipDiscoveryStrategy discovers hidden relationships via column name and value pattern matching"
    - "SchemaEvolutionTrackerStrategy tracks schema versions with diff detection"
    - "UsagePatternLearnerStrategy learns from access patterns to rank and recommend data assets"
    - "TODO.md sub-tasks 146.B2.1-146.B2.5 are marked [x]"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/LivingCatalog/LivingCatalogStrategies.cs"
      provides: "5 sealed strategy classes extending DataCatalogStrategyBase"
      contains: "SelfLearningCatalogStrategy"
  key_links:
    - from: "LivingCatalogStrategies.cs"
      to: "DataCatalogStrategyBase"
      via: "class inheritance"
      pattern: "DataCatalogStrategyBase"
    - from: "LivingCatalogStrategies.cs"
      to: "DataCatalogStrategyRegistry"
      via: "auto-discovery from assembly"
      pattern: "sealed class.*: DataCatalogStrategyBase"
---

<objective>
Implement 5 Living Catalog strategies (T146.B2.1-B2.5) in UltimateDataCatalog plugin.

Purpose: These AI-native catalog strategies provide industry-first capabilities where the catalog learns from usage, auto-tags assets, discovers hidden relationships, tracks schema evolution, and learns usage patterns -- all without explicit human configuration.

Output: LivingCatalogStrategies.cs with 5 production-ready sealed strategy classes in a new LivingCatalog subfolder.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-data-governance/13-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataCatalogStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/AssetDiscoveryStrategies.cs
@Metadata/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 5 Living Catalog strategies in LivingCatalogStrategies.cs</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/LivingCatalog/LivingCatalogStrategies.cs</files>
  <action>
Create directory `Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/LivingCatalog/` and file `LivingCatalogStrategies.cs` with namespace `DataWarehouse.Plugins.UltimateDataCatalog.Strategies.LivingCatalog`.

The existing catalog strategies are metadata-only (properties, no method implementations beyond base class). Follow same pattern: each strategy defines StrategyId, DisplayName, Category, Capabilities, SemanticDescription, Tags. BUT these living catalog strategies also include public methods for their domain-specific operations (the strategies serve as API surfaces).

**Strategy 1: SelfLearningCatalogStrategy**
- StrategyId: `"living-self-learning"`
- DisplayName: `"Self-Learning Catalog"`
- Category: `DataCatalogCategory.AssetDiscovery`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=true, SupportsFederation=true, SupportsVersioning=true, SupportsMultiTenancy=true, MaxEntries=0
- SemanticDescription: "Self-learning catalog that improves continuously by analyzing feedback, corrections, and usage patterns to refine asset metadata, descriptions, and classifications."
- Tags: `["self-learning", "feedback", "continuous-improvement", "ai-native", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, CatalogEntry> _entries`, `ConcurrentDictionary<string, List<FeedbackRecord>> _feedback`, `ConcurrentDictionary<string, double> _confidenceScores`
- Define internal records: `CatalogEntry(string AssetId, string Name, string Description, Dictionary<string, string> Metadata, DateTimeOffset LastUpdated, int Version)`, `FeedbackRecord(string FeedbackId, string AssetId, string FieldName, string OriginalValue, string CorrectedValue, DateTimeOffset Timestamp)`
- Public methods:
  - `RegisterAsset(string assetId, string name, string description, Dictionary<string, string>? metadata)` -> adds to _entries
  - `RecordFeedback(string assetId, string fieldName, string originalValue, string correctedValue)` -> records correction feedback
  - `ApplyLearning(string assetId)` -> examines feedback for the asset, if field was corrected more than 2 times, auto-update the entry's metadata with the most common corrected value, increment version, update confidence score
  - `GetConfidence(string assetId)` -> returns confidence score (0.0 to 1.0), starts at 0.5, increases by 0.05 per applied correction, decreases by 0.1 per new feedback (needs correction)

**Strategy 2: AutoTaggingStrategy**
- StrategyId: `"living-auto-tagging"`
- DisplayName: `"AI Auto-Tagging"`
- Category: `DataCatalogCategory.SearchDiscovery`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=true, SupportsFederation=false, SupportsVersioning=false, SupportsMultiTenancy=true, MaxEntries=0
- SemanticDescription: "AI-powered auto-tagging that assigns meaningful tags to data assets by analyzing column names, data samples, descriptions, and naming patterns."
- Tags: `["auto-tagging", "classification", "metadata-enrichment", "nlp", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, HashSet<string>> _assetTags`
- Public methods:
  - `GenerateTags(string assetId, string name, string description, IReadOnlyList<string> columnNames)` -> analyzes name (split on spaces/underscores/camelCase), description (extract capitalized phrases, domain keywords), columnNames (detect patterns like "email" -> "pii", "price"/"amount" -> "financial", "created_at" -> "temporal", "lat"/"lng" -> "geospatial"). Return generated tag set. Store in _assetTags.
  - `GetTags(string assetId)` -> returns current tags
  - Define a private method `InferDomainTags(IReadOnlyList<string> columnNames)` that maps known patterns: column contains "email"|"phone"|"ssn"|"name" -> "pii"; "price"|"amount"|"currency"|"balance" -> "financial"; "lat"|"lon"|"longitude"|"latitude"|"geo" -> "geospatial"; "date"|"time"|"timestamp"|"created"|"updated" -> "temporal"; "id"|"key"|"uuid" -> "identifier"; "status"|"state"|"flag" -> "categorical"

**Strategy 3: RelationshipDiscoveryStrategy**
- StrategyId: `"living-relationship-discovery"`
- DisplayName: `"Relationship Discovery"`
- Category: `DataCatalogCategory.DataRelationships`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=false, SupportsFederation=true, SupportsVersioning=false, SupportsMultiTenancy=true, MaxEntries=0
- SemanticDescription: "Discovers hidden relationships between data assets by analyzing column name overlap, naming patterns (e.g., user_id across tables), and value distribution similarity."
- Tags: `["relationship-discovery", "hidden-links", "pattern-matching", "cross-reference", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, HashSet<string>> _assetColumns` mapping assetId to column names, `ConcurrentDictionary<string, List<DiscoveredRelationship>> _relationships`
- Define internal record `DiscoveredRelationship(string SourceAssetId, string TargetAssetId, string SourceColumn, string TargetColumn, double Confidence, string RelationshipType)`
- Public methods:
  - `RegisterColumns(string assetId, IReadOnlyList<string> columnNames)` -> stores in _assetColumns
  - `DiscoverRelationships(string assetId)` -> for the given asset, compare its columns against all other registered assets. For each pair of columns: exact name match = 1.0 confidence "foreign_key"; suffix match (e.g., "user_id" matches "user_id" in another table) = 0.9 "foreign_key"; prefix match after stripping _id suffix = 0.7 "reference"; Jaccard similarity of column name tokens > 0.5 = confidence * 0.6 "derived". Return list of DiscoveredRelationship.

**Strategy 4: SchemaEvolutionTrackerStrategy**
- StrategyId: `"living-schema-evolution"`
- DisplayName: `"Schema Evolution Tracker"`
- Category: `DataCatalogCategory.SchemaRegistry`
- Capabilities: SupportsAsync=true, SupportsBatch=false, SupportsRealTime=true, SupportsFederation=false, SupportsVersioning=true, SupportsMultiTenancy=true, MaxEntries=0
- SemanticDescription: "Tracks schema changes over time, detecting column additions, removals, type changes, and renames. Maintains full version history with diff analysis."
- Tags: `["schema-evolution", "version-tracking", "diff-analysis", "change-detection", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, List<SchemaVersion>> _schemaHistory`
- Define internal records: `SchemaVersion(int Version, Dictionary<string, string> Columns, DateTimeOffset CapturedAt)`, `SchemaDiff(int FromVersion, int ToVersion, IReadOnlyList<string> AddedColumns, IReadOnlyList<string> RemovedColumns, IReadOnlyList<string> TypeChangedColumns)`
- Public methods:
  - `RecordSchema(string assetId, Dictionary<string, string> columns)` -> compare against latest version. If different (columns added/removed/type changed), add new SchemaVersion with incremented version number.
  - `GetHistory(string assetId)` -> return all schema versions
  - `ComputeDiff(string assetId, int fromVersion, int toVersion)` -> compute SchemaDiff between two versions: added = keys in toVersion not in fromVersion, removed = keys in fromVersion not in toVersion, typeChanged = keys in both but different values

**Strategy 5: UsagePatternLearnerStrategy**
- StrategyId: `"living-usage-learner"`
- DisplayName: `"Usage Pattern Learner"`
- Category: `DataCatalogCategory.SearchDiscovery`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=true, SupportsFederation=false, SupportsVersioning=false, SupportsMultiTenancy=true, MaxEntries=0
- SemanticDescription: "Learns from how data assets are accessed, queried, and consumed. Builds usage profiles to rank assets by popularity, identify frequently co-accessed datasets, and recommend related assets."
- Tags: `["usage-patterns", "access-tracking", "recommendation", "popularity-ranking", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, UsageProfile> _profiles`, `ConcurrentDictionary<string, ConcurrentDictionary<string, int>> _coAccess`
- Define internal class `UsageProfile` with: `long AccessCount`, `long QueryCount`, `DateTimeOffset LastAccessed`, `DateTimeOffset FirstAccessed`, `ConcurrentDictionary<string, int> AccessorCounts` (who accesses), `ConcurrentDictionary<string, int> OperationCounts` (read/write/query)
- Public methods:
  - `RecordAccess(string assetId, string actorId, string operationType)` -> update profile (increment counters, track last/first accessed, record actor, record operation type)
  - `RecordCoAccess(string assetId1, string assetId2)` -> increment co-access counter for both directions
  - `GetPopularAssets(int topK)` -> return top K assets by AccessCount
  - `GetRecommendations(string assetId, int topK)` -> return top K co-accessed assets sorted by co-access count
  - `GetUsageProfile(string assetId)` -> return the UsageProfile or null

All classes MUST be `sealed`. All must have XML `<summary>` and `<remarks>` docs referencing T146.B2.N. No TODO comments, no stubs.
  </action>
  <verify>Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj` -- must compile with zero errors.</verify>
  <done>5 sealed strategy classes exist in LivingCatalogStrategies.cs, all extending DataCatalogStrategyBase with real feedback learning, keyword extraction, column matching, schema diffing, and usage tracking. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Mark T146.B2 sub-tasks complete in TODO.md</name>
  <files>Metadata/TODO.md</files>
  <action>
In Metadata/TODO.md, find the T146 Phase B table (around line 15948-15952) and change the status of B2.1 through B2.5 from `[ ]` to `[x]`:

- Line with `146.B2.1` SelfLearningCatalogStrategy -> `[x]`
- Line with `146.B2.2` AutoTaggingStrategy -> `[x]`
- Line with `146.B2.3` RelationshipDiscoveryStrategy -> `[x]`
- Line with `146.B2.4` SchemaEvolutionTrackerStrategy -> `[x]`
- Line with `146.B2.5` UsagePatternLearnerStrategy -> `[x]`

Do NOT modify any other lines.
  </action>
  <verify>Grep for `146.B2` in TODO.md and confirm all 5 lines show `[x]`.</verify>
  <done>All 5 T146.B2 sub-tasks marked [x] in TODO.md.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj` passes with zero errors
- LivingCatalogStrategies.cs contains exactly 5 sealed classes extending DataCatalogStrategyBase
- Each class has unique StrategyId starting with "living-"
- No forbidden patterns: no TODO comments, no "simulation", no "mock", no "stub"
- All 5 T146.B2 sub-tasks marked [x] in TODO.md
</verification>

<success_criteria>
5 living catalog strategies compile, implement real feedback learning, keyword-based auto-tagging, column-name relationship discovery, schema version diff tracking, and usage profile analytics. All sub-tasks marked complete.
</success_criteria>

<output>
After completion, create `.planning/phases/13-data-governance/13-02-SUMMARY.md`
</output>
