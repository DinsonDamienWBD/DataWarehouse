---
phase: 13-data-governance
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/IntelligentGovernanceStrategies.cs
  - Metadata/TODO.md
autonomous: true
must_haves:
  truths:
    - "4 intelligent governance strategies (B5.1-B5.4) compile and are discoverable by DataGovernanceStrategyRegistry"
    - "Each strategy extends DataGovernanceStrategyBase with unique StrategyId and production-ready implementations"
    - "PolicyRecommendationStrategy recommends governance policies based on data pattern analysis and compliance rule matching"
    - "ComplianceGapDetectorStrategy identifies compliance gaps by comparing data handling practices against registered framework requirements"
    - "SensitivityClassifierStrategy auto-classifies data sensitivity using regex pattern detection for PII, PHI, PCI, and confidential data"
    - "RetentionOptimizerStrategy optimizes retention periods based on value scoring, access frequency, and regulatory minimums"
    - "TODO.md sub-tasks 146.B5.1-146.B5.4 are marked [x]"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/IntelligentGovernanceStrategies.cs"
      provides: "4 sealed strategy classes extending DataGovernanceStrategyBase"
      contains: "PolicyRecommendationStrategy"
  key_links:
    - from: "IntelligentGovernanceStrategies.cs"
      to: "DataGovernanceStrategyBase"
      via: "class inheritance"
      pattern: "DataGovernanceStrategyBase"
    - from: "IntelligentGovernanceStrategies.cs"
      to: "DataGovernanceStrategyRegistry"
      via: "auto-discovery from assembly"
      pattern: "sealed class.*: DataGovernanceStrategyBase"
---

<objective>
Implement 4 Intelligent Governance strategies (T146.B5.1-B5.4) in UltimateDataGovernance plugin.

Purpose: These AI-native governance strategies provide capabilities for automatically recommending policies, detecting compliance gaps, classifying data sensitivity, and optimizing retention -- reducing manual governance effort while improving coverage and accuracy.

Output: IntelligentGovernanceStrategies.cs with 4 production-ready sealed strategy classes in a new IntelligentGovernance subfolder.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-data-governance/13-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataGovernanceStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/PolicyManagement/PolicyManagementStrategies.cs
@Metadata/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 4 Intelligent Governance strategies in IntelligentGovernanceStrategies.cs</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/IntelligentGovernanceStrategies.cs</files>
  <action>
Create directory `Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/` and file `IntelligentGovernanceStrategies.cs` with namespace `DataWarehouse.Plugins.UltimateDataGovernance.Strategies.IntelligentGovernance`.

Use `using System.Collections.Concurrent;`, `using System.Text.RegularExpressions;`. Each strategy extends `DataGovernanceStrategyBase` which provides: StrategyId, DisplayName, Category (GovernanceCategory), Capabilities (DataGovernanceCapabilities), SemanticDescription, Tags.

**Strategy 1: PolicyRecommendationStrategy**
- StrategyId: `"intelligent-policy-recommendation"`
- DisplayName: `"AI Policy Recommendation"`
- Category: `GovernanceCategory.PolicyManagement`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=true, SupportsAudit=true, SupportsVersioning=true
- SemanticDescription: "AI-powered policy recommendation engine that analyzes data characteristics, sensitivity classifications, and compliance requirements to automatically recommend appropriate governance policies."
- Tags: `["ai", "recommendation", "policy", "automated-governance", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, DataProfile> _dataProfiles`, `ConcurrentDictionary<string, PolicyTemplate> _policyTemplates`
- Define internal records:
  - `DataProfile(string DataId, string DataType, IReadOnlyList<string> SensitivityLabels, IReadOnlyList<string> ComplianceFrameworks, double RiskScore, Dictionary<string, string> Attributes)`
  - `PolicyTemplate(string TemplateId, string PolicyName, string Description, IReadOnlyList<string> ApplicableSensitivities, IReadOnlyList<string> ApplicableFrameworks, int Priority)`
  - `PolicyRecommendation(string TemplateId, string PolicyName, string Reason, double Confidence, int Priority)`
  - `RecommendationReport(string DataId, IReadOnlyList<PolicyRecommendation> Recommendations, DateTimeOffset GeneratedAt)`
- Public methods:
  - `RegisterDataProfile(string dataId, string dataType, IReadOnlyList<string> sensitivityLabels, IReadOnlyList<string> complianceFrameworks, double riskScore, Dictionary<string, string>? attributes = null)` -> stores in _dataProfiles
  - `RegisterPolicyTemplate(string templateId, string policyName, string description, IReadOnlyList<string> applicableSensitivities, IReadOnlyList<string> applicableFrameworks, int priority = 0)` -> stores in _policyTemplates
  - `RecommendPolicies(string dataId)` -> retrieve data profile. For each policy template: compute match score = (sensitivity overlap count / max(1, template sensitivity count)) * 0.5 + (framework overlap count / max(1, template framework count)) * 0.3 + (riskScore > 0.7 ? 0.2 : riskScore > 0.4 ? 0.1 : 0.0). If matchScore > 0.3, include in recommendations. Confidence = matchScore. Reason = describe which sensitivities and frameworks matched. Return RecommendationReport sorted by priority desc then confidence desc.
  - Seed default policy templates in constructor: "encryption-at-rest" (for sensitivity: "pii", "phi", "pci"; frameworks: "gdpr", "hipaa", "pci-dss"), "access-logging" (all sensitivities, all frameworks), "data-masking" (for "pii", "phi"), "retention-limit" (for "gdpr", "ccpa"), "cross-border-restriction" (for "gdpr", "pipl")

**Strategy 2: ComplianceGapDetectorStrategy**
- StrategyId: `"intelligent-compliance-gap"`
- DisplayName: `"Compliance Gap Detector"`
- Category: `GovernanceCategory.RegulatoryCompliance`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=false, SupportsAudit=true, SupportsVersioning=true
- SemanticDescription: "Automatically identifies compliance gaps by comparing actual data handling practices against registered regulatory framework requirements, highlighting areas needing remediation."
- Tags: `["compliance-gap", "regulatory", "remediation", "audit", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, FrameworkRequirements> _frameworks`, `ConcurrentDictionary<string, DataHandlingPractice> _practices`
- Define internal records:
  - `FrameworkRequirements(string FrameworkId, string Name, ConcurrentDictionary<string, Requirement> Requirements)` where `Requirement(string RequirementId, string Description, string Category, bool IsMandatory)`
  - `DataHandlingPractice(string DataId, HashSet<string> ImplementedControls)` (set of requirement IDs that are satisfied)
  - `ComplianceGap(string FrameworkId, string RequirementId, string Description, string Category, bool IsMandatory, string Severity)`
  - `GapReport(string DataId, IReadOnlyList<ComplianceGap> Gaps, int TotalRequirements, int SatisfiedRequirements, double ComplianceScore, DateTimeOffset AnalyzedAt)`
- Public methods:
  - `RegisterFramework(string frameworkId, string name, Dictionary<string, Requirement> requirements)` -> stores in _frameworks
  - `RegisterPractice(string dataId, IReadOnlyList<string> implementedControls)` -> stores in _practices
  - `DetectGaps(string dataId, string frameworkId)` -> retrieve practice and framework. For each requirement in framework, check if requirementId is in implementedControls. If not, create ComplianceGap. Severity = "Critical" if IsMandatory, "Warning" if not. ComplianceScore = satisfiedCount / totalCount. Return GapReport.
  - `DetectAllGaps(string dataId)` -> run DetectGaps against every registered framework, return aggregated list of GapReport
  - Seed default frameworks in constructor: "gdpr" with 5 requirements (consent-management, data-minimization, right-to-erasure, breach-notification, dpa-appointment), "hipaa" with 5 requirements (access-control, audit-logging, encryption-transit, encryption-rest, minimum-necessary), "pci-dss" with 4 requirements (encryption-cardholder, access-restriction, logging-monitoring, vulnerability-scanning)

**Strategy 3: SensitivityClassifierStrategy**
- StrategyId: `"intelligent-sensitivity-classifier"`
- DisplayName: `"Sensitivity Auto-Classifier"`
- Category: `GovernanceCategory.DataClassification`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=true, SupportsAudit=true, SupportsVersioning=false
- SemanticDescription: "Automatically classifies data sensitivity levels using regex pattern detection for PII, PHI, PCI, and confidential data, with configurable classification rules and confidence scoring."
- Tags: `["sensitivity", "classification", "pii-detection", "auto-classify", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, List<ClassificationRule>> _rules`
- Define internal records:
  - `ClassificationRule(string RuleId, string SensitivityLevel, string Pattern, string Description, double Weight)` where Pattern is a regex
  - `ClassificationResult(string DataId, string OverallSensitivity, IReadOnlyList<DetectedPattern> Detections, double ConfidenceScore, DateTimeOffset ClassifiedAt)`
  - `DetectedPattern(string RuleId, string SensitivityLevel, string MatchedValue, int MatchCount, string Description)`
- Public methods:
  - `AddRule(string ruleId, string sensitivityLevel, string regexPattern, string description, double weight = 1.0)` -> add to _rules under sensitivityLevel key
  - `Classify(string dataId, string content)` -> run all rules against content. For each rule, count regex matches. If matches > 0, create DetectedPattern. OverallSensitivity = highest sensitivity level found (ordering: "public" < "internal" < "confidential" < "restricted" < "top-secret"). ConfidenceScore = min(1.0, totalMatchWeight / 10.0) where totalMatchWeight = sum of (matchCount * rule.Weight). Return ClassificationResult.
  - `ClassifyColumns(string dataId, Dictionary<string, string[]> columnSamples)` -> for each column, concatenate sample values, run Classify on concatenated content. Return dictionary of columnName to ClassificationResult.
  - Seed default rules in constructor:
    - "restricted" level: email pattern `\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b` weight 2.0, SSN pattern `\b\d{3}-\d{2}-\d{4}\b` weight 3.0, credit card `\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b` weight 3.0, phone `\b\d{3}[-.]?\d{3}[-.]?\d{4}\b` weight 1.5
    - "confidential" level: date of birth `\b\d{4}-\d{2}-\d{2}\b` weight 1.0, medical codes `\b[A-Z]\d{2}\.?\d{0,2}\b` (ICD-10 pattern) weight 2.0, salary/compensation keywords `\b(?:salary|compensation|wage|bonus)\b` weight 1.5
    - "internal" level: internal ID patterns `\b(?:emp|usr|cust)[-_]?\d{4,}\b` weight 0.5, IP addresses `\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b` weight 1.0

**Strategy 4: RetentionOptimizerStrategy**
- StrategyId: `"intelligent-retention-optimizer"`
- DisplayName: `"Retention Optimizer"`
- Category: `GovernanceCategory.RetentionManagement`
- Capabilities: SupportsAsync=true, SupportsBatch=true, SupportsRealTime=false, SupportsAudit=true, SupportsVersioning=true
- SemanticDescription: "Optimizes data retention periods based on value scoring (access frequency, business criticality), regulatory minimums, and storage cost analysis to recommend when data should be archived or deleted."
- Tags: `["retention", "optimization", "cost-analysis", "lifecycle", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, DataRetentionProfile> _profiles`, `ConcurrentDictionary<string, RegulatoryMinimum> _regulatoryMinimums`
- Define internal records:
  - `DataRetentionProfile(string DataId, DateTimeOffset CreatedAt, DateTimeOffset LastAccessed, long AccessCount, double BusinessCriticalityScore, IReadOnlyList<string> ComplianceFrameworks, double StorageCostPerMonthUsd)`
  - `RegulatoryMinimum(string FrameworkId, TimeSpan MinRetention, string Reason)`
  - `RetentionRecommendation(string DataId, TimeSpan RecommendedRetention, TimeSpan RegulatoryMinimum, string Action, double ValueScore, double CostSavingsPerMonthUsd, string Rationale)`
- Public methods:
  - `RegisterProfile(string dataId, DateTimeOffset createdAt, DateTimeOffset lastAccessed, long accessCount, double businessCriticality, IReadOnlyList<string> frameworks, double storageCostPerMonth)` -> stores in _profiles
  - `RegisterRegulatoryMinimum(string frameworkId, TimeSpan minRetention, string reason)` -> stores in _regulatoryMinimums
  - `OptimizeRetention(string dataId)` -> retrieve profile. Compute value score: accessFrequencyScore = min(1.0, accessCount / 1000.0) * 0.3, recencyScore = max(0, 1.0 - (daysInactive / 365.0)) * 0.3, criticalityScore = businessCriticalityScore * 0.4. ValueScore = accessFrequencyScore + recencyScore + criticalityScore. Compute regulatory minimum as max retention across all applicable frameworks. Recommended retention: if valueScore > 0.7 -> max(regulatoryMin, 7 years), if > 0.4 -> max(regulatoryMin, 3 years), if > 0.1 -> max(regulatoryMin, 1 year), else regulatoryMin. Action: if recommended < current age -> "archive" or "delete" (delete if past regulatory min), else "retain". CostSavings = storageCostPerMonth * monthsSaved (if archiving/deleting). Return RetentionRecommendation.
  - Seed default regulatory minimums: "gdpr" -> 3 years "GDPR data minimization principle", "hipaa" -> 6 years "HIPAA medical records retention", "sox" -> 7 years "SOX financial records", "pci-dss" -> 1 year "PCI DSS audit log retention"

All classes MUST be `sealed`. All must have XML `<summary>` and `<remarks>` docs referencing T146.B5.N. No TODO comments, no stubs. Use `RegexOptions.Compiled` for all regex patterns defined as `private static readonly Regex`.
  </action>
  <verify>Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj` -- must compile with zero errors.</verify>
  <done>4 sealed strategy classes exist in IntelligentGovernanceStrategies.cs, all extending DataGovernanceStrategyBase with real policy template matching, compliance gap analysis with seeded frameworks, regex-based sensitivity classification, and value-weighted retention optimization. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Mark T146.B5 sub-tasks complete in TODO.md</name>
  <files>Metadata/TODO.md</files>
  <action>
In Metadata/TODO.md, find the T146 Phase B table (around line 15965-15968) and change the status of B5.1 through B5.4 from `[ ]` to `[x]`:

- Line with `146.B5.1` PolicyRecommendationStrategy -> `[x]`
- Line with `146.B5.2` ComplianceGapDetectorStrategy -> `[x]`
- Line with `146.B5.3` SensitivityClassifierStrategy -> `[x]`
- Line with `146.B5.4` RetentionOptimizerStrategy -> `[x]`

Do NOT modify any other lines.
  </action>
  <verify>Grep for `146.B5` in TODO.md and confirm all 4 lines show `[x]`.</verify>
  <done>All 4 T146.B5 sub-tasks marked [x] in TODO.md.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj` passes with zero errors
- IntelligentGovernanceStrategies.cs contains exactly 4 sealed classes extending DataGovernanceStrategyBase
- Each class has unique StrategyId starting with "intelligent-"
- Seeded defaults: 5 policy templates, 3 compliance frameworks (14 requirements total), ~10 sensitivity regex rules, 4 regulatory minimums
- No forbidden patterns: no TODO comments, no "simulation", no "mock", no "stub"
- All 4 T146.B5 sub-tasks marked [x] in TODO.md
</verification>

<success_criteria>
4 intelligent governance strategies compile, implement real policy template matching with scored recommendations, compliance gap detection against seeded regulatory frameworks, regex-based sensitivity classification (PII/PHI/PCI patterns), and value-weighted retention optimization with cost savings analysis. All sub-tasks marked complete.
</success_criteria>

<output>
After completion, create `.planning/phases/13-data-governance/13-05-SUMMARY.md`
</output>
