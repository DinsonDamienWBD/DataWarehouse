---
phase: 13-data-governance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs
  - Metadata/TODO.md
autonomous: true
must_haves:
  truths:
    - "5 active lineage strategies (B1.1-B1.5) compile and are discoverable by LineageStrategyRegistry"
    - "Each strategy extends LineageStrategyBase with unique StrategyId, real graph traversal logic, and production-ready implementations"
    - "SelfTrackingDataStrategy maintains per-object lineage history with automatic recording of every transformation"
    - "RealTimeLineageCaptureStrategy captures lineage events as they happen using event-driven timestamps"
    - "LineageInferenceStrategy infers lineage relationships from data pattern similarity (column names, value distributions)"
    - "ImpactAnalysisEngineStrategy computes blast radius with weighted scoring across direct and transitive dependencies"
    - "LineageVisualizationStrategy exports lineage graphs to DOT/Mermaid/JSON formats for visual exploration"
    - "TODO.md sub-tasks 146.B1.1-146.B1.5 are marked [x]"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs"
      provides: "5 sealed strategy classes extending LineageStrategyBase"
      contains: "SelfTrackingDataStrategy"
  key_links:
    - from: "ActiveLineageStrategies.cs"
      to: "LineageStrategyBase"
      via: "class inheritance"
      pattern: "LineageStrategyBase"
    - from: "ActiveLineageStrategies.cs"
      to: "LineageStrategyRegistry"
      via: "auto-discovery from assembly"
      pattern: "sealed class.*: LineageStrategyBase"
---

<objective>
Implement 5 Active Lineage strategies (T146.B1.1-B1.5) in UltimateDataLineage plugin.

Purpose: These AI-native lineage strategies provide industry-first capabilities where data tracks its own history, lineage is captured in real-time, relationships are inferred from patterns, impact is analyzed with weighted scoring, and lineage graphs are exportable for visualization.

Output: ActiveLineageStrategies.cs with 5 production-ready sealed strategy classes.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-data-governance/13-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateDataLineage/LineageStrategyBase.cs
@Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/LineageStrategies.cs
@Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/AdvancedLineageStrategies.cs
@Metadata/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 5 Active Lineage strategies in ActiveLineageStrategies.cs</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs</files>
  <action>
Create `Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs` with namespace `DataWarehouse.Plugins.UltimateDataLineage.Strategies` containing 5 sealed strategy classes extending `LineageStrategyBase`.

All strategies use the base class's `_nodes`, `_edges`, `_provenance` ConcurrentDictionary fields and `AddNode`/`AddEdge` helpers. Each must implement abstract members: `GetUpstreamAsync`, `GetDownstreamAsync`, `AnalyzeImpactAsync`. Use `using System.Collections.Concurrent;` at top.

**Strategy 1: SelfTrackingDataStrategy**
- StrategyId: `"active-self-tracking"`
- DisplayName: `"Self-Tracking Data"`
- Category: `LineageCategory.Origin`
- Capabilities: all true (SupportsUpstream, SupportsDownstream, SupportsTransformations, SupportsSchemaEvolution, SupportsImpactAnalysis, SupportsVisualization, SupportsRealTime)
- SemanticDescription: describes data objects maintaining their own lineage history
- Tags: `["self-tracking", "automatic", "history", "industry-first"]`
- Private fields: `ConcurrentDictionary<string, List<TransformationRecord>> _objectHistory` for per-object transformation tracking
- Define internal sealed record `TransformationRecord` with: `string TransformId`, `string Operation`, `string? SourceObjectId`, `DateTimeOffset Timestamp`, `string? BeforeHash`, `string? AfterHash`
- Override `TrackAsync`: call base, then record a TransformationRecord into `_objectHistory` for the DataObjectId, extracting operation from record.Operation, source from SourceObjects
- `GetUpstreamAsync`: BFS traversal using `_provenance` data -- for each nodeId, look at ProvenanceRecords, find SourceObjects, traverse recursively up to maxDepth. Build LineageNodes from `_nodes` if present, else create minimal node. Build LineageEdges with EdgeType="self-tracked".
- `GetDownstreamAsync`: Reverse BFS -- scan all provenance records to find which objects list the current nodeId as a source. Build graph from those.
- `AnalyzeImpactAsync`: count direct downstream (depth 1) and indirect downstream (depth 2+), score = min(100, directCount * 15 + indirectCount * 5), return recommendations based on score thresholds

**Strategy 2: RealTimeLineageCaptureStrategy**
- StrategyId: `"active-realtime-capture"`
- DisplayName: `"Real-Time Lineage Capture"`
- Category: `LineageCategory.Origin`
- Capabilities: SupportsUpstream=true, SupportsDownstream=true, SupportsTransformations=true, SupportsSchemaEvolution=false, SupportsImpactAnalysis=false, SupportsVisualization=true, SupportsRealTime=true
- Private fields: `ConcurrentDictionary<string, DateTimeOffset> _captureTimestamps` for recording when each lineage event was captured, `ConcurrentDictionary<string, HashSet<string>> _upstreamLinks`, `ConcurrentDictionary<string, HashSet<string>> _downstreamLinks`
- Override `TrackAsync`: call base, record capture timestamp with `DateTimeOffset.UtcNow`, build upstream/downstream link maps from SourceObjects
- `GetUpstreamAsync`: BFS using `_upstreamLinks` (same pattern as InMemoryGraphStrategy in LineageStrategies.cs)
- `GetDownstreamAsync`: BFS using `_downstreamLinks`
- `AnalyzeImpactAsync`: return basic result with empty lists and score 0 (impact analysis not in capabilities)

**Strategy 3: LineageInferenceStrategy**
- StrategyId: `"active-inference"`
- DisplayName: `"Lineage Inference Engine"`
- Category: `LineageCategory.Transformation`
- Capabilities: SupportsUpstream=true, SupportsDownstream=true, SupportsTransformations=true, SupportsSchemaEvolution=true, SupportsImpactAnalysis=false, SupportsVisualization=false, SupportsRealTime=false
- SemanticDescription: infers lineage relationships from data patterns, column name similarity, and value distribution overlap
- Private fields: `ConcurrentDictionary<string, Dictionary<string, string>> _schemaCache` mapping nodeId to column->type
- Public method `RegisterSchema(string nodeId, Dictionary<string, string> schema)` to populate schema cache
- `GetUpstreamAsync`: for the given nodeId, find its schema, compare against all other schemas using Jaccard similarity on column names. If similarity > 0.5, create an inferred edge. Return graph of inferred upstream nodes ordered by similarity descending.
- `GetDownstreamAsync`: same logic but reversed -- find nodes whose schemas are similar to this node (these might have been derived from it)
- `AnalyzeImpactAsync`: return empty result (not supported)

**Strategy 4: ImpactAnalysisEngineStrategy**
- StrategyId: `"active-impact-engine"`
- DisplayName: `"Impact Analysis Engine"`
- Category: `LineageCategory.Impact`
- Capabilities: SupportsUpstream=true, SupportsDownstream=true, SupportsTransformations=false, SupportsSchemaEvolution=false, SupportsImpactAnalysis=true, SupportsVisualization=true, SupportsRealTime=true
- Private fields: `ConcurrentDictionary<string, double> _nodeCriticality` for weighted scoring, `ConcurrentDictionary<string, HashSet<string>> _dependencies` for directed dependency graph
- Public method `RegisterDependency(string sourceId, string targetId)` and `SetCriticality(string nodeId, double score)`
- Override `TrackAsync`: call base, auto-register dependencies from SourceObjects
- `GetUpstreamAsync` / `GetDownstreamAsync`: BFS on `_dependencies` (upstream = reverse edges, downstream = forward edges)
- `AnalyzeImpactAsync`: BFS from nodeId following all downstream dependencies, compute weighted impact score using criticality weights (default 1.0), classify as direct (depth 1) vs indirect (depth 2+). Score formula: sum of (criticality * depthDecayFactor) where depthDecayFactor = 1.0 / depth, normalized to 0-100. Return recommendations: score > 80 -> "Critical: halt deployment", score > 50 -> "High: staged rollout required", score > 20 -> "Medium: notify downstream owners", else "Low: proceed with monitoring"

**Strategy 5: LineageVisualizationStrategy**
- StrategyId: `"active-visualization"`
- DisplayName: `"Lineage Visualization Export"`
- Category: `LineageCategory.Visualization`
- Capabilities: SupportsUpstream=true, SupportsDownstream=true, SupportsTransformations=true, SupportsSchemaEvolution=false, SupportsImpactAnalysis=false, SupportsVisualization=true, SupportsRealTime=false
- Private fields: `ConcurrentDictionary<string, HashSet<string>> _upstreamLinks`, `ConcurrentDictionary<string, HashSet<string>> _downstreamLinks`
- Override `TrackAsync`: build link maps from SourceObjects
- Public methods for export formats:
  - `ExportDot(string rootNodeId)` -> returns string in DOT/Graphviz format: `digraph { "nodeA" -> "nodeB"; ... }`
  - `ExportMermaid(string rootNodeId)` -> returns string in Mermaid format: `graph TD\n  nodeA --> nodeB\n  ...`
  - `ExportJson(string rootNodeId)` -> returns JSON string via System.Text.Json of `{ nodes: [...], edges: [...] }`
- `GetUpstreamAsync` / `GetDownstreamAsync`: BFS on link maps
- `AnalyzeImpactAsync`: return empty result (not supported)

All strategies MUST use `internal sealed` where records are strategy-specific. Use XML `<summary>` docs on every class. Use `<remarks>` documenting the T146.B1.N sub-task. No TODO comments, no stubs, no placeholder logic.
  </action>
  <verify>Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataLineage/DataWarehouse.Plugins.UltimateDataLineage.csproj` -- must compile with zero errors.</verify>
  <done>5 sealed strategy classes exist in ActiveLineageStrategies.cs, all extending LineageStrategyBase with real BFS traversal, schema-based inference, weighted impact analysis, and multi-format visualization export. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Mark T146.B1 sub-tasks complete in TODO.md</name>
  <files>Metadata/TODO.md</files>
  <action>
In Metadata/TODO.md, find the T146 Phase B table (around line 15941-15946) and change the status of B1.1 through B1.5 from `[ ]` to `[x]`:

- Line with `146.B1.1` SelfTrackingDataStrategy -> `[x]`
- Line with `146.B1.2` RealTimeLineageCaptureStrategy -> `[x]`
- Line with `146.B1.3` LineageInferenceStrategy -> `[x]`
- Line with `146.B1.4` ImpactAnalysisEngineStrategy -> `[x]`
- Line with `146.B1.5` LineageVisualizationStrategy -> `[x]`

Do NOT modify any other lines.
  </action>
  <verify>Grep for `146.B1` in TODO.md and confirm all 5 lines show `[x]`.</verify>
  <done>All 5 T146.B1 sub-tasks marked [x] in TODO.md.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataLineage/DataWarehouse.Plugins.UltimateDataLineage.csproj` passes with zero errors
- ActiveLineageStrategies.cs contains exactly 5 sealed classes extending LineageStrategyBase
- Each class has unique StrategyId starting with "active-"
- No forbidden patterns: no TODO comments, no "simulation", no "mock", no "stub", no empty catch blocks
- All 5 T146.B1 sub-tasks marked [x] in TODO.md
</verification>

<success_criteria>
5 active lineage strategies compile, use real graph traversal algorithms (BFS), schema inference (Jaccard), weighted impact scoring, and multi-format export (DOT/Mermaid/JSON). All sub-tasks marked complete.
</success_criteria>

<output>
After completion, create `.planning/phases/13-data-governance/13-01-SUMMARY.md`
</output>
