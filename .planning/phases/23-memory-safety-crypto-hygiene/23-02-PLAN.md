---
phase: 23-memory-safety-crypto-hygiene
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Security/IKeyStore.cs
  - DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategy.cs
  - DataWarehouse.Shared/Services/UserCredentialVault.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/StellarAnchorsStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/SmartContractKeyStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/BiometricDerivedKeyStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/CloudKms/DigitalOceanVaultStrategy.cs
autonomous: true

must_haves:
  truths:
    - "All byte[] key material in SDK is wiped with CryptographicOperations.ZeroMemory, not Array.Clear"
    - "All byte[] key material in plugin strategies is wiped with CryptographicOperations.ZeroMemory"
    - "UserCredentialVault._masterKey is wiped with CryptographicOperations.ZeroMemory"
    - "PluginBase._knowledgeCache is bounded with configurable maximum size (default 10,000)"
    - "KeyStorePluginBase.KeyCache is bounded with configurable maximum size (default 1,000)"
    - "EncryptionPluginBase.KeyAccessLog is bounded with configurable maximum size (default 10,000)"
    - "SDK builds with zero new warnings and zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "ZeroMemory replacements, bounded knowledge cache, bounded KeyCache, bounded KeyAccessLog"
      contains: "CryptographicOperations.ZeroMemory"
    - path: "DataWarehouse.SDK/Security/IKeyStore.cs"
      provides: "ZeroMemory in KeyStoreStrategyBase.Dispose"
      contains: "CryptographicOperations.ZeroMemory"
    - path: "DataWarehouse.Shared/Services/UserCredentialVault.cs"
      provides: "ZeroMemory for _masterKey"
      contains: "CryptographicOperations.ZeroMemory"
  key_links:
    - from: "PluginBase._knowledgeCache"
      to: "CacheKnowledge method"
      via: "Max size check before adding to cache"
      pattern: "MaxKnowledgeCacheSize"
    - from: "KeyStorePluginBase.KeyCache"
      to: "MaxCachedKeys"
      via: "Existing MaxCachedKeys property enforced"
      pattern: "MaxCachedKeys"
---

<objective>
Replace all Array.Clear calls on sensitive byte arrays with CryptographicOperations.ZeroMemory across SDK and plugins, and add bounded maximum sizes to all public collections in base classes.

Purpose: MEM-01 requires all key material to be wiped securely (ZeroMemory prevents JIT dead-store elimination). MEM-02 addresses buffer pooling (deferred to hot-path optimization; the most impactful change is ZeroMemory). MEM-03 requires all public collections to have configurable maximum sizes preventing unbounded memory growth.
Output: Updated SDK and plugin files with secure wiping and bounded collections.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-memory-safety-crypto-hygiene/23-RESEARCH.md
@.planning/phases/23-memory-safety-crypto-hygiene/23-01-SUMMARY.md

# Key files for modification
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Security/IKeyStore.cs
@DataWarehouse.Shared/Services/UserCredentialVault.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace Array.Clear with CryptographicOperations.ZeroMemory in SDK and plugins</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Security/IKeyStore.cs
    DataWarehouse.Shared/Services/UserCredentialVault.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/StellarAnchorsStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/SmartContractKeyStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/BiometricDerivedKeyStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/CloudKms/DigitalOceanVaultStrategy.cs
  </files>
  <action>
**Critical Rule:** Only replace `Array.Clear` calls that operate on SECURITY-SENSITIVE byte arrays (keys, secrets, master keys, encryption keys). Do NOT replace `Array.Clear` calls on non-sensitive data like:
- `ReedSolomon.cs` (mathematical parity shards -- NOT sensitive)
- `CountMinSketch.cs` / `HyperLogLog.cs` (probabilistic data structures -- NOT sensitive)

**Part A: PluginBase.cs -- 3 locations**

Ensure `using System.Security.Cryptography;` is at the top of the file.

1. **Line ~2672** (KeyStorePluginBase.Dispose, inside the foreach loop):
   Change:
   ```csharp
   Array.Clear(entry.Key, 0, entry.Key.Length);
   ```
   To:
   ```csharp
   CryptographicOperations.ZeroMemory(entry.Key);
   ```

2. **Line ~3117** (EncryptionPluginBase.OnWriteAsync, in the finally block):
   Change:
   ```csharp
   Array.Clear(key, 0, key.Length);
   ```
   To:
   ```csharp
   CryptographicOperations.ZeroMemory(key);
   ```

3. **Line ~3194** (EncryptionPluginBase.OnReadAsync, in the finally block):
   Change:
   ```csharp
   Array.Clear(key, 0, key.Length);
   ```
   To:
   ```csharp
   CryptographicOperations.ZeroMemory(key);
   ```

**Part B: IKeyStore.cs -- KeyStoreStrategyBase.Dispose**

The `KeyStoreStrategyBase.Dispose()` method (around line 1258) clears `_keyCache` but does NOT wipe the key bytes first. It should. The `_keyCache` is `ConcurrentDictionary<string, CachedKey>` where `CachedKey.KeyData` is `byte[]`.

Ensure `using System.Security.Cryptography;` is at the top of the file (or use fully qualified).

Find the Dispose method (around line 1258):
```csharp
public virtual void Dispose()
{
    if (_disposed)
        return;

    _disposed = true;
    _keyCache.Clear();
    _initializationLock.Dispose();

    GC.SuppressFinalize(this);
}
```

Change to:
```csharp
public virtual void Dispose()
{
    if (_disposed)
        return;

    _disposed = true;

    // Wipe key material from cache before clearing
    foreach (var entry in _keyCache.Values)
    {
        if (entry.KeyData != null)
        {
            CryptographicOperations.ZeroMemory(entry.KeyData);
        }
    }
    _keyCache.Clear();
    _initializationLock.Dispose();

    GC.SuppressFinalize(this);
}
```

Note: Check the `CachedKey` class in IKeyStore.cs to confirm the property name is `KeyData` (not `Key`). The KeyStoreStrategyBase's CachedKey is a different class than KeyStorePluginBase's CachedKey. In IKeyStore.cs around line 929-940, find the CachedKey class and check.

**Part C: UserCredentialVault.cs -- 1 location**

Add `using System.Security.Cryptography;` at the top if not already present.

Line ~506:
Change:
```csharp
Array.Clear(_masterKey, 0, _masterKey.Length);
```
To:
```csharp
CryptographicOperations.ZeroMemory(_masterKey);
```

**Part D: Plugin strategies -- 4 files**

For EACH of the following files, add `using System.Security.Cryptography;` if not present, then replace `Array.Clear` with `CryptographicOperations.ZeroMemory`:

1. **StellarAnchorsStrategy.cs line ~731:**
   ```csharp
   // From: Array.Clear(_localEncryptionKey, 0, _localEncryptionKey.Length);
   // To:
   CryptographicOperations.ZeroMemory(_localEncryptionKey);
   ```

2. **SmartContractKeyStrategy.cs line ~670:**
   ```csharp
   // From: Array.Clear(_localEncryptionKey, 0, _localEncryptionKey.Length);
   // To:
   CryptographicOperations.ZeroMemory(_localEncryptionKey);
   ```

3. **BiometricDerivedKeyStrategy.cs line ~881:**
   ```csharp
   // From: Array.Clear(entry.CachedKey, 0, entry.CachedKey.Length);
   // To:
   CryptographicOperations.ZeroMemory(entry.CachedKey);
   ```

4. **DigitalOceanVaultStrategy.cs lines ~350 and ~353:**
   ```csharp
   // Line 350 -- from: Array.Clear(_masterSecret, 0, _masterSecret.Length);
   // To:
   CryptographicOperations.ZeroMemory(_masterSecret);

   // Line 353 -- from: Array.Clear(key, 0, key.Length);
   // To:
   CryptographicOperations.ZeroMemory(key);
   ```
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 new errors.
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateKeyManagement/DataWarehouse.Plugins.UltimateKeyManagement.csproj` -- 0 new errors.
Run `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` -- 0 new errors.

Verify no remaining Array.Clear on sensitive data:
```
grep -rn "Array.Clear" DataWarehouse.SDK/Contracts/PluginBase.cs
```
Should return 0 hits (the ReedSolomon and probabilistic ones are in other files, not PluginBase).
  </verify>
  <done>
All 7 Array.Clear calls on sensitive byte arrays (3 in PluginBase.cs, 1 in IKeyStore.cs, 1 in UserCredentialVault.cs, 5 in plugin strategies) replaced with CryptographicOperations.ZeroMemory. Non-sensitive Array.Clear calls (ReedSolomon, probabilistic structures) left unchanged. SDK and all modified plugins build with zero new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add bounded maximum sizes to knowledge cache, key cache, and key access log collections</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
  </files>
  <action>
**Part A: Bounded knowledge cache in PluginBase**

1. Add a new configurable property near the top of PluginBase (after the `MessageBus` property, around line 68):
   ```csharp
   /// <summary>
   /// Maximum number of entries in the knowledge cache.
   /// Override in derived classes to customize. Default: 10,000.
   /// Set to 0 for unlimited (not recommended).
   /// </summary>
   protected virtual int MaxKnowledgeCacheSize => 10_000;
   ```

2. Update the `CacheKnowledge` method (around line 867) to enforce the bound:
   Change:
   ```csharp
   protected void CacheKnowledge(string topic, KnowledgeObject knowledge)
   {
       _knowledgeCache[topic] = knowledge;
   }
   ```
   To:
   ```csharp
   protected void CacheKnowledge(string topic, KnowledgeObject knowledge)
   {
       // Enforce bounded cache size
       if (MaxKnowledgeCacheSize > 0 && !_knowledgeCache.ContainsKey(topic) && _knowledgeCache.Count >= MaxKnowledgeCacheSize)
       {
           // Evict oldest entry (first key in dictionary -- approximate LRU for ConcurrentDictionary)
           var firstKey = _knowledgeCache.Keys.FirstOrDefault();
           if (firstKey != null)
           {
               _knowledgeCache.TryRemove(firstKey, out _);
           }
       }
       _knowledgeCache[topic] = knowledge;
   }
   ```

**Part B: Enforce bounded KeyCache in KeyStorePluginBase**

KeyStorePluginBase already has `protected virtual int MaxCachedKeys => 100;` at line ~2364. But it is NOT enforced anywhere. The KeyCache (`ConcurrentDictionary<string, CachedKey>`) grows without limit.

Find where keys are added to the cache. Search for `KeyCache[` assignments in the KeyStorePluginBase section (between lines ~2309-2688). There should be a method that populates the cache (like `GetKeyInternalAsync` or similar).

Add a helper method in KeyStorePluginBase (after the MaxCachedKeys property):
```csharp
/// <summary>
/// Adds a key to the cache, evicting the oldest entry if at capacity.
/// Wipes evicted key material with ZeroMemory.
/// </summary>
protected void AddToKeyCache(string keyId, CachedKey cachedKey)
{
    // Enforce bounded cache
    if (KeyCache.Count >= MaxCachedKeys && !KeyCache.ContainsKey(keyId))
    {
        // Evict oldest by CachedAt timestamp
        var oldest = KeyCache.OrderBy(kvp => kvp.Value.CachedAt).FirstOrDefault();
        if (oldest.Key != null && KeyCache.TryRemove(oldest.Key, out var evicted))
        {
            CryptographicOperations.ZeroMemory(evicted.Key);
        }
    }
    KeyCache[keyId] = cachedKey;
}
```

Then find ALL places in KeyStorePluginBase where `KeyCache[keyId] = ...` is used and replace with `AddToKeyCache(keyId, ...)`. There should be at least one in the key retrieval/caching logic.

**Part C: Enforce bounded KeyAccessLog in EncryptionPluginBase**

Add a configurable max size property to EncryptionPluginBase (after the `AlgorithmId` property, around line 2793):
```csharp
/// <summary>
/// Maximum number of entries in the key access log.
/// Override in derived classes to customize. Default: 10,000.
/// </summary>
protected virtual int MaxKeyAccessLogSize => 10_000;
```

Find where KeyAccessLog is updated (search for `KeyAccessLog[` in the EncryptionPluginBase section, lines ~2699-3501). There should be assignments like `KeyAccessLog[keyId] = DateTime.UtcNow`.

For each assignment, add a bounds check BEFORE the assignment:
```csharp
// Before: KeyAccessLog[keyId] = DateTime.UtcNow;
// After:
if (KeyAccessLog.Count >= MaxKeyAccessLogSize && !KeyAccessLog.ContainsKey(keyId))
{
    // Evict oldest entry
    var oldest = KeyAccessLog.OrderBy(kvp => kvp.Value).FirstOrDefault();
    if (oldest.Key != null)
    {
        KeyAccessLog.TryRemove(oldest.Key, out _);
    }
}
KeyAccessLog[keyId] = DateTime.UtcNow;
```

Alternatively, wrap this in a helper method `RecordKeyAccess(string keyId)` and replace all direct `KeyAccessLog[keyId] = DateTime.UtcNow` calls.

**Part D: Bounded _indexStore in IndexableStoragePluginBase**

Add a configurable max size property to IndexableStoragePluginBase (around line 1684):
```csharp
/// <summary>
/// Maximum number of entries in the index store.
/// Override in derived classes to customize. Default: 100,000.
/// </summary>
protected virtual int MaxIndexStoreSize => 100_000;
```

Update `IndexDocumentAsync` (line ~1693) to enforce the bound:
```csharp
public virtual Task IndexDocumentAsync(string id, Dictionary<string, object> metadata, CancellationToken ct = default)
{
    // Enforce bounded index
    if (MaxIndexStoreSize > 0 && !_indexStore.ContainsKey(id) && _indexStore.Count >= MaxIndexStoreSize)
    {
        var firstKey = _indexStore.Keys.FirstOrDefault();
        if (firstKey != null)
        {
            _indexStore.TryRemove(firstKey, out _);
        }
    }

    metadata["_indexed_at"] = DateTime.UtcNow;
    _indexStore[id] = metadata;
    Interlocked.Increment(ref _indexedCount);
    return Task.CompletedTask;
}
```

IMPORTANT: All eviction patterns above use simple oldest-first heuristics. These are sufficient for Phase 23 (preventing unbounded growth). More sophisticated eviction (LRU with linked lists, etc.) can be added later if needed.

IMPORTANT: All default sizes are generous to avoid breaking existing functionality. 10,000 knowledge entries, 100 keys (already default), 10,000 access log entries, and 100,000 index entries should accommodate any normal use case.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 new errors.

Verify properties exist:
```
grep -n "MaxKnowledgeCacheSize\|MaxCachedKeys\|MaxKeyAccessLogSize\|MaxIndexStoreSize" DataWarehouse.SDK/Contracts/PluginBase.cs
```
Should show 4 configurable max size properties.
  </verify>
  <done>
PluginBase._knowledgeCache bounded to 10,000 (configurable via MaxKnowledgeCacheSize). KeyStorePluginBase.KeyCache enforces existing MaxCachedKeys (default 100) with ZeroMemory on eviction. EncryptionPluginBase.KeyAccessLog bounded to 10,000 (configurable). IndexableStoragePluginBase._indexStore bounded to 100,000 (configurable). All bounds use simple oldest-first eviction with generous defaults. SDK builds with zero new errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 new errors, 0 new warnings
2. `dotnet build DataWarehouse.Shared/DataWarehouse.Shared.csproj` -- 0 new errors
3. `dotnet build Plugins/DataWarehouse.Plugins.UltimateKeyManagement/DataWarehouse.Plugins.UltimateKeyManagement.csproj` -- 0 new errors
4. `grep -rn "Array.Clear" DataWarehouse.SDK/Contracts/PluginBase.cs` returns 0 results
5. `grep -rn "CryptographicOperations.ZeroMemory" DataWarehouse.SDK/Contracts/PluginBase.cs` returns 3+ results
6. All bounded collection properties are configurable via `protected virtual int` overrides
</verification>

<success_criteria>
- Zero Array.Clear calls remain on sensitive byte arrays in SDK (PluginBase, IKeyStore)
- Zero Array.Clear calls remain on sensitive byte arrays in plugin strategies (4 files updated)
- UserCredentialVault._masterKey wiped with ZeroMemory
- 4 collection bounds added: knowledge cache, key cache, key access log, index store
- All bounds are configurable via virtual properties with generous defaults
- SDK and all modified projects build with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-memory-safety-crypto-hygiene/23-02-SUMMARY.md`
</output>
