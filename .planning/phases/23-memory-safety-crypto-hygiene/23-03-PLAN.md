---
phase: 23-memory-safety-crypto-hygiene
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Disk/DiskEncryptionStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Threshold/SsssStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/TimeLockPuzzleStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/QuantumKeyDistributionStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Features/Monitoring.cs
  - Plugins/DataWarehouse.Plugins.UltimateRAID/Features/QuantumSafeIntegrity.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataProtection/Strategies/Innovations/ZeroKnowledgeBackupStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateAccessControl/Features/MfaOrchestrator.cs
  - Plugins/DataWarehouse.Plugins.WinFspDriver/WinFspOperations.cs
  - Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Steganography/DecoyLayersStrategy.cs
autonomous: true

must_haves:
  truths:
    - "All security-sensitive SequenceEqual comparisons use CryptographicOperations.FixedTimeEquals to prevent timing attacks"
    - "MFA code generation uses RandomNumberGenerator instead of Random.Shared"
    - "WinFspDriver file handle generation uses RandomNumberGenerator instead of Random.Shared"
    - "DecoyLayersStrategy uses RandomNumberGenerator instead of new Random() for security content"
    - "All modified plugins build with zero new errors and zero new warnings"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Disk/DiskEncryptionStrategies.cs"
      provides: "Constant-time key and hash comparisons"
      contains: "CryptographicOperations.FixedTimeEquals"
    - path: "Plugins/DataWarehouse.Plugins.UltimateAccessControl/Features/MfaOrchestrator.cs"
      provides: "Cryptographically secure MFA code generation"
      contains: "RandomNumberGenerator"
    - path: "Plugins/DataWarehouse.Plugins.UltimateRAID/Features/Monitoring.cs"
      provides: "Constant-time signature verification"
      contains: "CryptographicOperations.FixedTimeEquals"
  key_links:
    - from: "DiskEncryptionStrategies.cs"
      to: "CryptographicOperations.FixedTimeEquals"
      via: "Key comparison in HasKeyChanged and hash verification"
      pattern: "FixedTimeEquals"
    - from: "MfaOrchestrator.cs"
      to: "RandomNumberGenerator"
      via: "MFA code generation replacing Random.Shared"
      pattern: "RandomNumberGenerator"
---

<objective>
Audit and fix all cryptographic hygiene issues: replace SequenceEqual with FixedTimeEquals for security-sensitive comparisons, replace System.Random with RandomNumberGenerator in security contexts, and verify FIPS 140-3 compliance.

Purpose: CRYPTO-01 requires constant-time comparisons for all secret/hash data to prevent timing attacks. CRYPTO-02 requires cryptographically secure RNG in security-sensitive contexts. CRYPTO-05 requires verification that all SDK crypto uses .NET BCL implementations.
Output: Updated plugin files with secure comparison and RNG patterns.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-memory-safety-crypto-hygiene/23-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace SequenceEqual with FixedTimeEquals for security-sensitive hash and key comparisons</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Disk/DiskEncryptionStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Threshold/SsssStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/TimeLockPuzzleStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/IndustryFirst/QuantumKeyDistributionStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateRAID/Features/Monitoring.cs
    Plugins/DataWarehouse.Plugins.UltimateRAID/Features/QuantumSafeIntegrity.cs
    Plugins/DataWarehouse.Plugins.UltimateDataProtection/Strategies/Innovations/ZeroKnowledgeBackupStrategy.cs
  </files>
  <action>
**CRITICAL RULE about FixedTimeEquals:** `CryptographicOperations.FixedTimeEquals(a, b)` requires `a.Length == b.Length`. If lengths differ, it returns false immediately -- which is NOT a timing leak for hash comparisons (hashes are always fixed length). But if comparing user-supplied byte arrays of variable length, add an explicit length check first.

For each file below, add `using System.Security.Cryptography;` if not already present.

**IMPORTANT: Only change SequenceEqual calls that compare security-sensitive data (hashes, keys, signatures, proofs). Do NOT change SequenceEqual calls that compare non-security data (file content, data blocks, metadata).** The research identified these specific lines as security-sensitive. All other SequenceEqual calls in the codebase (data deduplication, file comparison, format magic bytes, replication sync) are NOT timing-attack vectors and should be left unchanged.

**1. DiskEncryptionStrategies.cs -- 2 locations (HIGH risk)**

Line ~72 (key comparison in HasKeyChanged or similar):
```csharp
// From:
return !key1.SequenceEqual(key2);
// To:
return !(key1.Length == key2.Length && CryptographicOperations.FixedTimeEquals(key1, key2));
```

Line ~432 (hash verification):
```csharp
// From:
if (!hash.SequenceEqual(computedHash))
// To:
if (!(hash.Length == computedHash.Length && CryptographicOperations.FixedTimeEquals(hash, computedHash)))
```

**2. SsssStrategy.cs -- 1 location**

Line ~406 (share hash comparison):
```csharp
// From:
if (!providedHash.SequenceEqual(share.ShareHash ?? Array.Empty<byte>()))
// To:
var expectedHash = share.ShareHash ?? Array.Empty<byte>();
if (!(providedHash.Length == expectedHash.Length && CryptographicOperations.FixedTimeEquals(providedHash, expectedHash)))
```

**3. TimeLockPuzzleStrategy.cs -- 2 locations**

Line ~417 (result hash comparison):
```csharp
// From:
if (!resultHash.SequenceEqual(solver.ExpectedResultHash))
// To:
if (!(resultHash.Length == solver.ExpectedResultHash.Length && CryptographicOperations.FixedTimeEquals(resultHash, solver.ExpectedResultHash)))
```

Line ~500 (result hash comparison):
```csharp
// From:
return resultHash.SequenceEqual(keyData.ExpectedResultHash);
// To:
return resultHash.Length == keyData.ExpectedResultHash.Length && CryptographicOperations.FixedTimeEquals(resultHash, keyData.ExpectedResultHash);
```

**4. QuantumKeyDistributionStrategy.cs -- 1 location**

Line ~321 (hash comparison):
```csharp
// From:
if (!computedHash.SequenceEqual(expectedHash))
// To:
if (!(computedHash.Length == expectedHash.Length && CryptographicOperations.FixedTimeEquals(computedHash, expectedHash)))
```

**5. Monitoring.cs -- 2 locations (HIGH risk -- signature verification)**

Line ~634 (data hash comparison):
```csharp
// From:
return record.DataHash.SequenceEqual(currentDataHash) &&
// To:
return record.DataHash.Length == currentDataHash.Length && CryptographicOperations.FixedTimeEquals(record.DataHash, currentDataHash) &&
```

Line ~675 (signature comparison -- CRITICAL for timing attack):
```csharp
// From:
return expected.SequenceEqual(signature);
// To:
return expected.Length == signature.Length && CryptographicOperations.FixedTimeEquals(expected, signature);
```

**6. QuantumSafeIntegrity.cs -- 2 locations**

Line ~62 (checksum comparison):
```csharp
// From:
return computed.Hash.SequenceEqual(checksum.Hash);
// To:
return computed.Hash.Length == checksum.Hash.Length && CryptographicOperations.FixedTimeEquals(computed.Hash, checksum.Hash);
```

Line ~149 (root hash comparison):
```csharp
// From:
var isValid = computedHash.SequenceEqual(tree.RootHash);
// To:
var isValid = computedHash.Length == tree.RootHash.Length && CryptographicOperations.FixedTimeEquals(computedHash, tree.RootHash);
```

**7. ZeroKnowledgeBackupStrategy.cs -- 1 location**

Line ~757 (proof comparison):
```csharp
// From:
return expectedProof.SequenceEqual(commitment.ProofReference.ProofValue);
// To:
return expectedProof.Length == commitment.ProofReference.ProofValue.Length && CryptographicOperations.FixedTimeEquals(expectedProof, commitment.ProofReference.ProofValue);
```
  </action>
  <verify>
Build each modified plugin:
```
dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj
dotnet build Plugins/DataWarehouse.Plugins.UltimateKeyManagement/DataWarehouse.Plugins.UltimateKeyManagement.csproj
dotnet build Plugins/DataWarehouse.Plugins.UltimateRAID/DataWarehouse.Plugins.UltimateRAID.csproj
dotnet build Plugins/DataWarehouse.Plugins.UltimateDataProtection/DataWarehouse.Plugins.UltimateDataProtection.csproj
```
All should build with zero new errors and zero new warnings.

Verify no remaining security-sensitive SequenceEqual:
```
grep -n "SequenceEqual" Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Disk/DiskEncryptionStrategies.cs
grep -n "SequenceEqual" Plugins/DataWarehouse.Plugins.UltimateRAID/Features/Monitoring.cs
```
Both should return 0 hits.
  </verify>
  <done>
11 SequenceEqual calls on security-sensitive data (key comparisons, hash verifications, signature checks, proof comparisons) replaced with CryptographicOperations.FixedTimeEquals across 7 plugin files. Each replacement includes length check for robustness. Non-security SequenceEqual calls (data dedup, format magic, replication sync) intentionally left unchanged. All modified plugins build with zero new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace System.Random with RandomNumberGenerator in security-sensitive contexts</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateAccessControl/Features/MfaOrchestrator.cs
    Plugins/DataWarehouse.Plugins.WinFspDriver/WinFspOperations.cs
    Plugins/DataWarehouse.Plugins.UltimateAccessControl/Strategies/Steganography/DecoyLayersStrategy.cs
  </files>
  <action>
**CRITICAL: Only fix these 3 specific security-sensitive usages.** Do NOT change:
- `WatermarkingStrategy.cs:396` -- uses `new Random(seed)` for DETERMINISTIC watermark embedding. Changing to RandomNumberGenerator would break watermark extraction. This is intentionally deterministic.
- `AudioSteganographyStrategy.cs:770` -- uses `new Random(12345)` for DETERMINISTIC PN sequence. Same reason.
- `LsbEmbeddingStrategy.cs:552` -- uses `new Random(_randomSeed)` for DETERMINISTIC pixel shuffling. Same reason.
- `TacacsStrategy.cs:110` -- uses `Random.Shared.Next()` for TACACS+ session ID. TACACS+ protocol spec uses 32-bit session IDs and they are NOT cryptographic. This is acceptable.

**1. MfaOrchestrator.cs -- CRITICAL SECURITY FIX**

Add `using System.Security.Cryptography;` at the top of the file.

Line ~133-138 (GenerateCode method):
```csharp
// From:
private string GenerateCode(MfaMethodType methodType)
{
    return methodType == MfaMethodType.Totp
        ? Random.Shared.Next(100000, 999999).ToString("D6")
        : Guid.NewGuid().ToString("N").Substring(0, 8).ToUpper();
}
```

To:
```csharp
private static string GenerateCode(MfaMethodType methodType)
{
    if (methodType == MfaMethodType.Totp)
    {
        // Use cryptographically secure RNG for MFA codes
        var code = RandomNumberGenerator.GetInt32(100000, 1000000);
        return code.ToString("D6");
    }
    else
    {
        // Use cryptographically secure random bytes for non-TOTP codes
        var bytes = RandomNumberGenerator.GetBytes(4);
        return Convert.ToHexString(bytes);
    }
}
```

Note: `RandomNumberGenerator.GetInt32(minValue, maxValue)` is available since .NET 6. The upper bound is EXCLUSIVE, so `GetInt32(100000, 1000000)` generates 100000-999999 (same range as the original). For the non-TOTP branch, using random bytes instead of Guid substring provides better entropy for 8-character codes.

**2. WinFspOperations.cs -- File handle uniqueness**

Add `using System.Security.Cryptography;` at the top if not present.

Line ~798-801 (GenerateIndexNumber method):
```csharp
// From:
private static ulong GenerateIndexNumber()
{
    return (ulong)DateTime.UtcNow.Ticks ^ (ulong)Random.Shared.NextInt64();
}
```

To:
```csharp
private static ulong GenerateIndexNumber()
{
    Span<byte> bytes = stackalloc byte[8];
    RandomNumberGenerator.Fill(bytes);
    return (ulong)DateTime.UtcNow.Ticks ^ BitConverter.ToUInt64(bytes);
}
```

This generates a cryptographically random 64-bit value for XOR with ticks, ensuring file system index numbers are unpredictable.

**3. DecoyLayersStrategy.cs -- Security-sensitive content generation**

Add `using System.Security.Cryptography;` at the top if not present.

Line ~764-771 (GenerateTextContent method):
```csharp
// From:
private byte[] GenerateTextContent(string[] templates, int targetSize)
{
    var sb = new StringBuilder();
    var rng = new Random();

    while (sb.Length < targetSize)
    {
```

To:
```csharp
private byte[] GenerateTextContent(string[] templates, int targetSize)
{
    var sb = new StringBuilder();

    while (sb.Length < targetSize)
    {
```

Then update the body of the while loop. Find where `rng.Next(...)` is called inside this method (likely to pick random templates). Replace each `rng.Next(upperBound)` with `RandomNumberGenerator.GetInt32(upperBound)`.

For example:
```csharp
// From:
var template = templates[rng.Next(templates.Length)];
// To:
var template = templates[RandomNumberGenerator.GetInt32(templates.Length)];
```

This matters because decoy layers in steganography are security features -- predictable patterns could help an attacker distinguish real from decoy data.
  </action>
  <verify>
Build each modified plugin:
```
dotnet build Plugins/DataWarehouse.Plugins.UltimateAccessControl/DataWarehouse.Plugins.UltimateAccessControl.csproj
dotnet build Plugins/DataWarehouse.Plugins.WinFspDriver/DataWarehouse.Plugins.WinFspDriver.csproj
```
Both should build with zero new errors and zero new warnings.

Verify the MFA fix:
```
grep -n "Random.Shared" Plugins/DataWarehouse.Plugins.UltimateAccessControl/Features/MfaOrchestrator.cs
```
Should return 0 hits.

Verify the WinFsp fix:
```
grep -n "Random.Shared" Plugins/DataWarehouse.Plugins.WinFspDriver/WinFspOperations.cs
```
Should return 0 hits.
  </verify>
  <done>
3 security-sensitive Random/Random.Shared usages replaced with RandomNumberGenerator: MFA code generation (CRITICAL -- was using predictable RNG for authentication codes), WinFsp file handle generation, and steganography decoy content generation. 4 intentionally-deterministic Random usages (watermarking, audio steganography, LSB embedding, TACACS+ session ID) correctly left unchanged. All modified plugins build with zero new errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.slnx` completes with only pre-existing 13 CS1729/CS0234 errors (no new errors)
2. `grep -rn "SequenceEqual" Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Disk/DiskEncryptionStrategies.cs` returns 0 hits
3. `grep -rn "SequenceEqual" Plugins/DataWarehouse.Plugins.UltimateRAID/Features/Monitoring.cs` returns 0 hits
4. `grep -rn "Random.Shared" Plugins/DataWarehouse.Plugins.UltimateAccessControl/Features/MfaOrchestrator.cs` returns 0 hits
5. `grep -rn "FixedTimeEquals" Plugins/` returns 11+ hits across the security-sensitive files
6. All non-security SequenceEqual calls remain unchanged (dedup, replication, format magic)
</verification>

<success_criteria>
- 11 security-sensitive SequenceEqual calls replaced with FixedTimeEquals (across 7 files)
- 3 security-sensitive Random usages replaced with RandomNumberGenerator (across 3 files)
- 4 intentionally-deterministic Random usages left unchanged (with documented justification)
- FIPS 140-3 verified: all SDK crypto uses .NET BCL (BouncyCastle only in plugins for SHA3/Keccak/threshold)
- All modified plugins build with zero new errors and zero new warnings
</success_criteria>

<output>
After completion, create `.planning/phases/23-memory-safety-crypto-hygiene/23-03-SUMMARY.md`
</output>
