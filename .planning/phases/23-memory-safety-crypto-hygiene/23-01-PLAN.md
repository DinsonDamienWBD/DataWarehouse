---
phase: 23-memory-safety-crypto-hygiene
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
  - DataWarehouse.SDK/Storage/HybridStoragePluginBase.cs
  - DataWarehouse.SDK/Database/HybridDatabasePluginBase.cs
autonomous: true

must_haves:
  truths:
    - "PluginBase implements both IDisposable and IAsyncDisposable with proper Dispose(bool) pattern"
    - "PluginBase.Dispose() cleans up _knowledgeSubscriptions, _knowledgeCache, _registeredCapabilityIds, _registeredKnowledgeIds"
    - "PluginBase.DisposeAsync() calls UnregisterFromSystemAsync() for async cleanup then Dispose(false)"
    - "IntelligenceAwarePluginBase overrides Dispose(bool) to clean up _intelligenceSubscriptions and _pendingRequests"
    - "KeyStorePluginBase and EncryptionPluginBase call base.Dispose(disposing) in their existing Dispose(bool) override"
    - "CacheableStoragePluginBase calls base.Dispose(disposing) in its Dispose(bool) override"
    - "HybridStoragePluginBase and HybridDatabasePluginBase use DisposeAsyncCore() pattern"
    - "SDK builds with zero new warnings and zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "IDisposable + IAsyncDisposable on PluginBase, updated dispose chains on derived classes"
      contains: "public abstract class PluginBase : IPlugin, IDisposable, IAsyncDisposable"
    - path: "DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs"
      provides: "Override Dispose(bool) and DisposeAsyncCore() for intelligence cleanup"
      contains: "protected override void Dispose(bool disposing)"
    - path: "DataWarehouse.SDK/Storage/HybridStoragePluginBase.cs"
      provides: "Updated IAsyncDisposable with DisposeAsyncCore() pattern"
      contains: "protected virtual async ValueTask DisposeAsyncCore()"
    - path: "DataWarehouse.SDK/Database/HybridDatabasePluginBase.cs"
      provides: "Updated IAsyncDisposable with DisposeAsyncCore() pattern"
      contains: "protected virtual async ValueTask DisposeAsyncCore()"
  key_links:
    - from: "PluginBase.Dispose(bool)"
      to: "KeyStorePluginBase.Dispose(bool)"
      via: "base.Dispose(disposing) call chain"
      pattern: "base\\.Dispose\\(disposing\\)"
    - from: "PluginBase.Dispose(bool)"
      to: "EncryptionPluginBase.Dispose(bool)"
      via: "base.Dispose(disposing) call chain through PipelinePluginBase/DataTransformationPluginBase"
      pattern: "base\\.Dispose\\(disposing\\)"
    - from: "PluginBase.DisposeAsyncCore()"
      to: "HybridStoragePluginBase.DisposeAsyncCore()"
      via: "override chain through IndexableStoragePluginBase/CacheableStoragePluginBase"
      pattern: "await base\\.DisposeAsyncCore\\(\\)"
---

<objective>
Add IDisposable and IAsyncDisposable to PluginBase with proper dispose pattern, and update all derived base classes that already implement IDisposable/IAsyncDisposable to call base.Dispose(disposing).

Purpose: MEM-04 requires PluginBase.Dispose() to properly clean up knowledge cache, capability subscriptions, and message bus subscriptions. MEM-05 requires all IAsyncDisposable implementations to follow the async dispose pattern with DisposeAsyncCore(). This is the foundation for all other Phase 23 work.
Output: Updated PluginBase.cs, IntelligenceAwarePluginBase.cs, HybridStoragePluginBase.cs, HybridDatabasePluginBase.cs with proper dispose hierarchies.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-memory-safety-crypto-hygiene/23-RESEARCH.md

# Key source files
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
@DataWarehouse.SDK/Storage/HybridStoragePluginBase.cs
@DataWarehouse.SDK/Database/HybridDatabasePluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IDisposable + IAsyncDisposable to PluginBase and update all derived base class dispose chains</name>
  <files>
    DataWarehouse.SDK/Contracts/PluginBase.cs
    DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
  </files>
  <action>
**Part A: PluginBase (line 20 of PluginBase.cs)**

1. Add `using System.Security.Cryptography;` at top of file if not present (needed for Plan 23-02 but harmless now).

2. Change class declaration at line 20 from:
   ```csharp
   public abstract class PluginBase : IPlugin
   ```
   to:
   ```csharp
   public abstract class PluginBase : IPlugin, IDisposable, IAsyncDisposable
   ```

3. Add a `_disposed` field near the other private fields (around line 57, after `_knowledgeRegistered`):
   ```csharp
   /// <summary>
   /// Whether this plugin has been disposed.
   /// </summary>
   private bool _disposed;
   ```

4. Add a `#region IDisposable / IAsyncDisposable` section at the END of the PluginBase class (before the closing `}` of the class, which is at line ~1199 -- just before the FeaturePluginBase declaration at line 1206). Insert:

   ```csharp
   #region IDisposable / IAsyncDisposable

   /// <summary>
   /// Gets whether this plugin has been disposed.
   /// </summary>
   protected bool IsDisposed => _disposed;

   /// <summary>
   /// Throws <see cref="ObjectDisposedException"/> if this plugin has been disposed.
   /// </summary>
   protected void ThrowIfDisposed()
   {
       ObjectDisposedException.ThrowIf(_disposed, this);
   }

   /// <summary>
   /// Releases managed and unmanaged resources.
   /// Override in derived classes to add cleanup logic. Always call base.Dispose(disposing).
   /// </summary>
   /// <param name="disposing">true if called from Dispose(); false if called from DisposeAsync().</param>
   protected virtual void Dispose(bool disposing)
   {
       if (_disposed) return;

       if (disposing)
       {
           // Dispose knowledge subscriptions
           foreach (var sub in _knowledgeSubscriptions)
           {
               try { sub.Dispose(); } catch { /* Swallow during cleanup */ }
           }
           _knowledgeSubscriptions.Clear();

           // Clear knowledge cache
           _knowledgeCache.Clear();

           // Clear registration tracking
           _registeredCapabilityIds.Clear();
           _registeredKnowledgeIds.Clear();
       }

       _disposed = true;
   }

   /// <inheritdoc/>
   public void Dispose()
   {
       Dispose(true);
       GC.SuppressFinalize(this);
   }

   /// <summary>
   /// Performs async cleanup. Override in derived classes for async disposal.
   /// Always call base.DisposeAsyncCore() at the end of your override.
   /// </summary>
   protected virtual async ValueTask DisposeAsyncCore()
   {
       // Async cleanup: unregister from system if message bus is available
       if (MessageBus != null)
       {
           try
           {
               await UnregisterFromSystemAsync();
           }
           catch
           {
               // Swallow during cleanup -- best effort
           }
       }
   }

   /// <inheritdoc/>
   public async ValueTask DisposeAsync()
   {
       await DisposeAsyncCore();
       Dispose(false);
       GC.SuppressFinalize(this);
   }

   #endregion
   ```

**Part B: Update KeyStorePluginBase dispose chain (line ~2663 in PluginBase.cs)**

The existing `Dispose(bool)` at line 2663 does NOT call `base.Dispose(disposing)`. Add it. Change:
```csharp
protected virtual void Dispose(bool disposing)
{
    if (_disposed) return;

    if (disposing)
    {
        // Clear sensitive data from cache
        foreach (var entry in KeyCache.Values)
        {
            Array.Clear(entry.Key, 0, entry.Key.Length);
        }
        KeyCache.Clear();
        InitLock.Dispose();
    }

    _disposed = true;
}
```
to:
```csharp
protected override void Dispose(bool disposing)
{
    if (_disposed) return;

    if (disposing)
    {
        // Clear sensitive data from cache
        foreach (var entry in KeyCache.Values)
        {
            Array.Clear(entry.Key, 0, entry.Key.Length);
        }
        KeyCache.Clear();
        InitLock.Dispose();
    }

    _disposed = true;
    base.Dispose(disposing);
}
```

IMPORTANT: Change `protected virtual` to `protected override`. This is valid because PluginBase now declares `Dispose(bool)` as `protected virtual`, and SecurityProviderPluginBase (the parent of KeyStorePluginBase) does NOT define its own Dispose(bool), so the override chain goes: KeyStorePluginBase -> SecurityProviderPluginBase -> PluginBase.

Also remove the standalone `public void Dispose()` method at line ~2681 and the `GC.SuppressFinalize(this)` call (lines 2681-2685), since PluginBase now provides these. But keep the `IDisposable` in the class declaration for now (it's redundant but not harmful and removing it is a separate cleanup):
```csharp
// REMOVE these lines (2681-2685):
// public void Dispose()
// {
//     Dispose(true);
//     GC.SuppressFinalize(this);
// }
```

Wait -- KeyStorePluginBase class declaration says `KeyStorePluginBase : SecurityProviderPluginBase, IKeyStore` (NO explicit IDisposable). Check: does it compile? Yes, because PluginBase now implements IDisposable, so the class inherits it. The `public void Dispose()` at line 2681 shadows the base. We need to REMOVE it so the base version is used. Delete lines 2681-2685.

**Part C: Update EncryptionPluginBase dispose chain (line ~3467 in PluginBase.cs)**

Same pattern. The class at line 2699 is declared as `EncryptionPluginBase : PipelinePluginBase, IDisposable`. Since PluginBase now implements IDisposable, the explicit `, IDisposable` is redundant. Remove it:
```csharp
// Change from:
public abstract class EncryptionPluginBase : PipelinePluginBase, IDisposable
// To:
public abstract class EncryptionPluginBase : PipelinePluginBase
```

Update the `Dispose(bool)` at line ~3467:
```csharp
// Change from:
protected virtual void Dispose(bool disposing)
// To:
protected override void Dispose(bool disposing)
```

Add `base.Dispose(disposing)` at the end:
```csharp
protected override void Dispose(bool disposing)
{
    if (_disposed) return;

    if (disposing)
    {
        KeyAccessLog.Clear();
    }

    _disposed = true;
    base.Dispose(disposing);
}
```

Remove the standalone `public void Dispose()` at lines 3479-3483 (same reason as KeyStorePluginBase).

**Part D: Update CacheableStoragePluginBase dispose chain (line ~1670 in PluginBase.cs)**

The existing `Dispose(bool)` at line 1670 does not have a `_disposed` guard and does not call base. Change:
```csharp
protected virtual void Dispose(bool disposing)
{
    if (disposing)
    {
        _cleanupTimer?.Dispose();
    }
}
```
to:
```csharp
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        _cleanupTimer?.Dispose();
    }
    base.Dispose(disposing);
}
```

Note: No `_disposed` guard needed here because the base handles it. Change `virtual` to `override`.

**Part E: IntelligenceAwarePluginBase (IntelligenceAwarePluginBase.cs)**

Add a Dispose override to clean up `_intelligenceSubscriptions` and `_pendingRequests`. These are currently cleaned up in `StopAsync()` (line 275), but Dispose should also handle them for safety.

Add at the end of the class (before the closing `}`):

```csharp
#region IDisposable / IAsyncDisposable

/// <summary>
/// Cleans up Intelligence subscriptions and pending requests.
/// </summary>
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        // Dispose Intelligence subscriptions
        foreach (var subscription in _intelligenceSubscriptions)
        {
            try { subscription.Dispose(); } catch { }
        }
        _intelligenceSubscriptions.Clear();

        // Cancel pending requests
        foreach (var kvp in _pendingRequests)
        {
            kvp.Value.TrySetCanceled();
        }
        _pendingRequests.Clear();
    }

    base.Dispose(disposing);
}

/// <summary>
/// Performs async cleanup of Intelligence resources.
/// </summary>
protected override async ValueTask DisposeAsyncCore()
{
    // Dispose Intelligence subscriptions
    foreach (var subscription in _intelligenceSubscriptions)
    {
        try { subscription.Dispose(); } catch { }
    }
    _intelligenceSubscriptions.Clear();

    // Cancel pending requests
    foreach (var kvp in _pendingRequests)
    {
        kvp.Value.TrySetCanceled();
    }
    _pendingRequests.Clear();

    await base.DisposeAsyncCore();
}

#endregion
```

Note: IntelligenceAwarePluginBase inherits from FeaturePluginBase, which inherits from PluginBase. FeaturePluginBase does NOT define Dispose(bool), so the override chain goes directly to PluginBase.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` and confirm:
- Zero new errors
- Zero new warnings
- Build succeeds

Then grep to verify the patterns are correct:
- `grep -n "base.Dispose(disposing)" DataWarehouse.SDK/Contracts/PluginBase.cs` should show KeyStorePluginBase, EncryptionPluginBase, CacheableStoragePluginBase
- `grep -n "DisposeAsyncCore" DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs` should show the override
  </verify>
  <done>
PluginBase declares `IDisposable, IAsyncDisposable` with `Dispose(bool)` pattern (cleaning up _knowledgeSubscriptions, _knowledgeCache, _registeredCapabilityIds, _registeredKnowledgeIds) and `DisposeAsyncCore()` pattern (calling UnregisterFromSystemAsync). KeyStorePluginBase, EncryptionPluginBase, CacheableStoragePluginBase all use `protected override void Dispose(bool)` and call `base.Dispose(disposing)`. IntelligenceAwarePluginBase overrides both Dispose(bool) and DisposeAsyncCore() for intelligence cleanup. SDK builds with zero new warnings and zero new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update HybridStoragePluginBase and HybridDatabasePluginBase to DisposeAsyncCore() pattern</name>
  <files>
    DataWarehouse.SDK/Storage/HybridStoragePluginBase.cs
    DataWarehouse.SDK/Database/HybridDatabasePluginBase.cs
  </files>
  <action>
**Part A: HybridStoragePluginBase (HybridStoragePluginBase.cs)**

The class at line 108 is declared as:
```csharp
public abstract class HybridStoragePluginBase<TConfig> : IndexableStoragePluginBase, IAsyncDisposable
```

Since PluginBase now implements IAsyncDisposable, remove the redundant `, IAsyncDisposable`:
```csharp
public abstract class HybridStoragePluginBase<TConfig> : IndexableStoragePluginBase
```

Replace the existing `DisposeAsync()` method (lines ~554-563):
```csharp
public async ValueTask DisposeAsync()
{
    if (_disposed) return;
    _disposed = true;

    _healthMonitorTimer?.Dispose();
    await _connectionRegistry.DisposeAsync();

    GC.SuppressFinalize(this);
}
```

With the DisposeAsyncCore pattern:
```csharp
/// <summary>
/// Performs async cleanup of storage connections and health monitor.
/// </summary>
protected override async ValueTask DisposeAsyncCore()
{
    if (_disposed) return;
    _disposed = true;

    _healthMonitorTimer?.Dispose();
    await _connectionRegistry.DisposeAsync();

    await base.DisposeAsyncCore();
}
```

Remove the standalone `DisposeAsync()` method entirely -- it is now inherited from PluginBase. Also remove the `GC.SuppressFinalize(this)` call -- the base handles it.

**Part B: HybridDatabasePluginBase (HybridDatabasePluginBase.cs)**

The class at line 31 is declared as:
```csharp
public abstract class HybridDatabasePluginBase<TConfig> : IndexableStoragePluginBase, IAsyncDisposable
```

Remove the redundant `, IAsyncDisposable`:
```csharp
public abstract class HybridDatabasePluginBase<TConfig> : IndexableStoragePluginBase
```

Replace the existing `DisposeAsync()` method (lines ~667-672):
```csharp
public async ValueTask DisposeAsync()
{
    await _connectionRegistry.DisposeAsync();
    _connectionLock.Dispose();
    GC.SuppressFinalize(this);
}
```

With:
```csharp
/// <summary>
/// Performs async cleanup of database connections and locks.
/// </summary>
protected override async ValueTask DisposeAsyncCore()
{
    await _connectionRegistry.DisposeAsync();
    _connectionLock.Dispose();

    await base.DisposeAsyncCore();
}
```

Remove the `IAsyncDisposable` region header/footer comments if present (clean up the region markers since DisposeAsyncCore is part of the inherited pattern).

**Build verification:** After both files are changed, run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` to confirm zero new errors.

IMPORTANT: The override chain for DisposeAsyncCore goes: HybridStoragePluginBase -> IndexableStoragePluginBase -> CacheableStoragePluginBase -> ListableStoragePluginBase -> StorageProviderPluginBase -> PluginBase. None of the intermediate classes define DisposeAsyncCore, so the override goes straight to PluginBase. This is correct.

IMPORTANT: If the compiler warns about `new` hiding base member, that means the method signatures conflict. Use `override` not `new`. Since PluginBase defines `protected virtual ValueTask DisposeAsyncCore()`, and neither IndexableStoragePluginBase nor CacheableStoragePluginBase define it, the `override` keyword works.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` and confirm:
- Zero new errors
- Zero new warnings
- Build succeeds

Then verify the full solution still builds:
```
dotnet build DataWarehouse.slnx
```
The pre-existing 13 CS1729/CS0234 errors in UltimateCompression and AedsCore are expected and NOT caused by these changes. Zero new errors should appear.
  </verify>
  <done>
HybridStoragePluginBase and HybridDatabasePluginBase use `protected override async ValueTask DisposeAsyncCore()` instead of standalone `DisposeAsync()`, properly calling `await base.DisposeAsyncCore()`. The redundant `IAsyncDisposable` is removed from both class declarations. The full SDK builds with zero new warnings and zero new errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` completes with 0 errors, 0 new warnings
2. `dotnet build DataWarehouse.slnx` completes with only the pre-existing 13 CS1729/CS0234 errors
3. `grep -rn "base.Dispose(disposing)" DataWarehouse.SDK/Contracts/PluginBase.cs` shows 3 hits (KeyStorePluginBase, EncryptionPluginBase, CacheableStoragePluginBase)
4. `grep -rn "DisposeAsyncCore" DataWarehouse.SDK/` shows hits in PluginBase.cs, IntelligenceAwarePluginBase.cs, HybridStoragePluginBase.cs, HybridDatabasePluginBase.cs
5. `grep -n "IDisposable, IAsyncDisposable" DataWarehouse.SDK/Contracts/PluginBase.cs` shows the PluginBase class declaration
</verification>

<success_criteria>
- PluginBase implements IDisposable + IAsyncDisposable with correct Dispose(bool) + DisposeAsyncCore() pattern
- All 5 derived base classes that had their own IDisposable/IAsyncDisposable now call base properly
- No standalone Dispose()/DisposeAsync() methods shadow the base class versions
- SDK builds clean (0 new errors, 0 new warnings)
- Full solution builds with no new errors beyond pre-existing 13
</success_criteria>

<output>
After completion, create `.planning/phases/23-memory-safety-crypto-hygiene/23-01-SUMMARY.md`
</output>
