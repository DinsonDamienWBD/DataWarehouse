---
phase: 23-memory-safety-crypto-hygiene
plan: 04
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - DataWarehouse.SDK/Security/IKeyRotationPolicy.cs
  - DataWarehouse.SDK/Security/IKeyStore.cs
  - DataWarehouse.SDK/Security/CryptographicAlgorithmRegistry.cs
  - DataWarehouse.SDK/Contracts/IMessageBus.cs
  - DataWarehouse.SDK/Utilities/PluginDetails.cs
autonomous: true

must_haves:
  truths:
    - "IKeyRotationPolicy interface exists in SDK with configurable rotation triggers (time-based, usage-based, event-based)"
    - "IKeyRotatable interface exists for key stores that support automated rotation"
    - "ICryptographicAlgorithmRegistry provides algorithm agility for hash and HMAC selection"
    - "IAuthenticatedMessageBus extends IMessageBus with HMAC-SHA256 message signing and verification"
    - "PluginMessage has optional Signature, Nonce, and ExpiresAt fields for replay protection"
    - "MessageAuthenticationOptions provides opt-in configuration for authenticated topics"
    - "SDK builds with zero new errors and zero new warnings"
  artifacts:
    - path: "DataWarehouse.SDK/Security/IKeyRotationPolicy.cs"
      provides: "IKeyRotationPolicy, IKeyRotatable, KeyRotationTrigger, KeyRotationResult types"
      contains: "interface IKeyRotationPolicy"
    - path: "DataWarehouse.SDK/Security/CryptographicAlgorithmRegistry.cs"
      provides: "ICryptographicAlgorithmRegistry for hash/HMAC algorithm agility"
      contains: "interface ICryptographicAlgorithmRegistry"
    - path: "DataWarehouse.SDK/Contracts/IMessageBus.cs"
      provides: "IAuthenticatedMessageBus with signing, verification, replay protection"
      contains: "interface IAuthenticatedMessageBus"
    - path: "DataWarehouse.SDK/Utilities/PluginDetails.cs"
      provides: "Signature, Nonce, ExpiresAt fields on PluginMessage"
      contains: "Signature"
  key_links:
    - from: "IKeyRotationPolicy"
      to: "IKeyStore"
      via: "IKeyRotatable extends IKeyStore with rotation capabilities"
      pattern: "interface IKeyRotatable"
    - from: "IAuthenticatedMessageBus"
      to: "IMessageBus"
      via: "Extension interface adding authentication layer"
      pattern: "IAuthenticatedMessageBus.*:.*IMessageBus"
    - from: "PluginMessage.Signature"
      to: "IAuthenticatedMessageBus.VerifyMessageAsync"
      via: "Message signature populated by publish, verified by subscriber"
      pattern: "VerifyMessage"
---

<objective>
Create SDK contracts for key rotation policy, algorithm agility for hash/HMAC, and authenticated message bus with HMAC-SHA256 signatures and replay protection.

Purpose: CRYPTO-03 requires key rotation contracts in the SDK. CRYPTO-04 requires algorithm agility (no hardcoded algorithm choices). CRYPTO-06 requires distributed message authentication with HMAC-SHA256 and replay protection. All three are new additive interfaces -- no breaking changes to existing code.
Output: New SDK interface files and updated PluginMessage/IMessageBus with authentication support.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-memory-safety-crypto-hygiene/23-RESEARCH.md
@.planning/phases/23-memory-safety-crypto-hygiene/23-01-SUMMARY.md

# Key source files
@DataWarehouse.SDK/Security/IKeyStore.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Utilities/PluginDetails.cs
@DataWarehouse.SDK/Security/SecretManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IKeyRotationPolicy and ICryptographicAlgorithmRegistry contracts</name>
  <files>
    DataWarehouse.SDK/Security/IKeyRotationPolicy.cs
    DataWarehouse.SDK/Security/CryptographicAlgorithmRegistry.cs
    DataWarehouse.SDK/Security/IKeyStore.cs
  </files>
  <action>
**Part A: Create IKeyRotationPolicy.cs (NEW FILE)**

Create `DataWarehouse.SDK/Security/IKeyRotationPolicy.cs`:

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace DataWarehouse.SDK.Security
{
    /// <summary>
    /// Defines when and how cryptographic keys should be rotated.
    /// Implementations can use time-based, usage-based, or event-based triggers.
    /// </summary>
    public interface IKeyRotationPolicy
    {
        /// <summary>
        /// Gets the unique identifier for this rotation policy.
        /// </summary>
        string PolicyId { get; }

        /// <summary>
        /// Gets the human-readable description of this policy.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Evaluates whether a key should be rotated based on its metadata and usage.
        /// </summary>
        /// <param name="keyId">The key identifier.</param>
        /// <param name="metadata">Current key metadata (creation time, usage count, etc.).</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>A rotation decision with reason.</returns>
        Task<KeyRotationDecision> ShouldRotateAsync(string keyId, KeyRotationMetadata metadata, CancellationToken ct = default);

        /// <summary>
        /// Gets the rotation triggers configured for this policy.
        /// </summary>
        IReadOnlyList<KeyRotationTrigger> Triggers { get; }
    }

    /// <summary>
    /// Result of a key rotation evaluation.
    /// </summary>
    public record KeyRotationDecision
    {
        /// <summary>
        /// Whether the key should be rotated.
        /// </summary>
        public bool ShouldRotate { get; init; }

        /// <summary>
        /// Urgency level of the rotation.
        /// </summary>
        public RotationUrgency Urgency { get; init; }

        /// <summary>
        /// Human-readable reason for the decision.
        /// </summary>
        public string Reason { get; init; } = string.Empty;

        /// <summary>
        /// The trigger that caused the rotation decision, if any.
        /// </summary>
        public KeyRotationTrigger? TriggeredBy { get; init; }

        /// <summary>
        /// Creates a decision indicating no rotation is needed.
        /// </summary>
        public static KeyRotationDecision NoRotation(string reason) =>
            new() { ShouldRotate = false, Urgency = RotationUrgency.None, Reason = reason };

        /// <summary>
        /// Creates a decision indicating rotation is needed.
        /// </summary>
        public static KeyRotationDecision Rotate(RotationUrgency urgency, string reason, KeyRotationTrigger? trigger = null) =>
            new() { ShouldRotate = true, Urgency = urgency, Reason = reason, TriggeredBy = trigger };
    }

    /// <summary>
    /// Urgency level for key rotation.
    /// </summary>
    public enum RotationUrgency
    {
        /// <summary>No rotation needed.</summary>
        None,

        /// <summary>Rotation recommended at next convenient time.</summary>
        Low,

        /// <summary>Rotation should happen soon (within hours).</summary>
        Medium,

        /// <summary>Rotation required immediately (key may be compromised).</summary>
        Critical
    }

    /// <summary>
    /// A trigger condition that can initiate key rotation.
    /// </summary>
    public record KeyRotationTrigger
    {
        /// <summary>
        /// Type of trigger.
        /// </summary>
        public KeyRotationTriggerType Type { get; init; }

        /// <summary>
        /// For time-based triggers: maximum age of a key before rotation.
        /// </summary>
        public TimeSpan? MaxKeyAge { get; init; }

        /// <summary>
        /// For usage-based triggers: maximum number of operations before rotation.
        /// </summary>
        public long? MaxUsageCount { get; init; }

        /// <summary>
        /// For data-based triggers: maximum bytes encrypted before rotation.
        /// </summary>
        public long? MaxBytesProcessed { get; init; }

        /// <summary>
        /// For event-based triggers: the event name that triggers rotation.
        /// </summary>
        public string? EventName { get; init; }

        /// <summary>
        /// Creates a time-based rotation trigger.
        /// </summary>
        public static KeyRotationTrigger TimeBased(TimeSpan maxAge) =>
            new() { Type = KeyRotationTriggerType.TimeBased, MaxKeyAge = maxAge };

        /// <summary>
        /// Creates a usage-count-based rotation trigger.
        /// </summary>
        public static KeyRotationTrigger UsageBased(long maxOperations) =>
            new() { Type = KeyRotationTriggerType.UsageBased, MaxUsageCount = maxOperations };

        /// <summary>
        /// Creates a data-volume-based rotation trigger.
        /// </summary>
        public static KeyRotationTrigger DataVolumeBased(long maxBytes) =>
            new() { Type = KeyRotationTriggerType.DataVolumeBased, MaxBytesProcessed = maxBytes };

        /// <summary>
        /// Creates an event-based rotation trigger.
        /// </summary>
        public static KeyRotationTrigger EventBased(string eventName) =>
            new() { Type = KeyRotationTriggerType.EventBased, EventName = eventName };
    }

    /// <summary>
    /// Types of key rotation triggers.
    /// </summary>
    public enum KeyRotationTriggerType
    {
        /// <summary>Rotate after a fixed time period.</summary>
        TimeBased,

        /// <summary>Rotate after N operations (encryptions, signings).</summary>
        UsageBased,

        /// <summary>Rotate after N bytes processed.</summary>
        DataVolumeBased,

        /// <summary>Rotate when a specific event occurs (compromise detected, compliance audit).</summary>
        EventBased
    }

    /// <summary>
    /// Metadata about a key used for rotation decisions.
    /// </summary>
    public record KeyRotationMetadata
    {
        /// <summary>When the key was created.</summary>
        public DateTime CreatedAt { get; init; }

        /// <summary>When the key was last used.</summary>
        public DateTime? LastUsedAt { get; init; }

        /// <summary>When the key was last rotated (null if never rotated).</summary>
        public DateTime? LastRotatedAt { get; init; }

        /// <summary>Number of operations performed with this key.</summary>
        public long UsageCount { get; init; }

        /// <summary>Total bytes processed with this key.</summary>
        public long BytesProcessed { get; init; }

        /// <summary>Current key version (increments on each rotation).</summary>
        public int Version { get; init; }

        /// <summary>Algorithm the key is used with.</summary>
        public string? Algorithm { get; init; }

        /// <summary>Additional metadata from the key store.</summary>
        public IReadOnlyDictionary<string, object> Properties { get; init; } = new Dictionary<string, object>();
    }

    /// <summary>
    /// Result of a key rotation operation.
    /// </summary>
    public record KeyRotationResult
    {
        /// <summary>Whether the rotation succeeded.</summary>
        public bool Success { get; init; }

        /// <summary>The new key ID after rotation.</summary>
        public string? NewKeyId { get; init; }

        /// <summary>The old key ID that was rotated.</summary>
        public string? OldKeyId { get; init; }

        /// <summary>When the old key will be decommissioned (grace period).</summary>
        public DateTime? OldKeyExpiresAt { get; init; }

        /// <summary>Error message if rotation failed.</summary>
        public string? ErrorMessage { get; init; }
    }

    /// <summary>
    /// Key stores that support automated key rotation implement this interface.
    /// </summary>
    public interface IKeyRotatable : IKeyStore
    {
        /// <summary>
        /// Gets or sets the active rotation policy.
        /// </summary>
        IKeyRotationPolicy? RotationPolicy { get; set; }

        /// <summary>
        /// Rotates a key, creating a new version and optionally keeping the old version
        /// accessible for a grace period.
        /// </summary>
        /// <param name="keyId">The key to rotate.</param>
        /// <param name="gracePeriod">How long the old key remains accessible.</param>
        /// <param name="context">Security context for authorization.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Result of the rotation operation.</returns>
        Task<KeyRotationResult> RotateKeyAsync(string keyId, TimeSpan gracePeriod, ISecurityContext context, CancellationToken ct = default);

        /// <summary>
        /// Gets the rotation metadata for a specific key.
        /// </summary>
        Task<KeyRotationMetadata> GetRotationMetadataAsync(string keyId, ISecurityContext context, CancellationToken ct = default);

        /// <summary>
        /// Checks all keys against the rotation policy and returns those needing rotation.
        /// </summary>
        Task<IReadOnlyList<KeyRotationDecision>> EvaluateAllKeysAsync(ISecurityContext context, CancellationToken ct = default);
    }
}
```

**Part B: Create CryptographicAlgorithmRegistry.cs (NEW FILE)**

Create `DataWarehouse.SDK/Security/CryptographicAlgorithmRegistry.cs`:

```csharp
using System;
using System.Collections.Generic;
using System.Security.Cryptography;

namespace DataWarehouse.SDK.Security
{
    /// <summary>
    /// Registry for cryptographic algorithm selection.
    /// Provides algorithm agility -- no hardcoded algorithm choices in SDK code.
    /// All algorithm selection goes through this registry, enabling runtime configuration.
    /// </summary>
    /// <remarks>
    /// Encryption algorithm agility already exists via IEncryptionStrategy/IEncryptionStrategyRegistry.
    /// This registry extends agility to hash algorithms and HMAC algorithms.
    /// </remarks>
    public interface ICryptographicAlgorithmRegistry
    {
        /// <summary>
        /// Gets the default hash algorithm name (e.g., SHA256, SHA384, SHA512).
        /// </summary>
        HashAlgorithmName DefaultHashAlgorithm { get; }

        /// <summary>
        /// Gets the default HMAC algorithm name.
        /// </summary>
        HashAlgorithmName DefaultHmacAlgorithm { get; }

        /// <summary>
        /// Gets all registered hash algorithm names.
        /// </summary>
        IReadOnlyList<HashAlgorithmName> SupportedHashAlgorithms { get; }

        /// <summary>
        /// Gets all registered HMAC algorithm names.
        /// </summary>
        IReadOnlyList<HashAlgorithmName> SupportedHmacAlgorithms { get; }

        /// <summary>
        /// Creates a hash algorithm instance by name.
        /// </summary>
        /// <param name="algorithmName">Algorithm name (e.g., SHA256).</param>
        /// <returns>A disposable hash algorithm instance.</returns>
        /// <exception cref="NotSupportedException">If the algorithm is not registered.</exception>
        HashAlgorithm CreateHashAlgorithm(HashAlgorithmName algorithmName);

        /// <summary>
        /// Creates an HMAC instance by algorithm name.
        /// </summary>
        /// <param name="algorithmName">HMAC algorithm name (e.g., SHA256 for HMAC-SHA256).</param>
        /// <param name="key">The HMAC key.</param>
        /// <returns>A disposable HMAC instance.</returns>
        /// <exception cref="NotSupportedException">If the algorithm is not registered.</exception>
        HMAC CreateHmac(HashAlgorithmName algorithmName, byte[] key);

        /// <summary>
        /// Computes a hash using the specified algorithm.
        /// Uses one-shot static APIs where available for zero allocation.
        /// </summary>
        /// <param name="algorithmName">Algorithm name.</param>
        /// <param name="data">Data to hash.</param>
        /// <returns>Hash bytes.</returns>
        byte[] ComputeHash(HashAlgorithmName algorithmName, ReadOnlySpan<byte> data);

        /// <summary>
        /// Computes an HMAC using the specified algorithm.
        /// Uses one-shot static APIs where available for zero allocation.
        /// </summary>
        /// <param name="algorithmName">HMAC algorithm name.</param>
        /// <param name="key">The HMAC key.</param>
        /// <param name="data">Data to authenticate.</param>
        /// <returns>HMAC bytes.</returns>
        byte[] ComputeHmac(HashAlgorithmName algorithmName, ReadOnlySpan<byte> key, ReadOnlySpan<byte> data);

        /// <summary>
        /// Checks whether the specified algorithm is FIPS 140-3 approved.
        /// </summary>
        bool IsFipsApproved(HashAlgorithmName algorithmName);
    }

    /// <summary>
    /// Default implementation using .NET BCL cryptographic primitives.
    /// All algorithms are FIPS 140-3 compliant (System.Security.Cryptography).
    /// </summary>
    public class DefaultCryptographicAlgorithmRegistry : ICryptographicAlgorithmRegistry
    {
        /// <inheritdoc/>
        public HashAlgorithmName DefaultHashAlgorithm => HashAlgorithmName.SHA256;

        /// <inheritdoc/>
        public HashAlgorithmName DefaultHmacAlgorithm => HashAlgorithmName.SHA256;

        /// <inheritdoc/>
        public IReadOnlyList<HashAlgorithmName> SupportedHashAlgorithms { get; } = new[]
        {
            HashAlgorithmName.SHA256,
            HashAlgorithmName.SHA384,
            HashAlgorithmName.SHA512
        };

        /// <inheritdoc/>
        public IReadOnlyList<HashAlgorithmName> SupportedHmacAlgorithms { get; } = new[]
        {
            HashAlgorithmName.SHA256,
            HashAlgorithmName.SHA384,
            HashAlgorithmName.SHA512
        };

        /// <inheritdoc/>
        public HashAlgorithm CreateHashAlgorithm(HashAlgorithmName algorithmName)
        {
            if (algorithmName == HashAlgorithmName.SHA256) return SHA256.Create();
            if (algorithmName == HashAlgorithmName.SHA384) return SHA384.Create();
            if (algorithmName == HashAlgorithmName.SHA512) return SHA512.Create();
            throw new NotSupportedException($"Hash algorithm '{algorithmName.Name}' is not supported. Use SHA256, SHA384, or SHA512.");
        }

        /// <inheritdoc/>
        public HMAC CreateHmac(HashAlgorithmName algorithmName, byte[] key)
        {
            if (algorithmName == HashAlgorithmName.SHA256) return new HMACSHA256(key);
            if (algorithmName == HashAlgorithmName.SHA384) return new HMACSHA384(key);
            if (algorithmName == HashAlgorithmName.SHA512) return new HMACSHA512(key);
            throw new NotSupportedException($"HMAC algorithm '{algorithmName.Name}' is not supported. Use SHA256, SHA384, or SHA512.");
        }

        /// <inheritdoc/>
        public byte[] ComputeHash(HashAlgorithmName algorithmName, ReadOnlySpan<byte> data)
        {
            if (algorithmName == HashAlgorithmName.SHA256) return SHA256.HashData(data);
            if (algorithmName == HashAlgorithmName.SHA384) return SHA384.HashData(data);
            if (algorithmName == HashAlgorithmName.SHA512) return SHA512.HashData(data);
            throw new NotSupportedException($"Hash algorithm '{algorithmName.Name}' is not supported.");
        }

        /// <inheritdoc/>
        public byte[] ComputeHmac(HashAlgorithmName algorithmName, ReadOnlySpan<byte> key, ReadOnlySpan<byte> data)
        {
            if (algorithmName == HashAlgorithmName.SHA256) return HMACSHA256.HashData(key, data);
            if (algorithmName == HashAlgorithmName.SHA384) return HMACSHA384.HashData(key, data);
            if (algorithmName == HashAlgorithmName.SHA512) return HMACSHA512.HashData(key, data);
            throw new NotSupportedException($"HMAC algorithm '{algorithmName.Name}' is not supported.");
        }

        /// <inheritdoc/>
        public bool IsFipsApproved(HashAlgorithmName algorithmName)
        {
            // All .NET BCL hash algorithms are FIPS 140-3 approved
            return algorithmName == HashAlgorithmName.SHA256
                || algorithmName == HashAlgorithmName.SHA384
                || algorithmName == HashAlgorithmName.SHA512;
        }
    }
}
```

**Part C: Add IKeyRotatable notice to IKeyStore.cs**

NO modification to IKeyStore.cs is needed. The `IKeyRotatable` interface is defined in the new `IKeyRotationPolicy.cs` file and extends `IKeyStore`. This is additive -- existing IKeyStore implementations are not affected.

However, add a `/// <seealso cref="IKeyRotatable"/>` XML doc reference to the `IKeyStore` interface doc comment, if one exists. This helps discoverability.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 new errors, 0 new warnings.

Verify new files exist:
```
ls DataWarehouse.SDK/Security/IKeyRotationPolicy.cs
ls DataWarehouse.SDK/Security/CryptographicAlgorithmRegistry.cs
```

Verify interfaces are present:
```
grep -n "interface IKeyRotationPolicy" DataWarehouse.SDK/Security/IKeyRotationPolicy.cs
grep -n "interface IKeyRotatable" DataWarehouse.SDK/Security/IKeyRotationPolicy.cs
grep -n "interface ICryptographicAlgorithmRegistry" DataWarehouse.SDK/Security/CryptographicAlgorithmRegistry.cs
```
Each should return exactly 1 hit.
  </verify>
  <done>
IKeyRotationPolicy interface defined with configurable triggers (time, usage, data volume, event). IKeyRotatable extends IKeyStore with RotateKeyAsync, GetRotationMetadataAsync, EvaluateAllKeysAsync. KeyRotationDecision, KeyRotationTrigger, KeyRotationMetadata records defined. ICryptographicAlgorithmRegistry provides hash/HMAC algorithm agility with DefaultCryptographicAlgorithmRegistry implementation using .NET BCL (FIPS 140-3). SDK builds with zero new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IAuthenticatedMessageBus with HMAC-SHA256 signing and replay protection</name>
  <files>
    DataWarehouse.SDK/Contracts/IMessageBus.cs
    DataWarehouse.SDK/Utilities/PluginDetails.cs
  </files>
  <action>
**Part A: Add authentication fields to PluginMessage (PluginDetails.cs)**

In the `PluginMessage` class (starting at line ~142 in PluginDetails.cs), add the following properties AFTER the existing `Metadata` property (around line ~193):

```csharp
/// <summary>
/// HMAC signature of the message for authentication.
/// Populated by IAuthenticatedMessageBus when publishing to authenticated topics.
/// Null for unauthenticated messages.
/// </summary>
public byte[]? Signature { get; set; }

/// <summary>
/// Unique nonce for replay protection.
/// Automatically generated by IAuthenticatedMessageBus when signing.
/// </summary>
public string? Nonce { get; set; }

/// <summary>
/// Expiration time for replay protection.
/// Messages received after this time should be rejected.
/// </summary>
public DateTime? ExpiresAt { get; set; }
```

Note: Using `set` (not `init`) because the message bus needs to populate these after construction. The existing properties use `init`, but Signature/Nonce/ExpiresAt are transport-layer concerns set by the bus, not the message creator.

**Part B: Add IAuthenticatedMessageBus to IMessageBus.cs**

Add the following AFTER the existing `MessageTopics` class (at the end of the file, but inside the namespace):

```csharp
/// <summary>
/// Configuration for message authentication on a specific topic.
/// </summary>
public class MessageAuthenticationOptions
{
    /// <summary>
    /// Whether messages on this topic require HMAC signatures.
    /// </summary>
    public bool RequireSignature { get; init; }

    /// <summary>
    /// Maximum age of a message before it is rejected (replay protection).
    /// Default: 5 minutes.
    /// </summary>
    public TimeSpan MaxMessageAge { get; init; } = TimeSpan.FromMinutes(5);

    /// <summary>
    /// Whether to track nonces for replay detection.
    /// When enabled, duplicate nonces within the MaxMessageAge window are rejected.
    /// </summary>
    public bool EnableReplayDetection { get; init; } = true;

    /// <summary>
    /// The hash algorithm to use for HMAC signing.
    /// Default: SHA256 (HMAC-SHA256).
    /// </summary>
    public System.Security.Cryptography.HashAlgorithmName HmacAlgorithm { get; init; } = System.Security.Cryptography.HashAlgorithmName.SHA256;
}

/// <summary>
/// Result of message verification.
/// </summary>
public record MessageVerificationResult
{
    /// <summary>
    /// Whether the message passed verification.
    /// </summary>
    public bool IsValid { get; init; }

    /// <summary>
    /// Reason for verification failure, if any.
    /// </summary>
    public string? FailureReason { get; init; }

    /// <summary>
    /// The type of failure (for programmatic handling).
    /// </summary>
    public MessageVerificationFailure? FailureType { get; init; }

    /// <summary>
    /// Creates a successful verification result.
    /// </summary>
    public static MessageVerificationResult Valid() => new() { IsValid = true };

    /// <summary>
    /// Creates a failed verification result.
    /// </summary>
    public static MessageVerificationResult Invalid(MessageVerificationFailure failureType, string reason) =>
        new() { IsValid = false, FailureType = failureType, FailureReason = reason };
}

/// <summary>
/// Types of message verification failures.
/// </summary>
public enum MessageVerificationFailure
{
    /// <summary>Message has no signature but topic requires one.</summary>
    MissingSignature,

    /// <summary>HMAC signature does not match message content.</summary>
    InvalidSignature,

    /// <summary>Message has expired (ExpiresAt is in the past).</summary>
    Expired,

    /// <summary>Message nonce was already seen (replay attack detected).</summary>
    ReplayDetected,

    /// <summary>Message has no nonce but replay detection is enabled.</summary>
    MissingNonce
}

/// <summary>
/// Extension of IMessageBus that adds HMAC-SHA256 message authentication and replay protection.
/// Implementations sign messages on publish and verify on receive for authenticated topics.
/// Authentication is opt-in per topic via ConfigureAuthentication.
/// </summary>
/// <remarks>
/// <para>
/// This interface extends IMessageBus to provide:
/// </para>
/// <list type="bullet">
///   <item>HMAC-SHA256 message signing (or configurable algorithm via MessageAuthenticationOptions)</item>
///   <item>Constant-time signature verification using CryptographicOperations.FixedTimeEquals</item>
///   <item>Nonce-based replay protection with configurable time window</item>
///   <item>Per-topic authentication configuration (not all topics need authentication)</item>
/// </list>
/// <para>
/// Usage: Register authenticated topics, then use standard Publish/Subscribe.
/// The authenticated bus automatically signs outgoing messages and verifies incoming ones.
/// </para>
/// </remarks>
public interface IAuthenticatedMessageBus : IMessageBus
{
    /// <summary>
    /// Configures authentication requirements for a topic.
    /// Messages published to this topic will be signed; received messages will be verified.
    /// </summary>
    /// <param name="topic">The topic to configure.</param>
    /// <param name="options">Authentication options.</param>
    void ConfigureAuthentication(string topic, MessageAuthenticationOptions options);

    /// <summary>
    /// Configures authentication for topics matching a pattern.
    /// </summary>
    /// <param name="topicPattern">Glob pattern (e.g., "security.*", "*.sensitive").</param>
    /// <param name="options">Authentication options.</param>
    void ConfigureAuthenticationPattern(string topicPattern, MessageAuthenticationOptions options);

    /// <summary>
    /// Sets the signing key used for HMAC message authentication.
    /// The key should be provisioned securely (e.g., from IKeyStore).
    /// </summary>
    /// <param name="key">The HMAC signing key.</param>
    void SetSigningKey(byte[] key);

    /// <summary>
    /// Rotates the signing key. The old key is retained for verification of in-flight messages
    /// during the grace period.
    /// </summary>
    /// <param name="newKey">The new HMAC signing key.</param>
    /// <param name="gracePeriod">How long to accept signatures from the old key.</param>
    void RotateSigningKey(byte[] newKey, TimeSpan gracePeriod);

    /// <summary>
    /// Manually verifies a message's signature and replay protection.
    /// Useful for messages received from external sources.
    /// </summary>
    /// <param name="message">The message to verify.</param>
    /// <param name="topic">The topic the message was received on.</param>
    /// <returns>Verification result with pass/fail and reason.</returns>
    MessageVerificationResult VerifyMessage(PluginMessage message, string topic);

    /// <summary>
    /// Gets whether a topic has authentication configured.
    /// </summary>
    bool IsAuthenticatedTopic(string topic);

    /// <summary>
    /// Gets the authentication options for a topic, or null if not configured.
    /// </summary>
    MessageAuthenticationOptions? GetAuthenticationOptions(string topic);
}

/// <summary>
/// Standard message topics that should use authenticated messaging.
/// </summary>
public static class AuthenticatedMessageTopics
{
    /// <summary>Security-sensitive operations should be authenticated.</summary>
    public const string SecurityPrefix = "security.";

    /// <summary>Key management operations should be authenticated.</summary>
    public const string KeyStorePrefix = "keystore.";

    /// <summary>Plugin lifecycle (load/unload) should be authenticated to prevent spoofing.</summary>
    public const string PluginLifecyclePrefix = "plugin.";

    /// <summary>System-level commands should be authenticated.</summary>
    public const string SystemPrefix = "system.";
}
```

**Part C: Add authentication topics to MessageTopics class**

In the existing `MessageTopics` class (around line 116 in IMessageBus.cs), add after the existing topics:

```csharp
// Authentication events
public const string AuthKeyRotated = "security.key.rotated";
public const string AuthSigningKeyChanged = "security.signing.changed";
public const string AuthReplayDetected = "security.replay.detected";
```

IMPORTANT: This is purely additive. The existing `IMessageBus` interface is NOT modified. `IAuthenticatedMessageBus` extends it. All existing code continues to work with the basic `IMessageBus`. The authenticated layer is opt-in.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 new errors, 0 new warnings.

Verify new interfaces:
```
grep -n "interface IAuthenticatedMessageBus" DataWarehouse.SDK/Contracts/IMessageBus.cs
grep -n "Signature" DataWarehouse.SDK/Utilities/PluginDetails.cs
```

Verify full solution still builds:
```
dotnet build DataWarehouse.slnx
```
Only pre-existing 13 CS1729/CS0234 errors should appear.
  </verify>
  <done>
IAuthenticatedMessageBus interface extends IMessageBus with HMAC signing/verification, per-topic authentication configuration, signing key rotation, and replay protection. PluginMessage has Signature, Nonce, and ExpiresAt fields. MessageAuthenticationOptions provides configurable MaxMessageAge and HMAC algorithm selection. MessageVerificationResult/MessageVerificationFailure types support detailed error reporting. AuthenticatedMessageTopics defines standard prefixes. All changes are additive (no breaking changes to existing IMessageBus consumers). SDK builds with zero new errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 new errors, 0 new warnings
2. `dotnet build DataWarehouse.slnx` -- only pre-existing 13 errors
3. New files exist: `DataWarehouse.SDK/Security/IKeyRotationPolicy.cs`, `DataWarehouse.SDK/Security/CryptographicAlgorithmRegistry.cs`
4. `IKeyRotationPolicy`, `IKeyRotatable`, `ICryptographicAlgorithmRegistry`, `IAuthenticatedMessageBus` interfaces all compile
5. `DefaultCryptographicAlgorithmRegistry` provides working default implementation
6. PluginMessage.Signature, PluginMessage.Nonce, PluginMessage.ExpiresAt are accessible
7. No existing code is broken (all changes are additive)
</verification>

<success_criteria>
- CRYPTO-03: IKeyRotationPolicy with time/usage/volume/event triggers, IKeyRotatable extends IKeyStore
- CRYPTO-04: ICryptographicAlgorithmRegistry with DefaultCryptographicAlgorithmRegistry (SHA256/384/512)
- CRYPTO-06: IAuthenticatedMessageBus with HMAC-SHA256, replay protection (nonce + expiry), per-topic opt-in
- All new types have full XML documentation
- All changes additive -- zero breaking changes
- SDK and full solution build with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-memory-safety-crypto-hygiene/23-04-SUMMARY.md`
</output>
