---
phase: 29-advanced-distributed-coordination
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ConsistentHashRing.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ConsistentHashLoadBalancer.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ResourceAwareLoadBalancer.cs
autonomous: true

must_haves:
  truths:
    - "ConsistentHashRing places virtual nodes on a 32-bit hash ring and walks clockwise to find target"
    - "Adding/removing a node only affects keys between the node and its predecessor"
    - "ConsistentHashLoadBalancer wraps the ring and implements ILoadBalancerStrategy with AlgorithmName 'ConsistentHash'"
    - "ResourceAwareLoadBalancer routes to nodes based on weighted health scores, excluding overloaded nodes"
    - "Empty ring operations throw InvalidOperationException (matching InMemoryLoadBalancerStrategy behavior)"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ConsistentHashRing.cs"
      provides: "IConsistentHashRing implementation with virtual nodes"
      min_lines: 120
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ConsistentHashLoadBalancer.cs"
      provides: "ILoadBalancerStrategy wrapping ConsistentHashRing"
      min_lines: 60
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ResourceAwareLoadBalancer.cs"
      provides: "ILoadBalancerStrategy with health-based weighted selection"
      min_lines: 100
  key_links:
    - from: "ConsistentHashRing"
      to: "System.IO.Hashing.XxHash32"
      via: "uses XxHash32 for ring placement (existing SDK dependency)"
      pattern: "XxHash32|HashToUInt32"
    - from: "ConsistentHashLoadBalancer"
      to: "ConsistentHashRing"
      via: "delegates GetNode to ring, maps to ClusterNode"
      pattern: "ConsistentHashRing|_ring|GetNode"
    - from: "ConsistentHashLoadBalancer"
      to: "ILoadBalancerStrategy"
      via: "implements SelectNode/SelectNodeAsync/ReportNodeHealth"
      pattern: "ILoadBalancerStrategy|SelectNode|AlgorithmName"
    - from: "ResourceAwareLoadBalancer"
      to: "NodeHealthReport"
      via: "computes weighted score from CPU/memory/connections/latency"
      pattern: "NodeHealthReport|CpuUsage|MemoryUsage|ActiveConnections"
---

<objective>
Implement consistent hashing load balancer (DIST-16) and resource-aware load balancer (DIST-17) as SDK-level classes.

Purpose: Provide two production-ready load balancing strategies. Consistent hashing ensures cache-friendly routing (same key always goes to same node, minimal disruption on membership changes). Resource-aware balancing routes based on real-time CPU/memory metrics, avoiding overloaded nodes.

Output:
- `ConsistentHashRing` implementing `IConsistentHashRing` with virtual nodes
- `ConsistentHashLoadBalancer` implementing `ILoadBalancerStrategy` (AlgorithmName = "ConsistentHash")
- `ResourceAwareLoadBalancer` implementing `ILoadBalancerStrategy` (AlgorithmName = "ResourceAware")
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-advanced-distributed-coordination/29-RESEARCH.md

@DataWarehouse.SDK/Contracts/Distributed/ILoadBalancerStrategy.cs
@DataWarehouse.SDK/Contracts/Distributed/IFederatedMessageBus.cs
@DataWarehouse.SDK/Infrastructure/InMemory/InMemoryLoadBalancerStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consistent Hash Ring and Load Balancer</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ConsistentHashRing.cs
    DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ConsistentHashLoadBalancer.cs
  </files>
  <action>
Create the `Distributed/LoadBalancing/` directory under `DataWarehouse.SDK/Infrastructure/`.

**File 1: ConsistentHashRing.cs**

Create `ConsistentHashRing` sealed class implementing `IConsistentHashRing`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Distributed`
- Attribute: `[SdkCompatibility("2.0.0", Notes = "Phase 29: Consistent hash ring")]`

Follow the pattern from the existing `ConsistentHashShardingStrategy` in UltimateDataManagement plugin (SortedDictionary + ReaderWriterLockSlim).

Constructor: `ConsistentHashRing(int virtualNodeCount = 150)`

Internal state:
- `SortedDictionary<uint, string> _ring = new()` -- hash -> nodeId
- `ReaderWriterLockSlim _lock = new()` -- thread safety for ring mutations
- `uint[]? _sortedKeys = null` -- cached sorted keys for binary search (invalidated on add/remove)
- `HashSet<string> _physicalNodes = new()` -- track physical nodes for GetNodes replication

`int VirtualNodeCount { get; }` -- from constructor

`void AddNode(string nodeId)`:
1. `_lock.EnterWriteLock()`
2. Add nodeId to `_physicalNodes`
3. For `i = 0` to `VirtualNodeCount - 1`:
   - Compute hash: `ComputeHash($"{nodeId}:{i}")` -- virtual node key format
   - `_ring[hash] = nodeId`
4. Invalidate `_sortedKeys = null`
5. `_lock.ExitWriteLock()`

`void RemoveNode(string nodeId)`:
1. `_lock.EnterWriteLock()`
2. Remove nodeId from `_physicalNodes`
3. For `i = 0` to `VirtualNodeCount - 1`:
   - Compute hash: `ComputeHash($"{nodeId}:{i}")`
   - `_ring.Remove(hash)`
4. Invalidate `_sortedKeys = null`
5. `_lock.ExitWriteLock()`

`string GetNode(string key)`:
1. `_lock.EnterReadLock()`
2. If `_ring.Count == 0`: throw `InvalidOperationException("Hash ring is empty.")` (Pitfall 4)
3. Get or build `_sortedKeys` (lazy: `_sortedKeys ??= _ring.Keys.ToArray()`)
4. Compute `hash = ComputeHash(key)`
5. Binary search: `Array.BinarySearch(_sortedKeys, hash)`
6. If index < 0: `~index` (insertion point)
7. If index >= `_sortedKeys.Length`: wrap to 0 (ring is circular)
8. Return `_ring[_sortedKeys[index]]`
9. `_lock.ExitReadLock()`
Use try/finally for lock release.

`IReadOnlyList<string> GetNodes(string key, int count)`:
1. `_lock.EnterReadLock()`
2. If `_ring.Count == 0`: throw InvalidOperationException
3. Find starting position (same as GetNode)
4. Walk clockwise collecting DISTINCT physical nodes until `count` unique nodes found or ring exhausted
5. Return list of distinct node IDs
6. `_lock.ExitReadLock()`

`static uint ComputeHash(string key)`:
- `var bytes = System.Text.Encoding.UTF8.GetBytes(key);`
- `return System.IO.Hashing.XxHash32.HashToUInt32(bytes);`
- Uses existing SDK dependency -- do NOT add new NuGet packages

Implement IDisposable: dispose `_lock`.

**File 2: ConsistentHashLoadBalancer.cs**

Create `ConsistentHashLoadBalancer` sealed class implementing `ILoadBalancerStrategy`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Distributed`
- Attribute: `[SdkCompatibility("2.0.0", Notes = "Phase 29: Consistent hash load balancer")]`

Constructor takes: `ConsistentHashRing ring`

`string AlgorithmName => "ConsistentHash"`

`ClusterNode SelectNode(LoadBalancerContext context)`:
1. If `context.AvailableNodes.Count == 0`: throw InvalidOperationException (match InMemoryLoadBalancerStrategy behavior)
2. Ensure ring has current nodes: sync ring with context.AvailableNodes (add missing, remove stale)
3. `string nodeId = _ring.GetNode(context.RequestKey)`
4. Find matching ClusterNode in context.AvailableNodes by NodeId
5. If not found (node removed between ring lookup and list check): fall back to first available node
6. Return node

`Task<ClusterNode> SelectNodeAsync(LoadBalancerContext context, CancellationToken ct)`:
- `ct.ThrowIfCancellationRequested();`
- `return Task.FromResult(SelectNode(context));`

`void ReportNodeHealth(string nodeId, NodeHealthReport report)`:
- Store health reports in `ConcurrentDictionary<string, NodeHealthReport>` (for potential future use)
- ConsistentHash doesn't use health for routing decisions, but stores them per contract

Internal: `SyncRingWithAvailableNodes(IReadOnlyList<ClusterNode> nodes)`:
- Add nodes in list but not in ring
- Remove nodes in ring but not in list
- Use a HashSet for efficient diff
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify ConsistentHashRing.cs and ConsistentHashLoadBalancer.cs exist. Grep for `IConsistentHashRing` confirms interface. Grep for `XxHash32.HashToUInt32` confirms hash function. Grep for `ReaderWriterLockSlim` confirms thread safety. Grep for `BinarySearch` confirms efficient lookup. Grep for `AlgorithmName.*ConsistentHash` confirms LB name.
  </verify>
  <done>
ConsistentHashRing implements IConsistentHashRing with 150 virtual nodes per physical node, SortedDictionary ring, binary search for O(log n) lookup, ReaderWriterLockSlim for thread safety, and XxHash32 for hashing. ConsistentHashLoadBalancer wraps the ring as an ILoadBalancerStrategy, syncing ring membership with context.AvailableNodes on each selection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Resource-Aware Load Balancer</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Distributed/LoadBalancing/ResourceAwareLoadBalancer.cs
  </files>
  <action>
**File: ResourceAwareLoadBalancer.cs**

Create `ResourceAwareLoadBalancer` sealed class implementing `ILoadBalancerStrategy`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Distributed`
- Attribute: `[SdkCompatibility("2.0.0", Notes = "Phase 29: Resource-aware load balancer")]`

Constructor takes: `ResourceAwareConfiguration? config = null`

`ResourceAwareConfiguration` record:
- `double CpuThresholdPercent` (default 90.0) -- exclude nodes above this CPU %
- `double MemoryThresholdPercent` (default 90.0) -- exclude nodes above this memory %
- `long MaxActiveConnections` (default 10000) -- exclude nodes above this connection count
- `double CpuWeight` (default 0.3) -- weight for CPU in composite score
- `double MemoryWeight` (default 0.3) -- weight for memory in composite score
- `double ConnectionsWeight` (default 0.2) -- weight for connections in composite score
- `double LatencyWeight` (default 0.2) -- weight for latency in composite score
- `TimeSpan HealthReportStaleness` (default 30 seconds) -- ignore reports older than this

`string AlgorithmName => "ResourceAware"`

Internal state:
- `ConcurrentDictionary<string, NodeHealthReport> _healthReports = new()` -- latest health per node

`void ReportNodeHealth(string nodeId, NodeHealthReport report)`:
- `_healthReports[nodeId] = report;`

`ClusterNode SelectNode(LoadBalancerContext context)`:
1. If `context.AvailableNodes.Count == 0`: throw InvalidOperationException
2. Filter eligible nodes:
   - For each node in context.AvailableNodes:
     - If no health report OR report is stale (older than HealthReportStaleness): include with default weight (assume healthy)
     - If health report exists and fresh: check thresholds
       - Exclude if CpuUsage > CpuThresholdPercent
       - Exclude if MemoryUsage > MemoryThresholdPercent
       - Exclude if ActiveConnections > MaxActiveConnections
3. If all nodes excluded: fall back to ALL available nodes (never return empty -- safety net)
4. For each eligible node, compute weighted score:
   - `cpuScore = (100.0 - report.CpuUsage) / 100.0` (lower CPU = higher score)
   - `memScore = (100.0 - report.MemoryUsage) / 100.0`
   - `connScore = Math.Max(0, 1.0 - (report.ActiveConnections / (double)config.MaxActiveConnections))`
   - `latScore = Math.Max(0, 1.0 - (report.AverageLatency.TotalMilliseconds / 1000.0))` (normalize to 1s)
   - `compositeScore = cpuScore * config.CpuWeight + memScore * config.MemoryWeight + connScore * config.ConnectionsWeight + latScore * config.LatencyWeight`
   - If no health report: compositeScore = 0.5 (neutral)
5. Weighted random selection:
   - Sum all composite scores
   - Generate random value in [0, totalScore) using `RandomNumberGenerator.GetInt32` mapped to the range
   - Walk through nodes accumulating scores until random value falls in a node's range
   - Return that node
6. Edge case: if all scores are 0 (all nodes at threshold), select randomly with equal weight

`Task<ClusterNode> SelectNodeAsync(LoadBalancerContext context, CancellationToken ct)`:
- `ct.ThrowIfCancellationRequested();`
- `return Task.FromResult(SelectNode(context));`

Use `RandomNumberGenerator` for weighted random selection (CRYPTO-02 compliance). For the weighted random:
- Convert composite scores to integer range (multiply by 10000 and cast to int)
- Use `RandomNumberGenerator.GetInt32(0, totalWeight)` for uniform random in range
- Walk cumulative weights to find selected node

Thread safety: ConcurrentDictionary for health reports. SelectNode is stateless except health reports (read-only during selection, no locks needed).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify ResourceAwareLoadBalancer.cs exists. Grep for `ILoadBalancerStrategy` confirms interface. Grep for `AlgorithmName.*ResourceAware` confirms name. Grep for `CpuUsage|MemoryUsage` confirms health-based routing. Grep for `RandomNumberGenerator` confirms CSPRNG for weighted selection. Grep for threshold constants confirms configurable exclusion.
  </verify>
  <done>
ResourceAwareLoadBalancer implements ILoadBalancerStrategy with health-based weighted selection. Nodes above CPU/memory/connection thresholds are excluded. Remaining nodes selected via weighted random based on composite health score (CPU, memory, connections, latency with configurable weights). Stale health reports are treated as healthy. Safety fallback ensures selection never fails when nodes exist.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Three new files exist: ConsistentHashRing.cs, ConsistentHashLoadBalancer.cs, ResourceAwareLoadBalancer.cs
3. ConsistentHashRing implements IConsistentHashRing (GetNode, GetNodes, AddNode, RemoveNode, VirtualNodeCount)
4. ConsistentHashLoadBalancer implements ILoadBalancerStrategy with AlgorithmName "ConsistentHash"
5. ResourceAwareLoadBalancer implements ILoadBalancerStrategy with AlgorithmName "ResourceAware"
6. XxHash32 used for hashing (existing SDK dependency, no new NuGet packages)
7. ReaderWriterLockSlim used for ring thread safety
8. RandomNumberGenerator used for weighted random selection
9. Health report thresholds are configurable
10. Empty node list throws InvalidOperationException (matching InMemory behavior)
</verification>

<success_criteria>
- Consistent hash ring distributes keys uniformly with 150 virtual nodes per physical node
- Adding/removing a node affects minimal keys (consistent hashing property)
- GetNodes returns N distinct physical nodes for replication
- Resource-aware LB excludes overloaded nodes (>90% CPU/memory by default)
- Weighted selection favors healthier nodes
- Both LB strategies handle empty node lists consistently
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/29-advanced-distributed-coordination/29-04-SUMMARY.md`
</output>
