---
phase: 29-advanced-distributed-coordination
plan: 03
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtReplicationSync.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtRegistry.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs
autonomous: true

must_haves:
  truths:
    - "SyncAsync resolves conflicts using CRDT merge when ConflictResolutionStrategy is Merge"
    - "CRDT types (GCounter, PNCounter, LWWRegister, ORSet) merge correctly and idempotently"
    - "GCounter merge uses Math.Max per node, not sum (Pitfall 3)"
    - "ORSet uses add-set/remove-set with unique tags for observed-remove semantics"
    - "LWWRegister picks higher timestamp on merge"
    - "Data propagates to peers via IGossipProtocol epidemic spread"
    - "CrdtRegistry maps data keys to CRDT types with LWWRegister as default"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs"
      provides: "Four SDK-level CRDT types: SdkGCounter, SdkPNCounter, SdkLWWRegister, SdkORSet"
      min_lines: 200
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtRegistry.cs"
      provides: "CRDT type registry mapping data keys to CRDT types"
      min_lines: 40
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtReplicationSync.cs"
      provides: "IReplicationSync implementation with CRDT conflict resolution"
      min_lines: 200
  key_links:
    - from: "CrdtReplicationSync"
      to: "IGossipProtocol"
      via: "uses gossip for epidemic state propagation"
      pattern: "IGossipProtocol|_gossip|SpreadAsync"
    - from: "CrdtReplicationSync"
      to: "CrdtRegistry"
      via: "looks up CRDT type for data key to determine merge function"
      pattern: "CrdtRegistry|_registry|GetCrdtType"
    - from: "CrdtReplicationSync"
      to: "VectorClock"
      via: "uses existing SDK VectorClock for causality tracking"
      pattern: "VectorClock|Increment|HappensBefore|Merge"
    - from: "SdkCrdtTypes"
      to: "System.Text.Json"
      via: "serialization for network transport"
      pattern: "JsonSerializer|SerializeToUtf8Bytes|Deserialize"
---

<objective>
Implement multi-master replication with CRDT conflict resolution (DIST-14) as SDK-level classes.

Purpose: Enable concurrent writes from multiple nodes with deterministic, conflict-free merge. When two nodes write the same key concurrently, CRDT merge functions ensure all replicas converge to the same state without coordination. Uses the existing SDK `VectorClock` for causality tracking and `IGossipProtocol` for data propagation.

Output:
- Four SDK-level CRDT types: `SdkGCounter`, `SdkPNCounter`, `SdkLWWRegister`, `SdkORSet`
- `CrdtRegistry` mapping data keys to CRDT types
- `CrdtReplicationSync` implementing `IReplicationSync` with CRDT merge-based conflict resolution
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-advanced-distributed-coordination/29-RESEARCH.md
@.planning/phases/29-advanced-distributed-coordination/29-01-SUMMARY.md

@DataWarehouse.SDK/Contracts/Distributed/IReplicationSync.cs
@DataWarehouse.SDK/Contracts/Distributed/IP2PNetwork.cs
@DataWarehouse.SDK/Replication/IMultiMasterReplication.cs
@DataWarehouse.SDK/Infrastructure/InMemory/InMemoryReplicationSync.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SDK-Level CRDT Types and Registry</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs
    DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtRegistry.cs
  </files>
  <action>
Files go in `DataWarehouse.SDK/Infrastructure/Distributed/Replication/` (directory created in plan 29-01).

**File 1: SdkCrdtTypes.cs**

Namespace: `DataWarehouse.SDK.Infrastructure.Distributed`

Create `ICrdtType` interface:
```csharp
internal interface ICrdtType
{
    byte[] Serialize();
    ICrdtType Merge(ICrdtType other);
}
```

Note: Use non-generic interface because CRDT type is determined at runtime from CrdtRegistry. The self-referential generic (`ICrdtType<TSelf>` from research) won't work well with runtime dispatch. Keep it simple.

**SdkGCounter** (Grow-only counter -- Shapiro et al. 2011):
- Internal sealed class implementing ICrdtType
- `ConcurrentDictionary<string, long> _counts` -- per-node counts
- `long Value => _counts.Values.Sum()`
- `void Increment(string nodeId, long amount = 1)`: AddOrUpdate nodeId with +amount
- `ICrdtType Merge(ICrdtType other)`:
  - Cast other to SdkGCounter
  - Create new SdkGCounter
  - For each key: use `Math.Max(this._counts[key], other._counts[key])` -- NOT sum (Pitfall 3: merge must be idempotent)
  - Return new instance
- `byte[] Serialize()`: `JsonSerializer.SerializeToUtf8Bytes(dict)` where dict is snapshot of _counts
- `static SdkGCounter Deserialize(byte[] data)`: deserialize back to dictionary, populate _counts

**SdkPNCounter** (Positive-Negative counter):
- Internal sealed class implementing ICrdtType
- Two SdkGCounters internally: `_positive` and `_negative`
- `long Value => _positive.Value - _negative.Value`
- `void Increment(string nodeId, long amount = 1)`: increment _positive
- `void Decrement(string nodeId, long amount = 1)`: increment _negative
- `ICrdtType Merge(ICrdtType other)`: merge both _positive and _negative independently
- Serialize/Deserialize as JSON object with "p" and "n" fields

**SdkLWWRegister** (Last-Writer-Wins Register):
- Internal sealed class implementing ICrdtType
- `byte[] Value` (get; private set)
- `DateTimeOffset Timestamp` (get; private set)
- `string NodeId` (get; private set) -- tiebreaker for equal timestamps
- `void Set(byte[] value, string nodeId)`: set value with DateTimeOffset.UtcNow
- `ICrdtType Merge(ICrdtType other)`:
  - Cast other to SdkLWWRegister
  - If other.Timestamp > this.Timestamp: return other
  - If timestamps equal: use string comparison of NodeId as deterministic tiebreaker
  - Otherwise: return this
- Serialize: JSON with value (base64), timestamp, nodeId
- Deserialize: reconstruct from JSON

**SdkORSet** (Observed-Remove Set):
- Internal sealed class implementing ICrdtType
- `ConcurrentDictionary<string, HashSet<string>> _addSet` -- element -> set of unique tags
- `ConcurrentDictionary<string, HashSet<string>> _removeSet` -- element -> set of removed tags
- `IReadOnlySet<string> Elements`: elements where addSet[e] has tags NOT in removeSet[e]
- `void Add(string element, string nodeId)`: generate unique tag (nodeId + Guid), add to _addSet[element]
- `void Remove(string element)`: move all current tags for element from _addSet to _removeSet
- `ICrdtType Merge(ICrdtType other)`:
  - Union _addSet tags: for each element, union both sides' tag sets
  - Union _removeSet tags: for each element, union both sides' removed tag sets
  - Elements present = those with tags in addSet not in removeSet
- Serialize/Deserialize as JSON with addSet and removeSet

All CRDT types: thread-safe via ConcurrentDictionary. All Merge methods are commutative, associative, and idempotent. Mark all with `[SdkCompatibility("2.0.0", Notes = "Phase 29: CRDT types")]`.

**File 2: CrdtRegistry.cs**

Namespace: `DataWarehouse.SDK.Infrastructure.Distributed`

Create `CrdtRegistry` sealed class:
- `ConcurrentDictionary<string, Type> _registrations` -- key pattern -> CRDT type
- `ICrdtType DefaultType => typeof(SdkLWWRegister)` -- default when no pattern matches
- `void Register(string keyPattern, Type crdtType)`: register mapping (validate crdtType implements ICrdtType)
- `void RegisterPrefix(string prefix, Type crdtType)`: register all keys starting with prefix
- `Type GetCrdtType(string key)`: find matching registration (check prefix registrations first, then exact match, then default)
- `ICrdtType CreateInstance(string key)`: instantiate the CRDT type for the given key
- `ICrdtType Deserialize(string key, byte[] data)`: deserialize using the correct CRDT type for the key

Attribute: `[SdkCompatibility("2.0.0", Notes = "Phase 29: CRDT type registry")]`
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify SdkCrdtTypes.cs and CrdtRegistry.cs exist. Grep for `Math.Max` in SdkGCounter confirms correct merge (not sum). Grep for `ICrdtType` confirms interface. Grep for `ConcurrentDictionary` confirms thread safety.
  </verify>
  <done>
Four CRDT types implemented: SdkGCounter (per-node max merge), SdkPNCounter (two GCounters), SdkLWWRegister (timestamp-based), SdkORSet (add/remove tag sets). All merge functions are commutative, associative, and idempotent. CrdtRegistry maps data keys to CRDT types with LWWRegister as default. All types serializable via System.Text.Json.
  </done>
</task>

<task type="auto">
  <name>Task 2: CRDT Replication Sync</name>
  <files>
    DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtReplicationSync.cs
  </files>
  <action>
**File: CrdtReplicationSync.cs**

Create `CrdtReplicationSync` sealed class implementing `IReplicationSync`:
- Namespace: `DataWarehouse.SDK.Infrastructure.Distributed`
- Attribute: `[SdkCompatibility("2.0.0", Notes = "Phase 29: CRDT-based multi-master replication")]`

Use type aliases to avoid namespace collisions (follow InMemoryReplicationSync pattern):
```csharp
using SyncResult = DataWarehouse.SDK.Contracts.Distributed.SyncResult;
using SyncConflict = DataWarehouse.SDK.Contracts.Distributed.SyncConflict;
using ConflictResolutionResult = DataWarehouse.SDK.Contracts.Distributed.ConflictResolutionResult;
using ConflictResolutionStrategy = DataWarehouse.SDK.Contracts.Distributed.ConflictResolutionStrategy;
```

Constructor takes:
- `IGossipProtocol gossip` -- for epidemic data propagation
- `IClusterMembership membership` -- for node identity (vector clock node IDs)
- `CrdtRegistry registry` -- for key-to-CRDT-type mapping
- `CrdtReplicationSyncConfiguration? config = null`

`CrdtReplicationSyncConfiguration` record:
- `int MaxStoredItems` (default 100000) -- bounded data store
- `ConflictResolutionStrategy DefaultStrategy` (default Merge) -- for non-CRDT keys
- `int SyncBatchSize` (default 100) -- items per sync batch
- `int GossipPropagationIntervalMs` (default 1000) -- background propagation interval

Internal state:
- `ConcurrentDictionary<string, CrdtDataItem> _dataStore` -- bounded to MaxStoredItems
- `ConcurrentDictionary<string, SyncStatus> _syncStatuses` -- per-target-node sync status
- `VectorClock _localClock` -- from `DataWarehouse.SDK.Replication.VectorClock`

`CrdtDataItem` internal class:
- `string Key`
- `ICrdtType Value` -- the CRDT instance
- `VectorClock Clock` -- causality tracking
- `DateTimeOffset LastModified`

**Implement IReplicationSync:**

`SyncMode CurrentMode => SyncMode.Online` (CRDT replication is online/real-time)

`SyncAsync(SyncRequest request, CancellationToken ct)`:
1. Fire OnSyncEvent(SyncStarted)
2. Update sync status for target node to Syncing
3. Get items to sync (all items, or filtered by DataSetFilter/SinceTimestamp)
4. Batch items into groups of SyncBatchSize
5. For each batch: serialize items (key + CRDT serialized value + vector clock) to byte[], create GossipMessage, spread via `_gossip.SpreadAsync`
6. Track items synced and conflicts detected
7. Fire OnSyncEvent(SyncCompleted) on success, OnSyncEvent(SyncFailed) on error
8. Return SyncResult.Ok or SyncResult.Error

`GetSyncStatusAsync(string targetNodeId, CancellationToken ct)`:
- Return stored SyncStatus for target, or default Idle status

`ResolveConflictAsync(SyncConflict conflict, CancellationToken ct)`:
1. Determine strategy: check if key has CRDT type in registry
2. If CRDT type exists (strategy = Merge):
   - Deserialize LocalValue and RemoteValue as CRDT instances using registry
   - Call `local.Merge(remote)` to get resolved CRDT
   - Serialize resolved value
   - Return ConflictResolutionResult with Strategy = Merge
3. If no CRDT (fallback strategies):
   - LocalWins: return local value
   - RemoteWins: return remote value
   - LatestWins: compare timestamps, return newer
   - Custom: throw NotSupportedException (custom resolvers registered separately)

**Background gossip reception:**
- Subscribe to `_gossip.OnGossipReceived`
- When gossip message arrives: deserialize payload as list of CrdtDataItems
- For each item: look up local version in _dataStore
  - If no local version: store directly
  - If local version exists: check VectorClock causality
    - If remote HappensBefore local: skip (local is newer)
    - If local HappensBefore remote: replace with remote
    - If concurrent (neither happens-before): CRDT merge -- `local.Value.Merge(remote.Value)`, merge VectorClocks
  - Fire OnSyncEvent(ConflictDetected) when concurrent, OnSyncEvent(ConflictResolved) after merge

**Background propagation:**
- Use PeriodicTimer at GossipPropagationIntervalMs intervals
- Periodically select a batch of recently modified items and spread via gossip
- This ensures convergence even if explicit SyncAsync isn't called

**Data store bounding:**
- When _dataStore exceeds MaxStoredItems: evict oldest items (by LastModified) using bounded eviction
- Same pattern as Phase 23 bounded collections

Vector clock usage:
- On local writes: `_localClock = _localClock.Increment(selfNodeId)`
- Attach _localClock to each CrdtDataItem
- On merge: `VectorClock.Merge(local.Clock, remote.Clock)`

Implement IDisposable: cancel background tasks, dispose semaphores.

All async methods pass CancellationToken.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify CrdtReplicationSync.cs exists. Grep for `IReplicationSync` confirms interface implementation. Grep for `VectorClock` confirms causality tracking. Grep for `ICrdtType.*Merge` confirms CRDT merge usage. Grep for `SpreadAsync` confirms gossip propagation. Grep for `using SyncResult =` confirms type alias pattern.
  </verify>
  <done>
CrdtReplicationSync fully implements IReplicationSync with CRDT-based conflict resolution. SyncAsync propagates data via gossip. ResolveConflictAsync uses CRDT merge for Merge strategy, timestamp-based for LatestWins, and direct selection for LocalWins/RemoteWins. Background gossip reception handles incoming data with VectorClock causality checking and automatic CRDT merge on concurrent writes. Data store is bounded.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. Three new files exist: SdkCrdtTypes.cs, CrdtRegistry.cs, CrdtReplicationSync.cs
3. Four CRDT types implement ICrdtType with correct merge semantics
4. GCounter uses Math.Max (not sum) per node for merge
5. ORSet uses add/remove tag sets for observed-remove semantics
6. LWWRegister uses timestamp comparison with deterministic tiebreaker
7. CrdtReplicationSync implements IReplicationSync (SyncAsync, GetSyncStatusAsync, ResolveConflictAsync)
8. VectorClock from SDK.Replication used for causality tracking
9. Gossip protocol used for epidemic data propagation
10. All collections bounded, all async methods accept CancellationToken
</verification>

<success_criteria>
- CRDT merge is commutative, associative, and idempotent for all 4 types
- Concurrent writes from multiple nodes converge deterministically via CRDT merge
- CrdtRegistry allows per-key CRDT type selection with LWWRegister as default
- Data propagates epidemically via IGossipProtocol
- VectorClock causality prevents unnecessary merge operations
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/29-advanced-distributed-coordination/29-03-SUMMARY.md`
</output>
