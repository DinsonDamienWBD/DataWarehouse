---
phase: 60-semantic-sync
plan: 08
type: execute
wave: 4
depends_on: ["60-02", "60-03", "60-04", "60-05", "60-06", "60-07"]
files_modified:
  - Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Orchestration/SemanticSyncOrchestrator.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Orchestration/SyncPipeline.cs
autonomous: true

must_haves:
  truths:
    - "Plugin wires all strategies together into a working end-to-end sync pipeline"
    - "Message bus subscriptions route classify/route/conflict/fidelity requests to correct strategies"
    - "Sync pipeline processes data through classify -> fidelity -> route -> sync -> conflict-resolve"
    - "Plugin initializes all strategies with proper dependency injection"
    - "Full solution builds with zero errors including the new plugin"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs"
      provides: "Fully wired plugin with all strategy registrations"
      contains: "RegisterStrategy"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Orchestration/SemanticSyncOrchestrator.cs"
      provides: "End-to-end semantic sync orchestration"
      contains: "class SemanticSyncOrchestrator"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Orchestration/SyncPipeline.cs"
      provides: "Pipeline definition: classify -> decide fidelity -> route -> sync"
      contains: "class SyncPipeline"
  key_links:
    - from: "SemanticSyncPlugin.cs"
      to: "All strategy classes from Plans 03-07"
      via: "strategy registration in InitializeAsync"
      pattern: "RegisterStrategy.*classifier|RegisterStrategy.*router|RegisterStrategy.*resolver|RegisterStrategy.*fidelity|RegisterStrategy.*inference"
    - from: "SemanticSyncOrchestrator"
      to: "SyncPipeline"
      via: "orchestrator executes pipeline per sync request"
      pattern: "SyncPipeline.*Execute"
    - from: "SemanticSyncPlugin.cs"
      to: "message bus topics"
      via: "SubscribeAsync for semantic-sync.* topics"
      pattern: "semantic-sync\\."
---

<objective>
Wire all strategies from Plans 03-07 into the SemanticSync plugin and build the orchestration pipeline that processes sync requests end-to-end.

Purpose: This is the integration plan that turns individual strategies into a working system. The plugin registers all strategies, the orchestrator coordinates the pipeline (classify -> decide fidelity -> route summary-vs-raw -> sync -> resolve conflicts), and message bus subscriptions make it accessible to other plugins (UltimateReplication, AdaptiveTransport, UltimateEdgeComputing).

Output: Updated plugin class + 2 new orchestration files
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/60-semantic-sync/60-01-SUMMARY.md
@.planning/phases/60-semantic-sync/60-02-SUMMARY.md
@.planning/phases/60-semantic-sync/60-03-SUMMARY.md
@.planning/phases/60-semantic-sync/60-04-SUMMARY.md
@.planning/phases/60-semantic-sync/60-05-SUMMARY.md
@.planning/phases/60-semantic-sync/60-06-SUMMARY.md
@.planning/phases/60-semantic-sync/60-07-SUMMARY.md
@Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sync Pipeline and Orchestrator</name>
  <files>
    Plugins/DataWarehouse.Plugins.SemanticSync/Orchestration/SyncPipeline.cs
    Plugins/DataWarehouse.Plugins.SemanticSync/Orchestration/SemanticSyncOrchestrator.cs
  </files>
  <action>
**SyncPipeline.cs:**
- Internal class defining the sync processing pipeline
- Constructor takes: `ISemanticClassifier classifier, ISyncFidelityController fidelityController, ISummaryRouter router, ISemanticConflictResolver conflictResolver, EdgeInferenceCoordinator edgeInference`

**Pipeline stages (executed in order):**

`Task<SyncPipelineResult> ExecuteAsync(string dataId, ReadOnlyMemory<byte> data, IDictionary<string, string>? metadata, CancellationToken ct)`:

1. **Classify**: If edge inference available and SupportsLocalInference, use EdgeInferenceCoordinator.InferAsync. Otherwise use classifier.ClassifyAsync. Result: SemanticClassification.

2. **Decide Fidelity**: Call fidelityController.DecideFidelityAsync with classification and current budget. If decision says Defer, return SyncPipelineResult with Status=Deferred and DeferUntil.

3. **Route**: Call router.RouteAsync to confirm/adjust fidelity decision. If RequiresSummary=true, call router.GenerateSummaryAsync to create summary. Payload becomes either raw data, downsampled data, or summary.

4. **Prepare Payload**: Build the sync payload (the actual bytes to send). If fidelity < Full, use the router/downsampler output. Track estimated vs actual size.

5. **Return** SyncPipelineResult: `sealed record SyncPipelineResult(string DataId, SyncPipelineStatus Status, SemanticClassification Classification, SyncDecision Decision, ReadOnlyMemory<byte> Payload, DataSummary? Summary, long OriginalSizeBytes, long PayloadSizeBytes, double CompressionRatio, TimeSpan ProcessingTime)` where Status is enum: Ready, Deferred, Failed.

**Conflict path** (called separately when sync detects conflict):
`Task<ConflictResolutionResult> ResolveConflictAsync(string dataId, ReadOnlyMemory<byte> localData, ReadOnlyMemory<byte> remoteData, CancellationToken ct)`:
1. Detect conflict via conflictResolver.DetectConflictAsync
2. If no conflict detected, return auto-resolve with local data
3. Classify conflict via conflictResolver.ClassifyConflictAsync
4. Resolve via conflictResolver.ResolveAsync
5. If resolution is DeferToUser, publish to `semantic-sync.conflict.pending` topic

**SemanticSyncOrchestrator.cs:**
- Internal class that manages concurrent sync operations
- Uses `Channel<SyncRequest>` for async work queue (System.Threading.Channels)
- `SyncRequest` record: `(string DataId, ReadOnlyMemory<byte> Data, IDictionary<string, string>? Metadata, TaskCompletionSource<SyncPipelineResult> Completion)`
- `Task<SyncPipelineResult> SubmitSyncAsync(string dataId, ReadOnlyMemory<byte> data, IDictionary<string, string>? metadata, CancellationToken ct)`: Enqueue request, await completion
- Background worker loop (started in StartAsync, stopped in StopAsync): reads from channel, executes pipeline, records bandwidth consumption to fidelity controller
- Concurrency: configurable max concurrent syncs (default 4), uses SemaphoreSlim
- Deferred items: maintains a `ConcurrentQueue<(SyncRequest, DateTimeOffset DeferUntil)>` — a Timer re-enqueues deferred items when their DeferUntil expires
- Metrics: track total syncs, total bytes saved (original - payload), average compression ratio
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>Pipeline and orchestrator compile, pipeline processes 5 stages in order, orchestrator manages concurrent syncs via Channel</done>
</task>

<task type="auto">
  <name>Task 2: Wire Plugin with All Strategies and Message Bus</name>
  <files>Plugins/DataWarehouse.Plugins.SemanticSync/SemanticSyncPlugin.cs</files>
  <action>
Update the SemanticSyncPlugin.cs (created in Plan 02) to wire everything together:

**In InitializeAsync:**
1. Create helper instances:
   - `var localModelManager = new LocalModelManager()` — load default model
   - `var budgetTracker = new BandwidthBudgetTracker()`
   - Create `FidelityPolicy` with defaults
   - `var policyEngine = new FidelityPolicyEngine(defaultPolicy)`

2. Create strategies (dependency injection by construction):
   - `var embeddingClassifier = new EmbeddingClassifier(aiProvider)` where aiProvider is resolved from kernel services (null if unavailable)
   - `var ruleClassifier = new RuleBasedClassifier()`
   - `var hybridClassifier = new HybridClassifier(embeddingClassifier, ruleClassifier, 0.7)`
   - `var summaryGenerator = new SummaryGenerator(aiProvider)`
   - `var downsampler = new FidelityDownsampler()`
   - `var summaryRouter = new BandwidthAwareSummaryRouter(summaryGenerator, downsampler)`
   - `var similarityDetector = new EmbeddingSimilarityDetector(aiProvider)`
   - `var conflictEngine = new ConflictClassificationEngine()`
   - `var conflictResolver = new SemanticMergeResolver(similarityDetector, conflictEngine)`
   - `var fidelityController = new AdaptiveFidelityController(budgetTracker, policyEngine)`
   - `var edgeInference = new EdgeInferenceCoordinator(localModelManager, hybridClassifier)`
   - `var federatedLearner = new FederatedSyncLearner(localModelManager)`

3. Register all strategies via RegisterStrategy():
   - `"classifier-embedding"` -> embeddingClassifier
   - `"classifier-rules"` -> ruleClassifier
   - `"classifier-hybrid"` -> hybridClassifier
   - `"router-summary"` -> summaryRouter
   - `"resolver-semantic"` -> conflictResolver
   - `"fidelity-adaptive"` -> fidelityController
   - `"edge-inference"` -> edgeInference

4. Create pipeline and orchestrator:
   - `var pipeline = new SyncPipeline(hybridClassifier, fidelityController, summaryRouter, conflictResolver, edgeInference)`
   - `var orchestrator = new SemanticSyncOrchestrator(pipeline)` — store as field
   - Start orchestrator background worker

5. Subscribe to message bus topics:
   - `semantic-sync.classify` -> classify via hybridClassifier, publish result to `semantic-sync.classified`
   - `semantic-sync.route` -> route via summaryRouter, publish to `semantic-sync.routed`
   - `semantic-sync.conflict` -> resolve via conflictResolver, publish to `semantic-sync.resolved`
   - `semantic-sync.fidelity.update` -> update bandwidth via fidelityController
   - `semantic-sync.sync-request` -> submit to orchestrator, publish result to `semantic-sync.sync-complete`
   - `federated-learning.model-aggregated` -> forward to federatedLearner.OnAggregatedModelReceivedAsync

**In ShutdownAsync:** Stop orchestrator, dispose all strategies, unsubscribe from topics.

**Resolve IAIProvider:** Try to get from kernel service registry. If not available (edge/air-gapped), pass null — all strategies handle null AI provider gracefully.

**Full solution build verification:** After wiring, ensure `dotnet build DataWarehouse.slnx` succeeds with zero errors.
  </action>
  <verify>dotnet build DataWarehouse.slnx 2>&1 | grep -E "(error|Error|Build succeeded)" | head -5</verify>
  <done>Full solution builds with zero errors, plugin registers 7 strategies, subscribes to 6 message bus topics, orchestrator processes sync requests end-to-end</done>
</task>

</tasks>

<verification>
- Full solution `dotnet build DataWarehouse.slnx` succeeds with zero errors
- SemanticSyncPlugin.InitializeAsync creates and registers all 7 strategies
- Message bus subscriptions exist for all 6 semantic-sync.* topics
- SyncPipeline executes classify -> fidelity -> route -> prepare stages
- SemanticSyncOrchestrator uses Channel for async work queue
- No direct plugin-to-plugin references (all communication via message bus)
- AI provider is optional (null-safe throughout)
</verification>

<success_criteria>
- End-to-end semantic sync pipeline processes data from classification through sync decision
- All strategies from Plans 03-07 are instantiated and wired correctly
- Message bus enables other plugins (UltimateReplication, AdaptiveTransport) to trigger semantic sync
- Full solution compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/60-semantic-sync/60-08-SUMMARY.md`
</output>
