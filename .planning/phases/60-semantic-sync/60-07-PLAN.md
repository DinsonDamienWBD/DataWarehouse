---
phase: 60-semantic-sync
plan: 07
type: execute
wave: 3
depends_on: ["60-01", "60-02", "60-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/EdgeInferenceCoordinator.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/LocalModelManager.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/FederatedSyncLearner.cs
autonomous: true

must_haves:
  truths:
    - "Edge nodes run local inference models for sync decisions without cloud connectivity"
    - "Local model manager handles model lifecycle: load, run, update, rollback"
    - "Federated learning improves classification models across edge nodes without sharing raw data"
    - "Edge inference integrates with classification strategies from Plan 03"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/EdgeInferenceCoordinator.cs"
      provides: "Coordinates local inference on edge nodes"
      contains: "class EdgeInferenceCoordinator : SemanticSyncStrategyBase"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/LocalModelManager.cs"
      provides: "Manages inference model lifecycle on edge"
      contains: "class LocalModelManager"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/FederatedSyncLearner.cs"
      provides: "Federated learning coordinator for sync model improvement"
      contains: "class FederatedSyncLearner"
  key_links:
    - from: "EdgeInferenceCoordinator"
      to: "LocalModelManager"
      via: "composition — coordinator uses manager for model access"
      pattern: "LocalModelManager.*GetModel"
    - from: "EdgeInferenceCoordinator"
      to: "ISemanticClassifier"
      via: "uses classifier interface for inference"
      pattern: "ISemanticClassifier.*Classify"
    - from: "FederatedSyncLearner"
      to: "FederatedLearningOrchestrator"
      via: "integrates with existing UltimateEdgeComputing federated learning"
      pattern: "FederatedLearning"
---

<objective>
Wire edge inference into the semantic sync protocol so edge nodes can make intelligent sync decisions locally, and improve their models over time through federated learning.

Purpose: Edge nodes cannot always reach the cloud for AI inference. The EdgeInferenceCoordinator runs local models to classify data and make sync decisions at the edge. The LocalModelManager handles model versioning, loading, and fallback. The FederatedSyncLearner connects to the existing FederatedLearningOrchestrator in UltimateEdgeComputing to improve edge classification models without sharing raw data across nodes.

Output: 3 files in Strategies/EdgeInference/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/60-semantic-sync/60-01-SUMMARY.md
@.planning/phases/60-semantic-sync/60-03-SUMMARY.md
@DataWarehouse.SDK/Contracts/SemanticSync/SemanticSyncModels.cs
@DataWarehouse.SDK/Contracts/SemanticSync/ISemanticClassifier.cs
@DataWarehouse.SDK/Contracts/EdgeComputing/IEdgeComputingStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/Strategies/FederatedLearning/FederatedLearningOrchestrator.cs
@Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/Strategies/FederatedLearning/FederatedLearningModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Local Model Manager</name>
  <files>Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/LocalModelManager.cs</files>
  <action>
**LocalModelManager.cs:**
- Internal class for managing inference model lifecycle on edge nodes
- Concept: a "model" here is represented as a set of reference embeddings (centroid vectors per importance level) + classification thresholds + domain-specific rules. This is NOT a neural network — it's a lightweight model that can run on any edge device.

**Model representation:**
- `sealed record SyncInferenceModel(string ModelId, string Version, float[][] ImportanceCentroids, Dictionary<string, double> ClassificationThresholds, Dictionary<string, string[]> DomainRules, DateTimeOffset TrainedAt, int TrainingSampleCount)`
- ImportanceCentroids: 5 arrays (one per SemanticImportance level), each a float[] embedding centroid
- ClassificationThresholds: similarity thresholds for each importance boundary
- DomainRules: domain-hint to tag mappings for rule-based enhancement

**Manager methods:**
- `SyncInferenceModel? GetCurrentModel()`: Return cached model, null if none loaded
- `Task LoadModelAsync(ReadOnlyMemory<byte> serializedModel, CancellationToken ct)`: Deserialize model from bytes (JSON format via System.Text.Json), validate centroids dimensionality matches, store as current. Keep previous as rollback.
- `Task<ReadOnlyMemory<byte>> SerializeModelAsync(SyncInferenceModel model, CancellationToken ct)`: Serialize to JSON bytes for transport
- `void RollbackModel()`: Replace current with previous version (if exists)
- `SyncInferenceModel CreateDefaultModel()`: Create a baseline model with 8-dimensional centroids (actual normalized vectors, NOT zeros). Critical=[0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2], High=[0.7,...], etc. — meaningful initial values that provide reasonable classification before any training.
- `SyncInferenceModel UpdateCentroids(SyncInferenceModel model, SemanticImportance importance, float[] newEmbedding, double learningRate)`: Online update — shift the importance centroid toward the new embedding by learningRate. Formula: newCentroid[i] = (1-lr)*old[i] + lr*new[i], then normalize. Returns new model with updated centroid.

Thread-safe: use ReaderWriterLockSlim for model swap (reads are concurrent, writes are exclusive).
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>LocalModelManager compiles, model representation is lightweight (centroid vectors), online update uses learning rate formula</done>
</task>

<task type="auto">
  <name>Task 2: Edge Inference Coordinator and Federated Sync Learner</name>
  <files>
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/EdgeInferenceCoordinator.cs
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/EdgeInference/FederatedSyncLearner.cs
  </files>
  <action>
**EdgeInferenceCoordinator.cs:**
- Class: `EdgeInferenceCoordinator : SemanticSyncStrategyBase`
- StrategyId: `"edge-inference-coordinator"`, Name: `"Edge Inference Coordinator"`
- SemanticDomain: `"universal"`, SupportsLocalInference: true
- Constructor takes `LocalModelManager` and optional `ISemanticClassifier` (the hybrid classifier from Plan 03 as cloud fallback)

**Core method:** `Task<EdgeInferenceResult> InferAsync(string dataId, ReadOnlyMemory<byte> data, IDictionary<string, string>? metadata, CancellationToken ct)`:
1. Try local model first: Get model from LocalModelManager
2. If model available:
   a. Compute similarity of data embedding against each importance centroid (use inherited ComputeCosineSimilarity)
   b. For embedding: if IAIProvider available, get embeddings; else hash data to pseudo-embedding (deterministic SHA256 -> float[8] via BitConverter)
   c. Pick the importance level with highest similarity above threshold
   d. Build SyncDecision using model's rules: Critical/High = Full, Normal = Standard, Low = Summarized, Negligible = Metadata
   e. Record inference latency, mark UsedLocalModel = true
3. If no local model AND cloud classifier available: delegate to cloud classifier, mark UsedLocalModel = false
4. If neither: use rule-based defaults (Normal importance, Standard fidelity), mark UsedLocalModel = false
5. Return EdgeInferenceResult with all fields

**FederatedSyncLearner.cs:**
- Internal class that connects semantic sync model improvement to the existing federated learning infrastructure
- Constructor takes `LocalModelManager`
- Communication pattern: via message bus topics (NOT direct plugin reference). Publishes to `federated-learning.gradient-update` and subscribes to `federated-learning.model-aggregated`.

**Methods:**
- `Task SubmitLocalGradientAsync(SemanticImportance label, float[] embedding, CancellationToken ct)`:
  1. Compute gradient: difference between current centroid for this importance and the new embedding
  2. Apply differential privacy: add Laplace noise (epsilon=1.0) to gradient before sharing (privacy-preserving)
  3. Package as gradient update message and publish to `federated-learning.gradient-update` topic
  4. Locally update model via LocalModelManager.UpdateCentroids with small learning rate (0.01)

- `Task OnAggregatedModelReceivedAsync(ReadOnlyMemory<byte> aggregatedModel, CancellationToken ct)`:
  1. Deserialize the aggregated model
  2. Validate dimensionality matches local model
  3. Load as new current model via LocalModelManager.LoadModelAsync
  4. Log model version update

- `Task<ReadOnlyMemory<byte>> ExportGradientsAsync(CancellationToken ct)`:
  Export local gradient accumulator as bytes for federated aggregation (the existing FederatedLearningOrchestrator in UltimateEdgeComputing handles the actual aggregation across nodes)

Note: This class does NOT import UltimateEdgeComputing directly — it communicates via message bus topics only (plugin isolation rule). The UltimateEdgeComputing plugin's FederatedLearningOrchestrator subscribes to `federated-learning.gradient-update` and publishes `federated-learning.model-aggregated`.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>EdgeInferenceCoordinator compiles with local-first inference, FederatedSyncLearner uses message bus topics (no direct plugin references), differential privacy applied to gradients</done>
</task>

</tasks>

<verification>
- All 3 files compile in plugin project
- No direct references to UltimateEdgeComputing plugin (grep confirms no `using DataWarehouse.Plugins.UltimateEdgeComputing`)
- EdgeInferenceCoordinator tries local model first, then cloud fallback
- FederatedSyncLearner communicates via message bus topic strings only
- Differential privacy noise added to gradients before sharing
- LocalModelManager has real centroid update formula (not a stub)
</verification>

<success_criteria>
- Edge nodes can classify data locally without cloud connectivity
- Local models improve over time through federated learning
- Privacy preserved: only noisy gradients shared, never raw data
- Graceful degradation: local model -> cloud classifier -> rule-based defaults
</success_criteria>

<output>
After completion, create `.planning/phases/60-semantic-sync/60-07-SUMMARY.md`
</output>
