---
phase: 60-semantic-sync
plan: 06
type: execute
wave: 3
depends_on: ["60-01", "60-02", "60-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/AdaptiveFidelityController.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/BandwidthBudgetTracker.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/FidelityPolicyEngine.cs
autonomous: true

must_haves:
  truths:
    - "Sync fidelity adjusts dynamically based on real-time bandwidth measurements"
    - "Budget tracker maintains running tallies of bandwidth consumption per fidelity level"
    - "Policy engine enforces minimum fidelity for critical data regardless of bandwidth"
    - "Fidelity decisions integrate classification output from Plan 03 classifiers"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/AdaptiveFidelityController.cs"
      provides: "Dynamic fidelity control strategy"
      contains: "class AdaptiveFidelityController : SemanticSyncStrategyBase, ISyncFidelityController"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/BandwidthBudgetTracker.cs"
      provides: "Real-time bandwidth budget accounting"
      contains: "class BandwidthBudgetTracker"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/FidelityPolicyEngine.cs"
      provides: "Policy enforcement for fidelity decisions"
      contains: "class FidelityPolicyEngine"
  key_links:
    - from: "AdaptiveFidelityController"
      to: "BandwidthBudgetTracker"
      via: "composition — controller queries tracker for budget state"
      pattern: "BandwidthBudgetTracker.*GetBudget"
    - from: "AdaptiveFidelityController"
      to: "FidelityPolicyEngine"
      via: "composition — controller applies policy constraints"
      pattern: "FidelityPolicyEngine.*Apply"
---

<objective>
Implement the bandwidth-aware fidelity controller that dynamically adjusts sync quality based on real-time network conditions and policy constraints.

Purpose: This is the "throttle" for the entire sync protocol. When bandwidth drops, it automatically reduces fidelity for lower-importance data while maintaining full fidelity for critical items. The budget tracker prevents bandwidth over-commitment. The policy engine ensures compliance requirements are never violated (e.g., audit data always syncs at minimum Standard fidelity).

Output: 3 files in Strategies/Fidelity/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/60-semantic-sync/60-01-SUMMARY.md
@.planning/phases/60-semantic-sync/60-03-SUMMARY.md
@DataWarehouse.SDK/Contracts/SemanticSync/ISyncFidelityController.cs
@DataWarehouse.SDK/Contracts/SemanticSync/SemanticSyncModels.cs
@Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthModels.cs
@Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/SyncParameterAdjuster.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bandwidth Budget Tracker and Policy Engine</name>
  <files>
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/BandwidthBudgetTracker.cs
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/FidelityPolicyEngine.cs
  </files>
  <action>
**BandwidthBudgetTracker.cs:**
- Internal thread-safe class for real-time bandwidth accounting
- Fields: `long _currentBandwidthBps` (volatile), `ConcurrentDictionary<SyncFidelity, long> _bytesConsumedByFidelity`, `int _pendingSyncCount` (Interlocked), `long _windowStartTicks`, `long _windowBytesConsumed`
- `void UpdateBandwidth(long currentBps)`: Update current bandwidth, reset window if >60s old
- `void RecordConsumption(SyncFidelity fidelity, long bytes)`: Track bytes consumed per fidelity level, increment window consumption
- `void RecordSyncQueued()` / `void RecordSyncCompleted()`: Interlocked increment/decrement of pending count
- `FidelityBudget GetCurrentBudget()`: Compute and return FidelityBudget from current state. BudgetUtilizationPercent = windowBytesConsumed / (currentBandwidthBps * 60) * 100 (percentage of 60-second window used). FidelityDistribution from _bytesConsumedByFidelity.
- `double GetRemainingCapacityPercent()`: 100 - BudgetUtilizationPercent, clamped to 0-100
- Thread-safe throughout using Interlocked and ConcurrentDictionary (NO locks, production-grade concurrency)

**FidelityPolicyEngine.cs:**
- Internal class for policy enforcement
- Constructor takes `FidelityPolicy` (defined in ISyncFidelityController.cs)
- `SyncFidelity ApplyPolicy(SemanticClassification classification, SyncFidelity proposedFidelity)`:
  1. If classification.Importance == Critical: enforce MinFidelityForCritical from policy (never go below it, even if bandwidth says Metadata)
  2. If classification.SemanticTags contains "compliance" or "audit": enforce minimum Standard fidelity
  3. If classification.SemanticTags contains "security" or "encryption": enforce minimum Detailed fidelity
  4. Otherwise: return proposedFidelity or DefaultFidelity from policy (whichever is lower fidelity — budget-conscious)
  5. Never return a fidelity HIGHER than proposed (policy can only constrain downward degradation, not upgrade)
- `SyncFidelity GetFidelityForBandwidth(long bandwidthBps)`: Look up in BandwidthThresholds dictionary (sorted descending), return the fidelity for the first threshold the bandwidth exceeds. If below all thresholds, return Metadata.
- `bool ShouldDefer(SemanticClassification classification, FidelityBudget budget)`: Return true if budget utilization > 90% AND importance is Negligible or Low — defer low-value syncs when budget is exhausted
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>Both classes compile, BandwidthBudgetTracker is lock-free thread-safe, FidelityPolicyEngine enforces minimum fidelity constraints</done>
</task>

<task type="auto">
  <name>Task 2: Adaptive Fidelity Controller Strategy</name>
  <files>Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Fidelity/AdaptiveFidelityController.cs</files>
  <action>
**AdaptiveFidelityController.cs:**
- Class: `AdaptiveFidelityController : SemanticSyncStrategyBase, ISyncFidelityController`
- StrategyId: `"fidelity-controller-adaptive"`, Name: `"Adaptive Fidelity Controller"`
- Constructor takes `BandwidthBudgetTracker` and `FidelityPolicyEngine`
- Private field: `FidelityPolicy _currentPolicy` with sensible defaults:
  - MinFidelityForCritical = Standard
  - DefaultFidelity = Standard
  - BandwidthThresholds = { 100_000_000 -> Full, 10_000_000 -> Detailed, 1_000_000 -> Standard, 100_000 -> Summarized, 0 -> Metadata }
  - MaxDeferDuration = 15 minutes

**DecideFidelityAsync:**
1. Get bandwidth-based fidelity from policy engine: `_policyEngine.GetFidelityForBandwidth(budget.AvailableBandwidthBps)`
2. Check if should defer: if `_policyEngine.ShouldDefer(classification, budget)`, return SyncDecision with DeferUntil = now + MaxDeferDuration
3. Apply policy constraints: `_policyEngine.ApplyPolicy(classification, bandwidthFidelity)` — this enforces minimums for critical/compliance data
4. Estimate size: base size * fidelity ratio (Full=1.0, Detailed=0.8, Standard=0.5, Summarized=0.15, Metadata=0.02)
5. Check if estimated size fits remaining budget capacity:
   - If budget remaining > 50%: use policy-adjusted fidelity
   - If budget remaining 20-50%: drop one fidelity level (unless policy prevents it)
   - If budget remaining < 20%: drop to minimum policy allows
6. Build and return SyncDecision with all fields

**GetCurrentBudgetAsync:** Delegate to tracker.GetCurrentBudget()

**UpdateBandwidthAsync:** Delegate to tracker.UpdateBandwidth()

**SetPolicyAsync:** Update _currentPolicy and recreate FidelityPolicyEngine with new policy
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>AdaptiveFidelityController compiles, implements ISyncFidelityController, makes budget-aware decisions with policy enforcement</done>
</task>

</tasks>

<verification>
- All 3 files compile in plugin project
- AdaptiveFidelityController implements ISyncFidelityController
- BandwidthBudgetTracker uses Interlocked/ConcurrentDictionary (no lock statements)
- Policy engine enforces Critical data minimum fidelity (grep for MinFidelityForCritical)
- Budget-aware degradation has 3 tiers (>50%, 20-50%, <20%)
- Defer logic works for low-importance items when budget exhausted
</verification>

<success_criteria>
- Dynamic fidelity adjustment responds to bandwidth changes in real-time
- Critical data never drops below configured minimum fidelity
- Compliance/audit tagged data maintains Standard+ fidelity
- Budget tracking prevents bandwidth over-commitment
</success_criteria>

<output>
After completion, create `.planning/phases/60-semantic-sync/60-06-SUMMARY.md`
</output>
