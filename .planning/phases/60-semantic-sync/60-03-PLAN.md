---
phase: 60-semantic-sync
plan: 03
type: execute
wave: 2
depends_on: ["60-01", "60-02"]
files_modified:
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/EmbeddingClassifier.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/RuleBasedClassifier.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/HybridClassifier.cs
autonomous: true

must_haves:
  truths:
    - "Data can be classified by semantic importance using AI embeddings"
    - "A rule-based fallback classifier works without AI provider availability"
    - "A hybrid classifier combines both approaches with configurable weighting"
    - "Classification outputs include confidence scores and semantic tags"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/EmbeddingClassifier.cs"
      provides: "AI embedding-based semantic classification"
      contains: "class EmbeddingClassifier : SemanticSyncStrategyBase, ISemanticClassifier"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/RuleBasedClassifier.cs"
      provides: "Metadata/heuristic-based fallback classification"
      contains: "class RuleBasedClassifier : SemanticSyncStrategyBase, ISemanticClassifier"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/HybridClassifier.cs"
      provides: "Weighted combination of embedding + rule-based classification"
      contains: "class HybridClassifier : SemanticSyncStrategyBase, ISemanticClassifier"
  key_links:
    - from: "EmbeddingClassifier"
      to: "IAIProvider.GetEmbeddingsAsync"
      via: "constructor injection of IAIProvider"
      pattern: "IAIProvider.*GetEmbeddings"
    - from: "HybridClassifier"
      to: "EmbeddingClassifier + RuleBasedClassifier"
      via: "composition — takes both classifiers"
      pattern: "ISemanticClassifier.*embedding.*ISemanticClassifier.*rule"
---

<objective>
Implement three semantic classification strategies that analyze data content and assign importance levels. This is the "brain" that decides WHAT matters.

Purpose: Edge AI classification is the foundation of the entire semantic sync protocol. Without knowing what data is critical vs. negligible, no intelligent sync decisions can be made. The three-strategy approach (embedding, rule-based, hybrid) ensures classification works across all environments — from cloud with full AI to air-gapped edge with no AI provider.

Output: 3 strategy files in Strategies/Classification/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/60-semantic-sync/60-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/SemanticSync/SemanticSyncModels.cs
@DataWarehouse.SDK/Contracts/SemanticSync/ISemanticClassifier.cs
@DataWarehouse.SDK/Contracts/SemanticSync/SemanticSyncStrategyBase.cs
@DataWarehouse.SDK/AI/IAIProvider.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Embedding and Rule-Based Classifiers</name>
  <files>
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/EmbeddingClassifier.cs
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/RuleBasedClassifier.cs
  </files>
  <action>
**EmbeddingClassifier.cs:**
- Class: `EmbeddingClassifier : SemanticSyncStrategyBase, ISemanticClassifier`
- StrategyId: `"semantic-classifier-embedding"`, Name: `"Embedding-Based Semantic Classifier"`
- SemanticDomain: `"universal"`, SupportsLocalInference: true
- Constructor takes `IAIProvider` (from SDK.AI) — the plugin injects this, NOT the strategy resolving it
- `ClassifyAsync`: Get embeddings via `IAIProvider.GetEmbeddingsAsync`, compute cosine similarity against reference embeddings for each importance level (Critical/High/Normal/Low/Negligible), return the best match with confidence score. Reference embeddings are pre-computed centroids stored as `static readonly float[][]` arrays (actual vectors, NOT placeholders — use representative 8-dimension normalized vectors for each importance level as a production baseline that gets refined by federated learning). Extract semantic tags from metadata keys if available.
- `ClassifyBatchAsync`: Batch embeddings via `GetEmbeddingsBatchAsync`, process in parallel with `Task.WhenAll`
- `ComputeSemanticSimilarityAsync`: Get embeddings for both items, compute cosine similarity using the inherited `ComputeCosineSimilarity` helper
- Capabilities: SupportsEmbeddings=true, SupportsLocalInference=true, SupportsDomainHints=true, MaxBatchSize=100

**RuleBasedClassifier.cs:**
- Class: `RuleBasedClassifier : SemanticSyncStrategyBase, ISemanticClassifier`
- StrategyId: `"semantic-classifier-rules"`, Name: `"Rule-Based Semantic Classifier"`
- SemanticDomain: `"universal"`, SupportsLocalInference: true (no AI needed)
- NO IAIProvider dependency — works purely on metadata heuristics
- `ClassifyAsync`: Classify based on metadata inspection:
  - File size: >100MB = High, <1KB = Low
  - Content-Type: "application/json" with "schema" or "config" = Critical; media types = Normal
  - Metadata tags: "compliance", "audit", "security" = Critical; "log", "temp", "cache" = Negligible
  - Recency: modified <1h ago = bump importance by 1 level; >30d ago = drop by 1
  - Access frequency (from metadata "access_count"): >100 = High, <5 = Low
  - Confidence is always 0.6-0.8 range (heuristic-based, never claims high confidence)
- `ClassifyBatchAsync`: Sequential iteration (no AI batching benefit)
- `ComputeSemanticSimilarityAsync`: Simple Jaccard similarity on metadata key-value pairs (production implementation, NOT placeholder)
- Capabilities: SupportsEmbeddings=false, SupportsLocalInference=true, SupportsDomainHints=false, MaxBatchSize=1000
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>Both classifiers compile, implement ISemanticClassifier, extend SemanticSyncStrategyBase</done>
</task>

<task type="auto">
  <name>Task 2: Hybrid Classifier with Weighted Fusion</name>
  <files>Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/Classification/HybridClassifier.cs</files>
  <action>
**HybridClassifier.cs:**
- Class: `HybridClassifier : SemanticSyncStrategyBase, ISemanticClassifier`
- StrategyId: `"semantic-classifier-hybrid"`, Name: `"Hybrid Semantic Classifier"`
- SemanticDomain: `"universal"`, SupportsLocalInference: true
- Constructor takes two `ISemanticClassifier` instances (embedding + rule-based) and a `double embeddingWeight` (0.0-1.0, default 0.7)
- `ClassifyAsync`:
  1. Run both classifiers in parallel via `Task.WhenAll`
  2. If embedding classifier throws (AI unavailable), fall back to rule-based only with its confidence
  3. Otherwise, weighted fusion: compute final importance as weighted average of ordinal values (Critical=4, High=3, Normal=2, Low=1, Negligible=0), round to nearest enum value
  4. Combined confidence = embeddingWeight * embeddingConfidence + (1-embeddingWeight) * ruleConfidence
  5. Merge semantic tags from both (deduplicate)
  6. DomainHint from embedding classifier if available, else rule-based
- `ClassifyBatchAsync`: Delegate to embedding classifier's batch if available, merge with rule-based per-item
- `ComputeSemanticSimilarityAsync`: Use embedding classifier's if available, else rule-based's Jaccard
- Capabilities: union of both classifiers' capabilities

This is the DEFAULT classifier — it gracefully degrades from AI-powered to rule-based when the AI provider is unavailable, which is critical for edge/air-gapped deployments.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>HybridClassifier compiles, implements weighted fusion with graceful AI fallback, all 3 classifiers build</done>
</task>

</tasks>

<verification>
- All 3 classifiers compile as part of the plugin project
- Each extends SemanticSyncStrategyBase and implements ISemanticClassifier
- EmbeddingClassifier uses IAIProvider (grep confirms GetEmbeddingsAsync call)
- RuleBasedClassifier has NO IAIProvider dependency
- HybridClassifier delegates to both with weighted fusion
- No stubs, no Task.Delay, no placeholder implementations
</verification>

<success_criteria>
- Three production-ready classifiers covering all deployment scenarios (cloud, edge, air-gapped)
- Hybrid classifier gracefully degrades when AI is unavailable
- Classification produces meaningful importance levels with confidence scores
</success_criteria>

<output>
After completion, create `.planning/phases/60-semantic-sync/60-03-SUMMARY.md`
</output>
