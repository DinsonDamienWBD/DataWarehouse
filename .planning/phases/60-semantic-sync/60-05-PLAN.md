---
phase: 60-semantic-sync
plan: 05
type: execute
wave: 2
depends_on: ["60-01", "60-02"]
files_modified:
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/SemanticMergeResolver.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/EmbeddingSimilarityDetector.cs
  - Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/ConflictClassificationEngine.cs
autonomous: true

must_haves:
  truths:
    - "Conflicts are detected by semantic similarity, not just byte comparison or timestamps"
    - "Semantically equivalent changes auto-resolve without user intervention"
    - "Divergent changes are classified into actionable conflict types"
    - "Merge resolution preserves fields from both sides based on semantic importance"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/SemanticMergeResolver.cs"
      provides: "Meaning-based conflict resolution strategy"
      contains: "class SemanticMergeResolver : SemanticSyncStrategyBase, ISemanticConflictResolver"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/EmbeddingSimilarityDetector.cs"
      provides: "Embedding-based conflict detection"
      contains: "class EmbeddingSimilarityDetector"
    - path: "Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/ConflictClassificationEngine.cs"
      provides: "Classifies conflicts into semantic categories"
      contains: "class ConflictClassificationEngine"
  key_links:
    - from: "SemanticMergeResolver"
      to: "EmbeddingSimilarityDetector"
      via: "composition — uses detector for conflict detection"
      pattern: "EmbeddingSimilarityDetector.*Detect"
    - from: "SemanticMergeResolver"
      to: "ConflictClassificationEngine"
      via: "composition — uses engine for conflict type classification"
      pattern: "ConflictClassificationEngine.*Classify"
---

<objective>
Implement semantic conflict resolution that resolves edge-cloud data conflicts based on meaning rather than timestamps or version numbers.

Purpose: Traditional conflict resolution (last-write-wins, version vectors) loses data. Semantic resolution understands that two edits might mean the same thing (auto-resolve), touch different semantic fields (merge), or genuinely conflict (escalate). This dramatically reduces false conflicts and data loss in edge-cloud sync.

Output: 3 files in Strategies/ConflictResolution/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/60-semantic-sync/60-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/SemanticSync/ISemanticConflictResolver.cs
@DataWarehouse.SDK/Contracts/SemanticSync/SemanticSyncModels.cs
@DataWarehouse.SDK/Contracts/Replication/ReplicationStrategy.cs
@DataWarehouse.SDK/AI/IAIProvider.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Embedding Similarity Detector and Conflict Classification Engine</name>
  <files>
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/EmbeddingSimilarityDetector.cs
    Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/ConflictClassificationEngine.cs
  </files>
  <action>
**EmbeddingSimilarityDetector.cs:**
- Internal class used by SemanticMergeResolver
- Constructor takes optional `IAIProvider`
- `Task<SemanticConflict?> DetectAsync(string dataId, ReadOnlyMemory<byte> localData, ReadOnlyMemory<byte> remoteData, CancellationToken ct)`:
  1. If data is identical (byte comparison via SequenceEqual): return null (no conflict)
  2. If AI provider available: get embeddings for both, compute cosine similarity
     - Similarity >= 0.95: no conflict (semantically equivalent despite byte differences — e.g., whitespace, field ordering)
     - Similarity 0.7-0.95: partial overlap conflict
     - Similarity < 0.7: divergent conflict
  3. If AI unavailable: fall back to structural comparison:
     - Both valid JSON? Compare top-level key sets. Same keys = PartialOverlap, different keys = SchemaEvolution
     - Binary? Compare headers (first 64 bytes). Same header = PartialOverlap, different = SemanticDivergent
  4. Create SemanticClassification for both local and remote (using metadata if available, else default Normal importance)
  5. Return SemanticConflict with all fields populated

**ConflictClassificationEngine.cs:**
- Internal class
- `ConflictType Classify(SemanticConflict conflict, double? similarityScore)`:
  - SemanticEquivalent: similarity >= 0.95 (meaning is the same despite different bytes)
  - SchemaEvolution: data structures differ (different JSON keys or different binary headers) but one is a superset of the other
  - PartialOverlap: some fields changed independently on both sides (can be merged)
  - SemanticDivergent: core meaning differs (similarity < 0.5 or conflicting values in same fields)
  - Irreconcilable: both sides modified the same critical fields to different values AND local/remote importance are both Critical
- For JSON data: implements actual field-level diff by parsing both as JsonDocument, comparing property names and values. Counts shared/unique/conflicting properties to determine type.
- For binary data: compares header blocks and size patterns
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>Both helper classes compile, detector uses embeddings with structural fallback, classifier categorizes all 5 conflict types</done>
</task>

<task type="auto">
  <name>Task 2: Semantic Merge Resolver Strategy</name>
  <files>Plugins/DataWarehouse.Plugins.SemanticSync/Strategies/ConflictResolution/SemanticMergeResolver.cs</files>
  <action>
**SemanticMergeResolver.cs:**
- Class: `SemanticMergeResolver : SemanticSyncStrategyBase, ISemanticConflictResolver`
- StrategyId: `"conflict-resolver-semantic-merge"`, Name: `"Semantic Merge Conflict Resolver"`
- Constructor takes `EmbeddingSimilarityDetector` and `ConflictClassificationEngine`

**DetectConflictAsync:** Delegate to EmbeddingSimilarityDetector.DetectAsync

**ClassifyConflictAsync:** Use EmbeddingSimilarityDetector to get similarity score, then delegate to ConflictClassificationEngine.Classify

**ResolveAsync — resolution strategy per conflict type:**
- `SemanticEquivalent`: Auto-resolve — pick whichever has higher classification confidence, explanation = "Semantically equivalent: both changes express the same meaning"
- `PartialOverlap`: Merge — for JSON: deep merge using 3-way merge logic (identify base, take non-conflicting changes from both sides, for conflicting fields prefer higher-importance side). For binary: prefer the side with higher semantic importance.
  - JSON merge implementation: parse both as JsonDocument, iterate properties, if property exists in both with same value = keep, if only in one = take it, if in both with different values = prefer the side whose SemanticClassification.Importance is higher
- `SchemaEvolution`: Merge — take the superset (union of all fields). The newer schema likely has additional fields. Keep old values for existing fields, add new fields from the evolved side.
- `SemanticDivergent`: Prefer the side with higher SemanticImportance. If same importance, prefer the side with more recent ClassifiedAt. Explanation includes what diverged.
- `Irreconcilable`: Return ConflictResolution.DeferToUser with explanation describing both sides. ResolvedData = local data (preserve local until user decides).

**SemanticSimilarity** in result: actual cosine similarity if embeddings available, else Jaccard on field names

**Capabilities:** SupportsAutoMerge=true, SupportedTypes=all 5, RequiresAI=false (works without, just lower quality)
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.SemanticSync/DataWarehouse.Plugins.SemanticSync.csproj 2>&1 | tail -5</verify>
  <done>SemanticMergeResolver compiles, implements all ISemanticConflictResolver methods, handles all 5 conflict types with real merge logic</done>
</task>

</tasks>

<verification>
- All 3 files compile in plugin project
- SemanticMergeResolver implements ISemanticConflictResolver
- JSON merge logic actually parses and merges documents (grep for JsonDocument usage)
- Conflict classification covers all 5 ConflictType enum values
- Resolution handles all 5 conflict types with distinct strategies
- Works with and without AI provider
</verification>

<success_criteria>
- Semantic conflict detection reduces false conflicts vs. byte-comparison approaches
- Auto-merge handles SemanticEquivalent and PartialOverlap without user intervention
- JSON deep merge preserves data from both sides based on importance
- Graceful degradation when AI unavailable (structural fallback)
</success_criteria>

<output>
After completion, create `.planning/phases/60-semantic-sync/60-05-SUMMARY.md`
</output>
