---
phase: 74-vde-identity-tamper
plan: 03
type: execute
wave: 3
depends_on: ["74-01", "74-02"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Identity/TamperResponse.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Identity/TamperDetectionOrchestrator.cs
autonomous: true

must_haves:
  truths:
    - "TamperResponse has 5 configurable levels: Log, Alert, ReadOnly, Quarantine, Reject"
    - "TamperResponse level is stored in the Policy Vault as a policy definition"
    - "When tamper is detected at VDE open, the configured TamperResponse is executed"
    - "Default TamperResponse is Reject (safest default)"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Identity/TamperResponse.cs"
      provides: "TamperResponse enum, TamperResponsePolicy, TamperResponseExecutor"
      exports: ["TamperResponse", "TamperResponsePolicy", "TamperResponseExecutor", "TamperDetectionResult"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Identity/TamperDetectionOrchestrator.cs"
      provides: "Runs all tamper checks in sequence and applies configured response"
      exports: ["TamperDetectionOrchestrator"]
  key_links:
    - from: "TamperDetectionOrchestrator"
      to: "HeaderIntegritySeal, MetadataChainHasher, FileSizeSentinel, FormatFingerprintValidator, NamespaceAuthority"
      via: "Calls each check in sequence, collects results, applies TamperResponse"
      pattern: "VerifySeal|ValidateChainHash|Validate.*Sentinel|ValidateFingerprint|VerifyRegistration"
    - from: "TamperResponsePolicy"
      to: "PolicyVaultRegion/PolicyDefinition"
      via: "Serializes TamperResponse level as a PolicyDefinition with PolicyType = 0x0074"
      pattern: "PolicyType.*0x0074|TamperResponse"
---

<objective>
Implement the TamperResponse system (5 severity levels) and the detection orchestrator that ties
all integrity checks together into a single VDE-open validation pipeline.

Purpose: Tamper detection is useless without a configurable response. This plan connects the
individual integrity checks (namespace signature, format fingerprint, header seal, chain hash,
file size sentinel) into a unified orchestrator with policy-driven response handling.

Output: TamperResponse enum, policy serialization, TamperDetectionOrchestrator with full check pipeline.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-vde-identity-tamper/74-01-SUMMARY.md
@.planning/phases/74-vde-identity-tamper/74-02-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockGroup.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/IntegrityAnchor.cs
@DataWarehouse.SDK/VirtualDiskEngine/Regions/PolicyVaultRegion.cs
@DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeIdentityException.cs
@DataWarehouse.SDK/VirtualDiskEngine/Identity/HeaderIntegritySeal.cs
@DataWarehouse.SDK/VirtualDiskEngine/Identity/MetadataChainHasher.cs
@DataWarehouse.SDK/VirtualDiskEngine/Identity/FileSizeSentinel.cs
@DataWarehouse.SDK/VirtualDiskEngine/Identity/FormatFingerprintValidator.cs
@DataWarehouse.SDK/VirtualDiskEngine/Identity/NamespaceAuthority.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: TamperResponse enum, policy, executor, and detection result types</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Identity/TamperResponse.cs
  </files>
  <action>
Create TamperResponse.cs in the Identity directory. Namespace: DataWarehouse.SDK.VirtualDiskEngine.Identity.

1. TamperResponse enum (byte-backed):
   - Log = 0         -- Record the tamper event, allow normal access
   - Alert = 1       -- Record + raise an alert/event, allow normal access
   - ReadOnly = 2    -- Record + open VDE in read-only mode (no writes permitted)
   - Quarantine = 3  -- Record + move VDE to quarantine state (accessible only to recovery tools)
   - Reject = 4      -- Record + refuse to open the VDE entirely (throw exception)

2. TamperDetectionResult class:
   - bool IsClean -- true if no tamper detected
   - TamperCheckResult[] Checks -- array of individual check results
   - TamperCheckResult: record struct with (string CheckName, bool Passed, string? FailureReason)
   - Predefined check names as constants: "NamespaceSignature", "FormatFingerprint", "HeaderIntegritySeal", "MetadataChainHash", "FileSizeSentinel"
   - IReadOnlyList<TamperCheckResult> FailedChecks property (filters to !Passed)
   - string Summary property: "All 5 integrity checks passed" or "2 of 5 integrity checks failed: HeaderIntegritySeal, FileSizeSentinel"

3. TamperResponsePolicy class:
   - TamperResponse Level property (get/set)
   - const ushort PolicyTypeId = 0x0074 (unique policy type for tamper response)
   - const ushort PolicyVersion = 1
   - byte[] Serialize() -> serializes Level as a single byte in the Data payload
   - static TamperResponsePolicy Deserialize(byte[] data) -> reads the byte back
   - PolicyDefinition ToPolicyDefinition() -> creates a PolicyDefinition with PolicyTypeId, PolicyVersion, and serialized data
   - static TamperResponsePolicy FromPolicyDefinition(PolicyDefinition pd) -> extracts and deserializes
   - static TamperResponsePolicy Default => new TamperResponsePolicy { Level = TamperResponse.Reject }

4. TamperResponseExecutor static class:
   - Execute(TamperDetectionResult result, TamperResponse configuredLevel) -> TamperResponseAction
   - TamperResponseAction: readonly struct with (TamperResponse AppliedLevel, bool AllowOpen, bool ReadOnlyMode, bool Quarantined, string Message)
   - Logic:
     - If result.IsClean -> return action with AllowOpen=true regardless of level
     - Log: AllowOpen=true, ReadOnlyMode=false, Message="Tamper detected (logged): {summary}"
     - Alert: AllowOpen=true, ReadOnlyMode=false, Message="ALERT: Tamper detected: {summary}"
     - ReadOnly: AllowOpen=true, ReadOnlyMode=true, Message="Tamper detected: VDE opened in read-only mode: {summary}"
     - Quarantine: AllowOpen=false, Quarantined=true, Message="Tamper detected: VDE quarantined: {summary}"
     - Reject: AllowOpen=false, Quarantined=false, throw VdeTamperDetectedException with summary

All types: [SdkCompatibility("6.0.0", Notes = "Phase 74: VDE Identity -- tamper response (VTMP-07)")].
  </action>
  <verify>
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5
Expect: Build succeeded, 0 errors.
  </verify>
  <done>
TamperResponse enum has exactly 5 levels. TamperResponsePolicy serializes to/from PolicyDefinition. TamperResponseExecutor returns correct AllowOpen/ReadOnlyMode for each level. TamperDetectionResult provides clear summary of passed/failed checks.
  </done>
</task>

<task type="auto">
  <name>Task 2: TamperDetectionOrchestrator -- unified open-time validation pipeline</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Identity/TamperDetectionOrchestrator.cs
  </files>
  <action>
Create TamperDetectionOrchestrator.cs. Namespace: DataWarehouse.SDK.VirtualDiskEngine.Identity.

This is the main entry point called during VDE open. It runs ALL integrity checks and produces a TamperDetectionResult, then applies the configured TamperResponse.

TamperDetectionOrchestrator class (static):

Method: ValidateOnOpen(TamperDetectionContext context) -> TamperResponseAction

TamperDetectionContext readonly struct:
- Stream VdeStream (the open file stream, positioned at 0)
- int BlockSize
- SuperblockV2 Superblock (already deserialized)
- IntegrityAnchor Integrity (already deserialized)
- ExtendedMetadata Extended (already deserialized)
- IReadOnlyDictionary<string, (long StartBlock, long BlockCount)> Regions (from region directory)
- byte[] HmacKey (for header seal verification)
- byte[]? NamespacePublicKey (null = skip namespace verification)
- INamespaceSignatureProvider? SignatureProvider (null = use default)
- TamperResponse ConfiguredResponse (from policy vault, default = Reject)

ValidateOnOpen implementation:
1. Create a List<TamperCheckResult> with capacity 5
2. Check 1 -- Format Fingerprint:
   - Call FormatFingerprintValidator.ValidateFingerprint(context.Integrity.FormatFingerprint)
   - Record pass/fail
3. Check 2 -- Namespace Signature (if public key provided):
   - Call NamespaceAuthority.VerifyRegistration(context.Extended.Namespace, context.NamespacePublicKey, provider)
   - Record pass/fail. If no key provided, record as passed with reason "Skipped: no public key"
4. Check 3 -- Header Integrity Seal:
   - Serialize the superblock to a temporary buffer, then call HeaderIntegritySeal.VerifySeal
   - Actually, we need the raw block bytes. Accept them via context OR re-read block 0 from VdeStream:
   - Read block 0 from VdeStream (stream.Position = 0, read blockSize bytes)
   - Call HeaderIntegritySeal.VerifySeal(block0Bytes, blockSize, hmacKey)
   - Record pass/fail
5. Check 4 -- File Size Sentinel:
   - Call FileSizeSentinel.Validate(context.VdeStream.Length, context.Superblock)
   - Record pass/fail
6. Check 5 -- Metadata Chain Hash:
   - Call MetadataChainHasher.ValidateChainHash(context.VdeStream, blockSize, regions, context.Integrity.MetadataChainHash)
   - Record pass/fail
7. Build TamperDetectionResult from checks
8. Call TamperResponseExecutor.Execute(result, context.ConfiguredResponse)
9. Return the TamperResponseAction

Also provide a convenience overload:
- ValidateOnOpen(Stream stream, byte[] hmacKey, TamperResponse response = TamperResponse.Reject) -> TamperResponseAction
  - Reads superblock group from stream
  - Builds region map from RegionDirectory
  - Constructs TamperDetectionContext
  - Calls the main ValidateOnOpen

[SdkCompatibility("6.0.0", Notes = "Phase 74: VDE Identity -- tamper detection orchestrator (VTMP-03/04/05/07)")].
  </action>
  <verify>
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5
Expect: Build succeeded, 0 errors.
  </verify>
  <done>
TamperDetectionOrchestrator.ValidateOnOpen runs all 5 checks in sequence and returns a TamperResponseAction. Clean VDE files pass all checks. Files with modified headers, truncated sizes, or altered metadata regions are detected. The configured TamperResponse level determines whether the VDE opens, opens read-only, or is rejected.
  </done>
</task>

</tasks>

<verification>
- dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj succeeds with 0 errors
- TamperResponse enum has 5 values: Log(0), Alert(1), ReadOnly(2), Quarantine(3), Reject(4)
- TamperResponsePolicy round-trips through PolicyDefinition serialization
- TamperDetectionOrchestrator.ValidateOnOpen runs all 5 checks and returns aggregated result
- Reject response throws VdeTamperDetectedException with full summary
- ReadOnly response returns AllowOpen=true, ReadOnlyMode=true
</verification>

<success_criteria>
1. TamperResponse enum defines exactly 5 levels matching the spec
2. TamperResponsePolicy can be stored in PolicyVaultRegion as a PolicyDefinition
3. TamperDetectionOrchestrator ties all checks from plans 01 and 02 into a single pipeline
4. Each check produces a named result with pass/fail and failure reason
5. TamperResponseExecutor applies the correct behavior for each response level
</success_criteria>

<output>
After completion, create `.planning/phases/74-vde-identity-tamper/74-03-SUMMARY.md`
</output>
