---
phase: 74-vde-identity-tamper
plan: 04
type: execute
wave: 4
depends_on: ["74-01", "74-02"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Identity/EmergencyRecoveryBlock.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeHealthMetadata.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeNestingValidator.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
autonomous: true

must_haves:
  truths:
    - "Emergency Recovery Block at fixed block 9 is accessible in plaintext without decryption keys"
    - "VDE Health metadata tracks creation timestamp, mount count, error count, and state machine"
    - "VDE nesting works up to 3 levels deep with detection and enforcement"
    - "Emergency Recovery Block contains volume UUID, creation time, volume label, and contact info for recovery"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Identity/EmergencyRecoveryBlock.cs"
      provides: "Plaintext recovery block at fixed position (block 9), readable without keys"
      exports: ["EmergencyRecoveryBlock"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeHealthMetadata.cs"
      provides: "Health state machine with mount count, error count, last mount/unmount times"
      exports: ["VdeHealthMetadata", "VdeHealthState"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeNestingValidator.cs"
      provides: "Validates and enforces VDE-within-VDE nesting depth limit of 3"
      exports: ["VdeNestingValidator"]
  key_links:
    - from: "EmergencyRecoveryBlock"
      to: "Block 9 of VDE file (second block of RegionDirectory, repurposed)"
      via: "Fixed position read at offset blockSize * 9"
      pattern: "EmergencyRecoveryBlockOffset|block.*9"
    - from: "VdeHealthMetadata"
      to: "IntegrityAnchor or ExtendedMetadata reserved bytes"
      via: "Serialized into reserved area of integrity anchor block"
      pattern: "VdeHealthMetadata.*Serialize"
    - from: "VdeNestingValidator"
      to: "MagicSignature detection at nested offsets"
      via: "Scans inner VDE headers for DWVD magic, counts depth"
      pattern: "NestingDepth|MaxNestingDepth"
---

<objective>
Implement the Emergency Recovery Block (plaintext at block 9), VDE Health metadata (state machine
with mount/error tracking), and VDE Nesting validation (3-level depth limit).

Purpose: Emergency recovery enables data recovery without encryption keys. Health metadata provides
operational telemetry. Nesting support enables VDE-in-VDE containers with depth enforcement.

Output: Three production classes completing all remaining VTMP requirements.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-vde-identity-tamper/74-01-SUMMARY.md
@.planning/phases/74-vde-identity-tamper/74-02-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/MagicSignature.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
@DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeIdentityException.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: EmergencyRecoveryBlock -- plaintext recovery data at fixed block 9</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Identity/EmergencyRecoveryBlock.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
  </files>
  <action>
First, add a new block type tag to BlockTypeTags.cs:
- ERCV = 0x45524356 ("ERCV" = Emergency Recovery)
- Add ERCV to the KnownTags FrozenSet

Create EmergencyRecoveryBlock.cs in Identity directory. Namespace: DataWarehouse.SDK.VirtualDiskEngine.Identity.

The Emergency Recovery Block lives at block 9 (the second block of the Region Directory area -- note: Region Directory is blocks 8-9, so block 9 is currently the SECOND region directory block). This is a design decision: block 9 is always at a FIXED, KNOWN position regardless of VDE configuration. The recovery block is ALWAYS plaintext (never encrypted) so that recovery tools can read it without keys.

EmergencyRecoveryBlock readonly struct:
- const int FixedBlockNumber = 9
- const int MagicSize = 4 -- "ERCV" marker at offset 0
- const int VolumeUuidSize = 16
- const int CreationTimestampSize = 8
- const int VolumeLabelSize = 64
- const int ContactInfoSize = 128
- const int FormatVersionSize = 4 (major, minor, specRev as 1+1+2)
- const int ErrorCountSize = 8
- const int MountCountSize = 8
- const int TotalFixedSize = 4+16+8+64+128+4+8+8 = 240 bytes

Fields:
- Guid VolumeUuid
- long CreationTimestampUtcTicks
- byte[] VolumeLabel (64 bytes, UTF-8 null-padded)
- byte[] ContactInfo (128 bytes, UTF-8 null-padded -- admin contact for data recovery)
- byte MajorVersion, byte MinorVersion, ushort SpecRevision
- long ErrorCount
- long MountCount

Constructor, CreateDefault(SuperblockV2 sb), CreateDefault(Guid volumeUuid, long createdTimestamp, byte[] label).

Static Serialize(in EmergencyRecoveryBlock erb, Span<byte> buffer, int blockSize):
- Writes "ERCV" magic at offset 0
- Writes all fields sequentially
- Writes UniversalBlockTrailer at end with ERCV tag

Static Deserialize(ReadOnlySpan<byte> buffer, int blockSize) -> EmergencyRecoveryBlock:
- Validates "ERCV" magic
- Reads all fields

Static ReadFromStream(Stream stream, int blockSize) -> EmergencyRecoveryBlock:
- Seeks to FixedBlockNumber * blockSize
- Reads one block
- Deserializes

Static WriteToStream(Stream stream, int blockSize, in EmergencyRecoveryBlock erb):
- Serializes to buffer
- Seeks to FixedBlockNumber * blockSize
- Writes

Static bool IsPresent(Stream stream, int blockSize):
- Reads first 4 bytes at block 9 position
- Returns true if they match "ERCV"

Helper methods:
- string GetVolumeLabelString() -- same pattern as SuperblockV2.GetVolumeLabelString
- string GetContactInfoString() -- same pattern
- static byte[] CreateContactInfo(string info) -- UTF-8 encode, pad to 128 bytes

[SdkCompatibility("6.0.0", Notes = "Phase 74: VDE Identity -- emergency recovery block (VTMP-08)")].
  </action>
  <verify>
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5
Expect: Build succeeded, 0 errors.
  </verify>
  <done>
EmergencyRecoveryBlock serializes to/from a fixed block position (block 9). ReadFromStream reads it without needing any encryption keys. The block contains volume UUID, creation timestamp, volume label, contact info, version, and error/mount counts. ERCV tag is registered in BlockTypeTags.
  </done>
</task>

<task type="auto">
  <name>Task 2: VdeHealthMetadata + VdeNestingValidator -- health state machine and nesting depth enforcement</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeHealthMetadata.cs
    DataWarehouse.SDK/VirtualDiskEngine/Identity/VdeNestingValidator.cs
  </files>
  <action>
Create VdeHealthMetadata.cs in Identity directory.

VdeHealthState enum (byte-backed):
- Created = 0       -- VDE created but never mounted
- Clean = 1         -- Cleanly unmounted
- Mounted = 2       -- Currently mounted (dirty flag)
- DirtyShutdown = 3 -- Was mounted, detected unclean shutdown on next open
- Recovering = 4    -- Recovery/repair in progress
- Degraded = 5      -- Operating with known issues (some checks failed but TamperResponse allowed open)

VdeHealthMetadata class:
- VdeHealthState State { get; private set; }
- long MountCount { get; private set; }
- long ErrorCount { get; private set; }
- long CreationTimestampUtcTicks { get; }
- long LastMountTimestampUtcTicks { get; private set; }
- long LastUnmountTimestampUtcTicks { get; private set; }
- long TotalMountedDurationTicks { get; private set; } -- cumulative mounted time

Methods:
- RecordMount(): State = Mounted, MountCount++, LastMountTimestampUtcTicks = now
- RecordUnmount(): TotalMountedDurationTicks += (now - LastMountTimestampUtcTicks), State = Clean, LastUnmountTimestampUtcTicks = now
- RecordError(): ErrorCount++
- RecordDirtyShutdown(): State = DirtyShutdown
- RecordRecoveryStart(): State = Recovering
- RecordRecoveryComplete(): State = Clean
- RecordDegraded(): State = Degraded

Serialization (fixed 64 bytes):
- [State:1][Padding:3][MountCount:8 LE][ErrorCount:8 LE][CreationTs:8 LE][LastMountTs:8 LE][LastUnmountTs:8 LE][TotalMountedDuration:8 LE][Reserved:12]
- Static Serialize(VdeHealthMetadata hm, Span<byte> buffer)
- Static Deserialize(ReadOnlySpan<byte> buffer) -> VdeHealthMetadata
- Static CreateNew() -> new VdeHealthMetadata with State=Created, CreationTs=now, all counters zero

Create VdeNestingValidator.cs in Identity directory.

VdeNestingValidator static class:
- const int MaxNestingDepth = 3
- const int DwvdMagicUint = 0x44575644 (from MagicSignature)

Methods:
- ValidateNestingDepth(int currentDepth) -> bool:
  - Returns currentDepth <= MaxNestingDepth
- ValidateOrThrow(int currentDepth):
  - Throws VdeNestingDepthExceededException("VDE nesting depth {currentDepth} exceeds maximum allowed depth of {MaxNestingDepth}. VDE files can be nested up to 3 levels deep.")
- DetectNestingDepth(Stream outerVdeStream, int blockSize) -> int:
  - Reads the superblock of the outer VDE
  - Scans data region blocks looking for DWVD magic signature (0x44575644 at offset 0 of a block)
  - If found, reads that inner VDE's data region and looks for another DWVD magic
  - Returns the maximum detected nesting depth (1 = no nesting, 2 = one level, 3 = two levels, etc.)
  - Note: This is a heuristic scan -- production code should track nesting depth in metadata rather than scanning. So ALSO provide:
- GetStoredNestingDepth(in ExtendedMetadata metadata) -> byte:
  - Reads the first byte of the FabricNamespaceRoot field (repurposing a reserved byte for nesting depth tracking)
  - This is a convention: byte 0 of FabricNamespaceRoot stores the nesting depth counter
  - Returns 0 if the byte is 0 (no nesting or not set)
- SetNestingDepth(byte[] fabricNamespaceRoot, byte depth) -> void:
  - Writes depth to fabricNamespaceRoot[0]
- IncrementNestingForInnerVde(in ExtendedMetadata outerMetadata) -> byte:
  - Returns GetStoredNestingDepth(outerMetadata) + 1
  - Does NOT validate (caller should call ValidateOrThrow with the result)

[SdkCompatibility("6.0.0", Notes = "Phase 74: VDE Identity -- health metadata and nesting (VTMP-09, VTMP-10)")].
  </action>
  <verify>
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5
Expect: Build succeeded, 0 errors.
  </verify>
  <done>
VdeHealthMetadata transitions through all 6 states correctly (Created->Mounted->Clean cycle). Mount/unmount/error recording updates counters and timestamps. Serialization round-trips through 64-byte buffer. VdeNestingValidator enforces MaxNestingDepth=3 and throws VdeNestingDepthExceededException at depth 4+. Nesting depth is stored in ExtendedMetadata for tracking across VDE-in-VDE creation.
  </done>
</task>

</tasks>

<verification>
- dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj succeeds with 0 errors
- EmergencyRecoveryBlock: write to block 9, read back without any key -> all fields match
- ERCV tag added to BlockTypeTags and in KnownTags set
- VdeHealthMetadata state machine: Created -> RecordMount -> Mounted -> RecordUnmount -> Clean
- VdeHealthMetadata: MountCount increments, ErrorCount increments, timestamps update
- VdeNestingValidator: depth 1-3 valid, depth 4+ throws VdeNestingDepthExceededException
- All new types have [SdkCompatibility("6.0.0")] attribute
</verification>

<success_criteria>
1. EmergencyRecoveryBlock at fixed block 9 is readable without encryption keys
2. ERCV block type tag registered in BlockTypeTags
3. VdeHealthMetadata tracks 6 states with mount/error/duration counters
4. VdeNestingValidator enforces 3-level maximum nesting depth
5. Nesting depth stored in ExtendedMetadata for inner VDE creation
6. All code is production-ready with no placeholders
</success_criteria>

<output>
After completion, create `.planning/phases/74-vde-identity-tamper/74-04-SUMMARY.md`
</output>
