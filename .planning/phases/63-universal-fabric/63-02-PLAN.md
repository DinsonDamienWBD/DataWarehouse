---
phase: 63-universal-fabric
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Storage/Fabric/IStorageFabric.cs
  - DataWarehouse.SDK/Storage/Fabric/IBackendRegistry.cs
  - DataWarehouse.SDK/Storage/Fabric/BackendDescriptor.cs
  - DataWarehouse.SDK/Storage/Fabric/StorageFabricErrors.cs
autonomous: true

must_haves:
  truths:
    - "IStorageFabric defines a single unified API for all storage operations across backends"
    - "IBackendRegistry allows registering and discovering storage backends by tag, tier, and capability"
    - "BackendDescriptor captures metadata about each backend (id, tags, tier, capabilities, health)"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/Fabric/IStorageFabric.cs"
      provides: "Unified storage facade interface"
      contains: "interface IStorageFabric"
    - path: "DataWarehouse.SDK/Storage/Fabric/IBackendRegistry.cs"
      provides: "Backend discovery and registration contract"
      contains: "interface IBackendRegistry"
    - path: "DataWarehouse.SDK/Storage/Fabric/BackendDescriptor.cs"
      provides: "Backend metadata record"
      contains: "record BackendDescriptor"
  key_links:
    - from: "DataWarehouse.SDK/Storage/Fabric/IStorageFabric.cs"
      to: "DataWarehouse.SDK/Storage/IObjectStorageCore.cs"
      via: "extends IObjectStorageCore with routing"
      pattern: "IObjectStorageCore"
---

<objective>
Define the SDK contracts for the Universal Storage Fabric: IStorageFabric, IBackendRegistry, and supporting types.

Purpose: These interfaces define the contract that the fabric plugin will implement. IStorageFabric extends IObjectStorageCore with dw:// address routing, backend selection, and cross-backend operations. IBackendRegistry provides backend discovery by tags, tiers, and capabilities.

Output: SDK-level interfaces and types (no implementation -- that comes in plan 04).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
@DataWarehouse.SDK/Storage/StorageAddress.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define IStorageFabric and IBackendRegistry interfaces</name>
  <files>DataWarehouse.SDK/Storage/Fabric/IStorageFabric.cs, DataWarehouse.SDK/Storage/Fabric/IBackendRegistry.cs</files>
  <action>
Create directory DataWarehouse.SDK/Storage/Fabric/.

1. IStorageFabric.cs -- namespace DataWarehouse.SDK.Storage.Fabric:
```
public interface IStorageFabric : IObjectStorageCore
{
    // Route a dw:// address to the correct backend and execute store
    Task<StorageObjectMetadata> StoreAsync(StorageAddress address, Stream data, StoragePlacementHints? hints = null, IDictionary<string, string>? metadata = null, CancellationToken ct = default);

    // Retrieve via dw:// with automatic backend resolution
    Task<Stream> RetrieveAsync(StorageAddress address, CancellationToken ct = default);

    // Copy between backends (dw://source -> dw://dest)
    Task<StorageObjectMetadata> CopyAsync(StorageAddress source, StorageAddress destination, CancellationToken ct = default);

    // Move between backends (copy + delete source)
    Task<StorageObjectMetadata> MoveAsync(StorageAddress source, StorageAddress destination, CancellationToken ct = default);

    // Get backend for a given address
    IStorageStrategy? ResolveBackend(StorageAddress address);

    // List all registered backends
    IBackendRegistry Registry { get; }

    // Get fabric-wide health across all backends
    Task<FabricHealthReport> GetFabricHealthAsync(CancellationToken ct = default);
}
```

2. IBackendRegistry.cs:
```
public interface IBackendRegistry
{
    // Register a backend with its descriptor
    void Register(BackendDescriptor descriptor, IStorageStrategy strategy);

    // Unregister a backend
    bool Unregister(string backendId);

    // Find backends by tag (e.g., "cloud", "local", "archive")
    IReadOnlyList<BackendDescriptor> FindByTag(string tag);

    // Find backends by tier
    IReadOnlyList<BackendDescriptor> FindByTier(StorageTier tier);

    // Find backends matching capability requirements
    IReadOnlyList<BackendDescriptor> FindByCapabilities(StorageCapabilities required);

    // Get a specific backend by ID
    BackendDescriptor? GetById(string backendId);

    // Get the strategy for a backend
    IStorageStrategy? GetStrategy(string backendId);

    // All registered backends
    IReadOnlyList<BackendDescriptor> All { get; }

    // Event when backend registered/unregistered
    event Action<BackendDescriptor, bool>? BackendChanged;
}
```

Add full XML doc comments. Add [SdkCompatibility("5.0.0", Notes = "Phase 63: Universal Storage Fabric")].
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>IStorageFabric and IBackendRegistry interfaces compile in SDK</done>
</task>

<task type="auto">
  <name>Task 2: Define BackendDescriptor, StoragePlacementHints, FabricHealthReport types</name>
  <files>DataWarehouse.SDK/Storage/Fabric/BackendDescriptor.cs, DataWarehouse.SDK/Storage/Fabric/StorageFabricErrors.cs</files>
  <action>
1. BackendDescriptor.cs -- all types in namespace DataWarehouse.SDK.Storage.Fabric:

```csharp
public record BackendDescriptor
{
    public required string BackendId { get; init; }         // e.g., "s3-us-east-1", "local-nvme"
    public required string Name { get; init; }              // Human-readable name
    public required string StrategyId { get; init; }        // Maps to IStorageStrategy.StrategyId
    public required StorageTier Tier { get; init; }
    public required StorageCapabilities Capabilities { get; init; }
    public IReadOnlySet<string> Tags { get; init; }         // e.g., {"cloud", "aws", "encrypted"}
    public string? Region { get; init; }                    // Geographic region if applicable
    public string? Endpoint { get; init; }                  // Connection endpoint
    public int Priority { get; init; } = 100;               // Lower = preferred (for placement)
    public long? MaxCapacityBytes { get; init; }
    public bool IsReadOnly { get; init; }
    public IDictionary<string, string>? Properties { get; init; } // Backend-specific config
}

public record StoragePlacementHints
{
    public StorageTier? PreferredTier { get; init; }
    public IReadOnlySet<string>? RequiredTags { get; init; }
    public string? PreferredRegion { get; init; }
    public string? PreferredBackendId { get; init; }        // Explicit backend override
    public bool RequireEncryption { get; init; }
    public bool RequireVersioning { get; init; }
    public long? ExpectedSizeBytes { get; init; }           // For capacity-aware placement
    public TimeSpan? MaxAcceptableLatency { get; init; }
}

public record FabricHealthReport
{
    public required int TotalBackends { get; init; }
    public required int HealthyBackends { get; init; }
    public required int DegradedBackends { get; init; }
    public required int UnhealthyBackends { get; init; }
    public required IReadOnlyDictionary<string, StorageHealthInfo> BackendHealth { get; init; }
    public required DateTime CheckedAt { get; init; }
    public HealthStatus OverallStatus => UnhealthyBackends > 0 ? HealthStatus.Degraded
        : DegradedBackends > 0 ? HealthStatus.Degraded : HealthStatus.Healthy;
}
```

2. StorageFabricErrors.cs -- custom exception types:
```csharp
public class BackendNotFoundException : InvalidOperationException { ... }  // No backend found for address
public class BackendUnavailableException : IOException { ... }             // Backend exists but unhealthy
public class PlacementFailedException : InvalidOperationException { ... }  // No backend matches hints
public class MigrationFailedException : IOException { ... }               // Cross-backend copy/move failed
```

Each exception with constructor(string message), constructor(string message, Exception inner), and relevant properties (BackendId, Address, etc.).
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>All fabric SDK types compile; BackendDescriptor, StoragePlacementHints, FabricHealthReport, and exception types available</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- IStorageFabric extends IObjectStorageCore
- All types are in DataWarehouse.SDK.Storage.Fabric namespace
</verification>

<success_criteria>
- SDK defines complete contracts for fabric operations
- Types are records (immutable) per SDK conventions
- No implementation code -- pure contracts
</success_criteria>

<output>
After completion, create `.planning/phases/63-universal-fabric/63-02-SUMMARY.md`
</output>
