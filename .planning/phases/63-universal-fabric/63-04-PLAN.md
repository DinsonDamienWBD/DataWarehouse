---
phase: 63-universal-fabric
plan: 04
type: execute
wave: 2
depends_on: ["63-01", "63-02"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UniversalFabric/UniversalFabricPlugin.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/BackendRegistryImpl.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/AddressRouter.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj
autonomous: true

must_haves:
  truths:
    - "UniversalFabricPlugin registers all UltimateStorage strategies as fabric backends on initialization"
    - "AddressRouter resolves dw:// addresses to the correct IStorageStrategy"
    - "BackendRegistryImpl supports find-by-tag, find-by-tier, find-by-capability queries"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/UniversalFabricPlugin.cs"
      provides: "Plugin implementing IStorageFabric"
      contains: "class UniversalFabricPlugin"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/BackendRegistryImpl.cs"
      provides: "Concrete IBackendRegistry implementation"
      contains: "class BackendRegistryImpl"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/AddressRouter.cs"
      provides: "dw:// address to backend resolution"
      contains: "class AddressRouter"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UniversalFabric/UniversalFabricPlugin.cs"
      to: "DataWarehouse.SDK/Storage/Fabric/IStorageFabric.cs"
      via: "implements interface"
      pattern: "IStorageFabric"
    - from: "Plugins/DataWarehouse.Plugins.UniversalFabric/AddressRouter.cs"
      to: "DataWarehouse.SDK/Storage/DwNamespace.cs"
      via: "pattern matches on DwBucketAddress etc"
      pattern: "DwBucketAddress"
---

<objective>
Implement the core Universal Storage Fabric plugin with backend registry and address routing.

Purpose: This is the central plugin that makes all 130+ storage backends accessible through dw:// addressing. It implements IStorageFabric, maintains a registry of available backends, and routes operations to the correct backend based on the address.

Output: Working plugin that can Store/Retrieve/Delete/Copy/Move objects across any registered backend via dw:// addresses.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/63-universal-fabric/63-01-SUMMARY.md
@.planning/phases/63-universal-fabric/63-02-SUMMARY.md
@DataWarehouse.SDK/Storage/Fabric/IStorageFabric.cs
@DataWarehouse.SDK/Storage/Fabric/IBackendRegistry.cs
@DataWarehouse.SDK/Storage/DwNamespace.cs
@Plugins/DataWarehouse.Plugins.UltimateStorage/UltimateStoragePlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UniversalFabric plugin project and BackendRegistryImpl</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj, Plugins/DataWarehouse.Plugins.UniversalFabric/BackendRegistryImpl.cs, Plugins/DataWarehouse.Plugins.UniversalFabric/AddressRouter.cs</files>
  <action>
1. Create new plugin project Plugins/DataWarehouse.Plugins.UniversalFabric/:
   - .csproj referencing DataWarehouse.SDK only (standard plugin pattern)
   - net10.0 target framework (match existing plugins)

2. BackendRegistryImpl.cs (implements IBackendRegistry):
   - Thread-safe ConcurrentDictionary<string, (BackendDescriptor, IStorageStrategy)> for backend storage
   - Register(): validates BackendDescriptor, stores with strategy, fires BackendChanged event
   - Unregister(): removes backend, fires BackendChanged event
   - FindByTag(): LINQ filter on Tags.Contains(tag)
   - FindByTier(): filter by Tier match
   - FindByCapabilities(): match required capabilities (versioning, encryption, etc.) against backend capabilities
   - GetById(), GetStrategy(): direct lookup
   - All: returns all descriptors as IReadOnlyList
   - BackendChanged event: Action<BackendDescriptor, bool> (bool = true for added, false for removed)

3. AddressRouter.cs -- resolves StorageAddress to backend:
   - `IStorageStrategy? Resolve(StorageAddress address, IBackendRegistry registry)` -- pattern match:
     - DwBucketAddress: lookup bucket -> backend mapping (ConcurrentDictionary<string, string> _bucketMappings)
     - DwNodeAddress: lookup node -> backend mapping
     - DwClusterAddress: lookup cluster -> backend mapping
     - ObjectKeyAddress: use default backend
     - FilePathAddress: use local filesystem backend
     - NetworkEndpointAddress: find backend by endpoint match
     - Other variants: use default backend
   - `void MapBucket(string bucket, string backendId)` -- register bucket-to-backend mapping
   - `void MapNode(string nodeId, string backendId)` -- register node-to-backend mapping
   - `void SetDefaultBackend(string backendId)` -- set fallback backend
   - `(string backendId, string objectKey) ExtractRoutingKey(StorageAddress address)` -- split address into backend + key
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>BackendRegistryImpl supports registration/discovery of backends; AddressRouter maps dw:// addresses to backends</done>
</task>

<task type="auto">
  <name>Task 2: Implement UniversalFabricPlugin with IStorageFabric</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/UniversalFabricPlugin.cs</files>
  <action>
Create UniversalFabricPlugin extending StoragePluginBase, implementing IStorageFabric, IDisposable:

Plugin metadata:
- Id: "com.datawarehouse.storage.universal-fabric"
- Name: "Universal Storage Fabric"
- Version: "5.0.0"

Fields:
- BackendRegistryImpl _registry
- AddressRouter _router
- IStorageStrategy? _defaultBackend

Initialize:
- In InitializeAsync, discover all registered IStorageStrategy instances via message bus query (publish "storage.fabric.discover" topic, collect responses)
- For each discovered strategy, create BackendDescriptor from strategy metadata (StrategyId, Name, Tier, Capabilities)
- Register each in _registry
- Auto-detect bucket mappings from strategy configuration

IStorageFabric implementation:
- StoreAsync(address, data, hints, metadata, ct): resolve backend via _router, delegate StoreAsync to strategy, return metadata
- RetrieveAsync(address, ct): resolve backend, delegate RetrieveAsync
- CopyAsync(source, dest, ct): resolve source backend, retrieve data, resolve dest backend, store data. Use streaming (don't buffer entire object in memory). Return dest metadata.
- MoveAsync(source, dest, ct): CopyAsync then DeleteAsync on source
- ResolveBackend(address): delegate to _router
- Registry: return _registry
- GetFabricHealthAsync: iterate all backends, collect health, build FabricHealthReport

IObjectStorageCore implementation (base string-key methods):
- StoreAsync(key, data, metadata, ct): convert key to StorageAddress (implicit conversion), route to fabric StoreAsync
- RetrieveAsync(key, ct): same pattern
- DeleteAsync, ExistsAsync, ListAsync, GetMetadataAsync: all delegate through router
- GetHealthAsync: delegate to default backend health
- GetAvailableCapacityAsync: sum across all backends

Error handling:
- If no backend found for address, throw BackendNotFoundException
- If backend unhealthy, try fallback backends (next priority in same tier)
- Wrap all backend exceptions in standardized error with context (backend id, address, operation)

Message bus integration:
- Subscribe to "storage.backend.registered" -- auto-register new backends
- Subscribe to "storage.backend.health" -- update health cache
- Publish "storage.fabric.ready" on successful initialization
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>UniversalFabricPlugin compiles, implements full IStorageFabric contract with address routing, backend discovery, cross-backend copy/move, and health aggregation</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/` compiles
- Plugin added to solution file
- Plugin references only SDK (no direct references to other plugins)
</verification>

<success_criteria>
- dw://bucket/path routes to correct backend strategy
- Cross-backend copy streams data without full buffering
- Backend registry supports tag/tier/capability queries
- Message bus discovery finds existing UltimateStorage strategies
</success_criteria>

<output>
After completion, create `.planning/phases/63-universal-fabric/63-04-SUMMARY.md`
</output>
