---
phase: 63-universal-fabric
plan: 13
type: execute
wave: 4
depends_on: ["63-06", "63-07"]
files_modified:
  - Clients/rust/Cargo.toml
  - Clients/rust/src/lib.rs
  - Clients/rust/src/client.rs
  - Clients/rust/src/s3.rs
autonomous: true

must_haves:
  truths:
    - "Rust client connects to DataWarehouse S3-compatible endpoint using aws-sdk-s3"
    - "Rust client supports get, put, delete, list operations"
    - "Rust crate compiles with cargo build"
  artifacts:
    - path: "Clients/rust/src/client.rs"
      provides: "Main DataWarehouse Rust client"
      contains: "pub struct Client"
    - path: "Clients/rust/src/s3.rs"
      provides: "S3-compatible operations"
      contains: "pub struct S3Client"
    - path: "Clients/rust/Cargo.toml"
      provides: "Crate definition"
      contains: "[package]"
  key_links:
    - from: "Clients/rust/src/s3.rs"
      to: "Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3HttpServer.cs"
      via: "S3 HTTP protocol"
      pattern: "aws_sdk_s3"
---

<objective>
Create the Rust cross-language client SDK for DataWarehouse.

Purpose: Rust is increasingly used for high-performance data systems. This client SDK allows Rust applications to interact with DataWarehouse via the S3-compatible API.

Output: Cargo crate with S3-compatible and native dw:// clients.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/63-universal-fabric/63-06-SUMMARY.md
@DataWarehouse.SDK/Storage/Fabric/S3Types.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Rust crate and S3-compatible client</name>
  <files>Clients/rust/Cargo.toml, Clients/rust/src/lib.rs, Clients/rust/src/s3.rs</files>
  <action>
1. Create Clients/rust/ directory.

2. Cargo.toml:
```toml
[package]
name = "dw-client"
version = "5.0.0"
edition = "2021"
description = "DataWarehouse Universal Storage Client for Rust"
license = "MIT"

[dependencies]
aws-sdk-s3 = "1.0"
aws-config = "1.0"
aws-credential-types = "1.0"
aws-smithy-types = "1.0"
tokio = { version = "1", features = ["full"] }
thiserror = "1.0"
url = "2.5"
```

3. src/lib.rs:
```rust
pub mod client;
pub mod s3;
mod error;
pub use client::Client;
pub use s3::S3Client;
pub use error::DwError;
```

4. src/error.rs (create this file too):
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum DwError {
    #[error("S3 error: {0}")]
    S3(String),
    #[error("Invalid URI: {0}")]
    InvalidUri(String),
    #[error("Backend not found: {0}")]
    BackendNotFound(String),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}
```

5. src/s3.rs -- S3-compatible client using aws-sdk-s3:

```rust
use aws_sdk_s3::{Client as AwsS3Client, config::Builder, primitives::ByteStream};
use aws_credential_types::Credentials;

pub struct S3Client {
    inner: AwsS3Client,
}

pub struct S3Config {
    pub endpoint: String,
    pub access_key: String,
    pub secret_key: String,
    pub region: String,
}

pub struct ObjectInfo {
    pub key: String,
    pub size: i64,
    pub last_modified: Option<String>,
    pub etag: Option<String>,
    pub content_type: Option<String>,
}

impl S3Client {
    pub async fn new(config: S3Config) -> Result<Self, DwError> {
        // Build AWS S3 client with custom endpoint
        // Use StaticCredentialsProvider
        // Set force_path_style(true)
    }

    // Bucket operations
    pub async fn list_buckets(&self) -> Result<Vec<String>, DwError>
    pub async fn create_bucket(&self, name: &str) -> Result<(), DwError>
    pub async fn delete_bucket(&self, name: &str) -> Result<(), DwError>

    // Object operations
    pub async fn put_object(&self, bucket: &str, key: &str, body: Vec<u8>,
                            content_type: Option<&str>) -> Result<String, DwError>
    pub async fn get_object(&self, bucket: &str, key: &str) -> Result<Vec<u8>, DwError>
    pub async fn delete_object(&self, bucket: &str, key: &str) -> Result<(), DwError>
    pub async fn head_object(&self, bucket: &str, key: &str) -> Result<ObjectInfo, DwError>
    pub async fn list_objects(&self, bucket: &str, prefix: Option<&str>) -> Result<Vec<ObjectInfo>, DwError>
    pub async fn object_exists(&self, bucket: &str, key: &str) -> Result<bool, DwError>

    // Copy
    pub async fn copy_object(&self, src_bucket: &str, src_key: &str,
                              dst_bucket: &str, dst_key: &str) -> Result<(), DwError>

    // Presigned
    pub async fn presign_get(&self, bucket: &str, key: &str,
                              expires_secs: u64) -> Result<String, DwError>
}
```

All methods must be fully implemented using aws-sdk-s3.
  </action>
  <verify>cd Clients/rust && cargo check 2>&1 | tail -10</verify>
  <done>Rust S3 client compiles with cargo check and wraps all S3 operations</done>
</task>

<task type="auto">
  <name>Task 2: Create native Rust DataWarehouse client with dw:// addressing</name>
  <files>Clients/rust/src/client.rs</files>
  <action>
```rust
use crate::s3::{S3Client, S3Config, ObjectInfo};
use crate::error::DwError;

pub struct Client {
    s3: S3Client,
}

pub struct ClientConfig {
    pub endpoint: String,
    pub access_key: String,
    pub secret_key: String,
    pub region: String,
}

impl Client {
    pub async fn new(config: ClientConfig) -> Result<Self, DwError> {
        let s3 = S3Client::new(S3Config {
            endpoint: config.endpoint,
            access_key: config.access_key,
            secret_key: config.secret_key,
            region: config.region,
        }).await?;
        Ok(Self { s3 })
    }

    /// Store data at a dw:// address.
    pub async fn store(&self, dw_uri: &str, data: Vec<u8>) -> Result<(), DwError>

    /// Retrieve data from a dw:// address.
    pub async fn retrieve(&self, dw_uri: &str) -> Result<Vec<u8>, DwError>

    /// Delete object at a dw:// address.
    pub async fn delete(&self, dw_uri: &str) -> Result<(), DwError>

    /// Check if object exists at a dw:// address.
    pub async fn exists(&self, dw_uri: &str) -> Result<bool, DwError>

    /// List objects under a dw:// prefix.
    pub async fn list(&self, dw_uri: &str) -> Result<Vec<ObjectInfo>, DwError>

    /// Copy between dw:// addresses.
    pub async fn copy(&self, src_uri: &str, dst_uri: &str) -> Result<(), DwError>

    /// Get the underlying S3 client for advanced operations.
    pub fn s3(&self) -> &S3Client { &self.s3 }
}

fn parse_dw_uri(uri: &str) -> Result<(String, String), DwError> {
    let uri = uri.strip_prefix("dw://")
        .or_else(|| uri.strip_prefix("s3://"))
        .ok_or_else(|| DwError::InvalidUri(format!("URI must start with dw:// or s3://: {}", uri)))?;
    let mut parts = uri.splitn(2, '/');
    let bucket = parts.next()
        .filter(|s| !s.is_empty())
        .ok_or_else(|| DwError::InvalidUri("missing bucket name".into()))?
        .to_string();
    let key = parts.next().unwrap_or("").to_string();
    Ok((bucket, key))
}
```

All methods fully implemented delegating to S3 client after URI parsing.
  </action>
  <verify>cd Clients/rust && cargo check 2>&1 | tail -10</verify>
  <done>Rust DataWarehouse client compiles with dw:// addressing and all methods implemented</done>
</task>

</tasks>

<verification>
- `cargo check` succeeds
- All public types and methods have doc comments
- dw:// URI parsing handles edge cases
</verification>

<success_criteria>
- Rust crate compiles with latest aws-sdk-s3
- Client connects to DataWarehouse S3 endpoint
- dw:// URIs parsed correctly
</success_criteria>

<output>
After completion, create `.planning/phases/63-universal-fabric/63-13-SUMMARY.md`
</output>
