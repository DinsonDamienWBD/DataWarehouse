---
phase: 63-universal-fabric
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Storage/StorageAddress.cs
  - DataWarehouse.SDK/Storage/StorageAddressKind.cs
  - DataWarehouse.SDK/Storage/DwNamespace.cs
  - DataWarehouse.SDK/Storage/DwAddressParser.cs
autonomous: true

must_haves:
  truths:
    - "dw://bucket/path addresses resolve to the correct bucket and object key"
    - "dw://node/object addresses resolve to a specific cluster node and object"
    - "dw://cluster/key addresses resolve to cluster-wide distributed keys"
    - "Existing StorageAddress variants continue to work unchanged"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/DwNamespace.cs"
      provides: "DwBucketAddress, DwNodeAddress, DwClusterAddress sealed records"
      contains: "sealed record DwBucketAddress"
    - path: "DataWarehouse.SDK/Storage/DwAddressParser.cs"
      provides: "Parser for dw:// URI scheme into typed StorageAddress variants"
      contains: "static StorageAddress Parse"
  key_links:
    - from: "DataWarehouse.SDK/Storage/DwAddressParser.cs"
      to: "DataWarehouse.SDK/Storage/StorageAddress.cs"
      via: "FromUri integration"
      pattern: "case \"dw\""
---

<objective>
Extend the StorageAddress discriminated union with dw:// namespace addressing.

Purpose: The dw:// scheme is the universal entry point for addressing any storage location in DataWarehouse. It must support three addressing modes: bucket-based (dw://bucket/path), node-based (dw://node@hostname/object), and cluster-based (dw://cluster/key). This builds on the existing StorageAddress infrastructure (9 variants, FromUri parsing).

Output: Three new StorageAddress variant records, a parser, and updated StorageAddressKind enum.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Storage/StorageAddress.cs
@DataWarehouse.SDK/Storage/StorageAddressKind.cs
@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dw:// StorageAddress variants and StorageAddressKind entries</name>
  <files>DataWarehouse.SDK/Storage/StorageAddressKind.cs, DataWarehouse.SDK/Storage/DwNamespace.cs, DataWarehouse.SDK/Storage/StorageAddress.cs</files>
  <action>
1. Add three new entries to StorageAddressKind enum: DwBucket, DwNode, DwCluster.

2. Create DwNamespace.cs with three sealed record variants inheriting StorageAddress:

- `DwBucketAddress(string Bucket, string ObjectPath)` -- represents dw://mybucket/path/to/object. Kind=DwBucket. ToKey() returns "dw://bucket/path". ToUri() returns Uri with dw scheme.
- `DwNodeAddress(string NodeId, string ObjectPath)` -- represents dw://node@hostname/object. Kind=DwNode. NodeId is the hostname or node identifier. ToKey() returns "dw://node@nodeId/path".
- `DwClusterAddress(string ClusterName, string Key)` -- represents dw://cluster:clustername/key. Kind=DwCluster. ToKey() returns "dw://cluster:name/key".

Each record must have [SdkCompatibility("5.0.0", Notes = "Phase 63: dw:// universal namespace")].

3. Add factory methods to StorageAddress class:
- `static StorageAddress FromDwBucket(string bucket, string objectPath)`
- `static StorageAddress FromDwNode(string nodeId, string objectPath)`
- `static StorageAddress FromDwCluster(string clusterName, string key)`

4. Update the FromUri switch in StorageAddress.cs to handle "dw" scheme, delegating to DwAddressParser.Parse.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>Three new StorageAddress variants compile, FromUri("dw://mybucket/file.txt") returns DwBucketAddress</done>
</task>

<task type="auto">
  <name>Task 2: Create DwAddressParser with format detection and validation</name>
  <files>DataWarehouse.SDK/Storage/DwAddressParser.cs</files>
  <action>
Create DwAddressParser as a static class in DataWarehouse.SDK.Storage namespace.

Public API:
- `static StorageAddress Parse(string dwUri)` -- parses a dw:// URI string into the correct variant
- `static StorageAddress Parse(Uri uri)` -- parses a Uri with dw scheme
- `static bool TryParse(string dwUri, out StorageAddress? address)` -- non-throwing variant

Parsing rules (all URIs start with dw://):
1. `dw://bucket/path/to/object` -> DwBucketAddress("bucket", "path/to/object"). The first segment after dw:// is the bucket name, everything after is the object path.
2. `dw://node@hostname/path` -> DwNodeAddress("hostname", "path"). The @ symbol separates the "node" keyword from the hostname.
3. `dw://cluster:name/key` -> DwClusterAddress("name", "key"). The : after "cluster" separates from cluster name.

Validation:
- Bucket names: 3-63 chars, lowercase alphanumeric + hyphens, no leading/trailing hyphen (S3-compatible rules)
- Node IDs: valid hostname or IP address
- Cluster names: 1-255 chars, alphanumeric + hyphens + dots
- Object paths: no null bytes, no path traversal (..), max 1024 chars
- Throw FormatException with clear message for invalid formats

Add XML doc comments explaining each format. Add [SdkCompatibility("5.0.0")].
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>DwAddressParser.Parse("dw://mybucket/file.txt") returns DwBucketAddress; DwAddressParser.Parse("dw://node@host1/data") returns DwNodeAddress; DwAddressParser.Parse("dw://cluster:prod/key") returns DwClusterAddress; invalid URIs throw FormatException</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors
- StorageAddress.FromUri(new Uri("dw://mybucket/path")) returns DwBucketAddress
- All existing StorageAddress variants remain unchanged (no regression)
</verification>

<success_criteria>
- dw:// URIs parse into three distinct typed variants
- Round-trip: Parse -> ToUri -> Parse produces identical result
- Existing StorageAddress code unaffected (implicit conversions, FromUri for other schemes)
</success_criteria>

<output>
After completion, create `.planning/phases/63-universal-fabric/63-01-SUMMARY.md`
</output>
