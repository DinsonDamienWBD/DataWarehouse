---
phase: 63-universal-fabric
plan: 08
type: execute
wave: 2
depends_on: ["63-02"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/BackendAbstractionLayer.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/FallbackChain.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/ErrorNormalizer.cs
autonomous: true

must_haves:
  truths:
    - "BackendAbstractionLayer wraps any IStorageStrategy with retry, fallback, and error normalization"
    - "FallbackChain tries alternative backends when primary fails"
    - "ErrorNormalizer maps backend-specific exceptions to standard StorageFabric exceptions"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/BackendAbstractionLayer.cs"
      provides: "Resilient backend wrapper"
      contains: "class BackendAbstractionLayer"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/FallbackChain.cs"
      provides: "Ordered fallback backend chain"
      contains: "class FallbackChain"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/ErrorNormalizer.cs"
      provides: "Exception normalization across backends"
      contains: "class ErrorNormalizer"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/BackendAbstractionLayer.cs"
      to: "DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs"
      via: "wraps IStorageStrategy"
      pattern: "IStorageStrategy"
---

<objective>
Implement the Backend Abstraction Layer providing retry, fallback, and error normalization across all storage backends.

Purpose: Different backends fail in different ways (S3 returns HTTP 503, local disk throws IOException, network storage times out). The abstraction layer normalizes these into consistent error types and provides automatic fallback to alternative backends.

Output: BackendAbstractionLayer wrapper, FallbackChain for cascading failures, ErrorNormalizer for exception mapping.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/63-universal-fabric/63-02-SUMMARY.md
@DataWarehouse.SDK/Storage/Fabric/IBackendRegistry.cs
@DataWarehouse.SDK/Storage/Fabric/StorageFabricErrors.cs
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ErrorNormalizer and FallbackChain</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/ErrorNormalizer.cs, Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/FallbackChain.cs</files>
  <action>
1. ErrorNormalizer.cs -- maps backend-specific exceptions to fabric exceptions:

```csharp
public class ErrorNormalizer
{
    // Normalize any backend exception into a standard fabric exception
    public Exception Normalize(Exception ex, string backendId, string operation, string? key = null)
    {
        return ex switch
        {
            // Already normalized
            BackendNotFoundException => ex,
            BackendUnavailableException => ex,

            // Network/connectivity
            HttpRequestException httpEx => new BackendUnavailableException(
                $"Backend '{backendId}' unreachable during {operation}: {httpEx.Message}", httpEx)
                { BackendId = backendId },

            TimeoutException => new BackendUnavailableException(
                $"Backend '{backendId}' timed out during {operation}", ex)
                { BackendId = backendId },

            // I/O errors
            IOException ioEx when ioEx.Message.Contains("disk full", StringComparison.OrdinalIgnoreCase) =>
                new StorageFabricException($"Backend '{backendId}' disk full during {operation}", ex),

            IOException => new BackendUnavailableException(
                $"Backend '{backendId}' I/O error during {operation}: {ex.Message}", ex)
                { BackendId = backendId },

            // Not found
            FileNotFoundException or DirectoryNotFoundException =>
                new KeyNotFoundException($"Object not found in backend '{backendId}': {key}"),

            // Auth errors
            UnauthorizedAccessException =>
                new StorageFabricException($"Access denied to backend '{backendId}': {ex.Message}", ex),

            // Default
            _ => new StorageFabricException(
                $"Backend '{backendId}' error during {operation}: {ex.Message}", ex)
        };
    }

    // Classify if an error is retryable
    public bool IsRetryable(Exception ex) => ex is BackendUnavailableException or TimeoutException or HttpRequestException;

    // Classify if an error warrants fallback to alternative backend
    public bool ShouldFallback(Exception ex) => ex is BackendUnavailableException;
}

// Add StorageFabricException to StorageFabricErrors.cs in SDK if not present
```

2. FallbackChain.cs -- ordered chain of backend alternatives:

```csharp
public class FallbackChain
{
    private readonly IBackendRegistry _registry;
    private readonly ErrorNormalizer _normalizer = new();

    public FallbackChain(IBackendRegistry registry)

    // Execute operation with fallback. Tries primary, then falls back through alternatives.
    public async Task<T> ExecuteWithFallbackAsync<T>(
        string primaryBackendId,
        Func<IStorageStrategy, Task<T>> operation,
        FallbackOptions? options = null,
        CancellationToken ct = default)
    {
        var primary = _registry.GetStrategy(primaryBackendId)
            ?? throw new BackendNotFoundException(primaryBackendId);

        try { return await operation(primary); }
        catch (Exception ex) when (_normalizer.ShouldFallback(ex))
        {
            // Find alternatives: same tier, healthy, not the failed backend
            var primaryDesc = _registry.GetById(primaryBackendId)!;
            var alternatives = _registry.FindByTier(primaryDesc.Tier)
                .Where(b => b.BackendId != primaryBackendId)
                .OrderBy(b => b.Priority);

            foreach (var alt in alternatives)
            {
                if (options?.MaxFallbackAttempts > 0 && --options.MaxFallbackAttempts <= 0) break;
                var altStrategy = _registry.GetStrategy(alt.BackendId);
                if (altStrategy == null) continue;

                try { return await operation(altStrategy); }
                catch { continue; } // Try next fallback
            }

            throw _normalizer.Normalize(ex, primaryBackendId, "fallback");
        }
    }
}

public record FallbackOptions
{
    public int MaxFallbackAttempts { get; init; } = 3;
    public bool AllowCrossTierFallback { get; init; } = false;
    public bool AllowCrossRegionFallback { get; init; } = false;
}
```
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>ErrorNormalizer maps all exception types; FallbackChain cascades through alternatives on backend failure</done>
</task>

<task type="auto">
  <name>Task 2: Implement BackendAbstractionLayer wrapping strategies</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/Resilience/BackendAbstractionLayer.cs</files>
  <action>
BackendAbstractionLayer wraps an IStorageStrategy to add cross-cutting concerns:

```csharp
public class BackendAbstractionLayer : IStorageStrategy
{
    private readonly IStorageStrategy _inner;
    private readonly string _backendId;
    private readonly ErrorNormalizer _normalizer;
    private readonly FallbackChain? _fallbackChain;
    private readonly BackendAbstractionOptions _options;

    // Circuit breaker state
    private int _consecutiveFailures;
    private DateTime _circuitOpenUntil = DateTime.MinValue;
    private readonly object _circuitLock = new();

    public BackendAbstractionLayer(
        IStorageStrategy inner,
        string backendId,
        ErrorNormalizer normalizer,
        FallbackChain? fallbackChain = null,
        BackendAbstractionOptions? options = null)

    // IStorageStrategy passthrough with added resilience
    public async Task<StorageObjectMetadata> StoreAsync(string key, Stream data, IDictionary<string, string>? metadata = null, CancellationToken ct = default)
    {
        CheckCircuitBreaker();
        try
        {
            var result = await ExecuteWithTimeoutAsync(
                () => _inner.StoreAsync(key, data, metadata, ct),
                _options.OperationTimeout, ct);
            RecordSuccess();
            return result;
        }
        catch (Exception ex)
        {
            RecordFailure();
            throw _normalizer.Normalize(ex, _backendId, "Store", key);
        }
    }

    // Same pattern for RetrieveAsync, DeleteAsync, ExistsAsync, ListAsync, GetMetadataAsync

    // Circuit breaker: open after N consecutive failures, half-open after cooldown
    private void CheckCircuitBreaker()
    {
        lock (_circuitLock)
        {
            if (_consecutiveFailures >= _options.CircuitBreakerThreshold &&
                DateTime.UtcNow < _circuitOpenUntil)
            {
                throw new BackendUnavailableException(
                    $"Circuit breaker open for backend '{_backendId}' until {_circuitOpenUntil:O}")
                    { BackendId = _backendId };
            }
        }
    }

    private void RecordFailure()
    {
        lock (_circuitLock)
        {
            _consecutiveFailures++;
            if (_consecutiveFailures >= _options.CircuitBreakerThreshold)
                _circuitOpenUntil = DateTime.UtcNow + _options.CircuitBreakerCooldown;
        }
    }

    private void RecordSuccess() { lock (_circuitLock) { _consecutiveFailures = 0; } }

    // Timeout wrapper
    private async Task<T> ExecuteWithTimeoutAsync<T>(Func<Task<T>> operation, TimeSpan timeout, CancellationToken ct)
    {
        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        timeoutCts.CancelAfter(timeout);
        return await operation();
    }
}

public record BackendAbstractionOptions
{
    public TimeSpan OperationTimeout { get; init; } = TimeSpan.FromSeconds(60);
    public int CircuitBreakerThreshold { get; init; } = 5;
    public TimeSpan CircuitBreakerCooldown { get; init; } = TimeSpan.FromSeconds(30);
    public bool EnableMetrics { get; init; } = true;
}
```

Forward all IStorageStrategy properties (StrategyId, Name, Tier, Capabilities) from _inner.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>BackendAbstractionLayer wraps any IStorageStrategy with circuit breaker, timeout, error normalization, and metrics</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/` compiles
- Circuit breaker opens after threshold failures and closes after cooldown
- Error normalization covers all common exception types
</verification>

<success_criteria>
- Any IStorageStrategy can be wrapped with resilience layer
- Circuit breaker prevents cascading failures
- Fallback chain tries alternatives before giving up
- All errors normalized to fabric exception hierarchy
</success_criteria>

<output>
After completion, create `.planning/phases/63-universal-fabric/63-08-SUMMARY.md`
</output>
