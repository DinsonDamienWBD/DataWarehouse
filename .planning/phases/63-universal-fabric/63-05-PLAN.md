---
phase: 63-universal-fabric
plan: 05
type: execute
wave: 2
depends_on: ["63-02"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementOptimizer.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementRule.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementScorer.cs
autonomous: true

must_haves:
  truths:
    - "PlacementOptimizer selects the best backend based on tags, tier, region, capacity, and cost"
    - "PlacementRules allow declarative backend selection policies"
    - "Placement scoring considers latency, available capacity, and backend priority"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementOptimizer.cs"
      provides: "Automatic backend selection engine"
      contains: "class PlacementOptimizer"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementRule.cs"
      provides: "Declarative placement rules"
      contains: "record PlacementRule"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementScorer.cs"
      provides: "Multi-factor backend scoring"
      contains: "class PlacementScorer"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementOptimizer.cs"
      to: "DataWarehouse.SDK/Storage/Fabric/IBackendRegistry.cs"
      via: "queries registry for candidates"
      pattern: "IBackendRegistry"
---

<objective>
Implement the Automatic Placement Optimizer that selects the optimal backend for new objects.

Purpose: When a store operation is issued without an explicit backend, the placement optimizer evaluates all available backends against the placement hints and rules to select the best target. This enables tag-based, cost-aware, and compliance-aware automatic placement.

Output: PlacementOptimizer, PlacementRule system, and PlacementScorer for multi-factor backend selection.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/63-universal-fabric/63-02-SUMMARY.md
@DataWarehouse.SDK/Storage/Fabric/IBackendRegistry.cs
@DataWarehouse.SDK/Storage/Fabric/BackendDescriptor.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PlacementRule and PlacementScorer</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementRule.cs, Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementScorer.cs</files>
  <action>
1. PlacementRule.cs -- declarative rules for backend selection:

```csharp
public record PlacementRule
{
    public required string Name { get; init; }
    public PlacementRuleType Type { get; init; }
    public PlacementCondition Condition { get; init; }
    public string? TargetBackendId { get; init; }         // Explicit backend
    public IReadOnlySet<string>? RequiredTags { get; init; }
    public IReadOnlySet<string>? ExcludedTags { get; init; }
    public StorageTier? RequiredTier { get; init; }
    public string? RequiredRegion { get; init; }
    public int Priority { get; init; } = 100;              // Lower = evaluated first
}

public enum PlacementRuleType { Include, Exclude, Prefer, Require }

public record PlacementCondition
{
    public string? ContentTypePattern { get; init; }       // e.g., "image/*", "video/*"
    public long? MinSizeBytes { get; init; }               // e.g., files > 1GB go to archive
    public long? MaxSizeBytes { get; init; }
    public IReadOnlySet<string>? MetadataKeys { get; init; } // e.g., if metadata has "compliance"
    public string? BucketPattern { get; init; }            // e.g., "archive-*"
}
```

2. PlacementScorer.cs -- multi-factor scoring:

```csharp
public class PlacementScorer
{
    // Score a backend for a given placement request (0.0 to 1.0)
    public double Score(BackendDescriptor backend, StoragePlacementHints hints, StorageHealthInfo? health)

    // Scoring factors (each 0.0 to 1.0, weighted):
    // - Tier match: 1.0 if exact match, 0.5 if adjacent tier, 0.0 if wrong tier (weight: 0.25)
    // - Tag match: proportion of required tags present (weight: 0.20)
    // - Region match: 1.0 if matches preferred region, 0.5 otherwise (weight: 0.15)
    // - Capacity: ratio of available to expected size, capped at 1.0 (weight: 0.15)
    // - Priority: normalized 1.0 - (priority / maxPriority) (weight: 0.10)
    // - Health: 1.0 healthy, 0.5 degraded, 0.0 unhealthy (weight: 0.10)
    // - Capability match: 1.0 if all required capabilities met (weight: 0.05)

    // Weights are configurable via constructor
    public PlacementScorer(PlacementWeights? weights = null)
}

public record PlacementWeights
{
    public double TierWeight { get; init; } = 0.25;
    public double TagWeight { get; init; } = 0.20;
    public double RegionWeight { get; init; } = 0.15;
    public double CapacityWeight { get; init; } = 0.15;
    public double PriorityWeight { get; init; } = 0.10;
    public double HealthWeight { get; init; } = 0.10;
    public double CapabilityWeight { get; init; } = 0.05;
}
```
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>PlacementRule and PlacementScorer compile with full multi-factor scoring</done>
</task>

<task type="auto">
  <name>Task 2: Implement PlacementOptimizer orchestrating rules and scoring</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/Placement/PlacementOptimizer.cs</files>
  <action>
PlacementOptimizer orchestrates rule evaluation and scoring to select the best backend:

```csharp
public class PlacementOptimizer
{
    private readonly IBackendRegistry _registry;
    private readonly PlacementScorer _scorer;
    private readonly List<PlacementRule> _rules = new();
    private readonly SemaphoreSlim _lock = new(1, 1);

    public PlacementOptimizer(IBackendRegistry registry, PlacementScorer? scorer = null)

    // Add/remove rules
    public void AddRule(PlacementRule rule)
    public void RemoveRule(string ruleName)
    public IReadOnlyList<PlacementRule> Rules { get; }

    // Select best backend for placement
    public async Task<PlacementResult> SelectBackendAsync(
        StoragePlacementHints hints,
        PlacementContext? context = null,
        CancellationToken ct = default)
    {
        // 1. Get all backends from registry
        // 2. Apply Require rules: filter to only backends matching required rules
        // 3. Apply Exclude rules: remove backends matching exclusion rules
        // 4. Apply condition-based rules (content type, size, metadata patterns)
        // 5. For remaining candidates, score each using PlacementScorer
        // 6. Sort by score descending
        // 7. If hints.PreferredBackendId is set and matches a candidate, prefer it (boost score by 0.2)
        // 8. Return PlacementResult with selected backend and score breakdown
        // 9. If no candidates remain, throw PlacementFailedException
    }

    // Select multiple backends (for replication scenarios)
    public async Task<IReadOnlyList<PlacementResult>> SelectBackendsAsync(
        StoragePlacementHints hints,
        int count,
        CancellationToken ct = default)
}

public record PlacementContext
{
    public string? ContentType { get; init; }
    public long? ObjectSize { get; init; }
    public IDictionary<string, string>? Metadata { get; init; }
    public string? BucketName { get; init; }
}

public record PlacementResult
{
    public required BackendDescriptor Backend { get; init; }
    public required double Score { get; init; }
    public required IReadOnlyDictionary<string, double> ScoreBreakdown { get; init; }
    public IReadOnlyList<BackendDescriptor>? Alternatives { get; init; }
}
```

The optimizer must be thread-safe (multiple concurrent store operations). Use read-write lock pattern for rules list.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>PlacementOptimizer selects backends with rule evaluation, multi-factor scoring, and fallback alternatives</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/` compiles
- PlacementOptimizer handles no-candidates case with PlacementFailedException
- Thread-safe concurrent placement requests
</verification>

<success_criteria>
- Tag-based rules correctly filter backends (e.g., "compliance:hipaa" only goes to HIPAA-certified backends)
- Multi-factor scoring produces deterministic rankings
- Placement result includes score breakdown for observability
</success_criteria>

<output>
After completion, create `.planning/phases/63-universal-fabric/63-05-SUMMARY.md`
</output>
