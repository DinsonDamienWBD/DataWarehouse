---
phase: 63-universal-fabric
plan: 06
type: execute
wave: 3
depends_on: ["63-03", "63-04"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3HttpServer.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3RequestParser.cs
  - Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3ResponseWriter.cs
autonomous: true

must_haves:
  truths:
    - "S3HttpServer listens on a configurable port and handles S3 API requests"
    - "S3RequestParser extracts bucket name, key, and operation from HTTP requests"
    - "S3ResponseWriter formats responses in S3 XML format"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3HttpServer.cs"
      provides: "HTTP listener implementing S3 API"
      contains: "class S3HttpServer"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3RequestParser.cs"
      provides: "S3 request routing and parsing"
      contains: "class S3RequestParser"
    - path: "Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3ResponseWriter.cs"
      provides: "S3 XML response formatting"
      contains: "class S3ResponseWriter"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3HttpServer.cs"
      to: "DataWarehouse.SDK/Storage/Fabric/IStorageFabric.cs"
      via: "delegates operations to fabric"
      pattern: "IStorageFabric"
    - from: "Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3RequestParser.cs"
      to: "DataWarehouse.SDK/Storage/Fabric/S3Types.cs"
      via: "creates S3 request DTOs"
      pattern: "S3GetObjectRequest"
---

<objective>
Implement the S3-Compatible HTTP Server that makes DataWarehouse a drop-in MinIO/S3 replacement.

Purpose: This server exposes all storage backends through the standard S3 API. Any S3 client (AWS CLI, boto3, MinIO client, etc.) can connect and use DataWarehouse as their storage backend. Buckets map to dw:// namespaces.

Output: Working HTTP server handling ListBuckets, Get/Put/Delete/Head/ListObjects, multipart upload, and presigned URLs.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/63-universal-fabric/63-03-SUMMARY.md
@.planning/phases/63-universal-fabric/63-04-SUMMARY.md
@DataWarehouse.SDK/Storage/Fabric/IS3CompatibleServer.cs
@DataWarehouse.SDK/Storage/Fabric/S3Types.cs
@DataWarehouse.SDK/Storage/Fabric/IS3AuthProvider.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement S3RequestParser and S3ResponseWriter</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3RequestParser.cs, Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3ResponseWriter.cs</files>
  <action>
1. S3RequestParser.cs -- parse HttpListenerRequest into S3 operation:

```csharp
public class S3RequestParser
{
    // Determine which S3 operation from the HTTP request
    public S3Operation ParseOperation(HttpListenerRequest request)
    // Returns enum: ListBuckets, CreateBucket, DeleteBucket, GetObject, PutObject,
    //   DeleteObject, HeadObject, ListObjectsV2, InitiateMultipartUpload,
    //   UploadPart, CompleteMultipartUpload, AbortMultipartUpload, CopyObject

    // Extract bucket and key from path-style or virtual-hosted-style URL
    // Path style: /bucketname/key  (default)
    // Virtual host: bucketname.s3.localhost/key
    public (string? bucket, string? key) ExtractBucketAndKey(HttpListenerRequest request)

    // Parse specific request types
    public S3GetObjectRequest ParseGetObject(HttpListenerRequest req, string bucket, string key)
    public S3PutObjectRequest ParsePutObject(HttpListenerRequest req, string bucket, string key)
    public S3ListObjectsRequest ParseListObjects(HttpListenerRequest req, string bucket)
    public S3InitiateMultipartRequest ParseInitiateMultipart(HttpListenerRequest req, string bucket, string key)
    public S3UploadPartRequest ParseUploadPart(HttpListenerRequest req, string bucket, string key)
    public S3CompleteMultipartRequest ParseCompleteMultipart(HttpListenerRequest req, string bucket, string key)
    public S3CopyObjectRequest ParseCopyObject(HttpListenerRequest req, string bucket, string key)
}
```

Operation detection logic:
- GET / (no bucket) -> ListBuckets
- PUT /bucket (no key) -> CreateBucket
- DELETE /bucket (no key) -> DeleteBucket
- GET /bucket/key -> GetObject
- PUT /bucket/key -> PutObject (or CopyObject if x-amz-copy-source header)
- DELETE /bucket/key -> DeleteObject
- HEAD /bucket/key -> HeadObject
- GET /bucket?list-type=2 -> ListObjectsV2
- POST /bucket/key?uploads -> InitiateMultipartUpload
- PUT /bucket/key?partNumber=N&uploadId=X -> UploadPart
- POST /bucket/key?uploadId=X -> CompleteMultipartUpload
- DELETE /bucket/key?uploadId=X -> AbortMultipartUpload

2. S3ResponseWriter.cs -- write S3 XML responses:

```csharp
public class S3ResponseWriter
{
    // Write standard S3 XML responses
    public void WriteListBucketsResponse(HttpListenerResponse resp, S3ListBucketsResponse data)
    public void WriteListObjectsResponse(HttpListenerResponse resp, S3ListObjectsResponse data)
    public void WriteInitiateMultipartResponse(HttpListenerResponse resp, S3InitiateMultipartResponse data)
    public void WriteCompleteMultipartResponse(HttpListenerResponse resp, S3CompleteMultipartResponse data)
    public void WriteCopyObjectResponse(HttpListenerResponse resp, S3CopyObjectResponse data)
    public void WriteErrorResponse(HttpListenerResponse resp, int statusCode, string errorCode, string message, string? resource = null)

    // Set standard S3 headers
    public void SetObjectHeaders(HttpListenerResponse resp, S3HeadObjectResponse metadata)
}
```

Use System.Xml.Linq (XElement/XDocument) for XML generation. S3 XML namespace: "http://s3.amazonaws.com/doc/2006-03-01/".

Error codes follow S3 spec: NoSuchBucket, NoSuchKey, InvalidBucketName, BucketAlreadyExists, InvalidArgument, InternalError, AccessDenied.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>S3RequestParser correctly identifies all S3 operations from HTTP requests; S3ResponseWriter produces valid S3 XML</done>
</task>

<task type="auto">
  <name>Task 2: Implement S3HttpServer with full request dispatch</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalFabric/S3Server/S3HttpServer.cs</files>
  <action>
S3HttpServer implements IS3CompatibleServer using HttpListener:

```csharp
public class S3HttpServer : IS3CompatibleServer
{
    private readonly IStorageFabric _fabric;
    private readonly S3RequestParser _parser = new();
    private readonly S3ResponseWriter _writer = new();
    private HttpListener? _listener;
    private CancellationTokenSource? _cts;
    private Task? _listenerTask;

    // Multipart upload state
    private readonly ConcurrentDictionary<string, MultipartUploadState> _activeUploads = new();

    public S3HttpServer(IStorageFabric fabric) { _fabric = fabric; }

    public async Task StartAsync(S3ServerOptions options, CancellationToken ct)
    {
        _listener = new HttpListener();
        var prefix = options.UseTls ? "https" : "http";
        _listener.Prefixes.Add($"{prefix}://{options.Host}:{options.Port}/");
        _listener.Start();
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        ListenUrl = $"{prefix}://{options.Host}:{options.Port}";
        _listenerTask = AcceptLoopAsync(_cts.Token);
    }

    private async Task AcceptLoopAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            var context = await _listener!.GetContextAsync();
            _ = Task.Run(() => HandleRequestAsync(context, ct), ct);
        }
    }

    private async Task HandleRequestAsync(HttpListenerContext context, CancellationToken ct)
    {
        try
        {
            // Auth check if provider configured
            // Parse operation
            // Dispatch to appropriate handler
            // Map bucket name to dw://bucket address for fabric operations
            var operation = _parser.ParseOperation(context.Request);
            var (bucket, key) = _parser.ExtractBucketAndKey(context.Request);

            switch (operation)
            {
                case S3Operation.ListBuckets: await HandleListBuckets(context, ct); break;
                case S3Operation.GetObject: await HandleGetObject(context, bucket!, key!, ct); break;
                case S3Operation.PutObject: await HandlePutObject(context, bucket!, key!, ct); break;
                case S3Operation.DeleteObject: await HandleDeleteObject(context, bucket!, key!, ct); break;
                case S3Operation.HeadObject: await HandleHeadObject(context, bucket!, key!, ct); break;
                case S3Operation.ListObjectsV2: await HandleListObjects(context, bucket!, ct); break;
                // ... all operations
            }
        }
        catch (Exception ex)
        {
            _writer.WriteErrorResponse(context.Response, 500, "InternalError", ex.Message);
        }
    }
}
```

Key handlers:
- HandleGetObject: resolve dw://bucket/key, retrieve from fabric, stream response body, set Content-Type/Content-Length/ETag/Last-Modified headers
- HandlePutObject: read request body, store via fabric at dw://bucket/key, return ETag
- HandleListBuckets: query registry for all bucket mappings, return XML
- HandleListObjects: list via fabric with prefix/delimiter, paginate with continuation token
- HandleHeadObject: get metadata, set headers, 200 with no body

Multipart:
- InitiateMultipartUpload: generate upload ID (GUID), store in _activeUploads, return XML
- UploadPart: store part in temp location (dw://bucket/.multipart/uploadId/partNumber), return ETag
- CompleteMultipartUpload: concatenate parts into final object, delete temp parts, return XML
- AbortMultipartUpload: delete all temp parts, remove from _activeUploads

Presigned URLs:
- GeneratePresignedUrlAsync: create HMAC-signed URL with expiry timestamp, query params for auth

StopAsync: cancel CTS, stop listener, dispose.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/DataWarehouse.Plugins.UniversalFabric.csproj 2>&1 | tail -5</verify>
  <done>S3HttpServer compiles with full S3 API dispatch: ListBuckets, Get/Put/Delete/Head/ListObjects, multipart upload, presigned URLs</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UniversalFabric/` compiles
- All S3 operations routed to correct handlers
- XML responses follow S3 namespace conventions
</verification>

<success_criteria>
- S3-compatible endpoint can be accessed by standard S3 clients
- Path-style URL parsing works correctly
- Multipart upload tracks state and concatenates parts
- Error responses use proper S3 error codes
</success_criteria>

<output>
After completion, create `.planning/phases/63-universal-fabric/63-06-SUMMARY.md`
</output>
