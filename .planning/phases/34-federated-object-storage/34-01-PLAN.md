---
phase: 34-federated-object-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Federation/Routing/RequestLanguage.cs
  - DataWarehouse.SDK/Federation/Routing/IRequestClassifier.cs
  - DataWarehouse.SDK/Federation/Routing/IStorageRouter.cs
  - DataWarehouse.SDK/Federation/Routing/StorageRequest.cs
  - DataWarehouse.SDK/Federation/Routing/DualHeadRouter.cs
  - DataWarehouse.SDK/Federation/Routing/PatternBasedClassifier.cs
  - DataWarehouse.SDK/Federation/Routing/RoutingPipeline.cs
autonomous: true

must_haves:
  truths:
    - "DualHeadRouter.RouteRequest correctly classifies UUID-based requests as Object language"
    - "DualHeadRouter.RouteRequest correctly classifies path-based requests as FilePath language"
    - "Mixed requests (path containing UUID) use configurable default with override hints"
    - "Classification is O(1) via pattern matching on request properties"
    - "Router delegates to appropriate pipeline based on classification"
  artifacts:
    - path: "DataWarehouse.SDK/Federation/Routing/RequestLanguage.cs"
      provides: "Enum discriminating Object vs FilePath language"
      min_lines: 10
    - path: "DataWarehouse.SDK/Federation/Routing/IRequestClassifier.cs"
      provides: "Interface for request classification strategy"
      min_lines: 15
    - path: "DataWarehouse.SDK/Federation/Routing/DualHeadRouter.cs"
      provides: "Main router implementation with dual-pipeline dispatch"
      min_lines: 150
    - path: "DataWarehouse.SDK/Federation/Routing/PatternBasedClassifier.cs"
      provides: "Pattern-matching classifier implementation"
      min_lines: 100
  key_links:
    - from: "DualHeadRouter"
      to: "IRequestClassifier"
      via: "constructor injection for pluggable classification"
      pattern: "IRequestClassifier.*_classifier"
    - from: "DualHeadRouter"
      to: "RoutingPipeline"
      via: "delegates to ObjectPipeline or FilePathPipeline based on classification"
      pattern: "RoutingPipeline.*Pipeline"
    - from: "PatternBasedClassifier"
      to: "StorageRequest"
      via: "examines request properties for classification signals"
      pattern: "StorageRequest\\."
---

<objective>
Create the Dual-Head Router (FOS-01) -- a request classification engine that determines whether incoming requests use Object Language (UUID, metadata queries, object operations) or FilePath Language (paths, directory listings, filesystem operations) and routes through the appropriate pipeline.

Purpose: This is the foundational entry point for federated object storage. All subsequent routing intelligence (permission-aware, location-aware, replication-aware) builds on top of this classification.

Output:
- `RequestLanguage` enum (Object, FilePath)
- `IRequestClassifier` interface for pluggable classification strategies
- `IStorageRouter` interface defining router contract
- `StorageRequest` class modeling incoming requests
- `DualHeadRouter` implementation with dual-pipeline dispatch
- `PatternBasedClassifier` default implementation using pattern matching
- `RoutingPipeline` abstract base for Object and FilePath pipelines
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/34-federated-object-storage/34-RESEARCH.md

@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
@DataWarehouse.SDK/Storage/StorageAddress.cs
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Request Language Enum and Core Interfaces</name>
  <files>
    DataWarehouse.SDK/Federation/Routing/RequestLanguage.cs
    DataWarehouse.SDK/Federation/Routing/IRequestClassifier.cs
    DataWarehouse.SDK/Federation/Routing/IStorageRouter.cs
    DataWarehouse.SDK/Federation/Routing/StorageRequest.cs
  </files>
  <action>
Create the `Federation/Routing/` directory under `DataWarehouse.SDK/`.

**File 1: RequestLanguage.cs**

Namespace: `DataWarehouse.SDK.Federation.Routing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Federated object storage language classification")]
public enum RequestLanguage
{
    /// <summary>Object-based addressing: UUIDs, metadata queries, object operations</summary>
    Object = 0,

    /// <summary>FilePath-based addressing: paths, directory listings, filesystem operations</summary>
    FilePath = 1
}
```

**File 2: StorageRequest.cs**

Namespace: `DataWarehouse.SDK.Federation.Routing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Storage request model for routing")]
public sealed class StorageRequest
{
    public required string RequestId { get; init; }
    public required StorageAddress Address { get; init; }
    public required StorageOperation Operation { get; init; }
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }
    public RequestLanguage? LanguageHint { get; init; }  // Optional override
    public string? UserId { get; init; }  // For permission checks
    public DateTimeOffset TimestampUtc { get; init; } = DateTimeOffset.UtcNow;
}

public enum StorageOperation
{
    Read,
    Write,
    Delete,
    List,
    GetMetadata,
    SetMetadata,
    Query
}
```

Add XML docs on all members.

**File 3: IRequestClassifier.cs**

Namespace: `DataWarehouse.SDK.Federation.Routing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Pluggable request classification strategy")]
public interface IRequestClassifier
{
    /// <summary>
    /// Classifies a storage request as Object or FilePath language.
    /// Classification should be O(1) via pattern matching.
    /// </summary>
    RequestLanguage Classify(StorageRequest request);
}
```

**File 4: IStorageRouter.cs**

Namespace: `DataWarehouse.SDK.Federation.Routing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Storage router contract")]
public interface IStorageRouter
{
    /// <summary>
    /// Routes a storage request to the appropriate pipeline based on language classification.
    /// </summary>
    Task<StorageResponse> RouteRequestAsync(StorageRequest request, CancellationToken ct = default);
}

public sealed class StorageResponse
{
    public required bool Success { get; init; }
    public required string NodeId { get; init; }
    public byte[]? Data { get; init; }
    public string? ErrorMessage { get; init; }
    public TimeSpan Latency { get; init; }
}
```

Add XML documentation on all interfaces and classes.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify all 4 files exist under DataWarehouse.SDK/Federation/Routing/.
  </verify>
  <done>
RequestLanguage enum defines Object vs FilePath. StorageRequest models incoming requests with address, operation, metadata, and optional language hint. IRequestClassifier defines classification contract. IStorageRouter defines router contract.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pattern-Based Classifier Implementation</name>
  <files>
    DataWarehouse.SDK/Federation/Routing/PatternBasedClassifier.cs
  </files>
  <action>
Create `PatternBasedClassifier` implementing `IRequestClassifier`.

Namespace: `DataWarehouse.SDK.Federation.Routing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Pattern-based request classifier")]
public sealed class PatternBasedClassifier : IRequestClassifier
```

Constructor takes `PatternClassifierConfiguration? config = null`.

Configuration record:
```csharp
public sealed record PatternClassifierConfiguration
{
    public RequestLanguage DefaultLanguage { get; init; } = RequestLanguage.Object;
    public bool PreferHints { get; init; } = true;
}
```

**Classification Logic** (`Classify` method):

1. If `request.LanguageHint` is set AND `config.PreferHints == true`, return the hint
2. Examine `request.Address`:
   - If `Address.Kind == StorageAddressKind.ObjectKey`, return `RequestLanguage.Object`
   - If `Address.Kind == StorageAddressKind.FilePath`, return `RequestLanguage.FilePath`
3. If `Address` is `ObjectKeyAddress`, check the key:
   - If key matches UUID pattern (regex `^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`), return `RequestLanguage.Object`
4. Examine `request.Operation`:
   - If operation is `GetMetadata`, `SetMetadata`, or `Query`, return `RequestLanguage.Object`
   - If operation is `List`, return `RequestLanguage.FilePath`
5. Examine `request.Metadata`:
   - If metadata contains key "object-id" or "uuid", return `RequestLanguage.Object`
   - If metadata contains key "path" or "directory", return `RequestLanguage.FilePath`
6. Fallback: return `config.DefaultLanguage`

Use compiled Regex for UUID pattern with `RegexOptions.Compiled | RegexOptions.CultureInvariant`.

Add comprehensive XML documentation explaining classification heuristics.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `IRequestClassifier` confirms interface implementation. Grep for `Regex.*Compiled` confirms regex optimization.
  </verify>
  <done>
PatternBasedClassifier implements O(1) classification via StorageAddress kind, UUID pattern matching, operation type, and metadata signals. Configurable default language and hint preference.
  </done>
</task>

<task type="auto">
  <name>Task 3: Routing Pipeline Abstraction and Dual-Head Router</name>
  <files>
    DataWarehouse.SDK/Federation/Routing/RoutingPipeline.cs
    DataWarehouse.SDK/Federation/Routing/DualHeadRouter.cs
  </files>
  <action>
**File 1: RoutingPipeline.cs**

Namespace: `DataWarehouse.SDK.Federation.Routing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Abstract routing pipeline")]
public abstract class RoutingPipeline
{
    public RequestLanguage Language { get; }

    protected RoutingPipeline(RequestLanguage language)
    {
        Language = language;
    }

    public abstract Task<StorageResponse> ExecuteAsync(StorageRequest request, CancellationToken ct);
}
```

Concrete stub implementations for Wave 1 (real implementations in later plans):

```csharp
internal sealed class ObjectPipeline : RoutingPipeline
{
    public ObjectPipeline() : base(RequestLanguage.Object) { }

    public override Task<StorageResponse> ExecuteAsync(StorageRequest request, CancellationToken ct)
    {
        // TODO Phase 34-02: Implement UUID-based object routing
        return Task.FromResult(new StorageResponse
        {
            Success = false,
            NodeId = "local",
            ErrorMessage = "ObjectPipeline not yet implemented"
        });
    }
}

internal sealed class FilePathPipeline : RoutingPipeline
{
    public FilePathPipeline() : base(RequestLanguage.FilePath) { }

    public override Task<StorageResponse> ExecuteAsync(StorageRequest request, CancellationToken ct)
    {
        // TODO Phase 34-02: Implement FilePath routing to VDE or filesystem
        return Task.FromResult(new StorageResponse
        {
            Success = false,
            NodeId = "local",
            ErrorMessage = "FilePathPipeline not yet implemented"
        });
    }
}
```

**File 2: DualHeadRouter.cs**

Namespace: `DataWarehouse.SDK.Federation.Routing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Dual-head router with language-based dispatch")]
public sealed class DualHeadRouter : IStorageRouter
```

Constructor takes:
- `IRequestClassifier classifier`
- `RoutingPipeline objectPipeline`
- `RoutingPipeline filePathPipeline`

Internal state:
- `readonly IRequestClassifier _classifier`
- `readonly RoutingPipeline _objectPipeline`
- `readonly RoutingPipeline _filePathPipeline`
- `readonly ConcurrentDictionary<RequestLanguage, long> _routingCounters` (for observability)

**RouteRequestAsync Implementation**:

```csharp
public async Task<StorageResponse> RouteRequestAsync(StorageRequest request, CancellationToken ct = default)
{
    ArgumentNullException.ThrowIfNull(request);

    var sw = Stopwatch.StartNew();

    try
    {
        // Classify request
        var language = _classifier.Classify(request);

        // Update metrics
        _routingCounters.AddOrUpdate(language, 1, (_, count) => count + 1);

        // Select pipeline
        var pipeline = language switch
        {
            RequestLanguage.Object => _objectPipeline,
            RequestLanguage.FilePath => _filePathPipeline,
            _ => throw new InvalidOperationException($"Unknown language: {language}")
        };

        // Execute
        var response = await pipeline.ExecuteAsync(request, ct).ConfigureAwait(false);

        sw.Stop();
        return response with { Latency = sw.Elapsed };
    }
    catch (Exception ex)
    {
        sw.Stop();
        return new StorageResponse
        {
            Success = false,
            NodeId = "router",
            ErrorMessage = $"Routing failed: {ex.Message}",
            Latency = sw.Elapsed
        };
    }
}
```

Add observability methods:
```csharp
public IReadOnlyDictionary<RequestLanguage, long> GetRoutingCounters() => _routingCounters;
```

Add comprehensive XML documentation.

Use `ArgumentNullException.ThrowIfNull` for parameter validation.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `IStorageRouter` in DualHeadRouter.cs confirms interface implementation. Grep for `Stopwatch` confirms latency tracking.
  </verify>
  <done>
DualHeadRouter implements IStorageRouter with classification-based dispatch to ObjectPipeline or FilePathPipeline. RoutingPipeline abstraction allows pluggable pipeline implementations. Routing counters provide observability. Stub pipelines return not-implemented errors until Phase 34-02.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 7 files exist under DataWarehouse.SDK/Federation/Routing/
3. RequestLanguage enum has Object and FilePath members
4. IRequestClassifier defines Classify method
5. PatternBasedClassifier implements UUID pattern matching
6. DualHeadRouter implements IStorageRouter with dual-pipeline dispatch
7. Routing counters track Object vs FilePath classification counts
8. All async methods accept and propagate CancellationToken
9. All types have XML documentation
10. SdkCompatibility attribute on all public types
</verification>

<success_criteria>
- DualHeadRouter correctly classifies UUID-based requests (e.g., "550e8400-e29b-41d4-a716-446655440000") as Object
- DualHeadRouter correctly classifies path-based requests (e.g., "C:\data\file.bin") as FilePath
- Mixed requests (e.g., path with embedded UUID) use configurable default or hint override
- Classification is O(1) via pattern matching (no database lookups, no network calls)
- Router delegates to appropriate pipeline based on classification
- Routing counters provide observability into classification distribution
- Zero new NuGet dependencies
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-federated-object-storage/34-01-SUMMARY.md`
</output>
