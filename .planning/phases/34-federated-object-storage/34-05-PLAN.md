---
phase: 34-federated-object-storage
plan: 05
type: execute
wave: 3
depends_on: [29-01, 29-02]
files_modified:
  - DataWarehouse.SDK/Federation/Orchestration/IFederationOrchestrator.cs
  - DataWarehouse.SDK/Federation/Orchestration/FederationOrchestrator.cs
  - DataWarehouse.SDK/Federation/Orchestration/NodeRegistration.cs
  - DataWarehouse.SDK/Federation/Orchestration/ClusterTopology.cs
  - DataWarehouse.SDK/Federation/Orchestration/NodeHeartbeat.cs
autonomous: true

must_haves:
  truths:
    - "Nodes register with orchestrator via SWIM membership"
    - "Topology management tracks rack/DC/region metadata from node announcements"
    - "Health monitoring via periodic heartbeats with resource metrics"
    - "Graceful scale-in/out updates cluster topology via Raft consensus"
    - "Split-brain prevention via Raft quorum for topology changes"
  artifacts:
    - path: "DataWarehouse.SDK/Federation/Orchestration/FederationOrchestrator.cs"
      provides: "Cluster lifecycle manager with node registration and health monitoring"
      min_lines: 250
    - path: "DataWarehouse.SDK/Federation/Orchestration/ClusterTopology.cs"
      provides: "Cluster-wide topology state with Raft-backed consistency"
      min_lines: 100
---

<objective>
Implement Federation Orchestrator (FOS-05) -- manages multi-node storage cluster lifecycle with node registration, topology management, health monitoring, graceful scale-in/out, and split-brain prevention using Raft from Phase 29.

Output: IFederationOrchestrator, FederationOrchestrator, NodeRegistration, ClusterTopology, NodeHeartbeat
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/34-federated-object-storage/34-RESEARCH.md
@DataWarehouse.SDK/Contracts/Distributed/IClusterMembership.cs
@DataWarehouse.SDK/Contracts/IConsensusEngine.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Membership/SwimClusterMembership.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Node Registration and Heartbeat Types</name>
  <files>
    DataWarehouse.SDK/Federation/Orchestration/NodeRegistration.cs
    DataWarehouse.SDK/Federation/Orchestration/NodeHeartbeat.cs
    DataWarehouse.SDK/Federation/Orchestration/ClusterTopology.cs
  </files>
  <action>
Create `Federation/Orchestration/` directory.

**NodeRegistration.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Node registration metadata")]
public sealed record NodeRegistration
{
    public required string NodeId { get; init; }
    public required string Address { get; init; }
    public required int Port { get; init; }
    public string? Rack { get; init; }
    public string? Datacenter { get; init; }
    public string? Region { get; init; }
    public double? Latitude { get; init; }
    public double? Longitude { get; init; }
    public long TotalBytes { get; init; }
    public DateTimeOffset RegisteredAt { get; init; } = DateTimeOffset.UtcNow;
    public IReadOnlyDictionary<string, string>? Tags { get; init; }
}
```

**NodeHeartbeat.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Node heartbeat with health metrics")]
public sealed record NodeHeartbeat
{
    public required string NodeId { get; init; }
    public required long FreeBytes { get; init; }
    public required long TotalBytes { get; init; }
    public required double HealthScore { get; init; }  // 0.0 to 1.0
    public required DateTimeOffset TimestampUtc { get; init; }
    public int ActiveRequests { get; init; }
    public TimeSpan AverageLatency { get; init; }
}
```

**ClusterTopology.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Cluster-wide topology state")]
public sealed class ClusterTopology
{
    private readonly ConcurrentDictionary<string, NodeTopology> _nodes;
    private readonly ReaderWriterLockSlim _lock;

    public ClusterTopology()
    {
        _nodes = new ConcurrentDictionary<string, NodeTopology>();
        _lock = new ReaderWriterLockSlim();
    }

    public void AddOrUpdateNode(NodeTopology node)
    {
        _lock.EnterWriteLock();
        try
        {
            _nodes[node.NodeId] = node;
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    public void RemoveNode(string nodeId)
    {
        _lock.EnterWriteLock();
        try
        {
            _nodes.TryRemove(nodeId, out _);
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    public NodeTopology? GetNode(string nodeId)
    {
        _lock.EnterReadLock();
        try
        {
            _nodes.TryGetValue(nodeId, out var node);
            return node;
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public IReadOnlyList<NodeTopology> GetAllNodes()
    {
        _lock.EnterReadLock();
        try
        {
            return _nodes.Values.ToList();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public byte[] Serialize()
    {
        _lock.EnterReadLock();
        try
        {
            return JsonSerializer.SerializeToUtf8Bytes(_nodes.Values.ToList());
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public static ClusterTopology Deserialize(byte[] data)
    {
        var nodes = JsonSerializer.Deserialize<List<NodeTopology>>(data) ?? new List<NodeTopology>();
        var topology = new ClusterTopology();
        foreach (var node in nodes)
        {
            topology.AddOrUpdateNode(node);
        }
        return topology;
    }
}
```
  </action>
  <verify>
Compile with zero errors.
  </verify>
  <done>
NodeRegistration, NodeHeartbeat, ClusterTopology defined with thread-safe operations and serialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Federation Orchestrator Implementation</name>
  <files>
    DataWarehouse.SDK/Federation/Orchestration/IFederationOrchestrator.cs
    DataWarehouse.SDK/Federation/Orchestration/FederationOrchestrator.cs
  </files>
  <action>
**IFederationOrchestrator.cs**:
```csharp
public interface IFederationOrchestrator : IDisposable
{
    Task StartAsync(CancellationToken ct = default);
    Task StopAsync(CancellationToken ct = default);
    Task RegisterNodeAsync(NodeRegistration registration, CancellationToken ct = default);
    Task UnregisterNodeAsync(string nodeId, CancellationToken ct = default);
    Task SendHeartbeatAsync(NodeHeartbeat heartbeat, CancellationToken ct = default);
    Task<ClusterTopology> GetTopologyAsync(CancellationToken ct = default);
}
```

**FederationOrchestrator.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Federation orchestrator with Raft-backed topology")]
public sealed class FederationOrchestrator : IFederationOrchestrator, ITopologyProvider
{
    private readonly IClusterMembership _membership;
    private readonly IConsensusEngine? _raft;
    private readonly IMessageBus _messageBus;
    private readonly ClusterTopology _topology;
    private readonly PeriodicTimer _healthCheckTimer;
    private readonly CancellationTokenSource _cts;
    private readonly FederationOrchestratorConfiguration _config;

    public FederationOrchestrator(
        IClusterMembership membership,
        IMessageBus messageBus,
        IConsensusEngine? raft = null,
        FederationOrchestratorConfiguration? config = null)
    {
        _membership = membership;
        _raft = raft;
        _messageBus = messageBus;
        _topology = new ClusterTopology();
        _config = config ?? new FederationOrchestratorConfiguration();
        _healthCheckTimer = new PeriodicTimer(TimeSpan.FromSeconds(_config.HealthCheckIntervalSeconds));
        _cts = new CancellationTokenSource();
    }

    public async Task StartAsync(CancellationToken ct = default)
    {
        // Subscribe to membership changes
        _membership.OnMembershipChanged += HandleMembershipChangedAsync;

        // Start health check loop
        _ = RunHealthCheckLoopAsync(_cts.Token);

        await Task.CompletedTask;
    }

    public async Task StopAsync(CancellationToken ct = default)
    {
        _cts.Cancel();
        _membership.OnMembershipChanged -= HandleMembershipChangedAsync;
        await Task.CompletedTask;
    }

    public async Task RegisterNodeAsync(NodeRegistration registration, CancellationToken ct = default)
    {
        var nodeTopology = new NodeTopology
        {
            NodeId = registration.NodeId,
            Address = registration.Address,
            Port = registration.Port,
            Rack = registration.Rack,
            Datacenter = registration.Datacenter,
            Region = registration.Region,
            Latitude = registration.Latitude,
            Longitude = registration.Longitude,
            TotalBytes = registration.TotalBytes,
            FreeBytes = registration.TotalBytes,
            HealthScore = 1.0,
            LastHeartbeat = DateTimeOffset.UtcNow
        };

        // Propose topology change via Raft if available
        if (_raft != null)
        {
            var command = new { action = "add-node", node = nodeTopology };
            await _raft.ProposeAsync(JsonSerializer.SerializeToUtf8Bytes(command), ct).ConfigureAwait(false);
        }
        else
        {
            _topology.AddOrUpdateNode(nodeTopology);
        }

        // Publish event
        await _messageBus.PublishAsync("federation.node.registered", nodeTopology, ct).ConfigureAwait(false);
    }

    public async Task UnregisterNodeAsync(string nodeId, CancellationToken ct = default)
    {
        if (_raft != null)
        {
            var command = new { action = "remove-node", nodeId };
            await _raft.ProposeAsync(JsonSerializer.SerializeToUtf8Bytes(command), ct).ConfigureAwait(false);
        }
        else
        {
            _topology.RemoveNode(nodeId);
        }

        await _messageBus.PublishAsync("federation.node.unregistered", nodeId, ct).ConfigureAwait(false);
    }

    public async Task SendHeartbeatAsync(NodeHeartbeat heartbeat, CancellationToken ct = default)
    {
        var node = _topology.GetNode(heartbeat.NodeId);
        if (node != null)
        {
            var updated = node with
            {
                FreeBytes = heartbeat.FreeBytes,
                HealthScore = heartbeat.HealthScore,
                LastHeartbeat = heartbeat.TimestampUtc
            };

            _topology.AddOrUpdateNode(updated);
        }

        await Task.CompletedTask;
    }

    public Task<ClusterTopology> GetTopologyAsync(CancellationToken ct = default)
    {
        return Task.FromResult(_topology);
    }

    // ITopologyProvider implementation
    public Task<NodeTopology?> GetNodeTopologyAsync(string nodeId, CancellationToken ct = default)
    {
        return Task.FromResult(_topology.GetNode(nodeId));
    }

    public Task<IReadOnlyList<NodeTopology>> GetAllNodesAsync(CancellationToken ct = default)
    {
        return Task.FromResult(_topology.GetAllNodes());
    }

    public Task<NodeTopology?> GetSelfTopologyAsync(CancellationToken ct = default)
    {
        var self = _membership.GetSelf();
        return Task.FromResult(_topology.GetNode(self.NodeId));
    }

    private async Task RunHealthCheckLoopAsync(CancellationToken ct)
    {
        try
        {
            while (await _healthCheckTimer.WaitForNextTickAsync(ct).ConfigureAwait(false))
            {
                await CheckNodeHealthAsync(ct).ConfigureAwait(false);
            }
        }
        catch (OperationCanceledException) { }
    }

    private async Task CheckNodeHealthAsync(CancellationToken ct)
    {
        var nodes = _topology.GetAllNodes();
        var staleThreshold = DateTimeOffset.UtcNow - TimeSpan.FromSeconds(_config.HeartbeatTimeoutSeconds);

        foreach (var node in nodes)
        {
            if (node.LastHeartbeat < staleThreshold)
            {
                // Mark node as degraded
                var degraded = node with { HealthScore = Math.Max(0.0, node.HealthScore - 0.2) };
                _topology.AddOrUpdateNode(degraded);

                if (degraded.HealthScore <= 0.0)
                {
                    await _messageBus.PublishAsync("federation.node.failed", node.NodeId, ct).ConfigureAwait(false);
                }
            }
        }
    }

    private Task HandleMembershipChangedAsync(object? sender, ClusterMembershipEventArgs e)
    {
        // Sync cluster membership changes to topology
        if (e.EventType == ClusterMembershipEventType.NodeDead)
        {
            _topology.RemoveNode(e.Node.NodeId);
        }
        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _cts.Cancel();
        _cts.Dispose();
        _healthCheckTimer.Dispose();
    }
}

public sealed record FederationOrchestratorConfiguration
{
    public int HealthCheckIntervalSeconds { get; init; } = 10;
    public int HeartbeatTimeoutSeconds { get; init; } = 30;
}
```
  </action>
  <verify>
Compile with zero errors. Grep for `IConsensusEngine` confirms Raft integration.
  </verify>
  <done>
FederationOrchestrator manages cluster topology with Raft-backed consistency, health monitoring via heartbeats, and automatic health degradation for stale nodes.
  </done>
</task>

</tasks>

<verification>
1. Build compiles with zero errors
2. FederationOrchestrator implements IFederationOrchestrator and ITopologyProvider
3. Node registration/unregistration goes through Raft if available
4. Health check loop degrades node health scores for stale heartbeats
5. Membership changes synced to topology
</verification>

<success_criteria>
- Add node to 3-node cluster → topology updated via Raft, all nodes see new node
- Remove node → topology updated, data rebalancing triggered (future work)
- Network partition → split-brain prevented via Raft quorum
- Stale heartbeat (>30 seconds) → node health score degraded
- Zero new NuGet dependencies, zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-federated-object-storage/34-05-SUMMARY.md`
</output>
