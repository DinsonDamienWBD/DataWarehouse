---
phase: 34-federated-object-storage
plan: 04
type: execute
wave: 2
depends_on: [34-01]
files_modified:
  - DataWarehouse.SDK/Federation/Topology/ITopologyProvider.cs
  - DataWarehouse.SDK/Federation/Topology/NodeTopology.cs
  - DataWarehouse.SDK/Federation/Topology/RoutingPolicy.cs
  - DataWarehouse.SDK/Federation/Topology/LocationAwareRouter.cs
  - DataWarehouse.SDK/Federation/Topology/ProximityCalculator.cs
autonomous: true

must_haves:
  truths:
    - "Router considers network topology (same-rack, same-DC, cross-DC) when selecting target nodes"
    - "Geographic proximity calculated from node metadata (region labels or lat/long)"
    - "Node health scores from health monitoring affect routing decisions"
    - "Routing policies support latency-optimized, throughput-optimized, and cost-optimized modes"
    - "Request from US-East routes to US-East replica when available and healthy"
  artifacts:
    - path: "DataWarehouse.SDK/Federation/Topology/NodeTopology.cs"
      provides: "Node topology metadata (rack, DC, region, health score)"
      min_lines: 60
    - path: "DataWarehouse.SDK/Federation/Topology/LocationAwareRouter.cs"
      provides: "Router with topology-aware node selection"
      min_lines: 200
---

<objective>
Implement Location-Aware Routing (FOS-04) -- router considers network topology, geographic proximity, node health scores, and current load when selecting target nodes, with configurable routing policies for latency/throughput/cost optimization.

Output: ITopologyProvider, NodeTopology metadata, RoutingPolicy enum, LocationAwareRouter, ProximityCalculator
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/34-federated-object-storage/34-RESEARCH.md
@DataWarehouse.SDK/Federation/Routing/IStorageRouter.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Topology Model and Policy Types</name>
  <files>
    DataWarehouse.SDK/Federation/Topology/NodeTopology.cs
    DataWarehouse.SDK/Federation/Topology/RoutingPolicy.cs
    DataWarehouse.SDK/Federation/Topology/ITopologyProvider.cs
  </files>
  <action>
Create `Federation/Topology/` directory.

**NodeTopology.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Node topology metadata")]
public sealed record NodeTopology
{
    public required string NodeId { get; init; }
    public required string Address { get; init; }
    public required int Port { get; init; }
    public string? Rack { get; init; }
    public string? Datacenter { get; init; }
    public string? Region { get; init; }
    public double? Latitude { get; init; }
    public double? Longitude { get; init; }
    public double HealthScore { get; init; } = 1.0;  // 0.0 (dead) to 1.0 (healthy)
    public long FreeBytes { get; init; }
    public long TotalBytes { get; init; }
    public DateTimeOffset LastHeartbeat { get; init; }

    public TopologyLevel GetLevelRelativeTo(NodeTopology other)
    {
        if (NodeId == other.NodeId) return TopologyLevel.SameNode;
        if (Rack == other.Rack && Rack != null) return TopologyLevel.SameRack;
        if (Datacenter == other.Datacenter && Datacenter != null) return TopologyLevel.SameDatacenter;
        if (Region == other.Region && Region != null) return TopologyLevel.SameRegion;
        return TopologyLevel.CrossRegion;
    }
}

public enum TopologyLevel
{
    SameNode = 0,
    SameRack = 1,
    SameDatacenter = 2,
    SameRegion = 3,
    CrossRegion = 4
}
```

**RoutingPolicy.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Routing policy selection")]
public enum RoutingPolicy
{
    LatencyOptimized,      // Prefer closest nodes (same-rack > same-DC > cross-DC)
    ThroughputOptimized,   // Prefer least-loaded nodes regardless of location
    CostOptimized,         // Prefer on-prem > cheap regions > expensive regions
    BalancedAuto           // Balance latency and load
}
```

**ITopologyProvider.cs**:
```csharp
public interface ITopologyProvider
{
    Task<NodeTopology?> GetNodeTopologyAsync(string nodeId, CancellationToken ct = default);
    Task<IReadOnlyList<NodeTopology>> GetAllNodesAsync(CancellationToken ct = default);
    Task<NodeTopology?> GetSelfTopologyAsync(CancellationToken ct = default);
}
```
  </action>
  <verify>
Compile with zero errors. All files exist.
  </verify>
  <done>
NodeTopology, RoutingPolicy, ITopologyProvider defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Proximity Calculator and Location-Aware Router</name>
  <files>
    DataWarehouse.SDK/Federation/Topology/ProximityCalculator.cs
    DataWarehouse.SDK/Federation/Topology/LocationAwareRouter.cs
  </files>
  <action>
**ProximityCalculator.cs**: Haversine distance for lat/long, topology level scoring.

```csharp
internal static class ProximityCalculator
{
    public static double CalculateProximityScore(NodeTopology source, NodeTopology target, RoutingPolicy policy)
    {
        var level = target.GetLevelRelativeTo(source);
        var baseScore = level switch
        {
            TopologyLevel.SameNode => 1.0,
            TopologyLevel.SameRack => 0.9,
            TopologyLevel.SameDatacenter => 0.7,
            TopologyLevel.SameRegion => 0.5,
            TopologyLevel.CrossRegion => 0.2,
            _ => 0.1
        };

        // Apply health penalty
        baseScore *= target.HealthScore;

        // Policy-specific adjustments
        if (policy == RoutingPolicy.ThroughputOptimized)
        {
            var loadFactor = target.FreeBytes / (double)Math.Max(target.TotalBytes, 1);
            baseScore *= loadFactor;
        }

        return baseScore;
    }

    public static double HaversineDistance(double lat1, double lon1, double lat2, double lon2)
    {
        const double R = 6371; // Earth radius in km
        var dLat = ToRadians(lat2 - lat1);
        var dLon = ToRadians(lon2 - lon1);
        var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                Math.Cos(ToRadians(lat1)) * Math.Cos(ToRadians(lat2)) *
                Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
        return R * 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
    }

    private static double ToRadians(double degrees) => degrees * Math.PI / 180.0;
}
```

**LocationAwareRouter.cs**: Decorator over IStorageRouter with topology-aware node selection.

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Location-aware routing")]
public sealed class LocationAwareRouter : IStorageRouter
{
    private readonly IStorageRouter _innerRouter;
    private readonly ITopologyProvider _topologyProvider;
    private readonly RoutingPolicy _policy;

    public LocationAwareRouter(
        IStorageRouter innerRouter,
        ITopologyProvider topologyProvider,
        RoutingPolicy policy = RoutingPolicy.LatencyOptimized)
    {
        _innerRouter = innerRouter;
        _topologyProvider = topologyProvider;
        _policy = policy;
    }

    public async Task<StorageResponse> RouteRequestAsync(StorageRequest request, CancellationToken ct = default)
    {
        // Get self and all nodes
        var self = await _topologyProvider.GetSelfTopologyAsync(ct).ConfigureAwait(false);
        var allNodes = await _topologyProvider.GetAllNodesAsync(ct).ConfigureAwait(false);

        if (self == null || allNodes.Count == 0)
        {
            // Fallback to inner router if topology unavailable
            return await _innerRouter.RouteRequestAsync(request, ct).ConfigureAwait(false);
        }

        // Score and sort nodes by proximity
        var scoredNodes = allNodes
            .Where(n => n.HealthScore > 0.1)  // Exclude unhealthy
            .Select(n => new { Node = n, Score = ProximityCalculator.CalculateProximityScore(self, n, _policy) })
            .OrderByDescending(x => x.Score)
            .ToList();

        if (scoredNodes.Count == 0)
        {
            return new StorageResponse
            {
                Success = false,
                NodeId = "router",
                ErrorMessage = "No healthy nodes available"
            };
        }

        // Select best node
        var bestNode = scoredNodes.First().Node;

        // Modify request to target selected node (attach node hint)
        var routedRequest = request with
        {
            Metadata = new Dictionary<string, string>(request.Metadata ?? new Dictionary<string, string>())
            {
                ["target-node-id"] = bestNode.NodeId
            }
        };

        return await _innerRouter.RouteRequestAsync(routedRequest, ct).ConfigureAwait(false);
    }
}
```
  </action>
  <verify>
Compile with zero errors. Grep for `ProximityCalculator.CalculateProximityScore` confirms scoring logic.
  </verify>
  <done>
LocationAwareRouter selects nodes based on topology level, health score, and routing policy. ProximityCalculator scores nodes with policy-specific adjustments.
  </done>
</task>

</tasks>

<verification>
1. Build compiles with zero errors
2. NodeTopology includes rack/DC/region/lat/long/health metadata
3. RoutingPolicy enum has 4 policies
4. ProximityCalculator scores nodes by topology level and health
5. LocationAwareRouter decorator selects best node and attaches target hint
</verification>

<success_criteria>
- Request from US-East client routes to US-East replica (highest proximity score)
- Unhealthy node (health score <0.1) excluded from routing
- Latency-optimized policy prefers same-rack > same-DC > cross-DC
- Throughput-optimized policy prefers least-loaded node
- Zero new NuGet dependencies, zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-federated-object-storage/34-04-SUMMARY.md`
</output>
