---
phase: 34-federated-object-storage
plan: 07
type: execute
wave: 4
depends_on: [34-04, 34-06]
files_modified:
  - DataWarehouse.SDK/Federation/Replication/ConsistencyLevel.cs
  - DataWarehouse.SDK/Federation/Replication/IReplicaSelector.cs
  - DataWarehouse.SDK/Federation/Replication/LocationAwareReplicaSelector.cs
  - DataWarehouse.SDK/Federation/Replication/ReplicaFallbackChain.cs
  - DataWarehouse.SDK/Federation/Replication/ReplicationAwareRouter.cs
autonomous: true

must_haves:
  truths:
    - "Read routing prefers local replicas when available"
    - "Consistency levels: eventual (any replica), bounded-staleness (within N seconds), strong (leader only)"
    - "Fallback chain tries progressively more distant replicas on failure"
    - "Replica failure triggers transparent fallback within timeout"
    - "With eventual consistency, reads served from nearest replica"
    - "With strong consistency, reads always go to Raft leader"
  artifacts:
    - path: "DataWarehouse.SDK/Federation/Replication/ConsistencyLevel.cs"
      provides: "Consistency level enum and configuration"
      min_lines: 20
    - path: "DataWarehouse.SDK/Federation/Replication/LocationAwareReplicaSelector.cs"
      provides: "Replica selector with topology-aware preference"
      min_lines: 150
    - path: "DataWarehouse.SDK/Federation/Replication/ReplicationAwareRouter.cs"
      provides: "Router decorator with replica selection and fallback"
      min_lines: 200
---

<objective>
Implement Cross-Node Replication-Aware Reads (FOS-07) -- read routing prefers local replicas when available with configurable consistency levels (eventual, bounded-staleness, strong) and fallback chain for replica failures.

Output: ConsistencyLevel enum, IReplicaSelector, LocationAwareReplicaSelector, ReplicaFallbackChain, ReplicationAwareRouter
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/34-federated-object-storage/34-RESEARCH.md
@DataWarehouse.SDK/Federation/Topology/LocationAwareRouter.cs
@DataWarehouse.SDK/Federation/Catalog/IManifestService.cs
@DataWarehouse.SDK/Contracts/IConsensusEngine.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consistency Level and Replica Selector Interface</name>
  <files>
    DataWarehouse.SDK/Federation/Replication/ConsistencyLevel.cs
    DataWarehouse.SDK/Federation/Replication/IReplicaSelector.cs
  </files>
  <action>
Create `Federation/Replication/` directory.

**ConsistencyLevel.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Consistency level for replication reads")]
public enum ConsistencyLevel
{
    /// <summary>Read from any replica (lowest latency, eventual consistency)</summary>
    Eventual = 0,

    /// <summary>Read from replica within staleness bound (bounded staleness)</summary>
    BoundedStaleness = 1,

    /// <summary>Read from Raft leader only (strong consistency, linearizable)</summary>
    Strong = 2
}

public sealed record ConsistencyConfiguration
{
    public ConsistencyLevel DefaultLevel { get; init; } = ConsistencyLevel.Eventual;
    public TimeSpan StalenessBound { get; init; } = TimeSpan.FromSeconds(5);
    public int MaxFallbackAttempts { get; init; } = 3;
    public TimeSpan FallbackTimeout { get; init; } = TimeSpan.FromSeconds(2);
}
```

**IReplicaSelector.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Replica selector interface")]
public interface IReplicaSelector
{
    /// <summary>
    /// Selects the best replica for a read request based on consistency level and topology.
    /// </summary>
    Task<ReplicaSelectionResult> SelectReplicaAsync(
        ObjectIdentity objectId,
        ConsistencyLevel consistency,
        CancellationToken ct = default);

    /// <summary>
    /// Gets fallback replicas in order of preference for retry logic.
    /// </summary>
    Task<IReadOnlyList<string>> GetFallbackChainAsync(
        ObjectIdentity objectId,
        string failedNodeId,
        CancellationToken ct = default);
}

public sealed record ReplicaSelectionResult
{
    public required string NodeId { get; init; }
    public required string Reason { get; init; }
    public required double ProximityScore { get; init; }
    public bool IsLeader { get; init; }
    public int FallbackAttempt { get; init; }
}
```
  </action>
  <verify>
Compile with zero errors.
  </verify>
  <done>
ConsistencyLevel enum, ConsistencyConfiguration, IReplicaSelector defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Location-Aware Replica Selector</name>
  <files>
    DataWarehouse.SDK/Federation/Replication/LocationAwareReplicaSelector.cs
    DataWarehouse.SDK/Federation/Replication/ReplicaFallbackChain.cs
  </files>
  <action>
**ReplicaFallbackChain.cs**: Builds ordered fallback list based on topology.

```csharp
internal static class ReplicaFallbackChain
{
    public static List<string> Build(
        string failedNodeId,
        IReadOnlyList<string> allReplicas,
        NodeTopology self,
        ITopologyProvider topologyProvider)
    {
        var replicas = allReplicas.Where(id => id != failedNodeId).ToList();

        // Score replicas by proximity
        var scored = new List<(string NodeId, double Score)>();
        foreach (var replicaId in replicas)
        {
            var topology = topologyProvider.GetNodeTopologyAsync(replicaId).Result;
            if (topology == null) continue;

            var score = ProximityCalculator.CalculateProximityScore(self, topology, RoutingPolicy.LatencyOptimized);
            scored.Add((replicaId, score));
        }

        // Sort by score descending
        return scored.OrderByDescending(x => x.Score).Select(x => x.NodeId).ToList();
    }
}
```

**LocationAwareReplicaSelector.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Location-aware replica selector")]
public sealed class LocationAwareReplicaSelector : IReplicaSelector
{
    private readonly IManifestService _manifest;
    private readonly ITopologyProvider _topology;
    private readonly IConsensusEngine? _raft;
    private readonly ConsistencyConfiguration _config;

    public LocationAwareReplicaSelector(
        IManifestService manifest,
        ITopologyProvider topology,
        IConsensusEngine? raft = null,
        ConsistencyConfiguration? config = null)
    {
        _manifest = manifest;
        _topology = topology;
        _raft = raft;
        _config = config ?? new ConsistencyConfiguration();
    }

    public async Task<ReplicaSelectionResult> SelectReplicaAsync(
        ObjectIdentity objectId,
        ConsistencyLevel consistency,
        CancellationToken ct = default)
    {
        // Get object location from manifest
        var location = await _manifest.GetLocationAsync(objectId, ct).ConfigureAwait(false);
        if (location == null || location.NodeIds.Count == 0)
        {
            throw new InvalidOperationException($"Object {objectId} not found in manifest");
        }

        // Strong consistency: always read from leader
        if (consistency == ConsistencyLevel.Strong)
        {
            var leaderId = await GetLeaderNodeIdAsync(ct).ConfigureAwait(false);
            if (leaderId == null || !location.NodeIds.Contains(leaderId))
            {
                throw new InvalidOperationException("Leader not available or does not have replica");
            }

            return new ReplicaSelectionResult
            {
                NodeId = leaderId,
                Reason = "Strong consistency requires leader read",
                ProximityScore = 1.0,
                IsLeader = true
            };
        }

        // Eventual or bounded staleness: prefer nearest replica
        var self = await _topology.GetSelfTopologyAsync(ct).ConfigureAwait(false);
        if (self == null)
        {
            // Fallback to first available replica
            return new ReplicaSelectionResult
            {
                NodeId = location.NodeIds.First(),
                Reason = "Self topology unavailable, using first replica",
                ProximityScore = 0.5
            };
        }

        // Score replicas by proximity
        var scoredReplicas = new List<(string NodeId, double Score, NodeTopology Topology)>();
        foreach (var replicaId in location.NodeIds)
        {
            var replicaTopology = await _topology.GetNodeTopologyAsync(replicaId, ct).ConfigureAwait(false);
            if (replicaTopology == null) continue;

            // Check staleness for bounded consistency
            if (consistency == ConsistencyLevel.BoundedStaleness)
            {
                var staleness = DateTimeOffset.UtcNow - replicaTopology.LastHeartbeat;
                if (staleness > _config.StalenessBound)
                    continue;  // Skip stale replica
            }

            var score = ProximityCalculator.CalculateProximityScore(self, replicaTopology, RoutingPolicy.LatencyOptimized);
            scoredReplicas.Add((replicaId, score, replicaTopology));
        }

        if (scoredReplicas.Count == 0)
        {
            throw new InvalidOperationException("No suitable replicas available for consistency level");
        }

        // Select best (highest score)
        var best = scoredReplicas.OrderByDescending(x => x.Score).First();

        return new ReplicaSelectionResult
        {
            NodeId = best.NodeId,
            Reason = $"Selected nearest replica (topology level: {best.Topology.GetLevelRelativeTo(self)})",
            ProximityScore = best.Score
        };
    }

    public async Task<IReadOnlyList<string>> GetFallbackChainAsync(
        ObjectIdentity objectId,
        string failedNodeId,
        CancellationToken ct = default)
    {
        var location = await _manifest.GetLocationAsync(objectId, ct).ConfigureAwait(false);
        if (location == null) return Array.Empty<string>();

        var self = await _topology.GetSelfTopologyAsync(ct).ConfigureAwait(false);
        if (self == null) return location.NodeIds.Where(id => id != failedNodeId).ToList();

        return ReplicaFallbackChain.Build(failedNodeId, location.NodeIds, self, _topology);
    }

    private async Task<string?> GetLeaderNodeIdAsync(CancellationToken ct)
    {
        if (_raft == null) return null;

        // Query Raft for current leader
        // (Assuming Raft exposes GetLeaderNodeId or similar)
        // Placeholder:
        return await Task.FromResult<string?>(null);
    }
}
```
  </action>
  <verify>
Compile with zero errors. Grep for `IReplicaSelector` confirms interface implementation.
  </verify>
  <done>
LocationAwareReplicaSelector selects replicas based on consistency level, proximity score, and staleness bounds. ReplicaFallbackChain builds ordered fallback list.
  </done>
</task>

<task type="auto">
  <name>Task 3: Replication-Aware Router with Fallback</name>
  <files>
    DataWarehouse.SDK/Federation/Replication/ReplicationAwareRouter.cs
  </files>
  <action>
**ReplicationAwareRouter.cs**: Router decorator with replica selection and automatic fallback.

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Replication-aware router with fallback")]
public sealed class ReplicationAwareRouter : IStorageRouter
{
    private readonly IStorageRouter _innerRouter;
    private readonly IReplicaSelector _replicaSelector;
    private readonly ConsistencyConfiguration _config;

    public ReplicationAwareRouter(
        IStorageRouter innerRouter,
        IReplicaSelector replicaSelector,
        ConsistencyConfiguration? config = null)
    {
        _innerRouter = innerRouter;
        _replicaSelector = replicaSelector;
        _config = config ?? new ConsistencyConfiguration();
    }

    public async Task<StorageResponse> RouteRequestAsync(StorageRequest request, CancellationToken ct = default)
    {
        // Only apply replica selection for read operations
        if (request.Operation != StorageOperation.Read && request.Operation != StorageOperation.GetMetadata)
        {
            return await _innerRouter.RouteRequestAsync(request, ct).ConfigureAwait(false);
        }

        // Extract object ID from address
        if (!UuidObjectAddress.TryGetUuid(request.Address, out var objectId))
        {
            // Not a UUID address -- delegate to inner router
            return await _innerRouter.RouteRequestAsync(request, ct).ConfigureAwait(false);
        }

        // Determine consistency level from request metadata
        var consistency = GetConsistencyLevel(request);

        // Select initial replica
        ReplicaSelectionResult selection;
        try
        {
            selection = await _replicaSelector.SelectReplicaAsync(objectId, consistency, ct).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            return new StorageResponse
            {
                Success = false,
                NodeId = "router",
                ErrorMessage = $"Replica selection failed: {ex.Message}"
            };
        }

        // Attempt read with fallback
        var attempt = 0;
        var currentNodeId = selection.NodeId;

        while (attempt < _config.MaxFallbackAttempts)
        {
            var routedRequest = request with
            {
                Metadata = new Dictionary<string, string>(request.Metadata ?? new Dictionary<string, string>())
                {
                    ["target-node-id"] = currentNodeId,
                    ["replica-selection-reason"] = selection.Reason,
                    ["fallback-attempt"] = attempt.ToString()
                }
            };

            var response = await TryReadFromReplicaAsync(routedRequest, ct).ConfigureAwait(false);

            if (response.Success)
                return response;

            // Failure -- try fallback
            attempt++;
            var fallbackChain = await _replicaSelector.GetFallbackChainAsync(objectId, currentNodeId, ct).ConfigureAwait(false);

            if (fallbackChain.Count == 0)
            {
                return new StorageResponse
                {
                    Success = false,
                    NodeId = currentNodeId,
                    ErrorMessage = $"Read failed, no fallback replicas available after {attempt} attempts"
                };
            }

            currentNodeId = fallbackChain.First();
        }

        return new StorageResponse
        {
            Success = false,
            NodeId = currentNodeId,
            ErrorMessage = $"Read failed after {_config.MaxFallbackAttempts} fallback attempts"
        };
    }

    private async Task<StorageResponse> TryReadFromReplicaAsync(StorageRequest request, CancellationToken ct)
    {
        using var timeoutCts = new CancellationTokenSource(_config.FallbackTimeout);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(ct, timeoutCts.Token);

        try
        {
            return await _innerRouter.RouteRequestAsync(request, linkedCts.Token).ConfigureAwait(false);
        }
        catch (OperationCanceledException) when (timeoutCts.Token.IsCancellationRequested)
        {
            return new StorageResponse
            {
                Success = false,
                NodeId = request.Metadata?["target-node-id"] ?? "unknown",
                ErrorMessage = $"Read timeout after {_config.FallbackTimeout.TotalSeconds}s"
            };
        }
        catch (Exception ex)
        {
            return new StorageResponse
            {
                Success = false,
                NodeId = request.Metadata?["target-node-id"] ?? "unknown",
                ErrorMessage = $"Read failed: {ex.Message}"
            };
        }
    }

    private ConsistencyLevel GetConsistencyLevel(StorageRequest request)
    {
        if (request.Metadata?.TryGetValue("consistency-level", out var level) == true)
        {
            if (Enum.TryParse<ConsistencyLevel>(level, true, out var parsed))
                return parsed;
        }

        return _config.DefaultLevel;
    }
}
```
  </action>
  <verify>
Compile with zero errors. Grep for `IStorageRouter` confirms interface implementation. Grep for `GetFallbackChainAsync` confirms fallback logic.
  </verify>
  <done>
ReplicationAwareRouter implements read routing with replica selection, consistency level enforcement, automatic fallback on failure, and timeout handling.
  </done>
</task>

</tasks>

<verification>
1. Build compiles with zero errors
2. ConsistencyLevel enum has Eventual, BoundedStaleness, Strong
3. LocationAwareReplicaSelector implements IReplicaSelector
4. ReplicationAwareRouter implements IStorageRouter with fallback logic
5. Fallback chain ordered by proximity score
6. Timeout handling for replica reads
</verification>

<success_criteria>
- With eventual consistency, reads served from nearest replica (highest proximity score)
- With strong consistency, reads always go to Raft leader
- With bounded staleness, reads served from replica within staleness bound (default 5 seconds)
- Replica failure triggers transparent fallback: try next-best replica up to max attempts
- Fallback timeout configurable (default 2 seconds)
- Zero new NuGet dependencies, zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-federated-object-storage/34-07-SUMMARY.md`
</output>
