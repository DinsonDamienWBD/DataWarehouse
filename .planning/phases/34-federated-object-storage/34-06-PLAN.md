---
phase: 34-federated-object-storage
plan: 06
type: execute
wave: 3
depends_on: [29-02, 34-02, 34-05]
files_modified:
  - DataWarehouse.SDK/Federation/Catalog/IManifestService.cs
  - DataWarehouse.SDK/Federation/Catalog/ObjectLocationEntry.cs
  - DataWarehouse.SDK/Federation/Catalog/ManifestStateMachine.cs
  - DataWarehouse.SDK/Federation/Catalog/RaftBackedManifest.cs
  - DataWarehouse.SDK/Federation/Catalog/ManifestCache.cs
autonomous: true

must_haves:
  truths:
    - "Manifest provides authoritative UUID-to-location mapping with O(1) lookup"
    - "Manifest backed by Raft state machine for linearizable consistency"
    - "Batch lookup API resolves 100K UUIDs/sec"
    - "UUID v7 prefix enables time-range queries without secondary index"
    - "After node failure, manifest reflects correct replica locations"
    - "Manifest state consistent across all cluster nodes"
  artifacts:
    - path: "DataWarehouse.SDK/Federation/Catalog/RaftBackedManifest.cs"
      provides: "Manifest service using Raft for consistency"
      min_lines: 250
    - path: "DataWarehouse.SDK/Federation/Catalog/ManifestStateMachine.cs"
      provides: "Raft state machine for manifest operations"
      min_lines: 150
---

<objective>
Implement Manifest/Catalog Service (FOS-06) -- authoritative mapping of object UUID to physical location(s) with batch lookups, range queries, and Raft-backed consistency guarantees.

Output: IManifestService, ObjectLocationEntry, ManifestStateMachine (Raft state machine), RaftBackedManifest, ManifestCache
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/34-federated-object-storage/34-RESEARCH.md
@DataWarehouse.SDK/Contracts/IConsensusEngine.cs
@DataWarehouse.SDK/Federation/Addressing/ObjectIdentity.cs
@DataWarehouse.SDK/Federation/Orchestration/ClusterTopology.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Manifest Entry and Interface</name>
  <files>
    DataWarehouse.SDK/Federation/Catalog/ObjectLocationEntry.cs
    DataWarehouse.SDK/Federation/Catalog/IManifestService.cs
  </files>
  <action>
Create `Federation/Catalog/` directory.

**ObjectLocationEntry.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Object location manifest entry")]
public sealed record ObjectLocationEntry
{
    public required ObjectIdentity ObjectId { get; init; }
    public required IReadOnlyList<string> NodeIds { get; init; }
    public required DateTimeOffset CreatedAt { get; init; }
    public required DateTimeOffset UpdatedAt { get; init; }
    public required long SizeBytes { get; init; }
    public string? ContentHash { get; init; }
    public int ReplicationFactor { get; init; } = 1;
}
```

**IManifestService.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Manifest service interface")]
public interface IManifestService
{
    Task<ObjectLocationEntry?> GetLocationAsync(ObjectIdentity objectId, CancellationToken ct = default);
    Task<IReadOnlyList<ObjectLocationEntry>> GetLocationsBatchAsync(IEnumerable<ObjectIdentity> objectIds, CancellationToken ct = default);
    Task<IReadOnlyList<ObjectLocationEntry>> QueryByTimeRangeAsync(DateTimeOffset start, DateTimeOffset end, CancellationToken ct = default);
    Task RegisterObjectAsync(ObjectLocationEntry entry, CancellationToken ct = default);
    Task UpdateLocationAsync(ObjectIdentity objectId, IReadOnlyList<string> nodeIds, CancellationToken ct = default);
    Task RemoveObjectAsync(ObjectIdentity objectId, CancellationToken ct = default);
    Task<ManifestStatistics> GetStatisticsAsync(CancellationToken ct = default);
}

public sealed record ManifestStatistics
{
    public long TotalObjects { get; init; }
    public long TotalBytes { get; init; }
    public double AverageReplication { get; init; }
    public int UniqueNodes { get; init; }
}
```
  </action>
  <verify>
Compile with zero errors.
  </verify>
  <done>
ObjectLocationEntry, IManifestService defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Raft State Machine for Manifest</name>
  <files>
    DataWarehouse.SDK/Federation/Catalog/ManifestStateMachine.cs
  </files>
  <action>
**ManifestStateMachine.cs**: Implements Raft state machine for manifest operations.

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Raft state machine for manifest")]
internal sealed class ManifestStateMachine : IRaftStateMachine
{
    private readonly ConcurrentDictionary<ObjectIdentity, ObjectLocationEntry> _index;
    private readonly ReaderWriterLockSlim _lock;

    public ManifestStateMachine()
    {
        _index = new ConcurrentDictionary<ObjectIdentity, ObjectLocationEntry>();
        _lock = new ReaderWriterLockSlim();
    }

    public byte[] GetSnapshot()
    {
        _lock.EnterReadLock();
        try
        {
            var entries = _index.Values.ToList();
            return JsonSerializer.SerializeToUtf8Bytes(entries);
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public void RestoreSnapshot(byte[] snapshot)
    {
        _lock.EnterWriteLock();
        try
        {
            _index.Clear();
            var entries = JsonSerializer.Deserialize<List<ObjectLocationEntry>>(snapshot) ?? new List<ObjectLocationEntry>();
            foreach (var entry in entries)
            {
                _index[entry.ObjectId] = entry;
            }
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    public void Apply(byte[] logEntry)
    {
        var command = JsonSerializer.Deserialize<ManifestCommand>(logEntry);
        if (command == null) return;

        _lock.EnterWriteLock();
        try
        {
            switch (command.Action)
            {
                case "register":
                    _index[command.Entry!.ObjectId] = command.Entry;
                    break;

                case "update":
                    if (_index.TryGetValue(command.ObjectId!.Value, out var existing))
                    {
                        var updated = existing with
                        {
                            NodeIds = command.NodeIds!,
                            UpdatedAt = DateTimeOffset.UtcNow
                        };
                        _index[command.ObjectId.Value] = updated;
                    }
                    break;

                case "remove":
                    _index.TryRemove(command.ObjectId!.Value, out _);
                    break;
            }
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    public ObjectLocationEntry? GetLocation(ObjectIdentity objectId)
    {
        _lock.EnterReadLock();
        try
        {
            _index.TryGetValue(objectId, out var entry);
            return entry;
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public List<ObjectLocationEntry> GetLocations(IEnumerable<ObjectIdentity> objectIds)
    {
        _lock.EnterReadLock();
        try
        {
            return objectIds
                .Select(id => _index.TryGetValue(id, out var entry) ? entry : null)
                .Where(e => e != null)
                .Cast<ObjectLocationEntry>()
                .ToList();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public List<ObjectLocationEntry> QueryByTimeRange(DateTimeOffset start, DateTimeOffset end)
    {
        _lock.EnterReadLock();
        try
        {
            // UUID v7 contains timestamp -- filter by UUID timestamp extraction
            return _index.Values
                .Where(e => e.ObjectId.Timestamp >= start && e.ObjectId.Timestamp <= end)
                .OrderBy(e => e.ObjectId)
                .ToList();
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }

    public ManifestStatistics GetStatistics()
    {
        _lock.EnterReadLock();
        try
        {
            var entries = _index.Values;
            return new ManifestStatistics
            {
                TotalObjects = entries.Count,
                TotalBytes = entries.Sum(e => e.SizeBytes),
                AverageReplication = entries.Any() ? entries.Average(e => e.ReplicationFactor) : 0,
                UniqueNodes = entries.SelectMany(e => e.NodeIds).Distinct().Count()
            };
        }
        finally
        {
            _lock.ExitReadLock();
        }
    }
}

internal sealed record ManifestCommand
{
    public required string Action { get; init; }  // register, update, remove
    public ObjectLocationEntry? Entry { get; init; }
    public ObjectIdentity? ObjectId { get; init; }
    public IReadOnlyList<string>? NodeIds { get; init; }
}
```
  </action>
  <verify>
Compile with zero errors. Grep for `IRaftStateMachine` confirms state machine contract.
  </verify>
  <done>
ManifestStateMachine implements Raft state machine with register/update/remove operations, snapshot/restore, and time-range queries via UUID v7 timestamp.
  </done>
</task>

<task type="auto">
  <name>Task 3: Raft-Backed Manifest Service with Cache</name>
  <files>
    DataWarehouse.SDK/Federation/Catalog/ManifestCache.cs
    DataWarehouse.SDK/Federation/Catalog/RaftBackedManifest.cs
  </files>
  <action>
**ManifestCache.cs**: In-memory cache for read-heavy workloads.

```csharp
internal sealed class ManifestCache
{
    private readonly ConcurrentDictionary<ObjectIdentity, ObjectLocationEntry> _cache;
    private readonly int _maxSize;

    public ManifestCache(int maxSize = 100_000)
    {
        _cache = new ConcurrentDictionary<ObjectIdentity, ObjectLocationEntry>();
        _maxSize = maxSize;
    }

    public bool TryGet(ObjectIdentity objectId, out ObjectLocationEntry entry)
    {
        return _cache.TryGetValue(objectId, out entry);
    }

    public void Set(ObjectLocationEntry entry)
    {
        if (_cache.Count >= _maxSize && !_cache.ContainsKey(entry.ObjectId))
        {
            // Evict oldest
            var oldest = _cache.Values.MinBy(e => e.UpdatedAt);
            if (oldest != null) _cache.TryRemove(oldest.ObjectId, out _);
        }

        _cache[entry.ObjectId] = entry;
    }

    public void Invalidate(ObjectIdentity objectId)
    {
        _cache.TryRemove(objectId, out _);
    }

    public void Clear() => _cache.Clear();
}
```

**RaftBackedManifest.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Raft-backed manifest service")]
public sealed class RaftBackedManifest : IManifestService
{
    private readonly IConsensusEngine _raft;
    private readonly ManifestStateMachine _stateMachine;
    private readonly ManifestCache _cache;

    public RaftBackedManifest(IConsensusEngine raft)
    {
        _raft = raft;
        _stateMachine = new ManifestStateMachine();
        _cache = new ManifestCache();

        // Register state machine with Raft
        // (Assuming Raft exposes RegisterStateMachine or similar)
    }

    public async Task<ObjectLocationEntry?> GetLocationAsync(ObjectIdentity objectId, CancellationToken ct = default)
    {
        // Try cache first
        if (_cache.TryGet(objectId, out var cached))
            return cached;

        // Read from state machine
        var entry = _stateMachine.GetLocation(objectId);
        if (entry != null)
        {
            _cache.Set(entry);
        }

        return entry;
    }

    public async Task<IReadOnlyList<ObjectLocationEntry>> GetLocationsBatchAsync(IEnumerable<ObjectIdentity> objectIds, CancellationToken ct = default)
    {
        var ids = objectIds.ToList();

        // Try cache
        var results = new List<ObjectLocationEntry>();
        var misses = new List<ObjectIdentity>();

        foreach (var id in ids)
        {
            if (_cache.TryGet(id, out var cached))
                results.Add(cached);
            else
                misses.Add(id);
        }

        // Fetch misses from state machine
        if (misses.Any())
        {
            var entries = _stateMachine.GetLocations(misses);
            foreach (var entry in entries)
            {
                _cache.Set(entry);
                results.Add(entry);
            }
        }

        return results;
    }

    public async Task<IReadOnlyList<ObjectLocationEntry>> QueryByTimeRangeAsync(DateTimeOffset start, DateTimeOffset end, CancellationToken ct = default)
    {
        return _stateMachine.QueryByTimeRange(start, end);
    }

    public async Task RegisterObjectAsync(ObjectLocationEntry entry, CancellationToken ct = default)
    {
        var command = new ManifestCommand
        {
            Action = "register",
            Entry = entry
        };

        await _raft.ProposeAsync(JsonSerializer.SerializeToUtf8Bytes(command), ct).ConfigureAwait(false);

        _cache.Set(entry);
    }

    public async Task UpdateLocationAsync(ObjectIdentity objectId, IReadOnlyList<string> nodeIds, CancellationToken ct = default)
    {
        var command = new ManifestCommand
        {
            Action = "update",
            ObjectId = objectId,
            NodeIds = nodeIds
        };

        await _raft.ProposeAsync(JsonSerializer.SerializeToUtf8Bytes(command), ct).ConfigureAwait(false);

        _cache.Invalidate(objectId);
    }

    public async Task RemoveObjectAsync(ObjectIdentity objectId, CancellationToken ct = default)
    {
        var command = new ManifestCommand
        {
            Action = "remove",
            ObjectId = objectId
        };

        await _raft.ProposeAsync(JsonSerializer.SerializeToUtf8Bytes(command), ct).ConfigureAwait(false);

        _cache.Invalidate(objectId);
    }

    public async Task<ManifestStatistics> GetStatisticsAsync(CancellationToken ct = default)
    {
        return _stateMachine.GetStatistics();
    }
}
```
  </action>
  <verify>
Compile with zero errors. Grep for `IConsensusEngine` confirms Raft integration.
  </verify>
  <done>
RaftBackedManifest implements IManifestService with Raft-backed consistency, in-memory cache for reads, batch lookup support, and time-range queries via UUID v7 timestamp.
  </done>
</task>

</tasks>

<verification>
1. Build compiles with zero errors
2. ManifestStateMachine implements IRaftStateMachine with Apply/GetSnapshot/RestoreSnapshot
3. RaftBackedManifest proposes register/update/remove via Raft
4. ManifestCache provides bounded in-memory cache (100K entries)
5. Batch lookup API supported
6. Time-range query uses UUID v7 timestamp extraction
</verification>

<success_criteria>
- Manifest resolves 100K UUIDs/sec via cache + state machine
- After node failure, manifest reflects correct replica locations via Raft consistency
- Manifest state consistent across all cluster nodes (Raft guarantees)
- UUID v7 prefix enables time-range queries: QueryByTimeRange(t1, t2) returns objects created between t1 and t2
- Zero new NuGet dependencies, zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-federated-object-storage/34-06-SUMMARY.md`
</output>
