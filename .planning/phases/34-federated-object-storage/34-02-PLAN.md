---
phase: 34-federated-object-storage
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Federation/Addressing/IObjectIdentityProvider.cs
  - DataWarehouse.SDK/Federation/Addressing/UuidGenerator.cs
  - DataWarehouse.SDK/Federation/Addressing/UuidObjectAddress.cs
  - DataWarehouse.SDK/Federation/Addressing/ObjectIdentity.cs
autonomous: true

must_haves:
  truths:
    - "UuidGenerator produces UUID v7 with time-ordering property"
    - "ObjectIdentity wraps UUID with location-independent semantics"
    - "UUID-to-string conversion is round-trippable"
    - "UuidObjectAddress integrates with StorageAddress abstraction"
    - "UUID v7 ordering enables time-range queries without secondary index"
  artifacts:
    - path: "DataWarehouse.SDK/Federation/Addressing/IObjectIdentityProvider.cs"
      provides: "Interface for UUID generation and validation"
      min_lines: 15
    - path: "DataWarehouse.SDK/Federation/Addressing/UuidGenerator.cs"
      provides: "UUID v7 generator with timestamp-based ordering"
      min_lines: 100
    - path: "DataWarehouse.SDK/Federation/Addressing/ObjectIdentity.cs"
      provides: "Value type wrapping UUID with object semantics"
      min_lines: 80
    - path: "DataWarehouse.SDK/Federation/Addressing/UuidObjectAddress.cs"
      provides: "StorageAddress extension for UUID-based addressing"
      min_lines: 40
  key_links:
    - from: "UuidGenerator"
      to: "IObjectIdentityProvider"
      via: "implements UUID generation contract"
      pattern: "IObjectIdentityProvider"
    - from: "ObjectIdentity"
      to: "Guid"
      via: "wraps System.Guid with UUID v7 semantics"
      pattern: "Guid.*_value"
    - from: "UuidObjectAddress"
      to: "StorageAddress"
      via: "extends StorageAddress with UUID-specific addressing"
      pattern: "StorageAddress\\."
---

<objective>
Implement UUID-based object addressing (FOS-02) -- every stored object gets a globally unique UUID (v7 for time-ordering), providing location-independent identity where the same UUID refers to the same object regardless of storage node.

Purpose: UUID v7 provides time-ordered global uniqueness without coordination. This enables location-independent object identity and natural time-range queries without secondary indexes. The manifest (34-06) will provide UUID-to-location mapping with O(1) lookup.

Output:
- `IObjectIdentityProvider` interface for UUID generation/validation
- `UuidGenerator` implementing UUID v7 generation with timestamp-based ordering
- `ObjectIdentity` value type wrapping Guid with object semantics
- `UuidObjectAddress` extending StorageAddress for UUID-based addressing
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/34-federated-object-storage/34-RESEARCH.md

@DataWarehouse.SDK/Storage/StorageAddress.cs
@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Object Identity Provider Interface and ObjectIdentity Value Type</name>
  <files>
    DataWarehouse.SDK/Federation/Addressing/IObjectIdentityProvider.cs
    DataWarehouse.SDK/Federation/Addressing/ObjectIdentity.cs
  </files>
  <action>
Create the `Federation/Addressing/` directory under `DataWarehouse.SDK/`.

**File 1: IObjectIdentityProvider.cs**

Namespace: `DataWarehouse.SDK.Federation.Addressing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: UUID-based object identity")]
public interface IObjectIdentityProvider
{
    /// <summary>
    /// Generates a new globally unique object identity.
    /// Implementations should use UUID v7 for time-ordering.
    /// </summary>
    ObjectIdentity Generate();

    /// <summary>
    /// Parses an object identity from string representation.
    /// </summary>
    bool TryParse(string value, out ObjectIdentity identity);

    /// <summary>
    /// Validates that an object identity is well-formed.
    /// </summary>
    bool IsValid(ObjectIdentity identity);
}
```

**File 2: ObjectIdentity.cs**

Namespace: `DataWarehouse.SDK.Federation.Addressing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Location-independent object identity")]
public readonly struct ObjectIdentity : IEquatable<ObjectIdentity>, IComparable<ObjectIdentity>
{
    private readonly Guid _value;

    public ObjectIdentity(Guid value)
    {
        _value = value;
    }

    public Guid Value => _value;

    /// <summary>
    /// Extracts the timestamp from UUID v7 (first 48 bits).
    /// </summary>
    public DateTimeOffset Timestamp
    {
        get
        {
            // UUID v7 format: timestamp_ms (48 bits) | ver (4) | rand_a (12) | var (2) | rand_b (62)
            var bytes = _value.ToByteArray();

            // Extract first 6 bytes (48 bits) as milliseconds since Unix epoch
            // Big-endian in UUID spec, but Guid uses mixed endianness
            long timestampMs = ((long)bytes[0] << 40) | ((long)bytes[1] << 32) |
                              ((long)bytes[2] << 24) | ((long)bytes[3] << 16) |
                              ((long)bytes[4] << 8) | bytes[5];

            return DateTimeOffset.FromUnixTimeMilliseconds(timestampMs);
        }
    }

    public static ObjectIdentity Empty => new(Guid.Empty);

    public bool IsEmpty => _value == Guid.Empty;

    public override string ToString() => _value.ToString("D");

    public string ToString(string format) => _value.ToString(format);

    public bool Equals(ObjectIdentity other) => _value.Equals(other._value);

    public override bool Equals(object? obj) => obj is ObjectIdentity other && Equals(other);

    public override int GetHashCode() => _value.GetHashCode();

    public int CompareTo(ObjectIdentity other) => _value.CompareTo(other._value);

    public static bool operator ==(ObjectIdentity left, ObjectIdentity right) => left.Equals(right);
    public static bool operator !=(ObjectIdentity left, ObjectIdentity right) => !left.Equals(right);
    public static bool operator <(ObjectIdentity left, ObjectIdentity right) => left.CompareTo(right) < 0;
    public static bool operator >(ObjectIdentity left, ObjectIdentity right) => left.CompareTo(right) > 0;
    public static bool operator <=(ObjectIdentity left, ObjectIdentity right) => left.CompareTo(right) <= 0;
    public static bool operator >=(ObjectIdentity left, ObjectIdentity right) => left.CompareTo(right) >= 0;

    public static implicit operator Guid(ObjectIdentity identity) => identity._value;
    public static implicit operator ObjectIdentity(Guid guid) => new(guid);

    public static ObjectIdentity Parse(string value) => new(Guid.Parse(value));

    public static bool TryParse(string? value, out ObjectIdentity identity)
    {
        if (Guid.TryParse(value, out var guid))
        {
            identity = new ObjectIdentity(guid);
            return true;
        }
        identity = Empty;
        return false;
    }
}
```

Add comprehensive XML documentation.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify both files exist.
  </verify>
  <done>
IObjectIdentityProvider defines UUID generation/validation contract. ObjectIdentity is a value type wrapping Guid with UUID v7 timestamp extraction, equality/comparison operators, and implicit conversion to/from Guid.
  </done>
</task>

<task type="auto">
  <name>Task 2: UUID v7 Generator Implementation</name>
  <files>
    DataWarehouse.SDK/Federation/Addressing/UuidGenerator.cs
  </files>
  <action>
Create `UuidGenerator` implementing `IObjectIdentityProvider` with UUID v7 generation.

Namespace: `DataWarehouse.SDK.Federation.Addressing`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: UUID v7 generator with time-ordering")]
public sealed class UuidGenerator : IObjectIdentityProvider
```

**UUID v7 Format** (RFC 9562 draft):
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          unix_ts_ms (48 bits)                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          unix_ts_ms (cont)    |  ver  |       rand_a (12)     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|var|                    rand_b (62 bits)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        rand_b (cont)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
- `unix_ts_ms`: 48 bits of Unix timestamp in milliseconds
- `ver`: 4 bits version = 0111 (7)
- `rand_a`: 12 bits of random data
- `var`: 2 bits variant = 10
- `rand_b`: 62 bits of random data

**Implementation**:

```csharp
public ObjectIdentity Generate()
{
    // Get current timestamp in milliseconds since Unix epoch
    long unixMs = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

    // Generate 10 random bytes (80 bits total, we'll use 74 bits)
    Span<byte> randomBytes = stackalloc byte[10];
    RandomNumberGenerator.Fill(randomBytes);

    // Build UUID v7 byte array (16 bytes)
    Span<byte> uuidBytes = stackalloc byte[16];

    // First 6 bytes: unix_ts_ms (48 bits, big-endian)
    uuidBytes[0] = (byte)(unixMs >> 40);
    uuidBytes[1] = (byte)(unixMs >> 32);
    uuidBytes[2] = (byte)(unixMs >> 24);
    uuidBytes[3] = (byte)(unixMs >> 16);
    uuidBytes[4] = (byte)(unixMs >> 8);
    uuidBytes[5] = (byte)unixMs;

    // Byte 6: upper 4 bits are version (0111), lower 4 bits from rand_a
    uuidBytes[6] = (byte)(0x70 | (randomBytes[0] & 0x0F));

    // Byte 7: rand_a continuation
    uuidBytes[7] = randomBytes[1];

    // Byte 8: upper 2 bits are variant (10), lower 6 bits from rand_b
    uuidBytes[8] = (byte)(0x80 | (randomBytes[2] & 0x3F));

    // Bytes 9-15: rand_b continuation (7 bytes = 56 bits)
    randomBytes.Slice(3, 7).CopyTo(uuidBytes.Slice(9));

    // Guid constructor expects specific byte order (mixed endianness)
    // We need to reorder for Guid's internal representation
    return new ObjectIdentity(new Guid(uuidBytes));
}

public bool TryParse(string value, out ObjectIdentity identity)
{
    return ObjectIdentity.TryParse(value, out identity);
}

public bool IsValid(ObjectIdentity identity)
{
    if (identity.IsEmpty)
        return false;

    // Check version bits (should be 0111 = 7)
    var bytes = identity.Value.ToByteArray();
    var version = (bytes[6] >> 4) & 0x0F;

    // Check variant bits (should be 10)
    var variant = (bytes[8] >> 6) & 0x03;

    return version == 0x07 && variant == 0x02;
}
```

Add comprehensive XML documentation explaining UUID v7 format, time-ordering guarantees, and thread safety.

Use `RandomNumberGenerator` (not `Random`) for cryptographic randomness per CRYPTO-02 requirement.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `IObjectIdentityProvider` confirms interface implementation. Grep for `RandomNumberGenerator.Fill` confirms cryptographic randomness.
  </verify>
  <done>
UuidGenerator implements IObjectIdentityProvider with UUID v7 generation following RFC 9562 draft. 48-bit millisecond timestamp provides time-ordering. Version field = 7, variant field = 10 (RFC 4122 variant). Cryptographic randomness via RandomNumberGenerator.
  </done>
</task>

<task type="auto">
  <name>Task 3: UUID Storage Address Extension</name>
  <files>
    DataWarehouse.SDK/Federation/Addressing/UuidObjectAddress.cs
  </files>
  <action>
Create `UuidObjectAddress` as a specialized extension of the existing `StorageAddress` system.

Namespace: `DataWarehouse.SDK.Federation.Addressing`

**Note**: This is an extension/helper, not a new StorageAddress variant. UUIDs use the existing `ObjectKeyAddress` from Phase 32.

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: UUID-aware storage address helpers")]
public static class UuidObjectAddress
{
    /// <summary>
    /// Creates a StorageAddress from an ObjectIdentity (UUID).
    /// Uses ObjectKeyAddress variant with UUID string representation.
    /// </summary>
    public static StorageAddress FromUuid(ObjectIdentity identity)
    {
        return StorageAddress.FromObjectKey(identity.ToString());
    }

    /// <summary>
    /// Attempts to extract an ObjectIdentity from a StorageAddress.
    /// Returns true if the address is an ObjectKeyAddress containing a valid UUID.
    /// </summary>
    public static bool TryGetUuid(StorageAddress address, out ObjectIdentity identity)
    {
        if (address is ObjectKeyAddress keyAddr)
        {
            return ObjectIdentity.TryParse(keyAddr.Key, out identity);
        }

        identity = ObjectIdentity.Empty;
        return false;
    }

    /// <summary>
    /// Checks if a StorageAddress represents a UUID-based object.
    /// </summary>
    public static bool IsUuidAddress(StorageAddress address)
    {
        return TryGetUuid(address, out _);
    }

    /// <summary>
    /// Creates a StorageAddress from a UUID string.
    /// Validates UUID format before creating address.
    /// </summary>
    public static StorageAddress FromUuidString(string uuid)
    {
        if (!ObjectIdentity.TryParse(uuid, out var identity))
        {
            throw new ArgumentException($"Invalid UUID format: {uuid}", nameof(uuid));
        }

        return FromUuid(identity);
    }

    /// <summary>
    /// Generates a new UUID-based StorageAddress.
    /// </summary>
    public static StorageAddress Generate(IObjectIdentityProvider? provider = null)
    {
        provider ??= new UuidGenerator();
        var identity = provider.Generate();
        return FromUuid(identity);
    }
}
```

Add comprehensive XML documentation.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `ObjectKeyAddress` confirms integration with Phase 32 StorageAddress.
  </verify>
  <done>
UuidObjectAddress provides static helper methods for creating UUID-based StorageAddress instances using the existing ObjectKeyAddress variant. TryGetUuid extracts ObjectIdentity from addresses. Integration with IObjectIdentityProvider for pluggable UUID generation.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 4 files exist under DataWarehouse.SDK/Federation/Addressing/
3. IObjectIdentityProvider defines Generate, TryParse, IsValid methods
4. UuidGenerator implements UUID v7 with 48-bit millisecond timestamp
5. ObjectIdentity extracts timestamp from UUID v7 format
6. UuidObjectAddress integrates with StorageAddress from Phase 32
7. RandomNumberGenerator used for cryptographic randomness (not Random)
8. All types have XML documentation
9. SdkCompatibility attribute on all public types
</verification>

<success_criteria>
- UuidGenerator.Generate() produces UUID v7 with time-ordering (earlier UUIDs < later UUIDs)
- ObjectIdentity.Timestamp extracts correct millisecond timestamp from UUID v7
- UuidGenerator.IsValid() returns true for UUID v7, false for other UUID versions
- UuidObjectAddress.FromUuid() creates StorageAddress with ObjectKeyAddress variant
- UUID-to-string conversion is round-trippable: Parse(Generate().ToString()) == original
- UUID v7 ordering enables time-range queries: UUIDs sort chronologically by generation time
- Zero new NuGet dependencies
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-federated-object-storage/34-02-SUMMARY.md`
</output>
