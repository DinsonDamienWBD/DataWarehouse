---
phase: 34-federated-object-storage
plan: 03
type: execute
wave: 2
depends_on: [34-01]
files_modified:
  - DataWarehouse.SDK/Federation/Authorization/IPermissionCache.cs
  - DataWarehouse.SDK/Federation/Authorization/PermissionCacheEntry.cs
  - DataWarehouse.SDK/Federation/Authorization/PermissionAwareRouter.cs
  - DataWarehouse.SDK/Federation/Authorization/PermissionCheckResult.cs
autonomous: true

must_haves:
  truths:
    - "Router integrates with UltimateAccessControl at routing time via message bus"
    - "Requests denied before reaching storage nodes if ACL check fails"
    - "Permission cache reduces message bus overhead with configurable staleness tolerance"
    - "Cache hit rate >95% for repeated access patterns"
    - "All permission denials logged with user ID, resource, and reason"
  artifacts:
    - path: "DataWarehouse.SDK/Federation/Authorization/IPermissionCache.cs"
      provides: "Interface for cached permission lookups"
      min_lines: 20
    - path: "DataWarehouse.SDK/Federation/Authorization/PermissionAwareRouter.cs"
      provides: "Router decorator with pre-flight ACL checks"
      min_lines: 150
    - path: "DataWarehouse.SDK/Federation/Authorization/PermissionCheckResult.cs"
      provides: "Permission check result with reason and cache metadata"
      min_lines: 30
  key_links:
    - from: "PermissionAwareRouter"
      to: "IStorageRouter"
      via: "decorator pattern wrapping base router"
      pattern: "IStorageRouter.*_innerRouter"
    - from: "PermissionAwareRouter"
      to: "IMessageBus"
      via: "calls accesscontrol.check via message bus"
      pattern: "RequestAsync.*accesscontrol\\.check"
    - from: "PermissionAwareRouter"
      to: "IPermissionCache"
      via: "uses cache to reduce message bus overhead"
      pattern: "IPermissionCache.*_cache"
---

<objective>
Implement Permission-Aware Routing (FOS-03) -- router integrates with UltimateAccessControl at routing time to deny requests before they reach storage nodes if the caller lacks permission. ACL checks use cached credentials with configurable staleness tolerance.

Purpose: Security and performance. Deny-early pattern prevents unauthorized requests from consuming storage resources. Permission cache reduces message bus round-trips for repeated access patterns (target: >95% cache hit rate).

Output:
- `IPermissionCache` interface for cached permission lookups
- `PermissionCacheEntry` with expiration and cache metadata
- `PermissionCheckResult` modeling ACL check outcomes
- `PermissionAwareRouter` decorator wrapping IStorageRouter with pre-flight ACL checks
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/34-federated-object-storage/34-RESEARCH.md
@.planning/phases/34-federated-object-storage/34-01-PLAN.md

@DataWarehouse.SDK/Federation/Routing/IStorageRouter.cs
@DataWarehouse.SDK/Infrastructure/MessageBus.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Permission Cache Interface and Entry Types</name>
  <files>
    DataWarehouse.SDK/Federation/Authorization/IPermissionCache.cs
    DataWarehouse.SDK/Federation/Authorization/PermissionCacheEntry.cs
    DataWarehouse.SDK/Federation/Authorization/PermissionCheckResult.cs
  </files>
  <action>
Create the `Federation/Authorization/` directory under `DataWarehouse.SDK/`.

**File 1: PermissionCheckResult.cs**

Namespace: `DataWarehouse.SDK.Federation.Authorization`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Permission check result")]
public sealed record PermissionCheckResult
{
    public required bool Granted { get; init; }
    public required string Reason { get; init; }
    public bool FromCache { get; init; }
    public DateTimeOffset CheckedAt { get; init; } = DateTimeOffset.UtcNow;
    public TimeSpan? CacheAge { get; init; }

    public static PermissionCheckResult Denied(string reason) =>
        new() { Granted = false, Reason = reason };

    public static PermissionCheckResult Allowed(string reason = "Access granted") =>
        new() { Granted = true, Reason = reason };
}
```

**File 2: PermissionCacheEntry.cs**

Namespace: `DataWarehouse.SDK.Federation.Authorization`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Cached permission entry")]
internal sealed record PermissionCacheEntry
{
    public required string UserId { get; init; }
    public required string ResourceKey { get; init; }
    public required string Operation { get; init; }
    public required bool Granted { get; init; }
    public required DateTimeOffset CachedAt { get; init; }
    public required TimeSpan TimeToLive { get; init; }

    public bool IsExpired => DateTimeOffset.UtcNow > CachedAt + TimeToLive;

    public string CacheKey => $"{UserId}:{ResourceKey}:{Operation}";
}
```

**File 3: IPermissionCache.cs**

Namespace: `DataWarehouse.SDK.Federation.Authorization`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Permission cache interface")]
public interface IPermissionCache
{
    /// <summary>
    /// Attempts to retrieve a cached permission check result.
    /// </summary>
    bool TryGet(string userId, string resourceKey, string operation, out PermissionCheckResult result);

    /// <summary>
    /// Stores a permission check result in the cache with TTL.
    /// </summary>
    void Set(string userId, string resourceKey, string operation, bool granted, TimeSpan ttl);

    /// <summary>
    /// Invalidates cached permissions for a specific user or resource.
    /// </summary>
    void Invalidate(string? userId = null, string? resourceKey = null);

    /// <summary>
    /// Returns cache statistics (hit rate, entry count, etc.)
    /// </summary>
    PermissionCacheStatistics GetStatistics();
}

public sealed record PermissionCacheStatistics
{
    public long TotalRequests { get; init; }
    public long CacheHits { get; init; }
    public long CacheMisses { get; init; }
    public int EntryCount { get; init; }
    public double HitRate => TotalRequests > 0 ? (double)CacheHits / TotalRequests : 0;
}
```

Add comprehensive XML documentation.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify all 3 files exist.
  </verify>
  <done>
PermissionCheckResult models ACL check outcomes with cache metadata. PermissionCacheEntry is internal cache storage with expiration. IPermissionCache defines cache interface with TryGet/Set/Invalidate and statistics.
  </done>
</task>

<task type="auto">
  <name>Task 2: In-Memory Permission Cache Implementation</name>
  <files>
    DataWarehouse.SDK/Federation/Authorization/InMemoryPermissionCache.cs
  </files>
  <action>
Create `InMemoryPermissionCache` implementing `IPermissionCache`.

Namespace: `DataWarehouse.SDK.Federation.Authorization`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: In-memory permission cache with bounded size")]
internal sealed class InMemoryPermissionCache : IPermissionCache, IDisposable
{
    private readonly ConcurrentDictionary<string, PermissionCacheEntry> _cache;
    private readonly PermissionCacheConfiguration _config;
    private readonly SemaphoreSlim _cleanupLock;
    private readonly PeriodicTimer _cleanupTimer;
    private readonly CancellationTokenSource _cleanupCts;

    private long _totalRequests;
    private long _cacheHits;
    private long _cacheMisses;

    public InMemoryPermissionCache(PermissionCacheConfiguration? config = null)
    {
        _config = config ?? new PermissionCacheConfiguration();
        _cache = new ConcurrentDictionary<string, PermissionCacheEntry>();
        _cleanupLock = new SemaphoreSlim(1, 1);
        _cleanupTimer = new PeriodicTimer(TimeSpan.FromMinutes(1));
        _cleanupCts = new CancellationTokenSource();

        _ = RunCleanupLoopAsync(_cleanupCts.Token);
    }

    public bool TryGet(string userId, string resourceKey, string operation, out PermissionCheckResult result)
    {
        Interlocked.Increment(ref _totalRequests);

        var cacheKey = $"{userId}:{resourceKey}:{operation}";

        if (_cache.TryGetValue(cacheKey, out var entry) && !entry.IsExpired)
        {
            Interlocked.Increment(ref _cacheHits);

            var age = DateTimeOffset.UtcNow - entry.CachedAt;
            result = new PermissionCheckResult
            {
                Granted = entry.Granted,
                Reason = entry.Granted ? "Cached: Access granted" : "Cached: Access denied",
                FromCache = true,
                CheckedAt = entry.CachedAt,
                CacheAge = age
            };
            return true;
        }

        Interlocked.Increment(ref _cacheMisses);
        result = PermissionCheckResult.Denied("Not in cache");
        return false;
    }

    public void Set(string userId, string resourceKey, string operation, bool granted, TimeSpan ttl)
    {
        var entry = new PermissionCacheEntry
        {
            UserId = userId,
            ResourceKey = resourceKey,
            Operation = operation,
            Granted = granted,
            CachedAt = DateTimeOffset.UtcNow,
            TimeToLive = ttl
        };

        var cacheKey = entry.CacheKey;

        // Enforce max cache size (bounded per SDK rules)
        if (_cache.Count >= _config.MaxEntries && !_cache.ContainsKey(cacheKey))
        {
            // Evict oldest entry
            var oldest = _cache.Values.MinBy(e => e.CachedAt);
            if (oldest != null)
            {
                _cache.TryRemove(oldest.CacheKey, out _);
            }
        }

        _cache[cacheKey] = entry;
    }

    public void Invalidate(string? userId = null, string? resourceKey = null)
    {
        if (userId == null && resourceKey == null)
        {
            _cache.Clear();
            return;
        }

        var keysToRemove = _cache.Values
            .Where(e => (userId == null || e.UserId == userId) &&
                       (resourceKey == null || e.ResourceKey == resourceKey))
            .Select(e => e.CacheKey)
            .ToList();

        foreach (var key in keysToRemove)
        {
            _cache.TryRemove(key, out _);
        }
    }

    public PermissionCacheStatistics GetStatistics()
    {
        return new PermissionCacheStatistics
        {
            TotalRequests = Interlocked.Read(ref _totalRequests),
            CacheHits = Interlocked.Read(ref _cacheHits),
            CacheMisses = Interlocked.Read(ref _cacheMisses),
            EntryCount = _cache.Count
        };
    }

    private async Task RunCleanupLoopAsync(CancellationToken ct)
    {
        try
        {
            while (await _cleanupTimer.WaitForNextTickAsync(ct).ConfigureAwait(false))
            {
                await CleanupExpiredEntriesAsync(ct).ConfigureAwait(false);
            }
        }
        catch (OperationCanceledException)
        {
            // Expected on disposal
        }
    }

    private async Task CleanupExpiredEntriesAsync(CancellationToken ct)
    {
        await _cleanupLock.WaitAsync(ct).ConfigureAwait(false);
        try
        {
            var expiredKeys = _cache.Values
                .Where(e => e.IsExpired)
                .Select(e => e.CacheKey)
                .ToList();

            foreach (var key in expiredKeys)
            {
                _cache.TryRemove(key, out _);
            }
        }
        finally
        {
            _cleanupLock.Release();
        }
    }

    public void Dispose()
    {
        _cleanupCts.Cancel();
        _cleanupCts.Dispose();
        _cleanupTimer.Dispose();
        _cleanupLock.Dispose();
    }
}

internal sealed record PermissionCacheConfiguration
{
    public int MaxEntries { get; init; } = 10_000;  // Bounded per SDK rules
    public TimeSpan DefaultTtl { get; init; } = TimeSpan.FromMinutes(5);
}
```

Thread safety: ConcurrentDictionary for cache, Interlocked for counters, SemaphoreSlim for cleanup.

Bounded cache: Max 10,000 entries (configurable), evict oldest when full.

Background cleanup: PeriodicTimer at 1-minute intervals prunes expired entries.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `IPermissionCache` confirms interface implementation. Grep for `ConcurrentDictionary` confirms thread-safe storage. Grep for `MaxEntries` confirms bounded behavior.
  </verify>
  <done>
InMemoryPermissionCache implements IPermissionCache with bounded size (10K entries), automatic expiration cleanup, and thread-safe statistics tracking. Evicts oldest entries when full.
  </done>
</task>

<task type="auto">
  <name>Task 3: Permission-Aware Router Decorator</name>
  <files>
    DataWarehouse.SDK/Federation/Authorization/PermissionAwareRouter.cs
  </files>
  <action>
Create `PermissionAwareRouter` implementing decorator pattern over `IStorageRouter`.

Namespace: `DataWarehouse.SDK.Federation.Authorization`

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 34: Permission-aware routing with deny-early pattern")]
public sealed class PermissionAwareRouter : IStorageRouter
{
    private readonly IStorageRouter _innerRouter;
    private readonly IMessageBus _messageBus;
    private readonly IPermissionCache _cache;
    private readonly PermissionRouterConfiguration _config;

    public PermissionAwareRouter(
        IStorageRouter innerRouter,
        IMessageBus messageBus,
        IPermissionCache? cache = null,
        PermissionRouterConfiguration? config = null)
    {
        _innerRouter = innerRouter;
        _messageBus = messageBus;
        _cache = cache ?? new InMemoryPermissionCache();
        _config = config ?? new PermissionRouterConfiguration();
    }

    public async Task<StorageResponse> RouteRequestAsync(StorageRequest request, CancellationToken ct = default)
    {
        // Skip permission check if no user ID
        if (string.IsNullOrEmpty(request.UserId))
        {
            if (_config.RequireUserId)
            {
                return new StorageResponse
                {
                    Success = false,
                    NodeId = "router",
                    ErrorMessage = "Permission check failed: UserId required but not provided"
                };
            }

            // No user ID and not required -- allow through
            return await _innerRouter.RouteRequestAsync(request, ct).ConfigureAwait(false);
        }

        // Pre-flight permission check
        var permissionCheck = await CheckPermissionAsync(request, ct).ConfigureAwait(false);

        if (!permissionCheck.Granted)
        {
            // Log denial
            await LogPermissionDenialAsync(request, permissionCheck, ct).ConfigureAwait(false);

            return new StorageResponse
            {
                Success = false,
                NodeId = "router",
                ErrorMessage = $"Permission denied: {permissionCheck.Reason}"
            };
        }

        // Permission granted -- route to inner router
        return await _innerRouter.RouteRequestAsync(request, ct).ConfigureAwait(false);
    }

    private async Task<PermissionCheckResult> CheckPermissionAsync(StorageRequest request, CancellationToken ct)
    {
        var resourceKey = request.Address.ToKey();
        var operation = request.Operation.ToString().ToLowerInvariant();

        // Try cache first
        if (_cache.TryGet(request.UserId!, resourceKey, operation, out var cachedResult))
        {
            return cachedResult;
        }

        // Cache miss -- call UltimateAccessControl via message bus
        var checkRequest = new
        {
            userId = request.UserId,
            resource = resourceKey,
            operation = operation,
            metadata = request.Metadata
        };

        try
        {
            var response = await _messageBus.RequestAsync<dynamic>(
                "accesscontrol.check",
                checkRequest,
                ct
            ).ConfigureAwait(false);

            var granted = response?.allowed == true;
            var reason = response?.reason?.ToString() ?? (granted ? "Access granted" : "Access denied");

            // Cache the result
            _cache.Set(request.UserId!, resourceKey, operation, granted, _config.CacheTtl);

            return new PermissionCheckResult
            {
                Granted = granted,
                Reason = reason,
                FromCache = false
            };
        }
        catch (Exception ex)
        {
            // On error, default to deny (fail-secure)
            return PermissionCheckResult.Denied($"Permission check failed: {ex.Message}");
        }
    }

    private async Task LogPermissionDenialAsync(StorageRequest request, PermissionCheckResult check, CancellationToken ct)
    {
        var logEntry = new
        {
            level = "Warning",
            category = "Federation.Authorization",
            message = "Permission denied at router",
            userId = request.UserId,
            resource = request.Address.ToKey(),
            operation = request.Operation.ToString(),
            reason = check.Reason,
            fromCache = check.FromCache,
            timestampUtc = DateTimeOffset.UtcNow
        };

        try
        {
            await _messageBus.PublishAsync("logging.security.denied", logEntry, ct).ConfigureAwait(false);
        }
        catch
        {
            // Logging failure should not block routing
        }
    }

    public PermissionCacheStatistics GetCacheStatistics() => _cache.GetStatistics();
}

public sealed record PermissionRouterConfiguration
{
    public bool RequireUserId { get; init; } = false;
    public TimeSpan CacheTtl { get; init; } = TimeSpan.FromMinutes(5);
}
```

Add comprehensive XML documentation.

**Message Bus Integration**:
- Topic: `accesscontrol.check`
- Request: `{ userId, resource, operation, metadata }`
- Response: `{ allowed: bool, reason: string }`

**Deny-Early Pattern**:
- Check permissions BEFORE routing to storage node
- Failed ACL check returns 403 immediately
- Never reaches storage layer if permission denied
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `IStorageRouter` confirms interface implementation. Grep for `RequestAsync.*accesscontrol\\.check` confirms message bus integration. Grep for `_cache.TryGet` confirms cache usage.
  </verify>
  <done>
PermissionAwareRouter implements decorator pattern over IStorageRouter with pre-flight ACL checks via message bus. Cache-first lookup reduces overhead. Deny-early pattern prevents unauthorized requests from reaching storage. All denials logged to logging.security.denied topic.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 4 files exist under DataWarehouse.SDK/Federation/Authorization/
3. IPermissionCache defines TryGet, Set, Invalidate, GetStatistics
4. InMemoryPermissionCache implements bounded cache with max 10,000 entries
5. PermissionAwareRouter implements IStorageRouter
6. Message bus integration uses `accesscontrol.check` topic
7. Cache statistics track hit rate
8. All async methods accept and propagate CancellationToken
9. All types have XML documentation
</verification>

<success_criteria>
- User without permission on resource X â†’ request denied at router (never reaches storage node)
- ACL cache hit rate >95% for repeated access patterns (same user, same resource, same operation)
- Permission checks use message bus topic `accesscontrol.check`
- Cache TTL configurable (default 5 minutes)
- Cache bounded to 10,000 entries, evicts oldest when full
- All permission denials logged to `logging.security.denied` topic with user ID, resource, and reason
- Zero new NuGet dependencies
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-federated-object-storage/34-03-SUMMARY.md`
</output>
