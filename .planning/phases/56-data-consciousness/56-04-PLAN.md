---
phase: 56-data-consciousness
plan: 04
type: execute
wave: 3
depends_on: ["56-02", "56-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/ConsciousnessScoringEngine.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/IngestPipelineConsciousnessStrategy.cs
autonomous: true

must_haves:
  truths:
    - "Composite consciousness engine combines value + liability into a single 0-100 score with grade and recommended action"
    - "Ingest pipeline strategy hooks into the write pipeline to automatically score every object on ingestion"
    - "Batch scoring processes multiple objects efficiently with configurable parallelism"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/ConsciousnessScoringEngine.cs"
      provides: "ConsciousnessScoringEngine class implementing IConsciousnessScorer"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/IngestPipelineConsciousnessStrategy.cs"
      provides: "IngestPipelineConsciousnessStrategy, ConsciousnessScoreStore"
      min_lines: 120
  key_links:
    - from: "ConsciousnessScoringEngine"
      to: "CompositeValueScoringStrategy"
      via: "calls ScoreValueAsync"
      pattern: "IValueScorer.*ScoreValueAsync"
    - from: "ConsciousnessScoringEngine"
      to: "CompositeLiabilityScoringStrategy"
      via: "calls ScoreLiabilityAsync"
      pattern: "ILiabilityScorer.*ScoreLiabilityAsync"
    - from: "IngestPipelineConsciousnessStrategy"
      to: "ConsciousnessScoringEngine"
      via: "uses engine to score on ingest"
      pattern: "ConsciousnessScoringEngine.*ScoreAsync"
---

<objective>
Build the composite consciousness scoring engine that merges value and liability into a final score, and create the ingest pipeline integration strategy that automatically scores every object on write.

Purpose: This is the heart of the system. The engine combines the value engine (Plan 02) and liability engine (Plan 03) into the final ConsciousnessScore with Grade and RecommendedAction. The pipeline strategy hooks into the existing write pipeline (between step 3 DATA GOVERNANCE and step 4 DATA TRANSFORMATION per PLUGIN-CATALOG flow) so every ingested object gets scored automatically.

Output: Scoring engine class and pipeline integration strategy.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/56-data-consciousness/56-01-SUMMARY.md
@.planning/phases/56-data-consciousness/56-02-SUMMARY.md
@.planning/phases/56-data-consciousness/56-03-SUMMARY.md
@DataWarehouse.SDK/Contracts/Consciousness/ConsciousnessScore.cs
@DataWarehouse.SDK/Contracts/Consciousness/IConsciousnessScorer.cs
@Plugins/DataWarehouse.Plugins.UltimateDataGovernance/UltimateDataGovernancePlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Composite consciousness scoring engine</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/ConsciousnessScoringEngine.cs</files>
  <action>
Create `ConsciousnessScoringEngine.cs` in namespace `DataWarehouse.Plugins.UltimateDataGovernance.Strategies.IntelligentGovernance`.

Class `ConsciousnessScoringEngine` extends ConsciousnessStrategyBase AND implements IConsciousnessScorer:
- StrategyId: "consciousness-composite-engine"
- Category: ConsciousnessCategory.CompositeScoring
- Capabilities: all true (async, batch, real-time, streaming, retroactive)

Constructor takes: IValueScorer valueScorer, ILiabilityScorer liabilityScorer, ConsciousnessScoringConfig config (with defaults).

**ScoreAsync implementation:**
1. Run valueScorer.ScoreValueAsync and liabilityScorer.ScoreLiabilityAsync in parallel (Task.WhenAll)
2. Compute composite: `config.ValueLiabilityRatio * valueScore.OverallScore + (1 - config.ValueLiabilityRatio) * (100 - liabilityScore.OverallScore)`
   - High value pushes score UP, high liability pushes score DOWN
   - A 100-value + 0-liability object gets 100. A 0-value + 100-liability object gets 0.
3. Determine Grade from composite (using ConsciousnessGrade thresholds)
4. Determine RecommendedAction from value/liability quadrant:
   - value >= 50 AND liability < 50 => Retain
   - value >= 50 AND liability >= 50 => Review (valuable but risky)
   - value < 50 AND liability < 50 => Archive (low value, low risk)
   - value < 50 AND liability >= 50 => Purge (toxic: low value, high risk)
   - Override: if liability >= config.ReviewThreshold => Quarantine regardless of value
5. Return ConsciousnessScore with all fields populated

**ScoreBatchAsync implementation:**
- Use SemaphoreSlim to limit concurrency (config.ScoringBatchSize controls parallelism, default 1000 but concurrent scoring capped at Environment.ProcessorCount * 2)
- Process items with Task.WhenAll in chunks
- Return IReadOnlyList<ConsciousnessScore>

Also create a static factory: `ConsciousnessScoringEngine.CreateDefault()` that instantiates with the default composite value/liability scorers from Plans 02/03.
  </action>
  <verify>Build the governance plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj --no-restore`. Zero errors.</verify>
  <done>ConsciousnessScoringEngine compiles, combines value+liability into composite 0-100, produces Grade and RecommendedAction, supports batch scoring with concurrency control.</done>
</task>

<task type="auto">
  <name>Task 2: Ingest pipeline consciousness strategy and score store</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Strategies/IntelligentGovernance/IngestPipelineConsciousnessStrategy.cs</files>
  <action>
Create `IngestPipelineConsciousnessStrategy.cs` in namespace `DataWarehouse.Plugins.UltimateDataGovernance.Strategies.IntelligentGovernance`.

**Class 1: ConsciousnessScoreStore**
- Thread-safe score storage using ConcurrentDictionary<string, ConsciousnessScore>
- Methods: StoreScore(ConsciousnessScore score), GetScore(string objectId), GetScoresByGrade(ConsciousnessGrade grade), GetScoresByAction(ConsciousnessAction action), GetScoresBelow(double threshold), GetScoresAbove(double threshold), GetAllScores(), RemoveScore(string objectId), GetStatistics() returning ConsciousnessStatistics
- ConsciousnessStatistics record: int TotalScored, double AverageScore, double MedianScore, Dictionary<ConsciousnessGrade, int> ByGrade, Dictionary<ConsciousnessAction, int> ByAction, int DarkDataCount (score < 25), DateTime ComputedAt
- Score stored as consciousness:score tag on the object metadata (Phase 55 Universal Tags integration point — store as metadata dict entry "consciousness:score" for now, Phase 55 will provide tag API)

**Class 2: IngestPipelineConsciousnessStrategy**
- Extends ConsciousnessStrategyBase
- StrategyId: "consciousness-ingest-pipeline"
- Category: ConsciousnessCategory.PipelineIntegration
- Capabilities: all true

- Constructor takes: ConsciousnessScoringEngine engine, ConsciousnessScoreStore store
- Method: `Task<ConsciousnessScore> ScoreOnIngestAsync(string objectId, byte[] data, Dictionary<string, object> metadata, CancellationToken ct)`
  1. Call engine.ScoreAsync
  2. Store result in ConsciousnessScoreStore
  3. Add "consciousness:score" and "consciousness:grade" and "consciousness:action" to metadata dictionary (in-place mutation for pipeline efficiency)
  4. Publish message bus event: "consciousness.score.computed" with objectId, composite score, grade, action
  5. If score < config.PurgeThreshold: publish "consciousness.purge.recommended" event
  6. If score < config.ArchiveThreshold: publish "consciousness.archive.recommended" event
  7. Return the ConsciousnessScore

Message bus integration: Use the standard pattern from PLUGIN-CATALOG — `MessageBus?.PublishAsync("topic", payload)` with null-check (message bus may not be wired in unit test contexts).

This strategy is designed to slot into the WRITE PIPELINE step 3 (DATA GOVERNANCE) alongside UltimateDataQuality and UltimateDataGovernance. The kernel's pipeline orchestrator will call it during ingest.
  </action>
  <verify>Build the governance plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj --no-restore`. Zero errors.</verify>
  <done>IngestPipelineConsciousnessStrategy scores objects on ingest, stores scores, mutates metadata with consciousness tags, publishes message bus events for downstream consumers (auto-archive, auto-purge).</done>
</task>

</tasks>

<verification>
- Governance plugin builds with zero errors
- ConsciousnessScoringEngine.ScoreAsync returns ConsciousnessScore with non-zero composite
- IngestPipelineConsciousnessStrategy adds consciousness:score, consciousness:grade, consciousness:action to metadata
- ConsciousnessScoreStore.GetStatistics returns valid statistics
- Message bus publish calls use null-conditional pattern
</verification>

<success_criteria>
Every ingested object can be scored via IngestPipelineConsciousnessStrategy. The composite engine correctly merges value and liability. Scores are stored for retrieval. Message bus events notify downstream systems of scoring results and recommendations.
</success_criteria>

<output>
After completion, create `.planning/phases/56-data-consciousness/56-04-SUMMARY.md`
</output>
