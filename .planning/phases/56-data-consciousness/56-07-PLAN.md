---
phase: 56-data-consciousness
plan: 07
type: execute
wave: 4
depends_on: ["56-04"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ConsciousnessLineageStrategies.cs
  - Plugins/DataWarehouse.Plugins.UniversalDashboards/Strategies/ConsciousnessDashboardStrategies.cs
autonomous: true

must_haves:
  truths:
    - "Lineage BFS traversal wired to multi-hop (not just single-hop) for consciousness-aware impact analysis"
    - "Dashboard metrics provide consciousness score distribution, dark data statistics, archive/purge activity"
    - "Lineage propagation spreads consciousness score changes to downstream dependents"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ConsciousnessLineageStrategies.cs"
      provides: "ConsciousnessAwareLineageStrategy, ConsciousnessImpactPropagationStrategy, MultiHopLineageBfsStrategy"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UniversalDashboards/Strategies/ConsciousnessDashboardStrategies.cs"
      provides: "ConsciousnessOverviewDashboardStrategy, ConsciousnessTrendDashboardStrategy, DarkDataDashboardStrategy"
      min_lines: 200
  key_links:
    - from: "ConsciousnessAwareLineageStrategy"
      to: "UltimateDataLineage active strategies"
      via: "extends existing BFS pattern from ActiveLineageStrategies.cs"
      pattern: "class ConsciousnessAwareLineageStrategy"
    - from: "ConsciousnessDashboardStrategies"
      to: "ConsciousnessScoreStore"
      via: "reads score data for metrics"
      pattern: "ConsciousnessScoreStore.*GetStatistics"
---

<objective>
Wire lineage BFS to multi-hop consciousness-aware traversal and build dashboard metrics for consciousness score visibility.

Purpose: Single-hop lineage (per STATE.md) is insufficient for consciousness propagation — when a high-value dataset's consciousness drops, all downstream consumers must be notified. Multi-hop BFS propagates consciousness changes through the lineage graph. Dashboard strategies provide organizational visibility into data consciousness across the entire estate.

Output: Consciousness-aware lineage strategies in UltimateDataLineage and dashboard strategies in UniversalDashboards.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/56-data-consciousness/56-01-SUMMARY.md
@.planning/phases/56-data-consciousness/56-04-SUMMARY.md
@DataWarehouse.SDK/Contracts/Consciousness/ConsciousnessScore.cs
@Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ActiveLineageStrategies.cs
@Plugins/DataWarehouse.Plugins.UniversalDashboards/Strategies/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consciousness-aware lineage strategies</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataLineage/Strategies/ConsciousnessLineageStrategies.cs</files>
  <action>
Create `ConsciousnessLineageStrategies.cs` in namespace `DataWarehouse.Plugins.UltimateDataLineage.Strategies`.

Read and follow the patterns from `ActiveLineageStrategies.cs` — the existing lineage strategies use DataLineageStrategyBase (which inherits from StrategyBase in SDK). These new strategies should follow the SAME base class pattern as existing lineage strategies. Also reference ConsciousnessScore types from SDK.

**Supporting types:**

`ConsciousnessLineageNode` record: string ObjectId, ConsciousnessScore? Score, int Depth, List<string> UpstreamIds, List<string> DownstreamIds.

`ConsciousnessImpactResult` record: string SourceObjectId, int TotalAffected, int DirectDependents, int TransitiveDependents, Dictionary<ConsciousnessGrade, int> AffectedByGrade, List<ConsciousnessLineageNode> AffectedNodes, TimeSpan TraversalTime.

`LineagePropagationEvent` record: string SourceObjectId, string AffectedObjectId, double OldScore, double NewScore, ConsciousnessGrade OldGrade, ConsciousnessGrade NewGrade, int HopDistance.

**Strategy 1: MultiHopLineageBfsStrategy**
- Extends the existing lineage strategy base class (match ActiveLineageStrategies.cs pattern)
- Implements BFS traversal that goes beyond single-hop: tracks visited set to avoid cycles, respects configurable max depth (default 10), supports both upstream and downstream traversal
- Method: `Task<List<ConsciousnessLineageNode>> TraverseBfsAsync(string objectId, int maxDepth, bool upstream, CancellationToken ct)`
- Uses Queue<(string id, int depth)> for BFS with visited HashSet<string>
- For each node, looks up consciousness score from metadata
- Returns ordered list of nodes by depth (breadth-first order)
- This addresses STATE.md noting lineage is currently single-hop

**Strategy 2: ConsciousnessAwareLineageStrategy**
- Extends lineage strategy base class
- Annotates the lineage graph with consciousness scores at each node
- Method: `Task<ConsciousnessImpactResult> AnalyzeImpactAsync(string objectId, CancellationToken ct)`
  1. Use MultiHopLineageBfsStrategy to traverse all downstream dependents
  2. For each dependent: look up its consciousness score
  3. Compute impact: how many downstream objects are in each grade?
  4. Identify critical paths: if this object is purged/archived, which high-value downstream objects are affected?
  5. Return ConsciousnessImpactResult with full dependency tree

**Strategy 3: ConsciousnessImpactPropagationStrategy**
- Extends lineage strategy base class
- When a source object's consciousness score changes, propagates score adjustments to downstream dependents
- Propagation rule: downstream object's lineage dimension score is affected by upstream changes. If upstream object's score drops below 30, downstream objects' lineage value dimension should be recalculated (losing a dependency reduces value of data that depends on it).
- Propagation decay: each hop reduces impact by 30% (direct dependent gets full impact, 2-hop gets 70%, 3-hop gets 49%, etc.)
- Method: `Task<List<LineagePropagationEvent>> PropagateAsync(string sourceObjectId, double oldScore, double newScore, CancellationToken ct)`
  1. BFS downstream from source
  2. At each hop, calculate propagated score delta = (newScore - oldScore) * decay^hop
  3. If propagated delta would change dependent's lineage dimension by > 5 points, create LineagePropagationEvent
  4. Publish "consciousness.lineage.propagated" for each affected object
  5. Return list of all propagation events
- Does NOT automatically rescore (that's the retroactive scorer's job) — only publishes events
  </action>
  <verify>Build the lineage plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataLineage/DataWarehouse.Plugins.UltimateDataLineage.csproj --no-restore`. Zero errors.</verify>
  <done>3 lineage strategies compile, multi-hop BFS traversal respects max depth and cycle detection, consciousness impact analysis identifies critical dependency paths, propagation decays by 30% per hop.</done>
</task>

<task type="auto">
  <name>Task 2: Consciousness dashboard strategies</name>
  <files>Plugins/DataWarehouse.Plugins.UniversalDashboards/Strategies/ConsciousnessDashboardStrategies.cs</files>
  <action>
Create `ConsciousnessDashboardStrategies.cs` in namespace `DataWarehouse.Plugins.UniversalDashboards.Strategies`.

Read the existing dashboard strategy files in UniversalDashboards/Strategies/ to understand the pattern and base class used. These strategies should follow the SAME pattern (likely extending a dashboard strategy base or StrategyBase).

Reference ConsciousnessScore types from SDK.

**Supporting types:**

`ConsciousnessDashboardData` record: ConsciousnessStatistics Statistics, List<ConsciousnessDistributionBucket> Distribution, List<ConsciousnessTopN> TopValue, List<ConsciousnessTopN> TopLiability, DateTime GeneratedAt.

`ConsciousnessDistributionBucket` record: int RangeStart, int RangeEnd, int ObjectCount, long TotalSizeBytes.

`ConsciousnessTopN` record: string ObjectId, double Score, ConsciousnessGrade Grade, string Description.

`ConsciousnessTrendPoint` record: DateTime Timestamp, double AverageScore, int TotalObjects, Dictionary<ConsciousnessGrade, int> GradeDistribution.

`DarkDataReport` record: int TotalDarkObjects, long DarkDataSizeBytes, double DarkDataPercentage, List<DarkDataCandidate> TopCandidates, DateTime ReportGeneratedAt.

**Strategy 1: ConsciousnessOverviewDashboardStrategy**
- Follows existing dashboard strategy pattern
- Provides: total objects scored, average consciousness score, grade distribution (pie chart data), action distribution, top 10 highest value, top 10 highest liability, storage size by grade
- Method: `Task<ConsciousnessDashboardData> GenerateOverviewAsync(CancellationToken ct)`
- Reads from ConsciousnessScoreStore (passed via constructor or resolved from context)
- Computes distribution buckets: 0-10, 10-20, 20-30, ..., 90-100

**Strategy 2: ConsciousnessTrendDashboardStrategy**
- Provides: score trends over time (daily/weekly/monthly averages), grade migration (how many objects moved between grades), archive/purge activity timeline
- Stores trend snapshots in ConcurrentDictionary<DateTime, ConsciousnessTrendPoint>
- Method: `Task<List<ConsciousnessTrendPoint>> GenerateTrendAsync(DateTime from, DateTime to, TimeSpan interval, CancellationToken ct)`
- Method: `void RecordSnapshot(ConsciousnessStatistics statistics)` — called periodically to capture point-in-time data

**Strategy 3: DarkDataDashboardStrategy**
- Provides: dark data percentage of total estate, dark data by reason, dark data by storage tier, dark data aging (how long has it been dark?), remediation progress (how many dark objects have been scored/classified since last scan)
- Method: `Task<DarkDataReport> GenerateReportAsync(CancellationToken ct)`
- Subscribes to "consciousness.dark_data.discovered" events to update metrics
- Tracks remediation: objects that were dark but have since been scored

All strategies must have XML doc comments. Use ConcurrentDictionary for all in-memory storage. No external dependencies beyond SDK types.
  </action>
  <verify>Build the dashboards plugin: `dotnet build Plugins/DataWarehouse.Plugins.UniversalDashboards/DataWarehouse.Plugins.UniversalDashboards.csproj --no-restore`. Zero errors.</verify>
  <done>3 dashboard strategies compile, overview provides grade distribution and top-N lists, trends track score evolution over time, dark data dashboard tracks remediation progress.</done>
</task>

</tasks>

<verification>
- UltimateDataLineage plugin builds with zero errors
- UniversalDashboards plugin builds with zero errors
- Multi-hop BFS traverses beyond single-hop with cycle detection
- Consciousness propagation decays 30% per hop
- Dashboard overview generates grade distribution buckets
- Dark data dashboard tracks remediation progress
</verification>

<success_criteria>
Lineage BFS is wired for multi-hop traversal (fixing the single-hop limitation noted in STATE.md). Consciousness score changes propagate through the lineage graph to downstream dependents. Dashboard strategies provide comprehensive visibility into consciousness score distribution, trends, and dark data remediation across the organization.
</success_criteria>

<output>
After completion, create `.planning/phases/56-data-consciousness/56-07-SUMMARY.md`
</output>
