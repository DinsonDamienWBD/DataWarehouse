---
phase: 56-data-consciousness
plan: 06
type: execute
wave: 4
depends_on: ["56-04"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/DarkDataDiscoveryStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/RetroactiveScoringStrategies.cs
autonomous: true

must_haves:
  truths:
    - "Dark data discovery scans untagged objects and retroactively computes consciousness scores"
    - "Scan strategies support incremental discovery (don't rescan already-scored objects)"
    - "Discovery results feed into the same ConsciousnessScoreStore as ingest-time scoring"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/DarkDataDiscoveryStrategies.cs"
      provides: "UntaggedObjectScanStrategy, OrphanedDataScanStrategy, ShadowDataScanStrategy, DarkDataDiscoveryOrchestrator"
      min_lines: 250
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/RetroactiveScoringStrategies.cs"
      provides: "RetroactiveBatchScoringStrategy, IncrementalRescoringStrategy, ScoreDecayRecalculationStrategy"
      min_lines: 200
  key_links:
    - from: "DarkDataDiscoveryOrchestrator"
      to: "ConsciousnessScoringEngine"
      via: "uses engine to score discovered dark data"
      pattern: "IConsciousnessScorer.*ScoreAsync"
    - from: "RetroactiveBatchScoringStrategy"
      to: "ConsciousnessScoreStore"
      via: "stores retroactive scores"
      pattern: "ConsciousnessScoreStore.*StoreScore"
---

<objective>
Implement dark data discovery and retroactive scoring strategies that find and score existing untagged objects that predate the consciousness scoring system.

Purpose: Consciousness scoring on ingest only covers new data. Organizations have vast stores of existing "dark data" — objects with no classification, no lineage, no metadata. This plan scans for those objects and retroactively applies consciousness scores, surfacing hidden value and liability across the entire data estate.

Output: Dark data discovery strategies in UltimateDataCatalog plugin and retroactive scoring strategies.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/56-data-consciousness/56-01-SUMMARY.md
@.planning/phases/56-data-consciousness/56-04-SUMMARY.md
@DataWarehouse.SDK/Contracts/Consciousness/ConsciousnessScore.cs
@DataWarehouse.SDK/Contracts/Consciousness/IConsciousnessScorer.cs
@Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/AssetDiscoveryStrategies.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dark data discovery strategies</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/DarkDataDiscoveryStrategies.cs</files>
  <action>
Create `DarkDataDiscoveryStrategies.cs` in namespace `DataWarehouse.Plugins.UltimateDataCatalog.Strategies.AssetDiscovery`.

Reference SDK consciousness types. These strategies extend ConsciousnessStrategyBase with Category = ConsciousnessCategory.DarkDataDiscovery.

**Supporting types:**

`DarkDataCandidate` record: string ObjectId, DarkDataReason Reason, DateTime DiscoveredAt, Dictionary<string, object> ExtractedMetadata, long SizeBytes, DateTime? LastModified.

`DarkDataReason` enum: NoClassification, NoOwner, NoLineage, NoAccessHistory, Orphaned (owner account deleted), Shadow (copied outside governance), Stale (no access in N days), Unregistered (not in catalog).

`DarkDataScanResult` record: int TotalScanned, int DarkDataFound, int AlreadyScored, List<DarkDataCandidate> Candidates, TimeSpan ScanDuration, DateTime ScanCompletedAt.

`DarkDataScanConfig` record: int MaxObjectsPerScan (default 10000), int StaleDaysThreshold (default 180), bool SkipAlreadyScored (default true), string[] IncludeStorageTiers (default all), string[] ExcludePatterns (default [".tmp", ".log", ".bak"]).

**Strategy 1: UntaggedObjectScanStrategy**
- StrategyId: "dark-data-untagged-scan"
- Scans for objects missing consciousness:score in metadata
- Also checks for objects missing classification, owner, or lineage tags
- Returns DarkDataCandidates with reason = NoClassification, NoOwner, or NoLineage
- Incremental: tracks last scan watermark (DateTime) in ConcurrentDictionary, only scans objects created/modified after watermark

**Strategy 2: OrphanedDataScanStrategy**
- StrategyId: "dark-data-orphaned-scan"
- Finds objects whose owner principal no longer exists in access control
- Finds objects whose upstream lineage references deleted/moved objects
- Returns candidates with reason = Orphaned
- Uses metadata: "owner_principal_id", "upstream_object_ids"

**Strategy 3: ShadowDataScanStrategy**
- StrategyId: "dark-data-shadow-scan"
- Detects data that was copied or moved outside governed pathways
- Identifies objects with duplicate content hashes but different governance metadata
- Finds objects in storage locations not registered in the data catalog
- Returns candidates with reason = Shadow or Unregistered

**Strategy 4: DarkDataDiscoveryOrchestrator**
- StrategyId: "dark-data-orchestrator"
- Category: ConsciousnessCategory.DarkDataDiscovery
- Coordinates all scan strategies, deduplicates results, and triggers scoring
- Method: `Task<DarkDataScanResult> RunDiscoveryAsync(DarkDataScanConfig config, CancellationToken ct)`
  1. Run all scan strategies in parallel
  2. Deduplicate candidates by ObjectId
  3. For each candidate: call IConsciousnessScorer.ScoreAsync with extracted metadata
  4. Store scores (delegate to caller — orchestrator returns scored candidates)
  5. Publish "consciousness.dark_data.discovered" event with count and summary
- Method: `Task<DarkDataScanResult> RunIncrementalAsync(CancellationToken ct)` — uses watermarks for efficient re-scanning
- Tracks scan history in ConcurrentDictionary<DateTime, DarkDataScanResult>
  </action>
  <verify>Build the catalog plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj --no-restore`. Zero errors.</verify>
  <done>4 dark data discovery strategies compile, orchestrator coordinates scans, incremental scanning uses watermarks, all strategies extend ConsciousnessStrategyBase.</done>
</task>

<task type="auto">
  <name>Task 2: Retroactive scoring strategies</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataCatalog/Strategies/AssetDiscovery/RetroactiveScoringStrategies.cs</files>
  <action>
Create `RetroactiveScoringStrategies.cs` in namespace `DataWarehouse.Plugins.UltimateDataCatalog.Strategies.AssetDiscovery`.

These extend ConsciousnessStrategyBase with Category = ConsciousnessCategory.DarkDataDiscovery.

**Supporting types:**

`RescoringResult` record: int TotalRescored, int ScoreChanged, int ScoreImproved, int ScoreDegraded, Dictionary<ConsciousnessGrade, int> GradeDistribution, TimeSpan Duration.

`RescoringConfig` record: int BatchSize (default 500), double MinScoreChangeTrigger (default 5.0 — only update if score changed by 5+), bool RecalculateDecay (default true), int DecayRecalcIntervalDays (default 30).

**Strategy 1: RetroactiveBatchScoringStrategy**
- StrategyId: "retroactive-batch-scoring"
- Scores large volumes of existing objects that have never been scored
- Processes in configurable batches with progress tracking
- Method: `Task<RescoringResult> ScoreBatchAsync(IReadOnlyList<(string objectId, byte[] data, Dictionary<string, object> metadata)> objects, IConsciousnessScorer scorer, CancellationToken ct)`
- Uses SemaphoreSlim for concurrency control (ProcessorCount * 2 concurrent scores)
- Reports progress via callback: `Action<int, int>? progressCallback` (scored, total)

**Strategy 2: IncrementalRescoringStrategy**
- StrategyId: "retroactive-incremental-rescore"
- Re-scores objects whose metadata has changed since last scoring
- Tracks "consciousness:scored_at" metadata timestamp
- Only rescores if: metadata changed (hash comparison), access patterns changed, lineage changed, classification changed
- Optimizes by checking metadata hash before expensive full rescore
- Method: `Task<RescoringResult> RescoreChangedAsync(IReadOnlyList<(string objectId, Dictionary<string, object> currentMetadata, Dictionary<string, object> previousMetadata)> objects, IConsciousnessScorer scorer, CancellationToken ct)`

**Strategy 3: ScoreDecayRecalculationStrategy**
- StrategyId: "retroactive-decay-recalc"
- Periodically recalculates scores accounting for time decay
- Freshness score decays over time (data becomes stale), access frequency decays (historical access becomes less relevant)
- Method: `Task<RescoringResult> RecalculateDecayAsync(IReadOnlyList<ConsciousnessScore> existingScores, IConsciousnessScorer scorer, CancellationToken ct)`
- Only rescores if decay would change score by > MinScoreChangeTrigger
- Publishes "consciousness.score.decayed" for objects that crossed grade boundaries (e.g., Aware -> Dormant)
  </action>
  <verify>Build the catalog plugin: `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataCatalog/DataWarehouse.Plugins.UltimateDataCatalog.csproj --no-restore`. Zero errors.</verify>
  <done>3 retroactive scoring strategies compile, batch scoring supports progress callbacks, incremental rescoring uses metadata hash comparison, decay recalculation respects minimum change threshold.</done>
</task>

</tasks>

<verification>
- UltimateDataCatalog plugin builds with zero errors
- Dark data discovery finds untagged, orphaned, and shadow data
- Retroactive scoring processes existing objects in batches
- Incremental rescoring only re-scores objects with changed metadata
- Score decay recalculation publishes events when grade boundaries are crossed
</verification>

<success_criteria>
Dark data discovery scans the entire data estate to find objects without consciousness scores. Retroactive scoring applies consciousness scores to all existing data. Incremental rescoring keeps scores current as metadata changes. Score decay recalculation accounts for time-based value degradation.
</success_criteria>

<output>
After completion, create `.planning/phases/56-data-consciousness/56-06-SUMMARY.md`
</output>
