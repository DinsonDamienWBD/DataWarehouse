---
phase: 37-multi-environment-deployment
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - DataWarehouse.SDK/Deployment/BareMetalDetector.cs
  - DataWarehouse.SDK/Deployment/BareMetalOptimizer.cs
  - DataWarehouse.SDK/Deployment/SpdkBindingValidator.cs
autonomous: true

must_haves:
  truths:
    - "BareMetalDetector identifies physical hardware (not VM) and checks for dedicated NVMe namespaces"
    - "SpdkBindingValidator verifies NVMe namespace is NOT mounted before SPDK binding to prevent system crash"
    - "BareMetalOptimizer delegates SPDK user-space binding to Phase 35 NvmePassthroughStrategy"
    - "SPDK mode bypasses kernel NVMe driver for maximum throughput (90%+ of NVMe hardware spec)"
    - "All SPDK operations check for dedicated namespace requirement -- NEVER bind OS NVMe"
    - "Graceful fallback to legacy kernel NVMe driver when SPDK not available or namespace not dedicated"
  artifacts:
    - path: "DataWarehouse.SDK/Deployment/BareMetalDetector.cs"
      provides: "Bare metal environment detection (physical hardware, not VM)"
      min_lines: 80
    - path: "DataWarehouse.SDK/Deployment/SpdkBindingValidator.cs"
      provides: "SPDK binding safety validator (checks namespace not mounted)"
      min_lines: 100
    - path: "DataWarehouse.SDK/Deployment/BareMetalOptimizer.cs"
      provides: "Bare metal SPDK mode optimizer (delegates to Phase 35)"
      min_lines: 120
  key_links:
    - from: "BareMetalDetector"
      to: "IHypervisorDetector"
      via: "Verify NO hypervisor detected for bare metal classification"
      pattern: "IHypervisorDetector"
    - from: "SpdkBindingValidator"
      to: "IHardwareProbe"
      via: "Use Phase 32 hardware probe to enumerate NVMe namespaces"
      pattern: "IHardwareProbe"
    - from: "BareMetalOptimizer"
      to: "NvmePassthroughStrategy"
      via: "Delegates SPDK binding to Phase 35 strategy"
      pattern: "NvmePassthroughStrategy"
---

<objective>
Implement bare metal SPDK mode (ENV-03) -- detect bare metal (physical hardware, not VM), validate dedicated NVMe namespaces, bind SPDK for user-space NVMe access, and integrate with Phase 35 NvmePassthroughStrategy.

Purpose: SPDK (Storage Performance Development Kit) enables user-space NVMe access, bypassing the kernel driver for maximum throughput. Sequential writes achieve 90%+ of NVMe hardware specification, 4K random reads achieve 90%+ IOPS. This is the highest-performance storage path in DataWarehouse, but requires dedicated NVMe namespaces (cannot share with OS).

Output:
- `BareMetalDetector` for bare metal environment detection
- `SpdkBindingValidator` for SPDK binding safety validation
- `BareMetalOptimizer` for SPDK mode activation
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/37-multi-environment-deployment/37-RESEARCH.md

@DataWarehouse.SDK/Virtualization/IHypervisorSupport.cs
@DataWarehouse.SDK/Hardware/IHardwareProbe.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bare Metal Environment Detection</name>
  <files>
    DataWarehouse.SDK/Deployment/BareMetalDetector.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Sealed class implementing `IDeploymentDetector`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Bare metal environment detection (ENV-03)")]`.

Constructor: accept optional `IHypervisorDetector? hypervisorDetector = null` and `IHardwareProbe? hardwareProbe = null` parameters.

`DetectAsync` implementation:

1. **Verify NOT running in a hypervisor:**
   - Call `IHypervisorDetector.DetectAsync()`
   - If `HypervisorInfo` is NOT null (hypervisor detected), return null (not bare metal)
   - This distinguishes bare metal from VMs

2. **Verify NOT running in a cloud environment:**
   - Quick check for cloud metadata endpoint (169.254.169.254 with 100ms timeout)
   - If cloud metadata responds, return null (cloud VM, not bare metal)
   - This distinguishes bare metal from cloud VMs

3. **Detect NVMe controllers and namespaces:**
   - Call `IHardwareProbe.DiscoverAsync(HardwareDeviceType.NvmeController | HardwareDeviceType.NvmeNamespace)`
   - Count NVMe controllers and namespaces
   - Store in metadata for later SPDK validation

4. **Check for SPDK availability:**
   - Check if Phase 35 NvmePassthroughStrategy is available (via reflection or DI)
   - Store SPDK availability in metadata

5. **Construct DeploymentContext:**
   - `Environment = DeploymentEnvironment.BareMetalSpdk` if SPDK available and NVMe present
   - `Environment = DeploymentEnvironment.BareMetalLegacy` if SPDK not available
   - `IsBareMetalSpdk = true/false` based on SPDK availability
   - `Metadata = new Dictionary<string, string>`
     - `["NvmeControllerCount"] = nvmeControllers.Count.ToString()`
     - `["NvmeNamespaceCount"] = nvmeNamespaces.Count.ToString()`
     - `["SpdkAvailable"] = spdkAvailable.ToString()`

6. Return the constructed DeploymentContext

Wrap all external calls in try/catch with graceful degradation.

Add XML documentation explaining:
- Detection criteria (no hypervisor, no cloud metadata, physical hardware)
- Difference between BareMetalSpdk (SPDK available) and BareMetalLegacy (standard kernel driver)
- Return value semantics (null if not bare metal)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/BareMetalDetector.cs`. Grep for `IDeploymentDetector` implementation. Grep for `IHypervisorDetector` usage (negation check). Grep for cloud metadata check with timeout. Grep for `IHardwareProbe` usage for NVMe detection. Grep for `DeploymentEnvironment.BareMetalSpdk` and `BareMetalLegacy`.
  </verify>
  <done>
BareMetalDetector implements IDeploymentDetector, verifies NO hypervisor detected, verifies NOT cloud VM, detects NVMe controllers/namespaces via IHardwareProbe, checks SPDK availability, returns DeploymentContext with BareMetalSpdk or BareMetalLegacy environment.
  </done>
</task>

<task type="auto">
  <name>Task 2: SPDK Binding Safety Validator</name>
  <files>
    DataWarehouse.SDK/Deployment/SpdkBindingValidator.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Public sealed class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: SPDK binding safety validator (ENV-03)")]`.

Constructor: accept optional `IHardwareProbe? hardwareProbe = null` parameter.

**Public record types:**

```csharp
public sealed record NvmeNamespaceInfo
{
    public string DeviceId { get; init; }
    public string DevicePath { get; init; } // /dev/nvme0n1, \\.\PhysicalDrive0
    public long SizeBytes { get; init; }
    public bool IsMounted { get; init; }
    public string? MountPoint { get; init; }
    public bool IsSystemDevice { get; init; } // True if OS is on this device
}

public sealed record SpdkBindingValidation
{
    public bool IsValid { get; init; }
    public string? ErrorMessage { get; init; }
    public IReadOnlyList<NvmeNamespaceInfo> SafeNamespaces { get; init; } = Array.Empty<NvmeNamespaceInfo>();
    public IReadOnlyList<NvmeNamespaceInfo> UnsafeNamespaces { get; init; } = Array.Empty<NvmeNamespaceInfo>();
}
```

**Public method:**

```csharp
public async Task<SpdkBindingValidation> ValidateBindingSafetyAsync(CancellationToken ct = default)
```

Implementation:

1. **Discover all NVMe namespaces:**
   - Call `IHardwareProbe.DiscoverAsync(HardwareDeviceType.NvmeNamespace)`
   - Extract device paths for each namespace

2. **Check if each namespace is mounted (Linux path):**
   - Read `/proc/mounts` to find all mounted devices
   - For each NVMe namespace device path, check if it appears in /proc/mounts
   - If mounted, store mount point and mark as unsafe
   - **CRITICAL:** Check if mount point is `/`, `/boot`, `/home`, `/usr` -- these are system-critical

3. **Check if each namespace is mounted (Windows path):**
   - Use WMI `SELECT * FROM Win32_DiskDrive` to get all disks
   - Use `SELECT * FROM Win32_DiskPartition WHERE DiskIndex = X` to get partitions
   - Use `SELECT * FROM Win32_LogicalDisk` to check which logical disks are mounted
   - Cross-reference NVMe device path with mounted volumes
   - Check if volume contains Windows directory or boot files

4. **Classify namespaces as safe or unsafe:**
   - **SAFE:** Not mounted, not system device, no partitions
   - **UNSAFE:** Mounted, system device, has partitions, or OS-critical mount point

5. **Construct validation result:**
   - `IsValid = true` if at least one safe namespace found
   - `IsValid = false` if zero safe namespaces (all mounted or system devices)
   - `ErrorMessage` explains why validation failed (if failed)
   - `SafeNamespaces` lists namespaces safe for SPDK binding
   - `UnsafeNamespaces` lists namespaces that must NOT be bound

**Critical safety check:**

```csharp
// CRITICAL: Never bind system device
if (IsMounted && (MountPoint == "/" || MountPoint == "C:\\" || MountPoint.Contains("Windows")))
{
    _logger.LogCritical("NVMe namespace {DevicePath} is a SYSTEM DEVICE. SPDK binding would crash the system.", devicePath);
    UnsafeNamespaces.Add(namespaceInfo);
}
```

Wrap all external calls in try/catch with graceful degradation.

Add comprehensive XML documentation explaining:
- Purpose: Prevent system crash by validating SPDK binding safety
- Safety criteria: namespace must be unmounted and not contain OS
- Return value: IsValid true only if safe namespace exists
- Critical warning: NEVER bind system device -- will cause immediate crash
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/SpdkBindingValidator.cs`. Grep for `IHardwareProbe` usage for NVMe discovery. Grep for `/proc/mounts` read (Linux). Grep for WMI Win32_DiskDrive/Win32_DiskPartition (Windows). Grep for critical safety check preventing system device binding. Grep for `SpdkBindingValidation` record with SafeNamespaces and UnsafeNamespaces.
  </verify>
  <done>
SpdkBindingValidator.ValidateBindingSafetyAsync discovers NVMe namespaces via IHardwareProbe, checks mount status on Linux (/proc/mounts) and Windows (WMI), classifies namespaces as safe (unmounted, non-system) or unsafe (mounted, system), returns validation with critical safety warnings.
  </done>
</task>

<task type="auto">
  <name>Task 3: Bare Metal SPDK Optimizer</name>
  <files>
    DataWarehouse.SDK/Deployment/BareMetalOptimizer.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Public sealed class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Bare metal SPDK optimizer (ENV-03)")]`.

Constructor: accept dependencies (SpdkBindingValidator, optional configuration).

**Public method:**

```csharp
public async Task OptimizeAsync(DeploymentContext context, CancellationToken ct = default)
```

Implementation:

**Step 1: Validate preconditions**
- Verify `context.Environment == DeploymentEnvironment.BareMetalSpdk`
- Verify `context.IsBareMetalSpdk == true`
- If preconditions fail, log and return (not SPDK mode)

**Step 2: Validate SPDK binding safety**
- Call `SpdkBindingValidator.ValidateBindingSafetyAsync()`
- If `validation.IsValid == false`:
  - Log CRITICAL warning with error message
  - Log all unsafe namespaces (device paths, mount points)
  - Return without binding SPDK (safety abort)
- If `validation.SafeNamespaces.Count == 0`:
  - Log warning: "No dedicated NVMe namespaces available for SPDK. Falling back to kernel driver."
  - Return without binding SPDK

**Step 3: Select NVMe namespace for SPDK**
- Choose the first safe namespace from `validation.SafeNamespaces`
- Log selected namespace (device path, size)
- Store selection in configuration for Phase 35 NvmePassthroughStrategy

**Step 4: Delegate SPDK binding to Phase 35**
- **NOTE:** Phase 35 provides `NvmePassthroughStrategy` with SPDK integration
- This plan does NOT re-implement SPDK binding -- it delegates to Phase 35
- Configure Phase 35 NvmePassthroughStrategy with selected namespace:
  - Set `NvmePassthroughConfig.SpdkEnabled = true`
  - Set `NvmePassthroughConfig.NvmeNamespacePath = selectedNamespace.DevicePath`
  - Set `NvmePassthroughConfig.UserSpaceDriver = "spdk"`
- Phase 35 strategy handles actual SPDK library binding, NVMe controller initialization, queue pair setup

**Step 5: Verify SPDK initialization**
- Check if Phase 35 NvmePassthroughStrategy initialized successfully
- If initialization failed:
  - Log error with failure reason
  - Fall back to kernel NVMe driver (standard I/O path)
- If initialization succeeded:
  - Log success: "SPDK user-space NVMe active on {devicePath}"
  - Log expected throughput: "Sequential write: 90%+ of hardware spec, 4K random read: 90%+ IOPS"

**Step 6: Configure I/O optimizations for SPDK**
- Disable kernel I/O scheduler (not needed with SPDK user-space driver)
- Configure I/O queue depth to match NVMe controller capabilities (typically 1024-4096)
- Enable NVMe write cache (if safe -- depends on power protection)

**Safety guardrails:**

```csharp
// CRITICAL: Abort if validation fails
if (!validation.IsValid)
{
    _logger.LogCritical("SPDK binding validation FAILED: {ErrorMessage}. Aborting SPDK mode.", validation.ErrorMessage);
    _logger.LogCritical("Unsafe namespaces: {UnsafeCount}. Safe namespaces: {SafeCount}.", validation.UnsafeNamespaces.Count, validation.SafeNamespaces.Count);
    return; // DO NOT proceed with SPDK binding
}

// CRITICAL: Never bind without Phase 35
if (nvmePassthroughStrategy == null)
{
    _logger.LogError("Phase 35 NvmePassthroughStrategy not available. SPDK mode requires Phase 35.");
    return;
}
```

Wrap all external calls in try/catch with graceful degradation.

Add comprehensive XML documentation explaining:
- Purpose: Enable SPDK user-space NVMe for maximum throughput on bare metal
- Safety: ALWAYS validates namespace safety before binding
- Delegation: Does NOT re-implement SPDK binding -- delegates to Phase 35
- Performance: 90%+ of NVMe hardware spec for sequential/random I/O
- Fallback: Graceful fallback to kernel driver if SPDK unavailable or unsafe
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/BareMetalOptimizer.cs`. Grep for `SpdkBindingValidator` usage. Grep for critical safety check (`validation.IsValid == false`). Grep for Phase 35 delegation (NvmePassthroughStrategy configuration). Grep for fallback to kernel driver on validation failure. Grep for critical log messages warning about unsafe namespaces.
  </verify>
  <done>
BareMetalOptimizer.OptimizeAsync validates SPDK binding safety via SpdkBindingValidator, selects safe NVMe namespace, delegates SPDK binding to Phase 35 NvmePassthroughStrategy, configures I/O optimizations, logs critical warnings on validation failure, gracefully falls back to kernel driver when SPDK unavailable or unsafe.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 3 new files exist in `DataWarehouse.SDK/Deployment/`
3. BareMetalDetector verifies NO hypervisor and NO cloud metadata (negative checks)
4. BareMetalDetector detects NVMe controllers/namespaces via IHardwareProbe
5. SpdkBindingValidator checks mount status on Linux (/proc/mounts) and Windows (WMI)
6. SpdkBindingValidator classifies namespaces as safe (unmounted) or unsafe (mounted/system)
7. SpdkBindingValidator NEVER allows binding system device (critical safety check)
8. BareMetalOptimizer validates binding safety before any SPDK operations
9. BareMetalOptimizer delegates SPDK binding to Phase 35 NvmePassthroughStrategy (does NOT re-implement)
10. BareMetalOptimizer gracefully falls back to kernel driver on validation failure
</verification>

<success_criteria>
- BareMetalDetector correctly identifies bare metal (no hypervisor, no cloud metadata)
- SpdkBindingValidator identifies safe NVMe namespaces (unmounted, non-system)
- SpdkBindingValidator NEVER allows binding OS device (prevents system crash)
- BareMetalOptimizer configures Phase 35 NvmePassthroughStrategy with safe namespace
- SPDK mode achieves 90%+ sequential write throughput of NVMe hardware spec
- SPDK mode achieves 90%+ 4K random read IOPS of NVMe hardware spec
- Graceful fallback to kernel driver when SPDK unavailable or unsafe
- Zero system crashes from incorrect SPDK binding (validated in testing)
- Zero NuGet dependencies added (delegates to Phase 35 infrastructure)
- Zero existing files modified -- purely additive
</success_criteria>

<output>
After completion, create `.planning/phases/37-multi-environment-deployment/37-03-SUMMARY.md`
</output>
