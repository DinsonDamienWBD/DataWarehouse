---
phase: 37-multi-environment-deployment
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Deployment/EdgeDetector.cs
  - DataWarehouse.SDK/Deployment/EdgeProfiles/EdgeProfile.cs
  - DataWarehouse.SDK/Deployment/EdgeProfiles/RaspberryPiProfile.cs
  - DataWarehouse.SDK/Deployment/EdgeProfiles/IndustrialGatewayProfile.cs
  - DataWarehouse.SDK/Deployment/EdgeProfiles/CustomEdgeProfileBuilder.cs
  - DataWarehouse.SDK/Deployment/EdgeProfiles/EdgeProfileEnforcer.cs
  - DataWarehouse.SDK/Deployment/DeploymentProfileFactory.cs
autonomous: true

must_haves:
  truths:
    - "EdgeDetector identifies edge/IoT platforms using IHardwareProbe GPIO/I2C/SPI detection"
    - "EdgeProfile defines memory ceiling, allowed plugins, flash optimization, offline resilience, bandwidth limits"
    - "RaspberryPiProfile preset: 256MB ceiling, essential plugins only, flash-optimized, 10MB/s bandwidth"
    - "IndustrialGatewayProfile preset: 1GB ceiling, MQTT/CoAP/sensor mesh enabled, 50MB/s bandwidth"
    - "EdgeProfileEnforcer enforces memory ceiling via GC.RegisterMemoryLimit (.NET 9+)"
    - "EdgeProfileEnforcer filters plugins via KernelInfrastructure.DisablePluginsExcept"
    - "CustomEdgeProfileBuilder provides fluent API for custom edge profiles"
    - "DeploymentProfileFactory selects optimal profile based on detected environment"
  artifacts:
    - path: "DataWarehouse.SDK/Deployment/EdgeDetector.cs"
      provides: "Edge/IoT platform detection via GPIO/I2C/SPI presence"
      min_lines: 80
    - path: "DataWarehouse.SDK/Deployment/EdgeProfiles/EdgeProfile.cs"
      provides: "Edge deployment profile record with constraints"
      min_lines: 60
    - path: "DataWarehouse.SDK/Deployment/EdgeProfiles/RaspberryPiProfile.cs"
      provides: "Raspberry Pi 256MB preset profile"
      min_lines: 40
    - path: "DataWarehouse.SDK/Deployment/EdgeProfiles/IndustrialGatewayProfile.cs"
      provides: "Industrial gateway 1GB preset profile"
      min_lines: 40
    - path: "DataWarehouse.SDK/Deployment/EdgeProfiles/EdgeProfileEnforcer.cs"
      provides: "Edge profile enforcement (memory, plugins, bandwidth)"
      min_lines: 200
    - path: "DataWarehouse.SDK/Deployment/DeploymentProfileFactory.cs"
      provides: "Profile selection factory for all deployment environments"
      min_lines: 120
  key_links:
    - from: "EdgeDetector"
      to: "IHardwareProbe"
      via: "Use Phase 32 hardware probe to detect GPIO/I2C/SPI for edge classification"
      pattern: "IHardwareProbe"
    - from: "EdgeProfileEnforcer"
      to: "GC"
      via: "GC.RegisterMemoryLimit for hard memory ceiling enforcement"
      pattern: "GC\\.RegisterMemoryLimit"
    - from: "EdgeProfileEnforcer"
      to: "KernelInfrastructure"
      via: "DisablePluginsExcept for plugin filtering"
      pattern: "DisablePluginsExcept"
---

<objective>
Implement edge deployment profiles (ENV-05) -- detect edge/IoT platforms, provide pre-configured profiles (Raspberry Pi, industrial gateway), enforce memory ceilings, filter plugins, optimize for flash storage, and constrain bandwidth for resource-limited environments.

Purpose: Edge devices (Raspberry Pi, industrial gateways, IoT controllers) have severe resource constraints: 256MB-1GB RAM, limited flash storage, bandwidth constraints. Edge profiles configure DataWarehouse to run within these limits by enforcing memory ceilings, disabling non-essential plugins, optimizing for flash storage (reduce write amplification), and throttling network bandwidth.

Output:
- `EdgeDetector` for edge/IoT platform detection
- `EdgeProfile` record type for edge-specific configuration
- `RaspberryPiProfile` preset (256MB, essential plugins, flash-optimized)
- `IndustrialGatewayProfile` preset (1GB, MQTT/CoAP/sensor mesh)
- `CustomEdgeProfileBuilder` for custom edge profiles
- `EdgeProfileEnforcer` for profile enforcement
- `DeploymentProfileFactory` for profile selection across all environments
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/37-multi-environment-deployment/37-RESEARCH.md

@DataWarehouse.SDK/Hardware/IHardwareProbe.cs
@DataWarehouse.SDK/Infrastructure/KernelInfrastructure.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Edge Platform Detection</name>
  <files>
    DataWarehouse.SDK/Deployment/EdgeDetector.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Sealed class implementing `IDeploymentDetector`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Edge/IoT platform detection (ENV-05)")]`.

Constructor: accept optional `IHardwareProbe? hardwareProbe = null` parameter.

`DetectAsync` implementation:

1. **Detect GPIO/I2C/SPI hardware presence (edge indicator):**
   - Call `IHardwareProbe.DiscoverAsync(HardwareDeviceType.GpioController | HardwareDeviceType.I2cBus | HardwareDeviceType.SpiBus)`
   - If any GPIO/I2C/SPI devices found, likely an edge device
   - Store device counts in metadata

2. **Platform-specific edge detection (Linux only, primarily):**
   - **Linux path:**
     - Check if `/sys/class/gpio/` exists (GPIO controller present)
     - Check if `/proc/device-tree/model` exists and contains "Raspberry Pi" or other known edge platforms
     - Read `/proc/meminfo` to detect low memory (<2GB = likely edge)
   - **Windows IoT path:**
     - Check registry for Windows IoT Core signatures
     - Check for low memory configuration
   - If edge indicators found, classify as edge device

3. **Detect specific edge platform:**
   - **Raspberry Pi:** `/proc/device-tree/model` contains "Raspberry Pi"
   - **Industrial gateway:** Serial ports + GPIO/I2C + moderate memory (512MB-2GB)
   - **Generic IoT:** GPIO/I2C/SPI present + low memory (<512MB)

4. **Construct DeploymentContext:**
   - `Environment = DeploymentEnvironment.EdgeDevice`
   - `IsEdgeDevice = true`
   - `Metadata = new Dictionary<string, string>`
     - `["PlatformModel"]` = detected platform (Raspberry Pi 4, Generic IoT, etc.)
     - `["GpioControllerCount"]` = gpio count
     - `["I2cBusCount"]` = i2c count
     - `["SpiBusCount"]` = spi count
     - `["TotalMemoryMB"]` = total system memory in MB

5. Return the constructed DeploymentContext if edge detected, null otherwise

Wrap all external calls in try/catch with graceful degradation.

Add XML documentation explaining:
- Detection criteria (GPIO/I2C/SPI presence, low memory, platform-specific signatures)
- Supported edge platforms (Raspberry Pi, industrial gateways, generic IoT)
- Return value semantics (null if not edge device)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/EdgeDetector.cs`. Grep for `IDeploymentDetector` implementation. Grep for `IHardwareProbe` usage for GPIO/I2C/SPI detection. Grep for `/proc/device-tree/model` read. Grep for `/proc/meminfo` read. Grep for `DeploymentEnvironment.EdgeDevice`.
  </verify>
  <done>
EdgeDetector implements IDeploymentDetector, uses IHardwareProbe to detect GPIO/I2C/SPI hardware, reads /proc/device-tree/model and /proc/meminfo on Linux, identifies specific platforms (Raspberry Pi, industrial gateway), returns DeploymentContext with EdgeDevice environment and platform metadata.
  </done>
</task>

<task type="auto">
  <name>Task 2: Edge Profile Types and Presets</name>
  <files>
    DataWarehouse.SDK/Deployment/EdgeProfiles/EdgeProfile.cs
    DataWarehouse.SDK/Deployment/EdgeProfiles/RaspberryPiProfile.cs
    DataWarehouse.SDK/Deployment/EdgeProfiles/IndustrialGatewayProfile.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment.EdgeProfiles`.

**File 1: EdgeProfile.cs**

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 37: Edge deployment profile (ENV-05)")]
public sealed record EdgeProfile
{
    public string Name { get; init; } = "custom";
    public long MaxMemoryBytes { get; init; }
    public IReadOnlyList<string> AllowedPlugins { get; init; } = Array.Empty<string>();
    public bool FlashOptimized { get; init; } = true;
    public bool OfflineResilience { get; init; } = true;
    public int MaxConcurrentConnections { get; init; } = 10;
    public long BandwidthCeilingBytesPerSec { get; init; } = 10 * 1024 * 1024; // 10 MB/s default
    public IReadOnlyDictionary<string, object> CustomSettings { get; init; } = ImmutableDictionary<string, object>.Empty;
}
```

Add comprehensive XML documentation explaining:
- `MaxMemoryBytes`: Hard memory ceiling enforced by GC (.NET 9+ only)
- `AllowedPlugins`: Plugin names allowed to load (all others disabled)
- `FlashOptimized`: Reduce write amplification for flash storage
- `OfflineResilience`: Buffer data when network unavailable
- `MaxConcurrentConnections`: Limit concurrent network connections
- `BandwidthCeilingBytesPerSec`: Network bandwidth throttle

**File 2: RaspberryPiProfile.cs**

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 37: Raspberry Pi edge profile preset (ENV-05)")]
public static class RaspberryPiProfile
{
    public static EdgeProfile Create() => new()
    {
        Name = "raspberry-pi",
        MaxMemoryBytes = 256 * 1024 * 1024, // 256MB (conservative for RPi with 512MB/1GB RAM)
        AllowedPlugins = new[]
        {
            "UltimateStorage",          // Core storage
            "TamperProof",              // Data integrity
            "EdgeSensorMesh",           // Edge/IoT sensor support (Phase 36)
            "UltimateCompression"       // Save bandwidth/storage
        },
        FlashOptimized = true,              // Reduce SD card wear
        OfflineResilience = true,           // Buffer data when offline
        MaxConcurrentConnections = 10,      // Limit network connections
        BandwidthCeilingBytesPerSec = 10 * 1024 * 1024 // 10 MB/s (WiFi/100Mbps Ethernet)
    };
}
```

Add XML docs explaining preset is optimized for Raspberry Pi with limited RAM, SD card storage, and WiFi/Ethernet connectivity.

**File 3: IndustrialGatewayProfile.cs**

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 37: Industrial gateway edge profile preset (ENV-05)")]
public static class IndustrialGatewayProfile
{
    public static EdgeProfile Create() => new()
    {
        Name = "industrial-gateway",
        MaxMemoryBytes = 1024 * 1024 * 1024, // 1GB
        AllowedPlugins = new[]
        {
            "UltimateStorage",          // Core storage
            "EdgeSensorMesh",           // Sensor data aggregation
            "MqttIntegration",          // MQTT protocol support
            "CoapIntegration",          // CoAP protocol support
            "TamperProof",              // Industrial data integrity
            "UltimateCompression",      // Bandwidth optimization
            "DataGravityScheduler"      // Data movement optimization
        },
        FlashOptimized = true,              // Industrial flash storage
        OfflineResilience = true,           // Critical for industrial environments
        MaxConcurrentConnections = 100,     // More connections than RPi
        BandwidthCeilingBytesPerSec = 50 * 1024 * 1024 // 50 MB/s (Gigabit Ethernet common)
    };
}
```

Add XML docs explaining preset is optimized for industrial IoT gateways with more resources than RPi, MQTT/CoAP protocol support, higher connection limits.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify all 3 files exist in `DataWarehouse.SDK/Deployment/EdgeProfiles/`. Grep for `EdgeProfile` record. Grep for `RaspberryPiProfile.Create()`. Grep for 256MB memory limit in Raspberry Pi preset. Grep for `IndustrialGatewayProfile.Create()`. Grep for 1GB memory limit in industrial gateway preset. Grep for MQTT/CoAP in allowed plugins.
  </verify>
  <done>
EdgeProfile record defines memory ceiling, allowed plugins, flash optimization, offline resilience, connection limits, bandwidth ceiling. RaspberryPiProfile preset: 256MB, essential plugins (UltimateStorage, TamperProof, EdgeSensorMesh, UltimateCompression), 10MB/s bandwidth. IndustrialGatewayProfile preset: 1GB, MQTT/CoAP/sensor mesh, 50MB/s bandwidth.
  </done>
</task>

<task type="auto">
  <name>Task 3: Custom Edge Profile Builder</name>
  <files>
    DataWarehouse.SDK/Deployment/EdgeProfiles/CustomEdgeProfileBuilder.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment.EdgeProfiles`.

Public sealed class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Custom edge profile builder (ENV-05)")]`.

**Fluent builder pattern:**

```csharp
public sealed class CustomEdgeProfileBuilder
{
    private string _name = "custom";
    private long _maxMemoryBytes = 512 * 1024 * 1024; // Default 512MB
    private List<string> _allowedPlugins = new();
    private bool _flashOptimized = true;
    private bool _offlineResilience = true;
    private int _maxConnections = 50;
    private long _bandwidthCeiling = 25 * 1024 * 1024; // Default 25 MB/s
    private Dictionary<string, object> _customSettings = new();

    public CustomEdgeProfileBuilder WithName(string name)
    {
        _name = name;
        return this;
    }

    public CustomEdgeProfileBuilder WithMemoryCeiling(long bytes)
    {
        _maxMemoryBytes = bytes;
        return this;
    }

    public CustomEdgeProfileBuilder WithMemoryCeilingMB(int megabytes)
    {
        _maxMemoryBytes = megabytes * 1024L * 1024L;
        return this;
    }

    public CustomEdgeProfileBuilder AllowPlugin(string pluginName)
    {
        _allowedPlugins.Add(pluginName);
        return this;
    }

    public CustomEdgeProfileBuilder AllowPlugins(params string[] pluginNames)
    {
        _allowedPlugins.AddRange(pluginNames);
        return this;
    }

    public CustomEdgeProfileBuilder WithFlashOptimization(bool enabled = true)
    {
        _flashOptimized = enabled;
        return this;
    }

    public CustomEdgeProfileBuilder WithOfflineResilience(bool enabled = true)
    {
        _offlineResilience = enabled;
        return this;
    }

    public CustomEdgeProfileBuilder WithMaxConnections(int maxConnections)
    {
        _maxConnections = maxConnections;
        return this;
    }

    public CustomEdgeProfileBuilder WithBandwidthCeilingMBps(int megabytesPerSecond)
    {
        _bandwidthCeiling = megabytesPerSecond * 1024L * 1024L;
        return this;
    }

    public CustomEdgeProfileBuilder WithCustomSetting(string key, object value)
    {
        _customSettings[key] = value;
        return this;
    }

    public EdgeProfile Build() => new()
    {
        Name = _name,
        MaxMemoryBytes = _maxMemoryBytes,
        AllowedPlugins = _allowedPlugins.ToArray(),
        FlashOptimized = _flashOptimized,
        OfflineResilience = _offlineResilience,
        MaxConcurrentConnections = _maxConnections,
        BandwidthCeilingBytesPerSec = _bandwidthCeiling,
        CustomSettings = _customSettings.ToImmutableDictionary()
    };
}
```

Add comprehensive XML documentation with usage example:
```csharp
// Example:
var profile = new CustomEdgeProfileBuilder()
    .WithName("custom-iot")
    .WithMemoryCeilingMB(384)
    .AllowPlugins("UltimateStorage", "TamperProof", "EdgeSensorMesh")
    .WithMaxConnections(25)
    .WithBandwidthCeilingMBps(15)
    .Build();
```
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/EdgeProfiles/CustomEdgeProfileBuilder.cs`. Grep for fluent builder methods (WithName, WithMemoryCeiling, AllowPlugin, WithFlashOptimization, etc.). Grep for `Build()` method returning EdgeProfile.
  </verify>
  <done>
CustomEdgeProfileBuilder provides fluent API for building custom edge profiles with WithName, WithMemoryCeiling, AllowPlugin/AllowPlugins, WithFlashOptimization, WithOfflineResilience, WithMaxConnections, WithBandwidthCeilingMBps, WithCustomSetting, and Build() methods.
  </done>
</task>

<task type="auto">
  <name>Task 4: Edge Profile Enforcer</name>
  <files>
    DataWarehouse.SDK/Deployment/EdgeProfiles/EdgeProfileEnforcer.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment.EdgeProfiles`.

Public sealed class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Edge profile enforcement (ENV-05)")]`.

Constructor: accept optional dependencies (ILogger, configuration).

**Public method:**

```csharp
public void ApplyProfile(EdgeProfile profile)
```

Implementation:

**Step 1: Enforce memory ceiling (NET 9+ only)**
```csharp
if (OperatingSystem.IsLinux() || OperatingSystem.IsWindows())
{
    try
    {
        // .NET 9+ API for hard memory limit
        GC.RegisterMemoryLimit(profile.MaxMemoryBytes);
        _logger.LogInformation("Memory ceiling enforced: {MemoryMB} MB", profile.MaxMemoryBytes / 1024 / 1024);
    }
    catch (PlatformNotSupportedException ex)
    {
        _logger.LogWarning(ex, "GC.RegisterMemoryLimit not available (requires .NET 9+). Memory ceiling not enforced.");
    }
}

// Additional GC tuning for low-memory environments
GCSettings.LatencyMode = GCLatencyMode.SustainedLowLatency;
GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
```

**Step 2: Filter plugins via KernelInfrastructure**
```csharp
if (profile.AllowedPlugins.Count > 0)
{
    try
    {
        // Use existing Phase 32 KernelInfrastructure for plugin management
        var kernel = GetKernelInstance(); // Via DI or static accessor
        kernel.DisablePluginsExcept(profile.AllowedPlugins);
        _logger.LogInformation("Plugins filtered. Allowed: {AllowedPlugins}", string.Join(", ", profile.AllowedPlugins));
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to filter plugins.");
    }
}
```

**Step 3: Configure flash storage optimization**
```csharp
if (profile.FlashOptimized)
{
    // Reduce write amplification for flash storage:
    // - Increase VDE block cache size (fewer small writes)
    // - Disable OS write-behind caching (use direct I/O)
    // - Configure WAL sync mode to reduce fsync calls
    ConfigureFlashOptimization();
    _logger.LogInformation("Flash storage optimizations enabled.");
}
```

**Step 4: Configure offline resilience**
```csharp
if (profile.OfflineResilience)
{
    // Buffer data when network unavailable:
    // - Enable local write buffer
    // - Configure retry policies for network failures
    // - Set offline mode threshold
    ConfigureOfflineResilience();
    _logger.LogInformation("Offline resilience enabled.");
}
```

**Step 5: Configure connection limits**
```csharp
// Set max concurrent connections on network layer
ConfigureConnectionLimit(profile.MaxConcurrentConnections);
_logger.LogInformation("Max concurrent connections: {MaxConnections}", profile.MaxConcurrentConnections);
```

**Step 6: Configure bandwidth throttling**
```csharp
// Throttle network bandwidth using token bucket or leaky bucket algorithm
ConfigureBandwidthThrottle(profile.BandwidthCeilingBytesPerSec);
_logger.LogInformation("Bandwidth ceiling: {BandwidthMBps} MB/s", profile.BandwidthCeilingBytesPerSec / 1024 / 1024);
```

**Helper methods (implementations):**

```csharp
private void ConfigureFlashOptimization()
{
    // Configure VDE for flash:
    // - Larger block cache (32MB instead of 8MB)
    // - WAL sync mode = Periodic (every 5s) instead of FSync (every write)
    // - Disable OS page cache (O_DIRECT on Linux)
}

private void ConfigureOfflineResilience()
{
    // Configure offline buffer:
    // - Local buffer size = 100MB
    // - Retry interval = 30s
    // - Offline mode threshold = 3 consecutive network failures
}

private void ConfigureConnectionLimit(int maxConnections)
{
    // Use SemaphoreSlim to limit concurrent connections
    // Apply to all network listeners (REST API, cluster communication)
}

private void ConfigureBandwidthThrottle(long bytesPerSec)
{
    // Token bucket algorithm:
    // - Bucket capacity = bytesPerSec
    // - Refill rate = bytesPerSec per second
    // - Apply to all outbound network traffic
}
```

Wrap all operations in try/catch with graceful degradation -- profile enforcement is best-effort.

Add comprehensive XML documentation explaining:
- Memory ceiling enforcement via GC.RegisterMemoryLimit (.NET 9+ only)
- Plugin filtering via existing KernelInfrastructure
- Flash optimization reduces write amplification
- Offline resilience buffers data during network outages
- Connection and bandwidth limits prevent resource exhaustion
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/EdgeProfiles/EdgeProfileEnforcer.cs`. Grep for `GC.RegisterMemoryLimit` call. Grep for `DisablePluginsExcept` call to KernelInfrastructure. Grep for `ConfigureFlashOptimization` method. Grep for `ConfigureBandwidthThrottle` method. Grep for graceful degradation on .NET 9+ API unavailability.
  </verify>
  <done>
EdgeProfileEnforcer.ApplyProfile enforces memory ceiling via GC.RegisterMemoryLimit (.NET 9+), filters plugins via KernelInfrastructure.DisablePluginsExcept, configures flash optimization (reduce write amplification), enables offline resilience (buffer data), limits concurrent connections, throttles bandwidth via token bucket algorithm.
  </done>
</task>

<task type="auto">
  <name>Task 5: Deployment Profile Factory (All Environments)</name>
  <files>
    DataWarehouse.SDK/Deployment/DeploymentProfileFactory.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Public static class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Deployment profile factory (ENV-01-05)")]`.

**Public method:**

```csharp
public static DeploymentProfile CreateProfile(DeploymentContext context)
```

Implementation (select profile based on detected environment):

```csharp
return context.Environment switch
{
    DeploymentEnvironment.HostedVm => new DeploymentProfile
    {
        Name = "hosted-vm",
        Environment = DeploymentEnvironment.HostedVm,
        DoubleWalBypassEnabled = true,  // ENV-01: Disable OS journaling when VDE WAL active
        ParavirtIoEnabled = false,      // Not applicable to hosted
        SpdkEnabled = false,            // Not applicable to hosted
        AutoScalingEnabled = false,     // Manual VM management
        MaxMemoryBytes = null           // No memory ceiling
    },

    DeploymentEnvironment.Hypervisor => new DeploymentProfile
    {
        Name = "hypervisor",
        Environment = DeploymentEnvironment.Hypervisor,
        DoubleWalBypassEnabled = false, // Hypervisor I/O path differs from hosted
        ParavirtIoEnabled = true,       // ENV-02: Enable virtio-blk/PVSCSI
        SpdkEnabled = false,            // Not applicable to VMs
        AutoScalingEnabled = false,     // Hypervisor manages resources
        MaxMemoryBytes = null
    },

    DeploymentEnvironment.BareMetalSpdk => new DeploymentProfile
    {
        Name = "bare-metal-spdk",
        Environment = DeploymentEnvironment.BareMetalSpdk,
        DoubleWalBypassEnabled = false, // No OS filesystem
        ParavirtIoEnabled = false,      // Not applicable to bare metal
        SpdkEnabled = true,             // ENV-03: SPDK user-space NVMe
        AutoScalingEnabled = false,     // Manual hardware management
        MaxMemoryBytes = null
    },

    DeploymentEnvironment.BareMetalLegacy => new DeploymentProfile
    {
        Name = "bare-metal-legacy",
        Environment = DeploymentEnvironment.BareMetalLegacy,
        DoubleWalBypassEnabled = false,
        ParavirtIoEnabled = false,
        SpdkEnabled = false,            // SPDK not available
        AutoScalingEnabled = false,
        MaxMemoryBytes = null
    },

    DeploymentEnvironment.HyperscaleCloud => new DeploymentProfile
    {
        Name = "hyperscale-cloud",
        Environment = DeploymentEnvironment.HyperscaleCloud,
        DoubleWalBypassEnabled = true,  // Cloud VMs on filesystems
        ParavirtIoEnabled = true,       // Cloud providers use paravirt I/O
        SpdkEnabled = false,            // Not applicable to cloud VMs
        AutoScalingEnabled = true,      // ENV-04: Auto-provision cloud resources
        MaxMemoryBytes = null
    },

    DeploymentEnvironment.EdgeDevice => CreateEdgeProfile(context),

    _ => new DeploymentProfile
    {
        Name = "default",
        Environment = DeploymentEnvironment.Unknown,
        DoubleWalBypassEnabled = false,
        ParavirtIoEnabled = false,
        SpdkEnabled = false,
        AutoScalingEnabled = false,
        MaxMemoryBytes = null
    }
};
```

**Helper method for edge profiles:**

```csharp
private static DeploymentProfile CreateEdgeProfile(DeploymentContext context)
{
    // Select edge preset based on platform metadata
    var platformModel = context.Metadata.GetValueOrDefault("PlatformModel", "");

    EdgeProfile edgeProfile;

    if (platformModel.Contains("Raspberry Pi", StringComparison.OrdinalIgnoreCase))
    {
        edgeProfile = RaspberryPiProfile.Create();
    }
    else if (platformModel.Contains("Industrial", StringComparison.OrdinalIgnoreCase) ||
             platformModel.Contains("Gateway", StringComparison.OrdinalIgnoreCase))
    {
        edgeProfile = IndustrialGatewayProfile.Create();
    }
    else
    {
        // Generic edge: conservative defaults
        edgeProfile = new CustomEdgeProfileBuilder()
            .WithName("generic-edge")
            .WithMemoryCeilingMB(512)
            .AllowPlugins("UltimateStorage", "TamperProof", "EdgeSensorMesh")
            .WithMaxConnections(25)
            .WithBandwidthCeilingMBps(20)
            .Build();
    }

    // Wrap EdgeProfile in DeploymentProfile
    return new DeploymentProfile
    {
        Name = edgeProfile.Name,
        Environment = DeploymentEnvironment.EdgeDevice,
        DoubleWalBypassEnabled = false,
        ParavirtIoEnabled = false,
        SpdkEnabled = false,
        AutoScalingEnabled = false,
        MaxMemoryBytes = edgeProfile.MaxMemoryBytes,
        AllowedPlugins = edgeProfile.AllowedPlugins,
        CustomSettings = new Dictionary<string, object>
        {
            ["EdgeProfile"] = edgeProfile // Store full EdgeProfile for enforcement
        }.ToImmutableDictionary()
    };
}
```

Add comprehensive XML documentation explaining:
- Profile selection logic per deployment environment
- Edge profile selection based on platform metadata
- Profile properties per environment (which optimizations enabled)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/DeploymentProfileFactory.cs`. Grep for `CreateProfile` method. Grep for switch expression on `context.Environment`. Grep for `RaspberryPiProfile.Create()` call in edge path. Grep for `IndustrialGatewayProfile.Create()` call in edge path. Grep for DeploymentProfile creation for all 6 environments.
  </verify>
  <done>
DeploymentProfileFactory.CreateProfile selects optimal DeploymentProfile based on detected environment: HostedVm (double-WAL bypass), Hypervisor (paravirt I/O), BareMetalSpdk (SPDK enabled), HyperscaleCloud (auto-scaling), EdgeDevice (memory ceiling + plugin filtering, selects Raspberry Pi or industrial gateway preset based on platform metadata).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 7 new files exist in `DataWarehouse.SDK/Deployment/` and `.../EdgeProfiles/`
3. EdgeDetector uses IHardwareProbe to detect GPIO/I2C/SPI for edge classification
4. EdgeProfile record defines memory ceiling, allowed plugins, flash optimization, offline resilience, bandwidth limits
5. RaspberryPiProfile preset: 256MB memory, essential plugins, 10MB/s bandwidth
6. IndustrialGatewayProfile preset: 1GB memory, MQTT/CoAP enabled, 50MB/s bandwidth
7. CustomEdgeProfileBuilder provides fluent API for custom profiles
8. EdgeProfileEnforcer enforces memory ceiling via GC.RegisterMemoryLimit (.NET 9+)
9. EdgeProfileEnforcer filters plugins via KernelInfrastructure.DisablePluginsExcept
10. DeploymentProfileFactory selects optimal profile for all 6 deployment environments
</verification>

<success_criteria>
- EdgeDetector correctly identifies edge devices via GPIO/I2C/SPI presence and low memory
- RaspberryPiProfile limits memory to 256MB, loads only essential plugins
- IndustrialGatewayProfile limits memory to 1GB, enables MQTT/CoAP/sensor mesh
- EdgeProfileEnforcer enforces hard memory ceiling via GC.RegisterMemoryLimit (.NET 9+)
- EdgeProfileEnforcer filters plugins via existing KernelInfrastructure
- Flash optimization reduces write amplification on SD cards and flash storage
- Offline resilience buffers data during network outages
- Bandwidth throttling prevents network saturation on limited connections
- DeploymentProfileFactory selects correct profile for all environments (hosted, hypervisor, bare metal, cloud, edge)
- Zero NuGet dependencies added (all .NET 9 BCL + existing SDK infrastructure)
- Zero existing files modified -- purely additive
</success_criteria>

<output>
After completion, create `.planning/phases/37-multi-environment-deployment/37-05-SUMMARY.md`
</output>
