---
phase: 37-multi-environment-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Deployment/IDeploymentDetector.cs
  - DataWarehouse.SDK/Deployment/DeploymentContext.cs
  - DataWarehouse.SDK/Deployment/DeploymentProfile.cs
  - DataWarehouse.SDK/Deployment/DeploymentEnvironment.cs
  - DataWarehouse.SDK/Deployment/HostedVmDetector.cs
  - DataWarehouse.SDK/Deployment/HostedOptimizer.cs
  - DataWarehouse.SDK/Deployment/FilesystemDetector.cs
autonomous: true

must_haves:
  truths:
    - "DeploymentContext record captures detected environment, hypervisor type, cloud provider, and metadata"
    - "HostedVmDetector.DetectAsync returns DeploymentContext when running in a VM on a filesystem (not bare metal)"
    - "HostedOptimizer.OptimizeAsync detects filesystem type (ext4, XFS, NTFS) and VDE WAL status"
    - "When VDE WAL is enabled, HostedOptimizer disables OS-level journaling for VDE container files to avoid double-WAL penalty"
    - "I/O alignment is configured to match filesystem block size for optimal performance"
    - "FilesystemDetector works on Linux (reads /proc/mounts) and Windows (WMI Win32_LogicalDisk)"
    - "All optimizations are conditional on VDE WAL being active -- never disable OS journaling without VDE WAL"
  artifacts:
    - path: "DataWarehouse.SDK/Deployment/DeploymentContext.cs"
      provides: "Deployment environment detection result record"
      min_lines: 40
    - path: "DataWarehouse.SDK/Deployment/HostedVmDetector.cs"
      provides: "VM-on-filesystem detection implementation"
      min_lines: 80
    - path: "DataWarehouse.SDK/Deployment/HostedOptimizer.cs"
      provides: "VM-specific optimizations (double-WAL bypass, I/O alignment)"
      min_lines: 150
    - path: "DataWarehouse.SDK/Deployment/FilesystemDetector.cs"
      provides: "Filesystem type detection (Linux /proc/mounts, Windows WMI)"
      min_lines: 100
  key_links:
    - from: "HostedOptimizer"
      to: "VirtualDiskEngineConfig"
      via: "Check WriteAheadLogEnabled before disabling OS journaling"
      pattern: "WriteAheadLogEnabled"
    - from: "FilesystemDetector"
      to: "System.Management"
      via: "WMI query for Win32_LogicalDisk on Windows"
      pattern: "Win32_LogicalDisk"
    - from: "HostedVmDetector"
      to: "IHypervisorDetector"
      via: "Use existing hypervisor detection to confirm VM status"
      pattern: "IHypervisorDetector"
---

<objective>
Implement hosted environment optimization (ENV-01) -- detect VM-on-filesystem deployment and apply VM-specific optimizations including double-WAL bypass (when VDE WAL is active) and filesystem-aware I/O alignment.

Purpose: VMs running on journaling filesystems (ext4, XFS, NTFS) suffer a performance penalty when DataWarehouse's VDE also uses a write-ahead log -- every write is journaled twice. By detecting this scenario and disabling OS-level journaling for VDE container files, we eliminate the double-WAL penalty and gain 30%+ write throughput improvement.

Output:
- `IDeploymentDetector` interface for environment detection
- `DeploymentContext` record type capturing detected environment
- `DeploymentProfile` record type for environment-specific configuration
- `DeploymentEnvironment` enum for environment classification
- `HostedVmDetector` for VM-on-filesystem detection
- `HostedOptimizer` for double-WAL bypass and I/O alignment
- `FilesystemDetector` for filesystem type detection
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/37-multi-environment-deployment/37-RESEARCH.md

@DataWarehouse.SDK/Virtualization/IHypervisorSupport.cs
@DataWarehouse.SDK/Hardware/IHardwareProbe.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Deployment Detection Core Types</name>
  <files>
    DataWarehouse.SDK/Deployment/DeploymentEnvironment.cs
    DataWarehouse.SDK/Deployment/DeploymentContext.cs
    DataWarehouse.SDK/Deployment/DeploymentProfile.cs
    DataWarehouse.SDK/Deployment/IDeploymentDetector.cs
  </files>
  <action>
**File 1: DeploymentEnvironment.cs**

Create in namespace `DataWarehouse.SDK.Deployment`:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 37: Deployment environment classification (ENV-01-05)")]
public enum DeploymentEnvironment
{
    Unknown = 0,
    HostedVm = 1,              // VM on filesystem (cloud or on-premises)
    Hypervisor = 2,            // Direct hypervisor integration (VMware/KVM/Hyper-V)
    BareMetalSpdk = 3,         // Bare metal with SPDK user-space NVMe
    BareMetalLegacy = 4,       // Bare metal without SPDK
    HyperscaleCloud = 5,       // Cloud platform (AWS/Azure/GCP)
    EdgeDevice = 6             // Edge/IoT device
}
```

Add XML docs on each member explaining the deployment scenario.

**File 2: DeploymentContext.cs**

Create in namespace `DataWarehouse.SDK.Deployment`:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 37: Detected deployment context (ENV-01-05)")]
public sealed record DeploymentContext
{
    public DeploymentEnvironment Environment { get; init; } = DeploymentEnvironment.Unknown;
    public string? HypervisorType { get; init; } // "VMware", "KVM", "Hyper-V", "Xen", null
    public string? CloudProvider { get; init; }  // "AWS", "Azure", "GCP", null
    public bool IsBareMetalSpdk { get; init; }
    public bool IsEdgeDevice { get; init; }
    public IReadOnlyDictionary<string, string> Metadata { get; init; } = ImmutableDictionary<string, string>.Empty;
    public string? FilesystemType { get; init; } // "ext4", "xfs", "NTFS", "ReFS", null
}
```

Add comprehensive XML documentation explaining that this record captures the detected runtime environment with platform-specific metadata.

**File 3: DeploymentProfile.cs**

Create in namespace `DataWarehouse.SDK.Deployment`:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 37: Deployment-specific configuration profile (ENV-01-05)")]
public sealed record DeploymentProfile
{
    public string Name { get; init; } = "default";
    public DeploymentEnvironment Environment { get; init; }
    public bool DoubleWalBypassEnabled { get; init; }       // ENV-01: Disable OS journaling when VDE WAL active
    public bool ParavirtIoEnabled { get; init; }            // ENV-02: Use virtio-blk/PVSCSI
    public bool SpdkEnabled { get; init; }                  // ENV-03: Use SPDK user-space NVMe
    public bool AutoScalingEnabled { get; init; }           // ENV-04: Auto-provision cloud resources
    public long? MaxMemoryBytes { get; init; }              // ENV-05: Memory ceiling for edge
    public IReadOnlyList<string>? AllowedPlugins { get; init; } // ENV-05: Plugin filtering for edge
    public IReadOnlyDictionary<string, object> CustomSettings { get; init; } = ImmutableDictionary<string, object>.Empty;
}
```

Add XML documentation explaining that profiles configure DataWarehouse for specific deployment environments.

**File 4: IDeploymentDetector.cs**

Create in namespace `DataWarehouse.SDK.Deployment`:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 37: Deployment environment detection interface (ENV-01-05)")]
public interface IDeploymentDetector
{
    /// <summary>
    /// Detects the deployment environment and returns a context record.
    /// </summary>
    /// <returns>DeploymentContext if detected, null if this detector does not apply</returns>
    Task<DeploymentContext?> DetectAsync(CancellationToken ct = default);
}
```

Add XML docs explaining that implementations should return null if they cannot detect their target environment (e.g., CloudDetector returns null on bare metal).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify all 4 files exist in `DataWarehouse.SDK/Deployment/`. Grep for `DeploymentEnvironment` enum with 6+ members. Grep for `DeploymentContext` record. Grep for `IDeploymentDetector` interface.
  </verify>
  <done>
DeploymentEnvironment enum with 6 variants. DeploymentContext record captures detected environment, hypervisor, cloud provider, and metadata. DeploymentProfile record defines environment-specific configuration. IDeploymentDetector interface for pluggable detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Filesystem Type Detection</name>
  <files>
    DataWarehouse.SDK/Deployment/FilesystemDetector.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Mark class with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Filesystem type detection (ENV-01)")]`.

Public static class with methods:

```csharp
public static async Task<string?> DetectFilesystemTypeAsync(string path, CancellationToken ct = default)
```

Implementation:

**Linux path (OperatingSystem.IsLinux()):**
1. Guard with `[SupportedOSPlatform("linux")]` attribute
2. Read `/proc/mounts` with `File.ReadAllLinesAsync`
3. Parse each line: format is `<device> <mountpoint> <fstype> <options> <dump> <pass>`
   - Example: `/dev/sda1 /mnt ext4 rw,relatime 0 0`
4. Find the longest matching mount point for the given path (to handle nested mounts correctly)
5. Extract the `fstype` column (3rd column, space-separated)
6. Return fstype or null if not found
7. Wrap in try/catch (FileNotFoundException, IOException) -- return null on error

**Windows path (OperatingSystem.IsWindows()):**
1. Guard with `[SupportedOSPlatform("windows")]` attribute
2. Extract drive letter from path using `Path.GetPathRoot(path)` and trim trailing backslash
3. Use `System.Management.ManagementObjectSearcher`:
   ```csharp
   var query = $"SELECT FileSystem FROM Win32_LogicalDisk WHERE DeviceID = '{driveLetter}'";
   using var searcher = new ManagementObjectSearcher(query);
   var result = searcher.Get().Cast<ManagementObject>().FirstOrDefault();
   return result?["FileSystem"]?.ToString(); // "NTFS", "ReFS", "FAT32"
   ```
4. Wrap in try/catch (ManagementException) -- return null on error

**macOS path (OperatingSystem.IsMacOS()):**
1. Guard with `[SupportedOSPlatform("macos")]` attribute
2. Use `Process.Start("df", $"-T {path}")` to get filesystem type
3. Parse output to extract filesystem type column
4. Return filesystem type or null if not found
5. Wrap in try/catch -- return null on error

Also provide helper method:

```csharp
public static async Task<long?> GetFilesystemBlockSizeAsync(string path, CancellationToken ct = default)
```

**Linux:** Read `/sys/block/<device>/queue/physical_block_size` or use `statvfs` via P/Invoke
**Windows:** Use `GetDiskFreeSpace` via P/Invoke to get bytes per sector
**macOS:** Parse `diskutil info` output

Return block size in bytes or null if not detectable.

Add comprehensive XML documentation explaining usage, platform-specific behavior, and graceful degradation (returns null on unsupported platforms or errors).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/FilesystemDetector.cs`. Grep for `DetectFilesystemTypeAsync`. Grep for `/proc/mounts` (Linux path). Grep for `Win32_LogicalDisk` (Windows path). Grep for `SupportedOSPlatform` attributes.
  </verify>
  <done>
FilesystemDetector static class provides DetectFilesystemTypeAsync (Linux: /proc/mounts, Windows: WMI, macOS: df) and GetFilesystemBlockSizeAsync with platform guards and graceful error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Hosted VM Detection</name>
  <files>
    DataWarehouse.SDK/Deployment/HostedVmDetector.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Sealed class implementing `IDeploymentDetector`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Hosted VM environment detection (ENV-01)")]`.

Constructor: accept optional `IHypervisorDetector? hypervisorDetector = null` parameter. If null, create default instance via reflection or use NullHypervisorDetector (graceful fallback).

`DetectAsync` implementation:

1. **Check if running in a hypervisor** using `IHypervisorDetector.DetectAsync()` (from SDK.Virtualization, existing Phase 32 infrastructure)
   - If `HypervisorInfo` is null or empty, return null (not a VM)
   - Store hypervisor type for context

2. **Detect filesystem type** using `FilesystemDetector.DetectFilesystemTypeAsync(Environment.CurrentDirectory)` or a well-known data path
   - If filesystem is null, assume hosted but filesystem unknown
   - Store filesystem type for context

3. **Construct DeploymentContext:**
   - `Environment = DeploymentEnvironment.HostedVm`
   - `HypervisorType = hypervisorInfo.Type`
   - `FilesystemType = detectedFsType`
   - `Metadata = new Dictionary<string, string> { ["HypervisorVersion"] = hypervisorInfo.Version }`

4. Return the constructed DeploymentContext

Wrap all external calls in try/catch with graceful degradation -- partial detection is better than no detection.

Add comprehensive XML documentation explaining:
- Detection heuristic (hypervisor presence + filesystem presence)
- What "hosted" means (VM running on a filesystem, not bare metal)
- Return value semantics (null if not hosted VM, DeploymentContext if hosted)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/HostedVmDetector.cs`. Grep for `IDeploymentDetector` interface implementation. Grep for `IHypervisorDetector` usage. Grep for `FilesystemDetector.DetectFilesystemTypeAsync` call. Grep for `DeploymentEnvironment.HostedVm`.
  </verify>
  <done>
HostedVmDetector implements IDeploymentDetector, uses IHypervisorDetector to confirm VM status, uses FilesystemDetector to identify filesystem type, returns DeploymentContext with HostedVm environment when both conditions met.
  </done>
</task>

<task type="auto">
  <name>Task 4: Hosted Environment Optimizer (Double-WAL Bypass & I/O Alignment)</name>
  <files>
    DataWarehouse.SDK/Deployment/HostedOptimizer.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Public sealed class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Hosted VM optimizations (ENV-01)")]`.

Constructor: Accept configuration dependencies (optional, use DI-friendly pattern).

**Public method:**

```csharp
public async Task OptimizeAsync(DeploymentContext context, string vdeContainerPath, CancellationToken ct = default)
```

Implementation:

**Step 1: Validate preconditions**
- Verify `context.Environment == DeploymentEnvironment.HostedVm`
- Verify `context.FilesystemType` is not null
- If preconditions fail, log and return (graceful degradation)

**Step 2: Check VDE WAL status**
- Access VDE configuration (via static config or injected config provider)
- Read `VirtualDiskEngineConfig.WriteAheadLogEnabled`
- If WAL is NOT enabled, log warning and skip double-WAL bypass (NEVER disable OS journaling without VDE WAL)

**Step 3: Double-WAL bypass (when safe)**
- If filesystem is `ext4` or `xfs` (Linux):
  - Guard with `[SupportedOSPlatform("linux")]` or `OperatingSystem.IsLinux()` check
  - For `ext4`: Use `Process.Start("chattr", "+j <file>")` to disable journaling for specific file (requires root/CAP_DAC_OVERRIDE)
    - Wrap in try/catch (UnauthorizedAccessException, Win32Exception) -- log warning if fails
  - For `xfs`: XFS does not support per-file journaling control -- log info message and skip
- If filesystem is `NTFS` (Windows):
  - Guard with `[SupportedOSPlatform("windows")]`
  - Use `DeviceIoControl` with `FSCTL_SET_ZERO_DATA` to bypass USN journal for specific file (advanced, requires P/Invoke)
    - Wrap in try/catch -- log warning if fails
- For other filesystems (ReFS, FAT32, etc.), log info and skip (no optimization available)

**Step 4: I/O alignment configuration**
- Call `FilesystemDetector.GetFilesystemBlockSizeAsync(vdeContainerPath)`
- If block size is detected:
  - Configure VDE (or storage layer) to align I/O operations to this block size
  - Store alignment in VDE config or runtime settings
  - Log info message with detected block size
- If block size is null, use default alignment (4096 bytes)

**Step 5: Log summary**
- Log which optimizations were applied
- Log which optimizations were skipped and why

Add comprehensive XML documentation:
- Explain double-WAL penalty (two journals = 2x write overhead)
- Explain safety: ONLY disable OS journaling when VDE WAL is active
- Explain I/O alignment benefits (reduces read-modify-write cycles)
- Document required permissions (root/CAP_DAC_OVERRIDE on Linux, admin on Windows)

**Important safety check:**
```csharp
// CRITICAL: Never disable OS journaling without VDE WAL
if (!vdeConfig.WriteAheadLogEnabled)
{
    _logger.LogWarning("VDE WAL is disabled. Skipping double-WAL bypass to preserve data safety.");
    return;
}
```
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/HostedOptimizer.cs`. Grep for `WriteAheadLogEnabled` check. Grep for `chattr` (Linux path). Grep for `FSCTL_SET_ZERO_DATA` or DeviceIoControl (Windows path). Grep for `FilesystemDetector.GetFilesystemBlockSizeAsync`. Grep for safety warning when WAL disabled.
  </verify>
  <done>
HostedOptimizer.OptimizeAsync detects filesystem type, verifies VDE WAL is enabled, disables OS-level journaling for VDE container files (ext4/NTFS), configures I/O alignment to filesystem block size, logs all actions and safety warnings. NEVER disables OS journaling without VDE WAL active.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 7 new files exist in `DataWarehouse.SDK/Deployment/`
3. DeploymentEnvironment enum has 6+ environment types
4. DeploymentContext record captures environment, hypervisor, cloud, filesystem
5. IDeploymentDetector interface defined with DetectAsync method
6. FilesystemDetector works on Linux (/proc/mounts) and Windows (WMI)
7. HostedVmDetector uses IHypervisorDetector and FilesystemDetector
8. HostedOptimizer has safety check for VDE WAL before disabling OS journaling
9. HostedOptimizer configures I/O alignment based on filesystem block size
10. All platform-specific code has SupportedOSPlatform attributes and runtime guards
</verification>

<success_criteria>
- DeploymentContext accurately represents detected environment on VMs
- HostedVmDetector correctly identifies VM-on-filesystem deployments using hypervisor detection
- FilesystemDetector returns correct filesystem type (ext4, xfs, NTFS, ReFS) on Linux and Windows
- HostedOptimizer disables OS journaling for VDE container files ONLY when VDE WAL is enabled
- HostedOptimizer configures I/O alignment to match filesystem block size
- All optimizations gracefully degrade on permission errors or unsupported platforms
- Zero NuGet dependencies added (all .NET 9 BCL + existing SDK infrastructure)
- Zero existing files modified -- purely additive
</success_criteria>

<output>
After completion, create `.planning/phases/37-multi-environment-deployment/37-01-SUMMARY.md`
</output>
