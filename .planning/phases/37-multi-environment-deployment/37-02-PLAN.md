---
phase: 37-multi-environment-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Deployment/HypervisorDetector.cs
  - DataWarehouse.SDK/Deployment/HypervisorOptimizer.cs
  - DataWarehouse.SDK/Deployment/ParavirtIoDetector.cs
  - DataWarehouse.SDK/Deployment/BalloonCoordinator.cs
autonomous: true

must_haves:
  truths:
    - "HypervisorDetector delegates to existing IHypervisorDetector from SDK.Virtualization and returns DeploymentContext with Hypervisor environment"
    - "ParavirtIoDetector identifies paravirtualized I/O devices (virtio-blk, virtio-scsi, PVSCSI) using IHardwareProbe"
    - "HypervisorOptimizer enables paravirtualized I/O when available for maximum throughput"
    - "BalloonCoordinator cooperates with hypervisor memory balloon driver to manage memory pressure"
    - "All hypervisor-specific optimizations gracefully degrade when paravirt drivers not available"
    - "Live migration hooks flush VDE WAL before pre-migration pause (when supported by hypervisor)"
  artifacts:
    - path: "DataWarehouse.SDK/Deployment/HypervisorDetector.cs"
      provides: "Hypervisor environment detection (delegates to existing IHypervisorDetector)"
      min_lines: 60
    - path: "DataWarehouse.SDK/Deployment/ParavirtIoDetector.cs"
      provides: "Paravirtualized I/O device detection (virtio-blk, PVSCSI)"
      min_lines: 100
    - path: "DataWarehouse.SDK/Deployment/HypervisorOptimizer.cs"
      provides: "Hypervisor-specific optimizations (paravirt I/O, balloon cooperation)"
      min_lines: 150
    - path: "DataWarehouse.SDK/Deployment/BalloonCoordinator.cs"
      provides: "Memory balloon driver cooperation for dynamic memory management"
      min_lines: 100
  key_links:
    - from: "HypervisorDetector"
      to: "IHypervisorDetector"
      via: "Delegates to existing SDK.Virtualization.IHypervisorDetector"
      pattern: "IHypervisorDetector"
    - from: "ParavirtIoDetector"
      to: "IHardwareProbe"
      via: "Uses Phase 32 hardware probe to detect virtio/PVSCSI devices"
      pattern: "IHardwareProbe"
    - from: "BalloonCoordinator"
      to: "IBalloonDriver"
      via: "Uses existing SDK.Virtualization.IBalloonDriver interface"
      pattern: "IBalloonDriver"
---

<objective>
Implement hypervisor acceleration (ENV-02) -- detect hypervisor type (VMware, KVM, Hyper-V, Xen), enable paravirtualized I/O paths (virtio-blk, PVSCSI), cooperate with hypervisor balloon driver for memory management, and support live migration hooks.

Purpose: Paravirtualized I/O bypasses emulated hardware for near-native performance (virtio-blk on KVM achieves 95%+ of bare metal throughput). Balloon driver cooperation allows hypervisors to reclaim memory dynamically without guest OS thrashing. Live migration hooks ensure VDE WAL is flushed before migration to prevent data loss.

Output:
- `HypervisorDetector` for hypervisor environment detection
- `ParavirtIoDetector` for paravirtualized device discovery
- `HypervisorOptimizer` for hypervisor-specific optimizations
- `BalloonCoordinator` for memory balloon cooperation
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/STATE.md
@.planning/phases/37-multi-environment-deployment/37-RESEARCH.md

@DataWarehouse.SDK/Virtualization/IHypervisorSupport.cs
@DataWarehouse.SDK/Hardware/IHardwareProbe.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hypervisor Environment Detection</name>
  <files>
    DataWarehouse.SDK/Deployment/HypervisorDetector.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Sealed class implementing `IDeploymentDetector`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Hypervisor environment detection (ENV-02)")]`.

Constructor: accept optional `IHypervisorDetector? hypervisorDetector = null` parameter. If null, create default instance using reflection or factory pattern from SDK.Virtualization.

`DetectAsync` implementation:

1. **Call existing IHypervisorDetector.DetectAsync()** from SDK.Virtualization (Phase 32 infrastructure)
   - If `HypervisorInfo` is null, return null (not running in hypervisor)
   - Store hypervisor type, version, and capabilities

2. **Check hypervisor capabilities:**
   - `SupportsBalloon` -- indicates balloon driver support
   - `SupportsParavirtualization` -- indicates virtio/PVSCSI available

3. **Construct DeploymentContext:**
   - `Environment = DeploymentEnvironment.Hypervisor`
   - `HypervisorType = hypervisorInfo.Type` (VMware, KVM, Hyper-V, Xen)
   - `Metadata = new Dictionary<string, string>`
     - `["HypervisorVersion"] = hypervisorInfo.Version`
     - `["BalloonSupport"] = hypervisorInfo.SupportsBalloon.ToString()`
     - `["ParavirtSupport"] = hypervisorInfo.SupportsParavirtualization.ToString()`

4. Return the constructed DeploymentContext

Wrap all external calls in try/catch with graceful degradation.

Add XML documentation explaining:
- Difference between HostedVm (VM on filesystem) and Hypervisor (direct hypervisor integration)
- Detection criteria (IHypervisorDetector from existing SDK.Virtualization)
- Return value semantics (null if not hypervisor environment)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/HypervisorDetector.cs`. Grep for `IDeploymentDetector` implementation. Grep for `IHypervisorDetector` usage. Grep for `DeploymentEnvironment.Hypervisor`.
  </verify>
  <done>
HypervisorDetector implements IDeploymentDetector, delegates to existing IHypervisorDetector from SDK.Virtualization, returns DeploymentContext with Hypervisor environment when hypervisor detected with capabilities metadata.
  </done>
</task>

<task type="auto">
  <name>Task 2: Paravirtualized I/O Device Detection</name>
  <files>
    DataWarehouse.SDK/Deployment/ParavirtIoDetector.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Public sealed class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Paravirtualized I/O detection (ENV-02)")]`.

Constructor: accept optional `IHardwareProbe? hardwareProbe = null` parameter. If null, create default instance using HardwareProbeFactory from Phase 32.

**Public record types:**

```csharp
public sealed record ParavirtDevice
{
    public string DeviceId { get; init; }
    public string Name { get; init; }
    public ParavirtDeviceType Type { get; init; }
    public string? DriverName { get; init; }
    public IReadOnlyDictionary<string, string> Properties { get; init; } = ImmutableDictionary<string, string>.Empty;
}

public enum ParavirtDeviceType
{
    VirtioBlock,       // virtio-blk (KVM)
    VirtioScsi,        // virtio-scsi (KVM)
    Pvscsi,            // PVSCSI (VMware)
    HyperVStorageVsc,  // Hyper-V storage VSC
    XenVirtualDisk     // Xen paravirtualized disk
}
```

**Public method:**

```csharp
public async Task<IReadOnlyList<ParavirtDevice>> DetectParavirtDevicesAsync(CancellationToken ct = default)
```

Implementation:

1. **Call IHardwareProbe.DiscoverAsync()** to get all hardware devices

2. **Filter for paravirtualized storage devices:**
   - **Linux detection:**
     - virtio-blk: Look for devices with `DriverName == "virtio_blk"` or device path `/dev/vd*`
     - virtio-scsi: Look for devices with `DriverName == "virtio_scsi"`
     - Check device properties for `Vendor == "0x1af4"` (VirtIO PCI vendor ID)
   - **Windows detection:**
     - PVSCSI: Look for devices with `DeviceId` containing `VEN_15AD&DEV_07C0` (VMware PVSCSI)
     - virtio-blk: Look for devices with `VEN_1AF4&DEV_1001` (VirtIO block device)
     - Hyper-V VSC: Look for devices with `DeviceId` containing `ROOT\STORVSC`
   - **Generic detection:**
     - Parse device name/description for keywords: "virtio", "pvscsi", "storvsc"

3. **Map HardwareDevice to ParavirtDevice:**
   - Extract device ID, name, driver
   - Classify ParavirtDeviceType based on vendor ID, device ID, or driver name
   - Store original hardware properties

4. Return list of detected paravirt devices (empty list if none found)

Wrap all hardware probe calls in try/catch with graceful degradation.

Add XML documentation explaining:
- Purpose: Identify paravirtualized I/O devices for performance optimization
- Detection heuristics per platform (Linux device paths, Windows PnP IDs)
- Return value (empty list if no paravirt devices found)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/ParavirtIoDetector.cs`. Grep for `IHardwareProbe` usage. Grep for `ParavirtDeviceType` enum with virtio-blk, PVSCSI, etc. Grep for vendor ID checks (`0x1af4`, `15AD`).
  </verify>
  <done>
ParavirtIoDetector detects paravirtualized storage devices (virtio-blk, virtio-scsi, PVSCSI, Hyper-V VSC, Xen) using IHardwareProbe from Phase 32, returns typed ParavirtDevice records with device classification and properties.
  </done>
</task>

<task type="auto">
  <name>Task 3: Memory Balloon Coordinator</name>
  <files>
    DataWarehouse.SDK/Deployment/BalloonCoordinator.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Public sealed class implementing `IDisposable`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Hypervisor balloon cooperation (ENV-02)")]`.

Constructor: accept optional `IBalloonDriver? balloonDriver = null` parameter (from SDK.Virtualization, existing Phase 32 infrastructure).

**Public methods:**

```csharp
public async Task StartCooperationAsync(CancellationToken ct = default)
public async Task StopCooperationAsync(CancellationToken ct = default)
public Task<BalloonStatus?> GetBalloonStatusAsync(CancellationToken ct = default)
```

**BalloonStatus record:**

```csharp
public sealed record BalloonStatus
{
    public long CurrentBalloonBytes { get; init; }
    public long TargetBalloonBytes { get; init; }
    public long GuestMemoryBytes { get; init; }
    public bool IsActive { get; init; }
}
```

**StartCooperationAsync implementation:**

1. Check if `IBalloonDriver` is available (not null and driver loaded)
2. Subscribe to balloon pressure events (if IBalloonDriver provides events)
3. On balloon inflation (hypervisor requesting memory back):
   - Trigger GC.Collect() to free managed memory
   - Reduce cache sizes (e.g., VDE block cache, object metadata cache)
   - Log memory pressure event
4. On balloon deflation (hypervisor releasing memory):
   - Restore cache sizes
   - Log memory release event
5. Set cooperation active flag

**StopCooperationAsync implementation:**

1. Unsubscribe from balloon events
2. Restore default cache sizes
3. Clear cooperation active flag

**GetBalloonStatusAsync implementation:**

1. Call `IBalloonDriver.GetBalloonInfoAsync()` (if available)
2. Return current balloon size, target size, guest memory, and active status
3. Return null if balloon driver not available

**Dispose:**
- Call StopCooperationAsync
- Dispose balloon driver if owned

Wrap all balloon driver calls in try/catch with graceful degradation -- balloon cooperation is optional optimization.

Add XML documentation explaining:
- Purpose: Cooperate with hypervisor memory management to avoid thrashing
- Behavior: Reduce memory usage when hypervisor requests memory back (balloon inflation)
- Restore: Increase memory usage when hypervisor releases memory (balloon deflation)
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/BalloonCoordinator.cs`. Grep for `IBalloonDriver` usage. Grep for `GC.Collect()` call on balloon inflation. Grep for `BalloonStatus` record.
  </verify>
  <done>
BalloonCoordinator cooperates with IBalloonDriver from SDK.Virtualization, triggers GC and reduces cache sizes on balloon inflation, restores sizes on deflation, provides balloon status query, implements IDisposable for cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 4: Hypervisor Optimizer (Paravirt I/O & Live Migration)</name>
  <files>
    DataWarehouse.SDK/Deployment/HypervisorOptimizer.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Deployment`.

Public sealed class. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 37: Hypervisor optimizations (ENV-02)")]`.

Constructor: accept dependencies (ParavirtIoDetector, BalloonCoordinator, optional configuration).

**Public methods:**

```csharp
public async Task OptimizeAsync(DeploymentContext context, CancellationToken ct = default)
public async Task RegisterLiveMigrationHooksAsync(Func<Task> preMigrationFlush, CancellationToken ct = default)
```

**OptimizeAsync implementation:**

**Step 1: Validate preconditions**
- Verify `context.Environment == DeploymentEnvironment.Hypervisor`
- Verify `context.HypervisorType` is not null
- If preconditions fail, log and return

**Step 2: Detect paravirtualized I/O devices**
- Call `ParavirtIoDetector.DetectParavirtDevicesAsync()`
- If paravirt devices found:
  - Log detected devices (count, types)
  - Configure storage layer to prefer paravirt devices over emulated
  - For virtio-blk/virtio-scsi: Enable multi-queue if supported (check device properties)
  - For PVSCSI: Enable adaptive queue depth
- If no paravirt devices found:
  - Log info message (running with emulated I/O, performance limited)
  - Continue with standard I/O path

**Step 3: Enable balloon cooperation**
- Check `context.Metadata["BalloonSupport"]`
- If balloon supported:
  - Start BalloonCoordinator cooperation
  - Log balloon cooperation active
- If not supported:
  - Log info message (balloon not available, memory management static)

**Step 4: Hypervisor-specific optimizations**
- **KVM:** Enable virtio-blk multi-queue if available, configure SCSI unmap for TRIM support
- **VMware:** Enable PVSCSI adaptive queue depth, configure VMware Tools integration if available
- **Hyper-V:** Enable dynamic memory cooperation, configure Hyper-V enlightenments
- **Xen:** Enable Xen paravirtualized block device, configure grant tables

**RegisterLiveMigrationHooksAsync implementation:**

1. Detect hypervisor type from context
2. **KVM/QEMU:**
   - Monitor for QEMU guest agent signals (if available)
   - On pre-migration signal: call `preMigrationFlush` to flush VDE WAL
3. **VMware:**
   - Use VMware Tools API to register pre-migration hook (if available)
   - On pre-migration: call `preMigrationFlush`
4. **Hyper-V:**
   - Monitor Hyper-V integration services for migration events
   - On pre-migration: call `preMigrationFlush`
5. **Xen:**
   - Monitor XenStore for migration signals
   - On pre-migration: call `preMigrationFlush`

If hooks are not available for the detected hypervisor, log info message (live migration hooks not supported, ensure WAL sync interval is short).

Wrap all external calls in try/catch with graceful degradation.

Add XML documentation explaining:
- Paravirt I/O performance benefits (95%+ of bare metal on KVM virtio-blk)
- Balloon cooperation for dynamic memory management
- Live migration hook purpose (prevent data loss during migration)
- Hypervisor-specific optimization details
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify file exists at `DataWarehouse.SDK/Deployment/HypervisorOptimizer.cs`. Grep for `ParavirtIoDetector` usage. Grep for `BalloonCoordinator` usage. Grep for `RegisterLiveMigrationHooksAsync`. Grep for hypervisor-specific optimization branches (KVM, VMware, Hyper-V, Xen).
  </verify>
  <done>
HypervisorOptimizer.OptimizeAsync detects paravirt I/O devices, enables multi-queue/adaptive depth, starts balloon cooperation, applies hypervisor-specific optimizations (KVM virtio-blk, VMware PVSCSI, Hyper-V VSC). RegisterLiveMigrationHooksAsync installs pre-migration hooks per hypervisor to flush VDE WAL.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 4 new files exist in `DataWarehouse.SDK/Deployment/`
3. HypervisorDetector delegates to existing IHypervisorDetector from SDK.Virtualization
4. ParavirtIoDetector uses IHardwareProbe from Phase 32 to detect virtio/PVSCSI devices
5. BalloonCoordinator uses IBalloonDriver from SDK.Virtualization for memory cooperation
6. HypervisorOptimizer enables paravirt I/O when available
7. HypervisorOptimizer starts balloon cooperation when supported
8. RegisterLiveMigrationHooksAsync installs hooks per hypervisor type (KVM, VMware, Hyper-V, Xen)
9. All optimizations gracefully degrade when drivers/features not available
10. Zero new NuGet dependencies (reuses Phase 32 infrastructure)
</verification>

<success_criteria>
- HypervisorDetector correctly identifies hypervisor type using existing SDK.Virtualization infrastructure
- ParavirtIoDetector identifies virtio-blk, PVSCSI, and other paravirt devices on Linux and Windows
- BalloonCoordinator reduces memory usage on balloon inflation, restores on deflation
- HypervisorOptimizer enables paravirt I/O for near-native performance (within 5% of bare metal)
- Live migration hooks flush VDE WAL before migration on supported hypervisors
- All optimizations gracefully degrade on unsupported platforms or missing drivers
- Zero NuGet dependencies added (all existing SDK infrastructure)
- Zero existing files modified -- purely additive
</success_criteria>

<output>
After completion, create `.planning/phases/37-multi-environment-deployment/37-02-SUMMARY.md`
</output>
