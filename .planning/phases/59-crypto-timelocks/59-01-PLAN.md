---
phase: 59-crypto-timelocks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/TamperProof/ITimeLockProvider.cs
  - DataWarehouse.SDK/Contracts/TamperProof/TimeLockTypes.cs
  - DataWarehouse.SDK/Contracts/TamperProof/TimeLockEnums.cs
autonomous: true

must_haves:
  truths:
    - "SDK defines ITimeLockProvider contract with per-object lock/unlock/status operations"
    - "TimeLock types include lock metadata, duration, unlock conditions, and ransomware vaccination flags"
    - "TimeLockProviderPluginBase provides validation, audit logging, and intelligence hooks"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/TamperProof/ITimeLockProvider.cs"
      provides: "ITimeLockProvider interface + TimeLockProviderPluginBase abstract class"
      exports: ["ITimeLockProvider", "TimeLockProviderPluginBase"]
    - path: "DataWarehouse.SDK/Contracts/TamperProof/TimeLockTypes.cs"
      provides: "TimeLockResult, TimeLockStatus, TimeLockPolicy, UnlockCondition, RansomwareVaccinationInfo"
      exports: ["TimeLockResult", "TimeLockStatus", "TimeLockPolicy", "UnlockCondition", "RansomwareVaccinationInfo"]
    - path: "DataWarehouse.SDK/Contracts/TamperProof/TimeLockEnums.cs"
      provides: "TimeLockMode, UnlockConditionType, VaccinationLevel enums"
      exports: ["TimeLockMode", "UnlockConditionType", "VaccinationLevel"]
  key_links:
    - from: "ITimeLockProvider"
      to: "IWormStorageProvider"
      via: "ITimeLockProvider extends WORM concepts with temporal locking"
      pattern: "ITimeLockProvider.*IPlugin"
    - from: "TimeLockProviderPluginBase"
      to: "IntegrityPluginBase"
      via: "inherits from IntegrityPluginBase like WormStorageProviderPluginBase"
      pattern: "class TimeLockProviderPluginBase.*IntegrityPluginBase"
---

<objective>
Define SDK contracts for per-object cryptographic time-locks.

Purpose: Establish the interface contracts, types, and base class that all time-lock implementations (software, hardware, cloud-backed) will use. This is the foundation for ransomware vaccination -- objects can be locked for configurable periods where even admin access cannot unlock them early.

Output: SDK contracts in DataWarehouse.SDK/Contracts/TamperProof/ for time-lock operations.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Contracts/TamperProof/IWormStorageProvider.cs
@DataWarehouse.SDK/Contracts/TamperProof/TamperProofEnums.cs
@DataWarehouse.SDK/Contracts/TamperProof/WriteContext.cs
@DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define TimeLock enums and types</name>
  <files>
    DataWarehouse.SDK/Contracts/TamperProof/TimeLockEnums.cs
    DataWarehouse.SDK/Contracts/TamperProof/TimeLockTypes.cs
  </files>
  <action>
Create TimeLockEnums.cs in namespace DataWarehouse.SDK.Contracts.TamperProof:

- `TimeLockMode` enum: Software (filesystem ACL + clock-based), HardwareHsm (HSM-backed time-release keys), CloudNative (S3 Object Lock / Azure Immutable Blob temporal mode), Hybrid (software + hardware verification)
- `UnlockConditionType` enum: TimeExpiry (UTC clock), MultiPartyApproval (M-of-N quorum), EmergencyBreakGlass (audited override), ComplianceRelease (regulatory authority), NeverUnlock (permanent archival)
- `VaccinationLevel` enum: None, Basic (time-lock only), Enhanced (time-lock + integrity check), Maximum (time-lock + integrity + PQC signature + blockchain anchor)

Create TimeLockTypes.cs in same namespace:

- `TimeLockPolicy` record: MinLockDuration (TimeSpan), MaxLockDuration (TimeSpan), DefaultLockDuration (TimeSpan), AllowedUnlockConditions (UnlockConditionType[]), RequireMultiPartyForEarlyUnlock (bool), VaccinationLevel (VaccinationLevel), AutoExtendOnTamperDetection (bool), RequirePqcSignature (bool)
- `TimeLockResult` class with required properties: ObjectId (Guid), LockId (string), LockedAt (DateTimeOffset), UnlocksAt (DateTimeOffset), TimeLockMode (TimeLockMode), ContentHash (string), VaccinationLevel (VaccinationLevel), PqcSignatureAlgorithm (string?), ProviderMetadata (Dictionary string string?)
- `TimeLockStatus` class with required properties: Exists (bool), ObjectId (Guid), IsLocked (bool computed from UnlocksAt), UnlocksAt (DateTimeOffset?), LockedAt (DateTimeOffset?), LockId (string?), TimeLockMode (TimeLockMode), VaccinationLevel (VaccinationLevel), ActiveHolds (IReadOnlyList of LegalHold), TamperDetected (bool), LastIntegrityCheck (DateTimeOffset?)
- `UnlockCondition` record: Type (UnlockConditionType), Parameters (Dictionary string object), RequiredApprovals (int, default 1), ExpiresAt (DateTimeOffset?)
- `RansomwareVaccinationInfo` record: VaccinationLevel (VaccinationLevel), TimeLockActive (bool), IntegrityVerified (bool), PqcSignatureValid (bool?), BlockchainAnchored (bool?), LastScanAt (DateTimeOffset), ThreatScore (double, 0.0-1.0)
- `TimeLockRequest` record: ObjectId (Guid), LockDuration (TimeSpan), TimeLockMode (TimeLockMode), VaccinationLevel (VaccinationLevel), UnlockConditions (UnlockCondition[]), Context (WriteContext)

Follow the same patterns as WormWriteResult, WormObjectStatus, and LegalHold in IWormStorageProvider.cs. Use required properties with init setters. Add XML documentation on every public member.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with 0 errors.</verify>
  <done>TimeLockEnums.cs has 3 enums (TimeLockMode, UnlockConditionType, VaccinationLevel). TimeLockTypes.cs has 6 types (TimeLockPolicy, TimeLockResult, TimeLockStatus, UnlockCondition, RansomwareVaccinationInfo, TimeLockRequest). All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Define ITimeLockProvider interface and base class</name>
  <files>
    DataWarehouse.SDK/Contracts/TamperProof/ITimeLockProvider.cs
  </files>
  <action>
Create ITimeLockProvider.cs in namespace DataWarehouse.SDK.Contracts.TamperProof:

Interface `ITimeLockProvider : IPlugin`:
- `Task of TimeLockResult LockAsync(TimeLockRequest request, CancellationToken ct)` -- apply time-lock to object
- `Task of TimeLockStatus GetStatusAsync(Guid objectId, CancellationToken ct)` -- get lock status
- `Task of bool IsLockedAsync(Guid objectId, CancellationToken ct)` -- quick check if locked
- `Task of RansomwareVaccinationInfo GetVaccinationInfoAsync(Guid objectId, CancellationToken ct)` -- get vaccination status
- `Task ExtendLockAsync(Guid objectId, TimeSpan additionalDuration, CancellationToken ct)` -- extend lock (never shorten)
- `Task of bool AttemptUnlockAsync(Guid objectId, UnlockCondition condition, CancellationToken ct)` -- attempt unlock with condition
- `Task of IReadOnlyList of TimeLockStatus ListLockedObjectsAsync(int limit, int offset, CancellationToken ct)` -- enumerate locked objects

Abstract class `TimeLockProviderPluginBase : IntegrityPluginBase, ITimeLockProvider, IIntelligenceAware`:
- Follow the EXACT same pattern as WormStorageProviderPluginBase in IWormStorageProvider.cs
- Implement LockAsync with validation (objectId not empty, duration positive, duration within policy bounds), then delegate to abstract `LockInternalAsync`
- Implement ExtendLockAsync with validation (cannot shorten), delegate to `ExtendLockInternalAsync`
- Implement AttemptUnlockAsync with validation (check condition type is allowed by policy), delegate to `AttemptUnlockInternalAsync`
- Intelligence socket: DiscoverIntelligenceAsync, DeclaredCapabilities with category TamperProof/subcategory TimeLock, GetStaticKnowledge
- GetMetadata override adding FeatureType=TimeLock, supported modes, vaccination levels
- Abstract methods: LockInternalAsync, ExtendLockInternalAsync, AttemptUnlockInternalAsync, GetStatusAsync, IsLockedAsync, GetVaccinationInfoAsync, ListLockedObjectsAsync

Import IPlugin from DataWarehouse.SDK.Contracts.Hierarchy. Import IntegrityPluginBase (same hierarchy as WormStorageProviderPluginBase). Use the same intelligence, capability registration, and knowledge bank patterns.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with 0 errors.</verify>
  <done>ITimeLockProvider interface defines 7 operations. TimeLockProviderPluginBase provides validated wrappers with audit trail, intelligence hooks, and 4 abstract methods for provider implementations.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors
- ITimeLockProvider.cs contains ITimeLockProvider interface and TimeLockProviderPluginBase class
- TimeLockTypes.cs contains TimeLockResult, TimeLockStatus, TimeLockPolicy, UnlockCondition, RansomwareVaccinationInfo, TimeLockRequest
- TimeLockEnums.cs contains TimeLockMode, UnlockConditionType, VaccinationLevel
</verification>

<success_criteria>
SDK compiles. All time-lock contracts defined with full XML documentation. Base class follows WormStorageProviderPluginBase pattern exactly. No stubs/TODOs.
</success_criteria>

<output>
After completion, create `.planning/phases/59-crypto-timelocks/59-01-SUMMARY.md`
</output>
