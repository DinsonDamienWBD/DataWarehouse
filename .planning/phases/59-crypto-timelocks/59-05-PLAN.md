---
phase: 59-crypto-timelocks
plan: 05
type: execute
wave: 2
depends_on: ["59-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/CrystalsDilithiumStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/SphincsPlusStrategies.cs
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/PqSignatureStrategies.cs
autonomous: true

must_haves:
  truths:
    - "CRYSTALS-Dilithium signature strategies at all 3 NIST levels (44/65/87) produce valid signatures"
    - "SPHINCS+ signature strategies at all 3 NIST levels (128f/192f/256f) produce valid hash-based signatures"
    - "All signature strategies use consistent wire format: [Signature Length:4][Signature][Data]"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/CrystalsDilithiumStrategies.cs"
      provides: "DilithiumSignature44/65/87Strategy"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/SphincsPlusStrategies.cs"
      provides: "SphincsPlus128f/192f/256fStrategy"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/PqSignatureStrategies.cs"
      provides: "Updated MlDsaStrategy and SlhDsaStrategy with FIPS references"
      min_lines: 300
  key_links:
    - from: "CrystalsDilithiumStrategies"
      to: "EncryptionStrategyBase"
      via: "extends encryption base for sign/verify"
      pattern: "class Dilithium.*EncryptionStrategyBase"
    - from: "SphincsPlusStrategies"
      to: "EncryptionStrategyBase"
      via: "extends encryption base for sign/verify"
      pattern: "class SphincsPlus.*EncryptionStrategyBase"
---

<objective>
Implement CRYSTALS-Dilithium (FIPS 204) and SPHINCS+ (FIPS 205) signature strategies.

Purpose: Complete the PQC signature suite with production-ready strategies at all NIST security levels. Dilithium provides fast lattice-based signatures for general use. SPHINCS+ provides conservative hash-based signatures for maximum assurance scenarios (critical infrastructure, long-term archival). Both are needed for ransomware vaccination (signing time-locked objects) and crypto-agility migration.

Output: New strategy files for Dilithium and SPHINCS+ at all security levels.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/59-crypto-timelocks/59-03-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/PqSignatureStrategies.cs
@DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategy.cs
@DataWarehouse.SDK/Contracts/Encryption/PqcAlgorithmRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CRYSTALS-Dilithium signature strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/CrystalsDilithiumStrategies.cs
  </files>
  <action>
Create CrystalsDilithiumStrategies.cs in namespace DataWarehouse.Plugins.UltimateEncryption.Strategies.PostQuantum:

Three strategies: DilithiumSignature44Strategy, DilithiumSignature65Strategy, DilithiumSignature87Strategy.

Create a shared `DilithiumSignatureHelper` static class (same pattern as KyberKemHelper in Plan 04):
- `Sign(byte[] data, byte[] privateKey, DilithiumParameters parameters)` -> byte[] signature
- `Verify(byte[] data, byte[] signature, byte[] publicKey, DilithiumParameters parameters)` -> bool
- `GenerateKeyPair(DilithiumParameters parameters, SecureRandom random)` -> (byte[] publicKey, byte[] privateKey)

Each strategy extends EncryptionStrategyBase and follows the EXACT pattern of MlDsaStrategy in PqSignatureStrategies.cs:

- DilithiumSignature44Strategy: StrategyId="crystals-dilithium-44", DilithiumParameters.Dilithium2, NistLevel=2, FIPS 204, SignatureSize=2420, PublicKeySize=1312, PrivateKeySize=2528
- DilithiumSignature65Strategy: StrategyId="crystals-dilithium-65", DilithiumParameters.Dilithium3, NistLevel=3, FIPS 204, SignatureSize=3309, PublicKeySize=1952, PrivateKeySize=4000
- DilithiumSignature87Strategy: StrategyId="crystals-dilithium-87", DilithiumParameters.Dilithium5, NistLevel=5, FIPS 204, SignatureSize=4627, PublicKeySize=2592, PrivateKeySize=4864

EncryptCoreAsync = sign the data (same pattern as MlDsaStrategy). DecryptCoreAsync = verify signature. Wire format: [Signature Length:4][Signature][Original Data].

Use BouncyCastle's DilithiumKeyPairGenerator, DilithiumSigner, DilithiumPrivateKeyParameters, DilithiumPublicKeyParameters. Import from Org.BouncyCastle.Pqc.Crypto.Crystals.Dilithium.

CipherInfo for each: IsAuthenticated=true, IsStreamable=false, SupportsAead=false, SecurityLevel=QuantumSafe, Parameters includes FipsReference="FIPS 204" and accurate key/signature sizes.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj --no-restore` -- 0 errors</verify>
  <done>Three Dilithium strategies at NIST Levels 2/3/5 with shared helper, accurate key sizes, FIPS 204 references. All sign/verify operations production-ready.</done>
</task>

<task type="auto">
  <name>Task 2: Create SPHINCS+ strategies and update PqSignatureStrategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/SphincsPlusStrategies.cs
    Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/PqSignatureStrategies.cs
  </files>
  <action>
SphincsPlusStrategies.cs in namespace DataWarehouse.Plugins.UltimateEncryption.Strategies.PostQuantum:

Three strategies: SphincsPlus128fStrategy, SphincsPlus192fStrategy, SphincsPlus256fStrategy.

Create shared `SphincsPlusSignatureHelper` static class:
- `Sign(byte[] data, byte[] privateKey, SphincsPlusParameters parameters)` -> byte[]
- `Verify(byte[] data, byte[] signature, byte[] publicKey, SphincsPlusParameters parameters)` -> bool
- `GenerateKeyPair(SphincsPlusParameters parameters, SecureRandom random)` -> (byte[] publicKey, byte[] privateKey)

Each extends EncryptionStrategyBase following SlhDsaStrategy pattern:

- SphincsPlus128fStrategy: StrategyId="sphincs-plus-shake-128f", SphincsPlusParameters.shake_128f, FIPS 205, SignatureSize=17088, PublicKeySize=32, PrivateKeySize=64
- SphincsPlus192fStrategy: StrategyId="sphincs-plus-shake-192f", SphincsPlusParameters.shake_192f, FIPS 205, SignatureSize=35664, PublicKeySize=48, PrivateKeySize=96
- SphincsPlus256fStrategy: StrategyId="sphincs-plus-shake-256f", SphincsPlusParameters.shake_256f, FIPS 205, SignatureSize=49856, PublicKeySize=64, PrivateKeySize=128

Wire format: [Signature Length:4][Signature][Original Data]. Same as Dilithium.

Use BouncyCastle's SphincsPlusKeyPairGenerator, SphincsPlusSigner, SphincsPlusPrivateKeyParameters, SphincsPlusPublicKeyParameters. Import from Org.BouncyCastle.Pqc.Crypto.SphincsPlus.

Update PqSignatureStrategies.cs:
1. Add CipherInfo.Parameters["FipsReference"] = "FIPS 204" to MlDsaStrategy
2. Add CipherInfo.Parameters["FipsReference"] = "FIPS 205" to SlhDsaStrategy
3. Add CipherInfo.Parameters["MigrationTarget"] to point to new dedicated strategies
4. Update XML docs to reference FIPS 204/205 explicitly
5. Do NOT change FalconStrategy (still unavailable)
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj --no-restore` -- 0 errors</verify>
  <done>Three SPHINCS+ strategies at security levels 128/192/256 with FIPS 205 references. PqSignatureStrategies updated with FIPS 204/205 references. All sign/verify operations production-ready.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj` -- 0 errors
- CrystalsDilithiumStrategies has 3 strategies + helper
- SphincsPlusStrategies has 3 strategies + helper
- PqSignatureStrategies has FIPS references on existing strategies
- Total: 6 new signature strategies + 2 updated existing strategies
</verification>

<success_criteria>
All signature strategies compile. Each produces valid sign/verify operations. FIPS 204/205 references throughout. No stubs.
</success_criteria>

<output>
After completion, create `.planning/phases/59-crypto-timelocks/59-05-SUMMARY.md`
</output>
