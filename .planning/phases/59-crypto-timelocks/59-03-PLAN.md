---
phase: 59-crypto-timelocks
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Encryption/ICryptoAgilityEngine.cs
  - DataWarehouse.SDK/Contracts/Encryption/CryptoAgilityTypes.cs
  - DataWarehouse.SDK/Contracts/Encryption/PqcAlgorithmRegistry.cs
autonomous: true

must_haves:
  truths:
    - "SDK defines ICryptoAgilityEngine contract for automated PQC migration"
    - "Algorithm registry tracks classical vs PQC algorithms with deprecation timelines"
    - "Migration types support double-encryption transition for zero-downtime algorithm swap"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Encryption/ICryptoAgilityEngine.cs"
      provides: "ICryptoAgilityEngine interface + CryptoAgilityEngineBase abstract class"
      exports: ["ICryptoAgilityEngine", "CryptoAgilityEngineBase"]
    - path: "DataWarehouse.SDK/Contracts/Encryption/CryptoAgilityTypes.cs"
      provides: "MigrationPlan, MigrationStatus, AlgorithmProfile, DoubleEncryptionEnvelope"
      exports: ["MigrationPlan", "MigrationStatus", "AlgorithmProfile", "DoubleEncryptionEnvelope", "MigrationPhase"]
    - path: "DataWarehouse.SDK/Contracts/Encryption/PqcAlgorithmRegistry.cs"
      provides: "Registry of all supported PQC algorithms with FIPS references"
      exports: ["PqcAlgorithmRegistry", "PqcAlgorithmInfo"]
  key_links:
    - from: "ICryptoAgilityEngine"
      to: "IPlugin"
      via: "implements IPlugin for plugin lifecycle"
      pattern: "ICryptoAgilityEngine.*IPlugin"
    - from: "MigrationPlan"
      to: "AlgorithmProfile"
      via: "maps from source to target algorithm"
      pattern: "SourceAlgorithm.*TargetAlgorithm"
---

<objective>
Define SDK contracts for the crypto-agility engine and PQC algorithm registry.

Purpose: The crypto-agility engine enables zero-downtime migration from classical to post-quantum algorithms. It manages migration plans, double-encryption transitions (encrypt with both old and new algorithm during transition), and algorithm deprecation schedules. The PQC algorithm registry catalogs all supported algorithms with their NIST FIPS references, security levels, and key sizes.

Output: SDK contracts for crypto-agility in DataWarehouse.SDK/Contracts/Encryption/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Contracts/Encryption/EncryptionStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/MlKemStrategies.cs
@Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/PostQuantum/PqSignatureStrategies.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define crypto-agility types and PQC algorithm registry</name>
  <files>
    DataWarehouse.SDK/Contracts/Encryption/CryptoAgilityTypes.cs
    DataWarehouse.SDK/Contracts/Encryption/PqcAlgorithmRegistry.cs
  </files>
  <action>
CryptoAgilityTypes.cs in namespace DataWarehouse.SDK.Contracts.Encryption:

- `MigrationPhase` enum: NotStarted, Assessment, DoubleEncryption, Verification, CutOver, Cleanup, Complete, Failed, RolledBack
- `AlgorithmCategory` enum: SymmetricEncryption, AsymmetricEncryption, KeyExchange, DigitalSignature, HashFunction, KeyDerivation
- `AlgorithmProfile` record: AlgorithmId (string), AlgorithmName (string), Category (AlgorithmCategory), SecurityLevel (SecurityLevel), IsPostQuantum (bool), FipsReference (string?, e.g. "FIPS 203"), NistLevel (int?), KeySizeBits (int), SignatureSizeBits (int?), IsDeprecated (bool), DeprecationDate (DateTimeOffset?), ReplacedBy (string?), StrategyId (string, maps to EncryptionStrategyBase.StrategyId)
- `MigrationPlan` class: PlanId (string), SourceAlgorithm (AlgorithmProfile), TargetAlgorithm (AlgorithmProfile), Phase (MigrationPhase), CreatedAt (DateTimeOffset), StartedAt (DateTimeOffset?), CompletedAt (DateTimeOffset?), ObjectsTotal (long), ObjectsMigrated (long), ObjectsFailed (long), UseDoubleEncryption (bool), RollbackOnFailureThreshold (double, 0.0-1.0), MaxConcurrentMigrations (int)
- `MigrationStatus` class: PlanId (string), Phase (MigrationPhase), Progress (double 0.0-1.0), ObjectsTotal/Migrated/Failed (long), CurrentBatchSize (int), EstimatedCompletionUtc (DateTimeOffset?), Errors (IReadOnlyList of string), IsRollbackAvailable (bool)
- `DoubleEncryptionEnvelope` class: ObjectId (Guid), PrimaryAlgorithmId (string), SecondaryAlgorithmId (string), PrimaryCiphertext (byte[]), SecondaryCiphertext (byte[]), TransitionCreatedAt (DateTimeOffset), TransitionExpiresAt (DateTimeOffset), Metadata (Dictionary string string?)
- `MigrationBatch` record: BatchId (string), ObjectIds (Guid[]), SourceAlgorithm (string), TargetAlgorithm (string), BatchSize (int)

PqcAlgorithmRegistry.cs in same namespace:

- `PqcAlgorithmInfo` record: inherits or wraps AlgorithmProfile, adds BouncyCastleType (string?), DotNetType (string?), ParameterSetName (string)
- `PqcAlgorithmRegistry` static class with:
  - Static readonly `IReadOnlyDictionary<string, PqcAlgorithmInfo> Algorithms` property
  - Pre-populated entries for: ml-kem-512 (FIPS 203, Level 1), ml-kem-768 (FIPS 203, Level 3), ml-kem-1024 (FIPS 203, Level 5), ml-dsa-44 (FIPS 204, Level 2), ml-dsa-65 (FIPS 204, Level 3), ml-dsa-87 (FIPS 204, Level 5), slh-dsa-shake-128f (FIPS 205, Level 1), slh-dsa-shake-192f (FIPS 205, Level 3), slh-dsa-shake-256f (FIPS 205, Level 5), hybrid-x25519-kyber768
  - `GetRecommendedKem(int nistLevel)` -- returns best KEM for given security level
  - `GetRecommendedSignature(int nistLevel)` -- returns best signature for given security level
  - `GetMigrationPath(string classicalAlgorithm)` -- returns recommended PQC replacement
  - `IsDeprecated(string algorithmId)` method

Use accurate key sizes: ML-KEM-768 public key 1184 bytes, ML-KEM-1024 public key 1568 bytes. ML-DSA-65 signature 3309 bytes. SLH-DSA-SHAKE-128f signature 17088 bytes. Include these in the AlgorithmProfile entries.
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors</verify>
  <done>CryptoAgilityTypes.cs has 6 types covering migration lifecycle. PqcAlgorithmRegistry has 10 pre-populated PQC algorithm entries with accurate FIPS references and key sizes.</done>
</task>

<task type="auto">
  <name>Task 2: Define ICryptoAgilityEngine interface and base class</name>
  <files>
    DataWarehouse.SDK/Contracts/Encryption/ICryptoAgilityEngine.cs
  </files>
  <action>
ICryptoAgilityEngine.cs in namespace DataWarehouse.SDK.Contracts.Encryption:

Interface `ICryptoAgilityEngine : IPlugin`:
- `Task<MigrationPlan> CreateMigrationPlanAsync(string sourceAlgorithmId, string targetAlgorithmId, MigrationOptions? options, CancellationToken ct)` -- create a migration plan
- `Task<MigrationStatus> StartMigrationAsync(string planId, CancellationToken ct)` -- begin executing a plan
- `Task<MigrationStatus> GetMigrationStatusAsync(string planId, CancellationToken ct)` -- check progress
- `Task PauseMigrationAsync(string planId, CancellationToken ct)` -- pause migration
- `Task ResumeMigrationAsync(string planId, CancellationToken ct)` -- resume paused migration
- `Task RollbackMigrationAsync(string planId, CancellationToken ct)` -- rollback to source algorithm
- `Task<DoubleEncryptionEnvelope> DoubleEncryptAsync(Guid objectId, byte[] plaintext, string primaryAlgorithmId, string secondaryAlgorithmId, CancellationToken ct)` -- encrypt with both algorithms
- `Task<byte[]> DecryptFromEnvelopeAsync(DoubleEncryptionEnvelope envelope, string preferredAlgorithmId, CancellationToken ct)` -- decrypt from either algorithm in envelope
- `Task<IReadOnlyList<AlgorithmProfile>> GetDeprecatedAlgorithmsAsync(CancellationToken ct)` -- list deprecated algorithms
- `Task<IReadOnlyList<MigrationPlan>> GetActiveMigrationsAsync(CancellationToken ct)` -- list active migrations

`MigrationOptions` record: UseDoubleEncryption (bool, default true), MaxConcurrentMigrations (int, default 4), RollbackOnFailureThreshold (double, default 0.05), BatchSize (int, default 100), DoubleEncryptionDuration (TimeSpan, default 7 days), NotifyOnCompletion (bool, default true)

Abstract class `CryptoAgilityEngineBase : FeaturePluginBase, ICryptoAgilityEngine, IIntelligenceAware`:
- Store migrations in ConcurrentDictionary<string, MigrationPlan>
- Implement CreateMigrationPlanAsync: validate source/target exist in PqcAlgorithmRegistry (or known algorithms), validate target is not deprecated, create plan with NotStarted phase
- Implement GetMigrationStatusAsync, PauseMigrationAsync, GetActiveMigrationsAsync, GetDeprecatedAlgorithmsAsync as concrete methods using ConcurrentDictionary
- Leave StartMigrationAsync, ResumeMigrationAsync, RollbackMigrationAsync, DoubleEncryptAsync, DecryptFromEnvelopeAsync as abstract (require encryption strategy access)
- Intelligence socket: DeclaredCapabilities with category Security/subcategory CryptoAgility
- Override GetMetadata with migration counts, active algorithms, deprecated count

Import IPlugin from DataWarehouse.SDK.Contracts.Hierarchy. Use FeaturePluginBase as base (crypto agility is a feature, not storage).
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` -- 0 errors</verify>
  <done>ICryptoAgilityEngine defines 10 operations for migration lifecycle. CryptoAgilityEngineBase provides concrete plan management and abstract migration execution methods.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors
- PqcAlgorithmRegistry has entries for all 10 PQC algorithms
- ICryptoAgilityEngine supports double-encryption transition
- Migration lifecycle: NotStarted -> Assessment -> DoubleEncryption -> Verification -> CutOver -> Cleanup -> Complete
</verification>

<success_criteria>
SDK compiles. Crypto-agility contracts complete. Algorithm registry has accurate FIPS 203/204/205 references. Double-encryption envelope supports zero-downtime transitions.
</success_criteria>

<output>
After completion, create `.planning/phases/59-crypto-timelocks/59-03-SUMMARY.md`
</output>
