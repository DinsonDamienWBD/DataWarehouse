---
phase: 59-crypto-timelocks
plan: 07
type: execute
wave: 3
depends_on: ["59-03", "59-04", "59-05", "59-06"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/CryptoAgilityEngine.cs
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/DoubleEncryptionService.cs
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/MigrationWorker.cs
autonomous: true

must_haves:
  truths:
    - "Crypto-agility engine creates and executes migration plans between algorithms"
    - "Double-encryption service encrypts objects with both source and target algorithm during transition"
    - "Migration worker processes batches of objects, re-encrypting from classical to PQC algorithms"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/CryptoAgilityEngine.cs"
      provides: "CryptoAgilityEngine extending CryptoAgilityEngineBase"
      min_lines: 250
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/DoubleEncryptionService.cs"
      provides: "DoubleEncryptionService for zero-downtime transitions"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/MigrationWorker.cs"
      provides: "MigrationWorker for batch re-encryption"
      min_lines: 200
  key_links:
    - from: "CryptoAgilityEngine"
      to: "CryptoAgilityEngineBase"
      via: "extends SDK base class"
      pattern: "class CryptoAgilityEngine.*CryptoAgilityEngineBase"
    - from: "CryptoAgilityEngine"
      to: "DoubleEncryptionService"
      via: "delegates double-encrypt operations"
      pattern: "DoubleEncryptionService"
    - from: "CryptoAgilityEngine"
      to: "MigrationWorker"
      via: "dispatches migration batches"
      pattern: "MigrationWorker"
    - from: "MigrationWorker"
      to: "encryption.encrypt"
      via: "delegates to encryption bus topic for re-encryption"
      pattern: "encryption\\.encrypt"
---

<objective>
Implement the crypto-agility engine with double-encryption and migration worker.

Purpose: The crypto-agility engine orchestrates zero-downtime migration from classical to post-quantum algorithms. During transition, objects are double-encrypted (both old and new algorithm) so readers using either algorithm can decrypt. The migration worker processes objects in batches with configurable concurrency, failure thresholds, and rollback support. This is the core PQC migration capability.

Output: Three production-ready classes in UltimateEncryption/CryptoAgility/ directory.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/59-crypto-timelocks/59-03-SUMMARY.md
@.planning/phases/59-crypto-timelocks/59-04-SUMMARY.md
@DataWarehouse.SDK/Contracts/Encryption/ICryptoAgilityEngine.cs
@DataWarehouse.SDK/Contracts/Encryption/CryptoAgilityTypes.cs
@DataWarehouse.SDK/Contracts/Encryption/PqcAlgorithmRegistry.cs
@Plugins/DataWarehouse.Plugins.UltimateEncryption/UltimateEncryptionPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CryptoAgilityEngine</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/CryptoAgilityEngine.cs
  </files>
  <action>
Create CryptoAgilityEngine.cs in namespace DataWarehouse.Plugins.UltimateEncryption.CryptoAgility:

Class `CryptoAgilityEngine : CryptoAgilityEngineBase`:

Plugin metadata: Id="encryption.crypto-agility", Name="Crypto-Agility Engine", Version=5.0.0

Override abstract methods:

StartMigrationAsync:
1. Look up plan in base class ConcurrentDictionary
2. Validate plan is in NotStarted or Paused state
3. Transition to Assessment phase: query PqcAlgorithmRegistry for source/target algorithm details
4. Transition to DoubleEncryption phase: create DoubleEncryptionService, begin double-encrypting new writes
5. Create MigrationWorker for batch processing existing objects
6. Update plan phase and return MigrationStatus
7. Publish migration events to bus topic "encryption.migration.started"

ResumeMigrationAsync:
1. Validate plan exists and is Paused
2. Resume MigrationWorker
3. Publish "encryption.migration.resumed"

RollbackMigrationAsync:
1. Validate plan exists and is not Complete
2. Stop MigrationWorker
3. Remove double-encryption for new writes
4. Re-encrypt migrated objects back to source algorithm
5. Set phase to RolledBack
6. Publish "encryption.migration.rolledback"

DoubleEncryptAsync:
1. Delegate to DoubleEncryptionService.EncryptAsync
2. Return DoubleEncryptionEnvelope

DecryptFromEnvelopeAsync:
1. Try preferred algorithm first
2. Fall back to other algorithm in envelope
3. Return decrypted plaintext

Internal: Use SemaphoreSlim for concurrent migration limit. Use CancellationTokenSource for pause/cancel. Store MigrationWorker instances in ConcurrentDictionary<string, MigrationWorker>.

Bus topics: encryption.migration.started, encryption.migration.completed, encryption.migration.failed, encryption.migration.progress, encryption.migration.rolledback
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj --no-restore` -- 0 errors</verify>
  <done>CryptoAgilityEngine implements full migration lifecycle with start/pause/resume/rollback, double-encryption orchestration, and bus event publishing.</done>
</task>

<task type="auto">
  <name>Task 2: Implement DoubleEncryptionService and MigrationWorker</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/DoubleEncryptionService.cs
    Plugins/DataWarehouse.Plugins.UltimateEncryption/CryptoAgility/MigrationWorker.cs
  </files>
  <action>
DoubleEncryptionService.cs in namespace DataWarehouse.Plugins.UltimateEncryption.CryptoAgility:

- Constructor takes IMessageBus (for delegating to encryption strategies via bus)
- `EncryptAsync(Guid objectId, byte[] plaintext, string primaryAlgorithmId, string secondaryAlgorithmId, CancellationToken ct)`:
  1. Publish encrypt request to bus for primary algorithm: topic "encryption.encrypt" with payload {algorithmId, plaintext}
  2. Publish encrypt request for secondary algorithm
  3. Build DoubleEncryptionEnvelope with both ciphertexts, timestamps, metadata
  4. Return envelope
- `DecryptAsync(DoubleEncryptionEnvelope envelope, string preferredAlgorithmId, CancellationToken ct)`:
  1. Determine which ciphertext matches preferred algorithm
  2. Publish decrypt request to bus
  3. Return plaintext
  4. If preferred fails, try the other algorithm
- `RemoveSecondaryEncryptionAsync(DoubleEncryptionEnvelope envelope, string algorithmToKeep, CancellationToken ct)`:
  1. Decrypt from envelope
  2. Re-encrypt with only the kept algorithm
  3. Return single-algorithm ciphertext
- All secrets zeroed in finally blocks

MigrationWorker.cs in same namespace:

- Constructor takes MigrationPlan, DoubleEncryptionService, IMessageBus, MigrationOptions
- Internal Channel<MigrationBatch> for batch processing
- `StartAsync(CancellationToken ct)`: Begin processing batches from channel
- `EnqueueBatchAsync(MigrationBatch batch)`: Add batch to channel
- `PauseAsync()`: Stop reading from channel (does not discard pending)
- `ResumeAsync()`: Continue reading
- `GetProgressAsync()`: Return MigrationStatus with counts

Batch processing loop:
1. Read batch from channel
2. For each objectId in batch: decrypt with source algorithm, encrypt with target algorithm
3. If UseDoubleEncryption: create DoubleEncryptionEnvelope instead of direct re-encrypt
4. Track success/failure counts
5. If failure rate > RollbackOnFailureThreshold: stop and signal rollback
6. Publish progress to "encryption.migration.progress" every N objects (configurable, default 100)
7. Use SemaphoreSlim to limit concurrent re-encryptions to MaxConcurrentMigrations

Use `Channel.CreateBounded<MigrationBatch>(new BoundedChannelOptions(100) { FullMode = BoundedChannelFullMode.Wait })` for backpressure.

Both classes: production-ready, no stubs, proper disposal of resources, XML docs.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj --no-restore` -- 0 errors</verify>
  <done>DoubleEncryptionService handles encrypt/decrypt with dual algorithms. MigrationWorker processes batches with concurrency control, failure thresholds, and rollback signaling.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateEncryption/DataWarehouse.Plugins.UltimateEncryption.csproj` -- 0 errors
- CryptoAgilityEngine extends CryptoAgilityEngineBase
- DoubleEncryptionService handles dual-algorithm encrypt/decrypt
- MigrationWorker uses Channel for batch processing with backpressure
- All bus topics follow encryption.migration.* pattern
</verification>

<success_criteria>
Crypto-agility engine compiles. Migration lifecycle works: create plan -> start -> double-encrypt -> migrate batches -> cut over -> cleanup. Rollback supported at any phase. No stubs.
</success_criteria>

<output>
After completion, create `.planning/phases/59-crypto-timelocks/59-07-SUMMARY.md`
</output>
