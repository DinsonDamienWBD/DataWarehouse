---
phase: 40-large-implementations
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthProbe.cs
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/LinkClassifier.cs
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/SyncParameterAdjuster.cs
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/SyncPriorityQueue.cs
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthAwareSyncMonitor.cs
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthModels.cs
  - Plugins/DataWarehouse.Plugins.AdaptiveTransport/AdaptiveTransportPlugin.cs
autonomous: true

must_haves:
  truths:
    - "BandwidthProbe measures real link bandwidth using TCP window analysis and active probing"
    - "LinkClassifier categorizes connections as fiber/broadband/mobile/satellite/intermittent within 5 seconds"
    - "SyncParameterAdjuster sets full-replication for fiber, delta-only for satellite, store-and-forward for intermittent"
    - "SyncPriorityQueue orders pending sync operations by configurable priority class"
    - "BandwidthAwareSyncMonitor continuously monitors and reacts to link quality changes within 5 seconds"
    - "AdaptiveTransportPlugin exposes bandwidth monitoring via transport.bandwidth.* message commands"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthAwareSyncMonitor.cs"
      provides: "Central monitor orchestrating probing, classification, parameter adjustment, and priority queue"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthProbe.cs"
      provides: "Active and passive bandwidth measurement with TCP window analysis"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/LinkClassifier.cs"
      provides: "Real-time link classification with hysteresis to prevent flapping"
      min_lines: 80
    - path: "Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/SyncParameterAdjuster.cs"
      provides: "Dynamic sync parameter selection based on link class"
      min_lines: 80
    - path: "Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/SyncPriorityQueue.cs"
      provides: "Thread-safe priority queue for sync operations with configurable priority classes"
      min_lines: 80
  key_links:
    - from: "BandwidthAwareSyncMonitor"
      to: "BandwidthProbe"
      via: "Monitor triggers periodic bandwidth measurements"
      pattern: "_probe\\.Measure|BandwidthProbe"
    - from: "BandwidthAwareSyncMonitor"
      to: "LinkClassifier"
      via: "Monitor classifies measured bandwidth into link categories"
      pattern: "_classifier\\.Classify|LinkClassifier"
    - from: "BandwidthAwareSyncMonitor"
      to: "SyncParameterAdjuster"
      via: "Monitor adjusts sync parameters when link class changes"
      pattern: "_adjuster\\.GetParameters|SyncParameterAdjuster"
    - from: "AdaptiveTransportPlugin"
      to: "BandwidthAwareSyncMonitor"
      via: "Plugin creates and manages the bandwidth monitor lifecycle"
      pattern: "_bandwidthMonitor|BandwidthAwareSyncMonitor"
---

<objective>
Build a real-time bandwidth-aware sync monitor that measures link quality, classifies connections, and dynamically adjusts edge sync parameters. Wire it into the existing AdaptiveTransportPlugin.

Purpose: IMPL-10 requires a bandwidth monitor that can detect link quality changes within 5 seconds and adjust sync behavior accordingly (fiber gets full replication, satellite gets delta-compressed summaries, intermittent links use store-and-forward). The AdaptiveTransportPlugin already has NetworkQualityMetrics and protocol switching, but lacks the sync parameter adjustment layer. This plan builds the missing monitor subsystem and integrates it.

Output: A BandwidthAwareSyncMonitor with probe, classifier, parameter adjuster, and priority queue. Integrated into AdaptiveTransportPlugin via message bus commands and wired into the existing network quality monitoring infrastructure.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/40-large-implementations/41-RESEARCH.md
@Plugins/DataWarehouse.Plugins.AdaptiveTransport/AdaptiveTransportPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Bandwidth Monitor Components (Probe, Classifier, Adjuster, Queue)</name>
  <files>
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthModels.cs
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthProbe.cs
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/LinkClassifier.cs
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/SyncParameterAdjuster.cs
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/SyncPriorityQueue.cs
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/BandwidthAwareSyncMonitor.cs
  </files>
  <action>
    Create `Plugins/DataWarehouse.Plugins.AdaptiveTransport/BandwidthMonitor/` directory with all bandwidth monitoring components. All classes in namespace `DataWarehouse.Plugins.AdaptiveTransport.BandwidthMonitor`.

    **BandwidthModels.cs** (~80 lines):
    - `public enum LinkClass { Fiber, Broadband, Mobile, Satellite, Intermittent, Unknown }`
    - `public enum SyncMode { FullReplication, FullWithCompression, DeltaOnly, DeltaCompressed, SummaryOnly, StoreAndForward }`
    - `public enum SyncPriority { Critical = 0, SchemaChange = 1, HighPriority = 2, Normal = 3, Analytics = 4, Background = 5 }`
    - `public sealed record BandwidthMeasurement(double BandwidthMbps, double LatencyMs, double JitterMs, double PacketLossPercent, DateTime MeasuredAt, MeasurementMethod Method);`
    - `public enum MeasurementMethod { ActiveProbe, PassiveTcpWindow, Both }`
    - `public sealed record LinkStatus(LinkClass Classification, BandwidthMeasurement LatestMeasurement, DateTime ClassifiedAt, int ConsecutiveSamples);`
    - `public sealed record SyncParameters(SyncMode Mode, bool EnableCompression, int MaxChunkSizeBytes, TimeSpan SyncInterval, int MaxConcurrentSyncs, bool EnablePriorityQueue);`
    - `public sealed record SyncOperation(string OperationId, string TargetEndpoint, SyncPriority Priority, long DataSizeBytes, DateTime QueuedAt, byte[]? Data, string? Description);`
    - `public sealed record BandwidthMonitorConfig(TimeSpan ProbeInterval = default, TimeSpan ClassificationWindow = default, int MinSamplesForClassification = 3, double HysteresisFactorPercent = 20.0, bool EnableActiveProbing = true, bool EnablePassiveMonitoring = true);`
      - Defaults: ProbeInterval = 5 seconds, ClassificationWindow = 30 seconds.

    **BandwidthProbe.cs** (~130 lines):
    - `public sealed class BandwidthProbe`.
    - Two measurement methods:

    1. **Active probing** (`MeasureActiveAsync`):
       - Send a known-size TCP payload (e.g., 64KB) to the target endpoint.
       - Measure round-trip time.
       - Bandwidth = payload_size / time.
       - Repeat 3 times, take median for robustness.
       - Use `System.Net.Sockets.TcpClient` or `System.Net.Http.HttpClient` (prefer HTTP HEAD/POST to a well-known endpoint).
       - Measure latency via separate small packet (64 bytes).
       - Jitter = standard deviation of latency samples.
       - Packet loss: send 10 UDP packets, count received (approximation).

    2. **Passive monitoring** (`MeasurePassiveAsync`):
       - Leverage existing `NetworkQualityMetrics` from AdaptiveTransportPlugin (the plugin already monitors latency, bandwidth, jitter, packet loss).
       - Convert `NetworkQualityMetrics` to `BandwidthMeasurement`.
       - This is the low-overhead option -- no extra traffic generated.

    3. `Task<BandwidthMeasurement> MeasureAsync(string endpoint, MeasurementMethod method, CancellationToken ct)`:
       - Route to active or passive based on method.
       - For `Both`: run active, validate against passive, return active (more accurate).
       - Handle network errors gracefully: timeout after 5 seconds, return last known measurement on failure.

    IMPORTANT: The active probe should be lightweight. Don't send GB of data. 64KB is sufficient for bandwidth estimation in the Mbps range. For very high bandwidth (>1Gbps), increase probe size to 1MB.

    **LinkClassifier.cs** (~100 lines):
    - `public sealed class LinkClassifier`.
    - Constructor takes `BandwidthMonitorConfig config`.
    - Classification thresholds (configurable but with sensible defaults):
      - Fiber: > 100 Mbps, latency < 10ms
      - Broadband: 10-100 Mbps, latency < 50ms
      - Mobile: 1-10 Mbps, latency < 200ms
      - Satellite: < 1 Mbps OR latency > 500ms
      - Intermittent: packet loss > 20% OR unable to measure for > 2 consecutive intervals
      - Unknown: insufficient data (< MinSamplesForClassification)
    - `LinkStatus Classify(IReadOnlyList<BandwidthMeasurement> recentMeasurements)`:
      - Use median of recent measurements (within ClassificationWindow) for classification.
      - Hysteresis: don't change classification unless the new class is sustained for `MinSamplesForClassification` consecutive measurements AND the bandwidth differs by more than `HysteresisFactorPercent` from the threshold. This prevents flapping between classes.
    - Private state: `LinkClass _currentClass`, `int _consecutiveNewClassSamples`.
    - `event EventHandler<LinkClassChangedEventArgs>? LinkClassChanged` -- fired when classification changes (after hysteresis).
    - `public sealed class LinkClassChangedEventArgs(LinkClass OldClass, LinkClass NewClass, BandwidthMeasurement Trigger) : EventArgs;`

    **SyncParameterAdjuster.cs** (~100 lines):
    - `public sealed class SyncParameterAdjuster`.
    - `SyncParameters GetParameters(LinkClass linkClass)`:
      - Returns optimal sync parameters for the given link class:
      - **Fiber** (>100 Mbps): SyncMode.FullReplication, no compression (bandwidth is cheap), 16MB chunks, 1s interval, 10 concurrent, no priority queue needed.
      - **Broadband** (10-100 Mbps): SyncMode.FullWithCompression, enable compression, 4MB chunks, 5s interval, 5 concurrent, no priority queue.
      - **Mobile** (1-10 Mbps): SyncMode.DeltaOnly, enable compression, 256KB chunks, 30s interval, 2 concurrent, enable priority queue.
      - **Satellite** (<1 Mbps): SyncMode.DeltaCompressed, enable compression, 64KB chunks, 60s interval, 1 concurrent, enable priority queue, summaries only for non-critical data.
      - **Intermittent**: SyncMode.StoreAndForward, enable compression, 32KB chunks, best-effort interval, 1 concurrent, enable priority queue, queue all operations.
      - **Unknown**: SyncMode.DeltaCompressed (safe default), enable compression, 128KB chunks, 30s interval, 2 concurrent, enable priority queue.
    - `SyncParameters Interpolate(LinkClass linkClass, double actualBandwidthMbps)`:
      - Fine-tune parameters within a class based on actual bandwidth.
      - E.g., broadband at 90Mbps gets larger chunks than broadband at 15Mbps.
      - Linear interpolation of chunk size and concurrent connections within class range.
    - Parameters are configurable via `SyncParameterProfile` dictionary (override defaults for specific environments).

    **SyncPriorityQueue.cs** (~100 lines):
    - `public sealed class SyncPriorityQueue`.
    - Thread-safe priority queue for sync operations.
    - Uses `PriorityQueue<SyncOperation, int>` (.NET 6+) wrapped with `SemaphoreSlim` for thread safety.
    - `void Enqueue(SyncOperation operation)` -- add operation at its priority level.
    - `SyncOperation? Dequeue()` -- get highest priority (lowest number) operation.
    - `SyncOperation? Peek()` -- peek without removing.
    - `int Count` -- total queued operations.
    - `long TotalQueuedBytes` -- sum of DataSizeBytes for all queued operations.
    - `void PurgeExpired(TimeSpan maxAge)` -- remove operations older than maxAge (prevent queue bloat).
    - `IReadOnlyList<SyncOperation> GetByPriority(SyncPriority priority)` -- list operations at specific priority.
    - Bounded capacity: configurable max queue size (default 10,000), reject lowest priority when full.
    - `event EventHandler<SyncOperation>? OperationDropped` -- fired when operation rejected due to capacity.

    **BandwidthAwareSyncMonitor.cs** (~200 lines):
    - `public sealed class BandwidthAwareSyncMonitor : IAsyncDisposable`.
    - Orchestrates BandwidthProbe, LinkClassifier, SyncParameterAdjuster, SyncPriorityQueue.
    - Constructor takes `BandwidthMonitorConfig config, string targetEndpoint`.
    - Private: `Timer _probeTimer`, `BandwidthProbe _probe`, `LinkClassifier _classifier`, `SyncParameterAdjuster _adjuster`, `SyncPriorityQueue _queue`, `List<BandwidthMeasurement> _measurementHistory`.

    - `Task StartAsync(CancellationToken ct)`:
      - Start periodic probing at `config.ProbeInterval` (default 5s).
      - On each probe: measure bandwidth, add to history, classify, adjust parameters if class changed.
      - Subscribe to `_classifier.LinkClassChanged` to trigger parameter adjustment.

    - `Task StopAsync()`:
      - Stop probe timer, flush queue.

    - `SyncParameters CurrentParameters` -- current sync parameters based on latest classification.
    - `LinkStatus CurrentLinkStatus` -- latest link classification with measurement.
    - `BandwidthMeasurement? LatestMeasurement` -- most recent probe result.

    - `void QueueSync(SyncOperation operation)`:
      - If current parameters have `EnablePriorityQueue`, add to queue.
      - Otherwise, operations are processed immediately (caller responsibility).

    - `SyncOperation? GetNextSync()`:
      - Dequeue highest priority operation respecting current sync parameters (chunk size, concurrency).

    - `IReadOnlyList<BandwidthMeasurement> GetHistory(TimeSpan window)`:
      - Return measurements within the time window.

    - `event EventHandler<LinkClassChangedEventArgs>? LinkClassChanged`:
      - Proxy from classifier for external subscribers.

    - `event EventHandler<SyncParameters>? ParametersChanged`:
      - Fired when sync parameters change due to link class change.

    - Internal probe loop:
      ```
      async void OnProbeTimer()
        measurement = await _probe.MeasureAsync(endpoint, method, ct)
        _measurementHistory.Add(measurement)
        Trim history to ClassificationWindow
        linkStatus = _classifier.Classify(recent measurements)
        if linkStatus changed:
          newParams = _adjuster.GetParameters(linkStatus.Classification)
          CurrentParameters = newParams
          ParametersChanged?.Invoke(newParams)
        _queue.PurgeExpired(maxAge)
      ```

    CRITICAL: No external NuGet dependencies. Use System.Net.Sockets for TCP probing, System.Net.Http for HTTP-based probing. Leverage existing AdaptiveTransportPlugin.NetworkQualityMetrics for passive monitoring.

    CRITICAL (Rule 13): Real bandwidth measurement logic. Real hysteresis in classification. Real priority queue with bounded capacity. No stubs or placeholders.
  </action>
  <verify>
    `dotnet build Plugins/DataWarehouse.Plugins.AdaptiveTransport/DataWarehouse.Plugins.AdaptiveTransport.csproj` compiles with zero new errors. Verify all 6 files exist in BandwidthMonitor directory. Grep for `NotImplementedException` in BandwidthMonitor directory -- zero matches. Grep for `LinkClass.Fiber` in SyncParameterAdjuster.cs -- confirms classification-based parameter selection.
  </verify>
  <done>
    All 6 bandwidth monitor components implemented: BandwidthProbe (active TCP probing + passive monitoring), LinkClassifier (5 classes with hysteresis), SyncParameterAdjuster (class-specific sync parameters), SyncPriorityQueue (thread-safe bounded priority queue), BandwidthAwareSyncMonitor (orchestrator with periodic probing and event-driven adjustment). Detection within 5 seconds of link change via configurable probe interval.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate BandwidthAwareSyncMonitor into AdaptiveTransportPlugin</name>
  <files>
    Plugins/DataWarehouse.Plugins.AdaptiveTransport/AdaptiveTransportPlugin.cs
  </files>
  <action>
    Wire BandwidthAwareSyncMonitor into the existing AdaptiveTransportPlugin.

    Read AdaptiveTransportPlugin.cs first to understand current structure. The plugin already has:
    - `_endpointMetrics` (ConcurrentDictionary of NetworkQualityMetrics per endpoint)
    - `_qualityMonitorTimer` (periodic network quality monitoring)
    - `MeasureNetworkQualityAsync(endpoint)` method returning NetworkQualityMetrics
    - `MonitorNetworkQualityAsync()` periodic check method
    - Message handlers for `transport.send`, `transport.quality`, `transport.switch`, `transport.config`, `transport.stats`

    Modifications:

    1. Add private field:
       `private BandwidthAwareSyncMonitor? _bandwidthMonitor;`
       `private readonly ConcurrentDictionary<string, BandwidthAwareSyncMonitor> _endpointMonitors = new();`

    2. Add `using DataWarehouse.Plugins.AdaptiveTransport.BandwidthMonitor;` at top.

    3. In `StartAsync(CancellationToken ct)`, after existing initialization:
       - Create a default BandwidthAwareSyncMonitor with the primary endpoint (if configured).
       - Subscribe to `ParametersChanged` to log sync parameter changes.

    4. In `StopAsync()`:
       - Dispose all endpoint monitors.

    5. Add new message handlers in `OnMessageAsync`:
       - `"transport.bandwidth.measure"`: Trigger immediate bandwidth measurement for specified endpoint. Return BandwidthMeasurement.
       - `"transport.bandwidth.status"`: Return current LinkStatus and SyncParameters for an endpoint.
       - `"transport.bandwidth.history"`: Return bandwidth measurement history for specified window.
       - `"transport.bandwidth.sync.queue"`: Enqueue a sync operation at specified priority.
       - `"transport.bandwidth.sync.next"`: Dequeue next sync operation.
       - `"transport.bandwidth.monitor.start"`: Start monitoring a specific endpoint with custom config.
       - `"transport.bandwidth.monitor.stop"`: Stop monitoring an endpoint.

    6. Bridge existing NetworkQualityMetrics to BandwidthProbe passive monitoring:
       - In `MonitorNetworkQualityAsync()`, after updating `_endpointMetrics`, feed the metrics to any active BandwidthAwareSyncMonitor for that endpoint.
       - This reuses the existing quality monitoring infrastructure for passive bandwidth measurement.

    7. Add to `GetMetadata()`:
       - `metadata["BandwidthMonitors"] = _endpointMonitors.Count;`
       - `metadata["CurrentSyncMode"]` for primary endpoint if monitor exists.

    8. Add to `GetCapabilities()`:
       - New capability: `new() { Name = "transport.bandwidth", DisplayName = "Bandwidth Monitor", Description = "Real-time bandwidth monitoring and adaptive sync" }`.

    IMPORTANT: Do NOT break or modify existing message handlers. Only ADD new cases to the switch statement. Do NOT change the constructor signature. Do NOT modify the existing `MeasureNetworkQualityAsync` method. Only EXTEND.

    The bridge between existing NetworkQualityMetrics and BandwidthMeasurement is key: `NetworkQualityMetrics` already has latency, jitter, packet loss, estimated bandwidth. Convert to `BandwidthMeasurement` to feed into the classifier without duplicating measurement work.
  </action>
  <verify>
    `dotnet build Plugins/DataWarehouse.Plugins.AdaptiveTransport/DataWarehouse.Plugins.AdaptiveTransport.csproj` compiles with zero new errors. Grep for `_bandwidthMonitor` or `BandwidthAwareSyncMonitor` in AdaptiveTransportPlugin.cs -- must find references. Grep for `"transport.bandwidth."` -- must find at least 3 message handler cases. Verify existing message handlers still exist: grep for `"transport.send"`, `"transport.quality"` -- must still be present (not broken).
  </verify>
  <done>
    AdaptiveTransportPlugin extended with BandwidthAwareSyncMonitor integration. New message commands: transport.bandwidth.measure, transport.bandwidth.status, transport.bandwidth.history, transport.bandwidth.sync.queue, transport.bandwidth.sync.next, transport.bandwidth.monitor.start/stop. Existing NetworkQualityMetrics bridged to passive bandwidth monitoring. All existing functionality preserved (transport.send, transport.quality, transport.switch, transport.config, transport.stats unchanged).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.AdaptiveTransport/DataWarehouse.Plugins.AdaptiveTransport.csproj` -- zero new errors
2. Grep all BandwidthMonitor files for `NotImplementedException` -- zero matches
3. Grep AdaptiveTransportPlugin.cs for `"transport.send"` -- still present (existing handler not broken)
4. Grep AdaptiveTransportPlugin.cs for `"transport.bandwidth."` -- at least 3 matches (new handlers)
5. Grep LinkClassifier.cs for `Fiber.*100|Broadband.*10` -- confirms real threshold logic
6. File count in BandwidthMonitor directory -- exactly 6 files
7. Total new LOC -- approximately 700-1,000 lines
</verification>

<success_criteria>
- BandwidthProbe measures real bandwidth via active TCP probing and passive metric observation
- LinkClassifier categorizes connections into 5 classes (fiber/broadband/mobile/satellite/intermittent) with hysteresis to prevent flapping
- SyncParameterAdjuster maps each link class to specific sync parameters (mode, compression, chunk size, interval, concurrency)
- SyncPriorityQueue provides thread-safe bounded priority queue for sync operations
- BandwidthAwareSyncMonitor detects link quality changes within 5 seconds (configurable probe interval)
- AdaptiveTransportPlugin exposes bandwidth monitoring via transport.bandwidth.* message commands
- Existing AdaptiveTransport functionality fully preserved (zero regression)
- Bridge between existing NetworkQualityMetrics and new BandwidthMeasurement avoids duplicate probing
- Zero external NuGet dependencies
- Zero stubs (Rule 13)
</success_criteria>

<output>
After completion, create `.planning/phases/40-large-implementations/41-04-SUMMARY.md`
</output>
