---
phase: 40-large-implementations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/ExascaleMetadataStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/MemTable.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/SSTable.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/SSTableWriter.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/SSTableReader.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/BloomFilter.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/CompactionManager.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/LsmTreeEngine.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/WalWriter.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/ByteArrayComparer.cs
  - Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/MetadataPartitioner.cs
autonomous: true

must_haves:
  truths:
    - "ExascaleMetadataStrategy.StoreAsyncCore persists data to LSM-Tree and returns real metadata"
    - "ExascaleMetadataStrategy.RetrieveAsyncCore returns the actual data previously stored"
    - "ExascaleMetadataStrategy.ListAsyncCore returns real metadata entries matching prefix"
    - "ExascaleMetadataStrategy.DeleteAsyncCore removes data from the LSM-Tree"
    - "LSM-Tree provides O(log n) lookup performance at scale"
    - "BloomFilter provides fast negative lookups to avoid unnecessary disk reads"
    - "Compaction merges SSTables to bound disk amplification"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/LsmTreeEngine.cs"
      provides: "Core LSM-Tree engine orchestrating MemTable, WAL, SSTables, compaction"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/MemTable.cs"
      provides: "In-memory sorted write buffer with concurrent read/write access"
      min_lines: 80
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/SSTable.cs"
      provides: "Immutable on-disk sorted string table with index and data blocks"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/BloomFilter.cs"
      provides: "Probabilistic membership test for fast negative lookups"
      min_lines: 60
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/CompactionManager.cs"
      provides: "Background SSTable merge with leveled compaction strategy"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/ExascaleMetadataStrategy.cs"
      provides: "Fully implemented storage strategy using LSM-Tree engine"
      min_lines: 60
  key_links:
    - from: "ExascaleMetadataStrategy"
      to: "LsmTreeEngine"
      via: "Strategy delegates all CRUD to LSM-Tree engine instance"
      pattern: "_lsmTree\\.(Put|Get|Delete|Scan)"
    - from: "LsmTreeEngine"
      to: "MemTable"
      via: "Writes go to MemTable first, flush to SSTable when full"
      pattern: "_memTable\\.Put|_memTable\\.Get"
    - from: "LsmTreeEngine"
      to: "SSTable"
      via: "Reads check MemTable then SSTables newest-to-oldest"
      pattern: "SSTableReader|_sstables"
    - from: "LsmTreeEngine"
      to: "BloomFilter"
      via: "Check bloom filter before reading SSTable to skip negative lookups"
      pattern: "_bloomFilter\\.MayContain|BloomFilter"
    - from: "LsmTreeEngine"
      to: "CompactionManager"
      via: "Background compaction merges SSTables to bound read amplification"
      pattern: "_compactionManager|CompactionManager"
---

<objective>
Build a production-ready LSM-Tree (Log-Structured Merge Tree) metadata engine and wire it into the existing ExascaleMetadataStrategy stub, replacing all no-op methods with real distributed metadata storage.

Purpose: IMPL-07 requires a metadata store capable of O(log n) operations at 10^15 object scale. The existing ExascaleMetadataStrategy is a complete stub that returns empty MemoryStreams and fake metadata. This plan builds the entire LSM-Tree data structure from scratch using .NET BCL only (no external dependencies), then integrates it as the backing store for the strategy.

Output: A fully functional LSM-Tree engine with MemTable, WAL, SSTables, Bloom filters, and leveled compaction. ExascaleMetadataStrategy performs real Store/Retrieve/List/Delete/Exists operations against this engine.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/40-large-implementations/41-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/ExascaleMetadataStrategy.cs
@Plugins/DataWarehouse.Plugins.UltimateStorage/StorageStrategyBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build LSM-Tree Engine Core (MemTable, WAL, SSTable, BloomFilter)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/ByteArrayComparer.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/MemTable.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/WalWriter.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/SSTable.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/SSTableWriter.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/SSTableReader.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/BloomFilter.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/CompactionManager.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/MetadataPartitioner.cs
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/LsmTreeEngine.cs
  </files>
  <action>
    Create the `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/LsmTree/` directory with all LSM-Tree components. All classes in namespace `DataWarehouse.Plugins.UltimateStorage.Strategies.Scale.LsmTree`.

    **ByteArrayComparer.cs** (~30 lines):
    - `internal sealed class ByteArrayComparer : IComparer<byte[]>` implementing lexicographic byte comparison.
    - Static `Instance` singleton.
    - Also implement `IEqualityComparer<byte[]>` for dictionary usage (GetHashCode via XxHash32 or simple byte hash).

    **MemTable.cs** (~120 lines):
    - `internal sealed class MemTable` using `SortedList<byte[], byte[]>` with `ByteArrayComparer.Instance`.
    - `ReaderWriterLockSlim` for concurrent read/write access.
    - `Put(byte[] key, byte[] value)` -- insert/update, track approximate size.
    - `Get(byte[] key) -> byte[]?` -- point lookup.
    - `Delete(byte[] key)` -- insert tombstone marker (empty byte array or special sentinel).
    - `bool ShouldFlush` -- true when approximate size >= configurable threshold (default 64MB).
    - `IEnumerable<KeyValuePair<byte[], byte[]>> GetSortedEntries()` -- snapshot for flushing.
    - `void Clear()` -- reset after flush.
    - Tombstone sentinel: `public static readonly byte[] Tombstone = new byte[] { 0xFF, 0xDE, 0xAD };`

    **WalWriter.cs** (~100 lines):
    - `internal sealed class WalWriter : IDisposable` wrapping a `FileStream`.
    - Constructor takes directory path, creates WAL file with monotonic sequence number.
    - `AppendAsync(byte[] key, byte[] value, WalEntryType type)` -- write length-prefixed entries with CRC32 checksum.
    - `WalEntryType` enum: Put, Delete.
    - Entry format: [4-byte key length][key bytes][4-byte value length][value bytes][1-byte type][4-byte CRC32].
    - `FlushAsync()` -- flush to disk.
    - `static IEnumerable<WalEntry> Replay(string walFilePath)` -- replay entries from WAL file for crash recovery.
    - `void MarkComplete()` -- rename/delete WAL file after successful SSTable flush.

    **SSTable.cs** (~50 lines):
    - `internal sealed record SSTableInfo(string FilePath, int Level, long SequenceNumber, byte[] MinKey, byte[] MaxKey, long EntryCount);`
    - Data structures for SSTable file format.

    **SSTableWriter.cs** (~150 lines):
    - `internal sealed class SSTableWriter : IDisposable`.
    - Writes sorted key-value pairs to an SSTable file with index block.
    - SSTable file format: [Data Block: length-prefixed KV pairs] [Index Block: sampled keys with offsets every N entries] [Footer: index offset, entry count, min/max key, bloom filter bytes].
    - `WriteAsync(IEnumerable<KeyValuePair<byte[], byte[]>> sortedEntries)` -- writes all entries.
    - Builds BloomFilter during write.
    - Returns `SSTableInfo` after completion.

    **SSTableReader.cs** (~150 lines):
    - `internal sealed class SSTableReader : IDisposable`.
    - Reads SSTable file, loads index block and bloom filter into memory.
    - `byte[]? Get(byte[] key)` -- binary search index block, then scan data block. Check bloom filter first.
    - `IEnumerable<KeyValuePair<byte[], byte[]>> Scan(byte[]? startKey, byte[]? endKey)` -- range scan.
    - `BloomFilter LoadedBloomFilter` -- loaded from footer.
    - Index kept in memory, data blocks read on demand from disk.

    **BloomFilter.cs** (~80 lines):
    - `internal sealed class BloomFilter`.
    - Constructor takes expected element count and false positive rate (default 1%).
    - Bit array size: `m = -n * ln(p) / (ln(2)^2)`.
    - Hash count: `k = (m/n) * ln(2)`.
    - Use MurmurHash3-style double hashing: `hash_i = hash1 + i * hash2`.
    - `void Add(byte[] key)` -- set k bits.
    - `bool MayContain(byte[] key)` -- check k bits. False = definitely absent, true = possibly present.
    - `byte[] Serialize()` / `static BloomFilter Deserialize(byte[] data)` for SSTable embedding.

    **CompactionManager.cs** (~150 lines):
    - `internal sealed class CompactionManager`.
    - Leveled compaction strategy (like RocksDB/LevelDB):
      - Level 0: direct flush from MemTable (may overlap)
      - Level 1+: non-overlapping, sorted runs, size increases by factor of 10 per level
    - `void RegisterSSTable(SSTableInfo info)` -- track tables by level.
    - `Task CompactAsync(CancellationToken ct)` -- check if any level exceeds threshold, merge overlapping tables into next level.
    - Merge: multi-way merge of sorted entries, write new SSTable(s), delete old ones.
    - `IReadOnlyList<SSTableInfo> GetTablesForLevel(int level)`.
    - Thread-safe: compaction runs on background Task, does not block reads/writes.

    **MetadataPartitioner.cs** (~60 lines):
    - `internal sealed class MetadataPartitioner`.
    - Consistent hash ring for partitioning metadata keys across nodes.
    - `int GetPartition(byte[] key, int partitionCount)` -- hash key to partition index.
    - Uses XxHash32 or simple hash for distribution.
    - This is a placeholder for future multi-node distribution; single-node uses partition 0.

    **LsmTreeEngine.cs** (~300 lines):
    - `internal sealed class LsmTreeEngine : IAsyncDisposable`.
    - Orchestrates all components: MemTable, WAL, SSTables, CompactionManager, BloomFilter.
    - Constructor takes `LsmTreeOptions` (directory path, memtable flush threshold, compaction settings).
    - **Write path**: `PutAsync(byte[] key, byte[] value)` -> append to WAL -> insert into MemTable -> if ShouldFlush, flush MemTable to SSTable (background).
    - **Read path**: `GetAsync(byte[] key) -> byte[]?` -> check MemTable -> check SSTables newest-to-oldest (bloom filter first) -> return first match or null.
    - **Delete path**: `DeleteAsync(byte[] key)` -> write tombstone to WAL and MemTable.
    - **Scan path**: `ScanAsync(byte[]? prefix) -> IAsyncEnumerable<KeyValuePair<byte[], byte[]>>` -> merge MemTable entries with SSTable scans, skip tombstones.
    - **Recovery**: On initialization, replay any incomplete WAL files to rebuild MemTable.
    - **Flush**: `FlushMemTableAsync()` -> snapshot MemTable, create new MemTable, write snapshot to SSTable, register with CompactionManager, delete old WAL.
    - **Compaction trigger**: After each flush, check if compaction needed, run in background.
    - All operations use `SemaphoreSlim` for write serialization; reads are lock-free after MemTable snapshot.
    - `LsmTreeOptions` record: `string DataDirectory, long MemTableFlushThresholdBytes = 64 * 1024 * 1024, int Level0CompactionTrigger = 4, int MaxLevels = 7, double LevelSizeMultiplier = 10.0`.

    CRITICAL: No external NuGet dependencies. Use only .NET BCL types (SortedList, ReaderWriterLockSlim, FileStream, BinaryReader/Writer, BitArray, CRC32 from System.IO.Hashing or manual implementation). All math for BloomFilter sizing uses System.Math. All file I/O uses System.IO.

    CRITICAL (Rule 13): Every method must contain real algorithmic logic. No `throw new NotImplementedException()`, no `Task.CompletedTask` stubs, no placeholder comments like "// TODO: implement". Real CRC32 checksums, real bloom filter hashing, real multi-way merge in compaction.
  </action>
  <verify>
    `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj` compiles with zero new errors. Verify all 10 files exist in the LsmTree directory. Grep for `NotImplementedException` in the LsmTree directory -- must return zero matches. Grep for `Task.CompletedTask` in LsmTree directory -- must return zero matches (except in tests if any).
  </verify>
  <done>
    LSM-Tree engine builds successfully. All 10 source files exist with real algorithmic implementations: MemTable with concurrent sorted access, WAL with CRC32 checksummed entries, SSTableWriter/Reader with index blocks, BloomFilter with configurable false-positive rate, CompactionManager with leveled merge, and LsmTreeEngine orchestrating the full write/read/delete/scan path.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire LSM-Tree into ExascaleMetadataStrategy</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/ExascaleMetadataStrategy.cs
  </files>
  <action>
    Replace the stub implementation of ExascaleMetadataStrategy with real logic backed by LsmTreeEngine.

    The existing stub file at `Plugins/DataWarehouse.Plugins.UltimateStorage/Strategies/Scale/ExascaleMetadataStrategy.cs` currently:
    - Returns `new MemoryStream()` from RetrieveAsyncCore
    - Returns `AsyncEnumerable.Empty<StorageObjectMetadata>()` from ListAsyncCore
    - Returns fake metadata from StoreAsyncCore (no actual storage)
    - Returns `true` from ExistsAsyncCore without checking anything

    Replace with:

    1. Add private field: `private LsmTreeEngine? _lsmTree;`

    2. **InitializeCoreAsync**: Create `LsmTreeEngine` with options pointing to a configurable data directory (use `Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "DataWarehouse", "exascale-metadata")`). Call recovery/init on the engine.

    3. **StoreAsyncCore(key, data, metadata, ct)**:
       - Serialize the stream data to byte array (read stream into MemoryStream, get bytes).
       - Serialize metadata dictionary to JSON bytes (System.Text.Json).
       - Create a composite value: [4-byte data length][data bytes][metadata JSON bytes].
       - Call `_lsmTree.PutAsync(Encoding.UTF8.GetBytes(key), compositeValue)`.
       - Return real `StorageObjectMetadata` with actual size, timestamps, key.
       - Keep `IncrementOperationCounter` and `IncrementBytesStored` calls.

    4. **RetrieveAsyncCore(key, ct)**:
       - Call `_lsmTree.GetAsync(Encoding.UTF8.GetBytes(key))`.
       - If null, throw or return empty stream (strategy pattern: return empty MemoryStream with position 0 for not-found, consistent with other strategies).
       - Parse composite value: read first 4 bytes as data length, extract data bytes.
       - Return `new MemoryStream(dataBytes)`.

    5. **DeleteAsyncCore(key, ct)**: Call `_lsmTree.DeleteAsync(Encoding.UTF8.GetBytes(key))`.

    6. **ExistsAsyncCore(key, ct)**: Call `_lsmTree.GetAsync(...)`, return `result != null`.

    7. **ListAsyncCore(prefix, ct)**: Call `_lsmTree.ScanAsync(prefix != null ? Encoding.UTF8.GetBytes(prefix) : null)`. For each entry, deserialize the composite value to extract metadata JSON, yield `StorageObjectMetadata` with real key, size, timestamps from stored metadata.

    8. **GetMetadataAsyncCore(key, ct)**: Similar to Retrieve but only parse the metadata JSON portion, not the data.

    9. **GetHealthAsyncCore**: Return real health based on `_lsmTree` status (initialized, SSTable count, MemTable size).

    10. Override `Dispose(bool disposing)` to dispose `_lsmTree`.

    Keep the existing class signature: `public class ExascaleMetadataStrategy : UltimateStorageStrategyBase`. Keep all existing property overrides (StrategyId, Name, Tier, Capabilities). Only replace method bodies.

    Add `using` for: `System.Text`, `System.Text.Json`, `DataWarehouse.Plugins.UltimateStorage.Strategies.Scale.LsmTree`.
  </action>
  <verify>
    `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj` compiles with zero new errors. Grep ExascaleMetadataStrategy.cs for `new MemoryStream()` used as a return value for RetrieveAsyncCore -- should NOT find the old stub pattern (empty MemoryStream return). Grep for `AsyncEnumerable.Empty` -- must NOT appear. Grep for `_lsmTree` -- must find at least 5 references (one per CRUD method).
  </verify>
  <done>
    ExascaleMetadataStrategy is fully wired to LSM-Tree engine. Store writes real data to LSM-Tree. Retrieve returns actual stored data. List scans with real prefix matching. Delete removes entries via tombstones. Exists checks real presence. Health reflects actual engine state. All operations use real LSM-Tree I/O with WAL durability, SSTable persistence, bloom filter optimization, and background compaction. Zero stubs remain.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.UltimateStorage/DataWarehouse.Plugins.UltimateStorage.csproj` -- zero new errors
2. Grep all files in `Strategies/Scale/LsmTree/` for `NotImplementedException` -- zero matches
3. Grep `ExascaleMetadataStrategy.cs` for `AsyncEnumerable.Empty` -- zero matches (old stub pattern removed)
4. Grep `ExascaleMetadataStrategy.cs` for `_lsmTree` -- 5+ references confirming real wiring
5. File count in `Strategies/Scale/LsmTree/` directory -- exactly 10 files
6. Total new LOC across all files -- approximately 1,200-1,800 lines of real algorithmic code
</verification>

<success_criteria>
- ExascaleMetadataStrategy performs real CRUD operations backed by LSM-Tree engine
- LSM-Tree implements: MemTable (sorted concurrent writes), WAL (crash recovery), SSTables (persistent sorted storage), BloomFilter (negative lookup optimization), leveled compaction (bounded read amplification)
- O(log n) lookup complexity verified by algorithmic design (sorted structures + binary search)
- Zero external NuGet dependencies added
- Zero stubs, mocks, or placeholders in any new code (Rule 13)
- Build compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/40-large-implementations/41-01-SUMMARY.md`
</output>
