---
phase: 40-large-implementations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/KalmanFilter.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/ComplementaryFilter.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/WeightedAverageFusion.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/VotingFusion.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/TemporalAligner.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/MatrixMath.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/SensorFusionEngine.cs
  - Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/SensorFusionModels.cs
  - Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/Strategies/SpecializedStrategies.cs
autonomous: true

must_haves:
  truths:
    - "KalmanFilter produces smoother position estimates than raw GPS by fusing GPS + IMU data"
    - "ComplementaryFilter combines accelerometer and gyroscope for stable orientation"
    - "WeightedAverageFusion combines redundant sensor readings with configurable weights"
    - "VotingFusion detects and excludes faulty sensors via majority voting"
    - "TemporalAligner aligns multi-rate sensors to a common timeline within 1ms"
    - "SensorFusionEngine orchestrates all five algorithms with configurable pipeline"
    - "IoTGatewayStrategy.ProcessSensorDataAsync applies fusion to sensor readings"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/KalmanFilter.cs"
      provides: "Full Kalman filter with predict/update cycle using matrix math"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/ComplementaryFilter.cs"
      provides: "Alpha-weighted high-pass/low-pass filter for IMU fusion"
      min_lines: 60
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/WeightedAverageFusion.cs"
      provides: "Redundant sensor combination with dynamic weights and outlier detection"
      min_lines: 80
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/VotingFusion.cs"
      provides: "Majority voting with Byzantine fault tolerance for discrete sensors"
      min_lines: 80
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/TemporalAligner.cs"
      provides: "Multi-rate sensor alignment with interpolation and clock drift handling"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/MatrixMath.cs"
      provides: "Dependency-free matrix operations for Kalman filter (multiply, transpose, inverse, add)"
      min_lines: 120
    - path: "Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/SensorFusionEngine.cs"
      provides: "Orchestrator combining all five fusion algorithms into configurable pipeline"
      min_lines: 100
  key_links:
    - from: "SensorFusionEngine"
      to: "KalmanFilter"
      via: "Engine routes GPS+IMU fusion requests to Kalman filter"
      pattern: "_kalmanFilter\\.Update|KalmanFilter"
    - from: "SensorFusionEngine"
      to: "VotingFusion"
      via: "Engine routes redundant sensor arrays to voting"
      pattern: "_votingFusion\\.Vote|VotingFusion"
    - from: "KalmanFilter"
      to: "MatrixMath"
      via: "Kalman predict/update uses matrix multiply, transpose, inverse"
      pattern: "MatrixMath\\.(Multiply|Transpose|Inverse)"
    - from: "IoTGatewayStrategy.ProcessSensorDataAsync"
      to: "SensorFusionEngine"
      via: "Strategy delegates sensor processing to fusion engine"
      pattern: "_fusionEngine|SensorFusionEngine"
---

<objective>
Build five production-ready sensor fusion algorithms (Kalman filter, complementary filter, weighted averaging, voting, temporal alignment) and integrate them into the UltimateIoTIntegration plugin. Wire the fusion engine into IoTGatewayStrategy for real sensor data processing.

Purpose: IMPL-08 requires real sensor fusion algorithms that don't exist anywhere in the codebase (zero matches for "Kalman", "complementary filter", "IMU" in any .cs file). The IoTGatewayStrategy currently stores raw readings in a ConcurrentDictionary with no fusion, filtering, or alignment. This plan builds the complete sensor fusion subsystem from scratch.

Output: A SensorFusionEngine class with five composable algorithms, dependency-free matrix math for Kalman filter, and integration into IoTGatewayStrategy.ProcessSensorDataAsync.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/40-large-implementations/41-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorIngestion/SensorIngestionStrategies.cs
@Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/Strategies/SpecializedStrategies.cs
@Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/DeviceManagement/DeviceManagementStrategies.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Sensor Fusion Algorithms and Matrix Math Library</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/SensorFusionModels.cs
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/MatrixMath.cs
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/KalmanFilter.cs
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/ComplementaryFilter.cs
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/WeightedAverageFusion.cs
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/VotingFusion.cs
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/TemporalAligner.cs
    Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/SensorFusionEngine.cs
  </files>
  <action>
    Create the `Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/Strategies/SensorFusion/` directory with all sensor fusion components. All classes in namespace `DataWarehouse.Plugins.UltimateIoTIntegration.Strategies.SensorFusion`.

    **SensorFusionModels.cs** (~80 lines):
    - `public sealed record SensorReading(string SensorId, string SensorType, double Value, DateTime Timestamp, double? Accuracy = null, double? NoiseVariance = null);`
    - `public sealed record FusedReading(double Value, double Confidence, DateTime Timestamp, string FusionMethod, string[] ContributingSensors);`
    - `public sealed record SensorState(double[] StateVector, double[,] Covariance);`
    - `public sealed record TemporalSample(string SensorId, double Value, DateTime Timestamp, double SampleRateHz);`
    - `public sealed record AlignedSample(DateTime Timestamp, Dictionary<string, double> SensorValues);`
    - `public enum FusionAlgorithm { Kalman, Complementary, WeightedAverage, Voting, TemporalAlignment }`
    - `public sealed record FusionConfiguration(FusionAlgorithm Algorithm, double? Alpha = null, int? MinSensorsForVoting = null, double? OutlierSigmaThreshold = null, InterpolationMethod Interpolation = InterpolationMethod.Linear);`
    - `public enum InterpolationMethod { ZeroOrderHold, Linear, CubicSpline }`

    **MatrixMath.cs** (~200 lines):
    - `internal static class MatrixMath` providing dependency-free matrix operations on `double[,]` and `double[]`.
    - `static double[,] Multiply(double[,] a, double[,] b)` -- standard O(n^3) matrix multiply with dimension validation.
    - `static double[] MultiplyVector(double[,] matrix, double[] vector)` -- matrix-vector multiply.
    - `static double[,] Transpose(double[,] m)` -- transpose.
    - `static double[,] Add(double[,] a, double[,] b)` -- element-wise addition.
    - `static double[,] Subtract(double[,] a, double[,] b)` -- element-wise subtraction.
    - `static double[] AddVectors(double[] a, double[] b)` -- vector addition.
    - `static double[] SubtractVectors(double[] a, double[] b)` -- vector subtraction.
    - `static double[,] ScalarMultiply(double scalar, double[,] m)` -- scalar multiply.
    - `static double[,] Identity(int n)` -- n x n identity matrix.
    - `static double[,] Inverse(double[,] m)` -- matrix inverse via Gauss-Jordan elimination with partial pivoting. For small matrices (up to ~12x12 for Kalman state). Throw `InvalidOperationException` if singular.
    - `static double Determinant(double[,] m)` -- via LU decomposition or recursive for small matrices.
    - All operations validate dimension compatibility, throw `ArgumentException` on mismatch.
    - Use `double` precision throughout (IEEE 754 double sufficient for sensor fusion).

    **KalmanFilter.cs** (~200 lines):
    - `public sealed class KalmanFilter` implementing the standard linear Kalman filter.
    - Constructor takes: `int stateDimension, int measurementDimension, double[,] transitionMatrix (F), double[,] observationMatrix (H), double[,] processNoise (Q), double[,] measurementNoise (R)`.
    - Private state: `double[] _state (x)`, `double[,] _covariance (P)`.
    - `void SetInitialState(double[] state, double[,] covariance)` -- set x0 and P0.
    - **Predict()**: `x = F * x`, `P = F * P * F' + Q`. Standard Kalman predict step.
    - **Update(double[] measurement)**: Innovation `y = z - H * x`. Innovation covariance `S = H * P * H' + R`. Kalman gain `K = P * H' * S^-1`. State update `x = x + K * y`. Covariance update using Joseph form: `P = (I - K*H) * P * (I - K*H)' + K * R * K'` (numerically more stable than the simple `(I - K*H) * P` form, per research recommendation).
    - `SensorState GetState()` -- return current state and covariance as record.
    - `double[] PredictMeasurement()` -- return `H * x` (expected measurement without updating).
    - Factory methods for common configurations:
      - `static KalmanFilter CreateGpsImuFilter()` -- 6-state (x, y, z, vx, vy, vz) for GPS+IMU fusion.
      - `static KalmanFilter Create1DPositionVelocity(double processNoise, double measurementNoise)` -- simple 2-state (position, velocity).
    - All matrix operations delegate to `MatrixMath`.

    **ComplementaryFilter.cs** (~80 lines):
    - `public sealed class ComplementaryFilter`.
    - Constructor takes `double alpha` (default 0.98 -- typical for IMU), `int dimensions` (default 3 for pitch/roll/yaw).
    - Private state: `double[] _angle` (current fused angle estimate).
    - `double[] Update(double[] gyroRate, double[] accelAngle, double deltaTimeSeconds)`:
      - For each dimension: `angle[i] = alpha * (angle[i] + gyroRate[i] * dt) + (1 - alpha) * accelAngle[i]`.
      - High-pass filter on gyroscope (integrates angular rate, captures fast changes).
      - Low-pass filter on accelerometer (captures absolute angle, immune to drift).
    - `void Reset()` -- zero angles.
    - `double[] GetAngles()` -- return current fused angles.
    - Include XML doc explaining why complementary filter works: gyro is accurate short-term but drifts, accelerometer is noisy but no drift, combination gets best of both.

    **WeightedAverageFusion.cs** (~100 lines):
    - `public sealed class WeightedAverageFusion`.
    - `FusedReading Fuse(IReadOnlyList<SensorReading> readings, double[]? weights = null)`:
      - If weights null, use uniform weights (1/N).
      - Normalize weights to sum to 1.0.
      - Compute weighted average: `result = sum(w_i * value_i)`.
      - Compute weighted variance for confidence.
    - `FusedReading FuseWithOutlierDetection(IReadOnlyList<SensorReading> readings, double sigmaThreshold = 3.0)`:
      - Compute median and MAD (Median Absolute Deviation).
      - Exclude readings > sigmaThreshold * MAD from median.
      - Fuse remaining readings with inverse-variance weighting (if NoiseVariance provided) or uniform.
      - Return fused value with confidence = 1.0 - (excluded_count / total_count).
    - `void UpdateDynamicWeights(string sensorId, double observedError)`:
      - Track rolling error for each sensor.
      - Sensors with lower error get higher weight over time.
      - Uses exponential moving average of squared error.

    **VotingFusion.cs** (~100 lines):
    - `public sealed class VotingFusion`.
    - `FusedReading MajorityVote(IReadOnlyList<SensorReading> readings, double tolerance = 0.1)`:
      - Group readings by value (within tolerance).
      - Largest group wins (majority).
      - Return average of majority group.
      - Confidence = majority_count / total_count.
    - `(FusedReading Result, string[] FaultySensors) FaultTolerantVote(IReadOnlyList<SensorReading> readings, int maxFaulty)`:
      - Byzantine fault tolerance: can tolerate up to `(N-1)/3` faulty sensors.
      - Validate `maxFaulty <= (readings.Count - 1) / 3`.
      - Iteratively exclude the sensor furthest from consensus until faulty count <= maxFaulty.
      - Return fused value and list of excluded (faulty) sensor IDs.
    - `void TrackSensorReliability(string sensorId, bool wasCorrect)`:
      - Track per-sensor reliability score (rolling window).
      - Sensors consistently excluded get flagged.

    **TemporalAligner.cs** (~150 lines):
    - `public sealed class TemporalAligner`.
    - Manages sliding window buffers for multi-rate sensors.
    - `void AddSample(TemporalSample sample)` -- add timestamped reading to sensor's buffer. Bounded buffer (configurable max, default 1000 per sensor).
    - `IReadOnlyList<AlignedSample> Align(DateTime targetTime, TimeSpan tolerance, InterpolationMethod method = InterpolationMethod.Linear)`:
      - For each sensor, find the two samples bracketing targetTime.
      - Interpolate value at targetTime:
        - **ZeroOrderHold**: use most recent value before targetTime.
        - **Linear**: `v = v1 + (v2 - v1) * (t - t1) / (t2 - t1)`.
        - **CubicSpline**: use 4 surrounding points for smooth interpolation (Catmull-Rom or natural cubic spline).
      - Return aligned samples at common timestamp.
    - `IReadOnlyList<AlignedSample> AlignToCommonRate(double targetRateHz, DateTime startTime, DateTime endTime, InterpolationMethod method = InterpolationMethod.Linear)`:
      - Generate aligned samples at uniform rate from startTime to endTime.
      - Useful for creating uniform time series from irregular multi-rate sensors.
    - Handle clock drift: if sensor timestamps are consistently offset, detect and compensate via `void CalibrateClockOffset(string sensorId, TimeSpan offset)`.

    **SensorFusionEngine.cs** (~150 lines):
    - `public sealed class SensorFusionEngine`.
    - Composes all five algorithms into a unified API.
    - Constructor: `SensorFusionEngine(FusionConfiguration? defaultConfig = null)`.
    - Private instances: `KalmanFilter`, `ComplementaryFilter`, `WeightedAverageFusion`, `VotingFusion`, `TemporalAligner`.
    - `FusedReading FuseReadings(IReadOnlyList<SensorReading> readings, FusionAlgorithm algorithm)`:
      - Routes to appropriate algorithm based on enum.
      - Kalman: requires prior Predict() call, then Update with measurement.
      - Complementary: requires gyro + accel pair.
      - WeightedAverage/Voting: works with any redundant sensor list.
    - `IReadOnlyList<AlignedSample> AlignAndFuse(IReadOnlyList<SensorReading> readings, FusionConfiguration config)`:
      - Step 1: Add all readings to TemporalAligner.
      - Step 2: Align to most recent timestamp.
      - Step 3: Apply selected fusion algorithm to aligned readings.
    - `SensorState GetKalmanState()` -- expose Kalman filter state for monitoring.
    - `void ResetFilters()` -- reset all filter states.
    - `Dictionary<string, double> GetSensorReliabilityScores()` -- aggregate reliability from voting tracker.

    CRITICAL: No external NuGet dependencies. Matrix math is hand-written using double[,] arrays. Use only System.Numerics for basic types if needed, NOT MathNet.Numerics (per research decision: "prefer dependency-free array implementation over MathNet.Numerics").

    CRITICAL (Rule 13): Every algorithm must contain real mathematical logic. The Kalman filter must implement actual matrix operations. The complementary filter must do real alpha-weighted combination. The voting must implement actual Byzantine fault tolerance logic. No stubs.
  </action>
  <verify>
    `dotnet build Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/DataWarehouse.Plugins.UltimateIoTIntegration.csproj` compiles with zero new errors. Verify all 8 files exist in the SensorFusion directory. Grep for `NotImplementedException` in SensorFusion directory -- zero matches. Grep for `MatrixMath.Multiply` in KalmanFilter.cs -- must find matches (confirming real matrix operations).
  </verify>
  <done>
    All five sensor fusion algorithms are implemented with real mathematical logic: KalmanFilter (predict/update with Joseph-form covariance), ComplementaryFilter (alpha-weighted gyro/accel fusion), WeightedAverageFusion (outlier detection via MAD), VotingFusion (Byzantine fault tolerance), TemporalAligner (multi-rate interpolation). MatrixMath provides dependency-free Gauss-Jordan inverse, multiply, transpose. SensorFusionEngine orchestrates all algorithms.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SensorFusionEngine into IoTGatewayStrategy</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/Strategies/SpecializedStrategies.cs
  </files>
  <action>
    Wire SensorFusionEngine into the IoTGatewayStrategy class in `Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/Strategies/SpecializedStrategies.cs`.

    The IoTGatewayStrategy currently has:
    - `ProcessSensorDataAsync(string sensorId, Dictionary<string, double> readings, CancellationToken ct)` that just stores raw readings in `_sensorData` dictionary and returns them unmodified after `Task.Delay(5, ct)`.

    Modify IoTGatewayStrategy:

    1. Add a `using DataWarehouse.Plugins.UltimateIoTIntegration.Strategies.SensorFusion;` (the UltimateEdgeComputing .csproj likely already references UltimateIoTIntegration -- if not, the strategy can create its own instance since SensorFusionEngine has no plugin dependencies, just pure algorithms).

    IMPORTANT: If UltimateEdgeComputing cannot reference UltimateIoTIntegration (plugin isolation rule), then instead:
    - Copy only the SensorFusionEngine and its dependencies into UltimateEdgeComputing/Strategies/SensorFusion/ as internal classes, OR
    - Move the sensor fusion code to `DataWarehouse.SDK/Algorithms/SensorFusion/` so both plugins can reference it via SDK.

    CHECK FIRST: Look at UltimateEdgeComputing.csproj for existing ProjectReferences. If it only references SDK (as expected per plugin isolation), then the sensor fusion algorithms MUST live in the SDK or in the IoTIntegration plugin with integration via message bus.

    **Preferred approach (message bus integration, respects plugin isolation):**
    - Keep all fusion algorithms in UltimateIoTIntegration.
    - In IoTGatewayStrategy.ProcessSensorDataAsync:
      - Convert `Dictionary<string, double> readings` to `List<SensorReading>` (one per key-value pair, using sensorId as the SensorType).
      - Create a SensorFusionEngine instance (or cache it as a field) -- BUT this requires the type. Since we can't reference the plugin...

    **Best approach: Place fusion algorithms in SDK.**
    - Move the 8 SensorFusion files to `DataWarehouse.SDK/Algorithms/SensorFusion/`.
    - This way both UltimateIoTIntegration and UltimateEdgeComputing can use them.
    - Update namespace to `DataWarehouse.SDK.Algorithms.SensorFusion`.
    - Update Task 1 file paths accordingly.

    WAIT -- re-read the task 1 paths. Task 1 puts files in UltimateIoTIntegration. If plugin isolation prevents cross-reference, we must adjust.

    **DECISION: Place all SensorFusion files in `DataWarehouse.SDK/Algorithms/SensorFusion/` instead.**

    This means Task 1 file paths should be:
    - `DataWarehouse.SDK/Algorithms/SensorFusion/*.cs` (all 8 files)

    And this task (Task 2) wires into IoTGatewayStrategy via SDK types.

    In IoTGatewayStrategy:
    1. Add field: `private readonly SensorFusionEngine _fusionEngine = new();`
    2. Replace `ProcessSensorDataAsync` body:
       - Convert readings dictionary to `List<SensorReading>`: each key becomes SensorType, value becomes Value, timestamp is `DateTime.UtcNow`.
       - If readings.Count >= 3, apply voting fusion to detect faulty sensors.
       - If readings.Count >= 2, apply weighted average fusion.
       - If readings.Count == 1, pass through (no fusion needed).
       - Store fused result in `_sensorData`.
       - Remove the `Task.Delay(5, ct)` -- that was a stub placeholder.
       - Return `SensorDataResult` with `AggregatedValues` containing the fused values (not raw readings).

    3. Add new method: `public SensorState? GetKalmanState() => _fusionEngine.GetKalmanState();`
    4. Add new method: `public Dictionary<string, double> GetSensorReliability() => _fusionEngine.GetSensorReliabilityScores();`

    NOTE: If Task 1 already placed files in UltimateIoTIntegration, this task must MOVE them to SDK first. The executor should check the actual file locations and move if needed.

    **UPDATE Task 1 file locations**: The executor should create the SensorFusion files in `DataWarehouse.SDK/Algorithms/SensorFusion/` (not UltimateIoTIntegration). This keeps everything clean with plugin isolation. Adjust namespace to `DataWarehouse.SDK.Algorithms.SensorFusion`.
  </action>
  <verify>
    `dotnet build Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/DataWarehouse.Plugins.UltimateEdgeComputing.csproj` compiles with zero new errors. Grep `SpecializedStrategies.cs` for `Task.Delay(5` -- must NOT appear (stub removed). Grep for `_fusionEngine` or `SensorFusionEngine` -- must find references. Grep for `SensorReading` in SpecializedStrategies.cs -- must find usage.
  </verify>
  <done>
    IoTGatewayStrategy.ProcessSensorDataAsync now applies real sensor fusion: voting for 3+ redundant sensors, weighted average for 2 sensors, pass-through for single sensors. The Task.Delay stub is removed. Fused results are stored and returned. SensorFusionEngine is accessible from both UltimateIoTIntegration and UltimateEdgeComputing via SDK placement.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors (SDK builds with SensorFusion algorithms)
2. `dotnet build Plugins/DataWarehouse.Plugins.UltimateIoTIntegration/DataWarehouse.Plugins.UltimateIoTIntegration.csproj` -- zero new errors
3. `dotnet build Plugins/DataWarehouse.Plugins.UltimateEdgeComputing/DataWarehouse.Plugins.UltimateEdgeComputing.csproj` -- zero new errors
4. Grep all SensorFusion files for `NotImplementedException` -- zero matches
5. Grep `KalmanFilter.cs` for `MatrixMath.Multiply` -- confirms real matrix operations
6. Grep `SpecializedStrategies.cs` for `Task.Delay(5` -- zero matches (stub removed)
7. Total new LOC -- approximately 1,000-1,400 lines of real algorithmic code
</verification>

<success_criteria>
- Five sensor fusion algorithms implemented with real mathematical logic (no stubs, Rule 13)
- KalmanFilter: full predict/update cycle with Joseph-form covariance update
- ComplementaryFilter: real alpha-weighted gyro + accelerometer combination
- WeightedAverageFusion: inverse-variance weighting with MAD-based outlier detection
- VotingFusion: majority voting with Byzantine fault tolerance (N-1)/3
- TemporalAligner: multi-rate alignment with linear and cubic spline interpolation
- MatrixMath: dependency-free Gauss-Jordan inverse for matrices up to 12x12
- SensorFusionEngine: orchestrator composing all five algorithms
- IoTGatewayStrategy wired to SensorFusionEngine for real sensor data processing
- Zero external NuGet dependencies (dependency-free per research decision)
- Algorithms placed in SDK for cross-plugin accessibility (plugin isolation)
</success_criteria>

<output>
After completion, create `.planning/phases/40-large-implementations/41-02-SUMMARY.md`
</output>
