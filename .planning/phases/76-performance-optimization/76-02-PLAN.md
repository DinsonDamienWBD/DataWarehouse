---
phase: 76-performance-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySkipOptimizer.cs
autonomous: true

must_haves:
  truths:
    - "BloomFilterSkipIndex confirms 'no override' for 99%+ of paths in O(1) with zero false negatives"
    - "False positive rate is bounded at ~1% via tuned bit array size and hash count"
    - "Per-VDE bloom filter is rebuilt on policy store mutations (not on every check)"
    - "PolicySkipOptimizer uses bloom filter to short-circuit before hitting the policy store"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs"
      provides: "Bloom filter for O(1) 'has override?' checks per VDE"
      contains: "class BloomFilterSkipIndex"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySkipOptimizer.cs"
      provides: "Skip optimizer that wraps IPolicyStore with bloom filter pre-check"
      contains: "class PolicySkipOptimizer"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySkipOptimizer.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/IPolicyStore.cs"
      via: "Wraps IPolicyStore.HasOverrideAsync with bloom filter check"
      pattern: "IPolicyStore|HasOverrideAsync"
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs"
      via: "Keys built from PolicyLevel + path"
      pattern: "PolicyLevel"
---

<objective>
Build the BloomFilterSkipIndex that provides O(1) "has override?" checks per VDE path, enabling the resolution engine to skip unnecessary store lookups for the 99%+ of paths with no overrides.

Purpose: PERF-02 requires a bloom filter with zero false negatives and ~1% false positive rate. Most VDE paths have no policy overrides; the bloom filter confirms "definitely no override" in O(1) without touching the policy store. False positives fall through to the real store (safe but slightly slower).

Output: BloomFilterSkipIndex (per-VDE bloom filter with XxHash64 multi-hash), PolicySkipOptimizer (wraps store with bloom filter pre-check).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Infrastructure/Policy/InMemoryPolicyStore.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyStore.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: BloomFilterSkipIndex with XxHash64 multi-hash</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-02)")]:

1. `public sealed class BloomFilterSkipIndex` -- per-VDE bloom filter for O(1) "has override?" checks:

   Constructor takes:
   - `int expectedItems = 10_000` -- expected number of override paths
   - `double falsePositiveRate = 0.01` -- target 1% false positive rate

   Computed fields:
   - `_bitCount` = optimal bit array size: `(int)Math.Ceiling(-expectedItems * Math.Log(falsePositiveRate) / (Math.Log(2) * Math.Log(2)))` -- rounded up to next multiple of 64 for alignment
   - `_hashCount` = optimal hash count: `(int)Math.Ceiling((_bitCount / (double)expectedItems) * Math.Log(2))`
   - `_bits` = `long[]` array of size `_bitCount / 64` (use bit-packed longs for cache efficiency)
   - `private volatile int _itemCount` -- track number of items added

   Properties:
   - `public int BitCount => _bitCount`
   - `public int HashCount => _hashCount`
   - `public int ItemCount => _itemCount`

   Methods:

   `public void Add(PolicyLevel level, string path)`:
   - Build composite key bytes: `Encoding.UTF8.GetBytes($"{(int)level}:{path}")`
   - Compute _hashCount positions using double-hashing: h1 = XxHash64 with seed 0, h2 = XxHash64 with seed 0x9E3779B97F4A7C15 (golden ratio constant)
   - Position[i] = (h1 + i * h2) % _bitCount
   - Set each bit via `_bits[pos / 64] |= (1L << (int)(pos % 64))` using Interlocked.Or for thread safety
   - Interlocked.Increment _itemCount

   `public bool MayContain(PolicyLevel level, string path)`:
   - Same key bytes and hash computation as Add
   - Check each bit: if ANY bit is 0, return false (definitely no override -- zero false negatives)
   - If all bits are 1, return true (might have override -- possible false positive)
   - Read via Volatile.Read on each long element

   `public void Clear()`:
   - Zero all _bits array elements
   - Reset _itemCount to 0

   `public static BloomFilterSkipIndex BuildFromStore(IPolicyStore store, IReadOnlyList<string> featureIds, CancellationToken ct = default)`:
   - Static async factory: queries store.ListOverridesAsync for each featureId, adds all (level, path) pairs
   - Returns a fully populated filter
   - Make this `async Task<BloomFilterSkipIndex>` (static async factory)

Use `System.IO.Hashing.XxHash64` for the hash function (already used in Phase 72 for bloom filters). The double-hashing technique (h1 + i*h2) produces _hashCount independent positions from just 2 hash computations, which is standard bloom filter practice.

Key design: zero false negatives guaranteed because we never remove bits (only Add and Clear). Removal is done by rebuilding the filter via Clear + re-Add.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>BloomFilterSkipIndex compiles with XxHash64 double-hashing, zero false negatives guaranteed by add-only bits, ~1% false positive rate via optimal sizing</done>
</task>

<task type="auto">
  <name>Task 2: PolicySkipOptimizer wrapping IPolicyStore with bloom filter pre-check</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySkipOptimizer.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySkipOptimizer.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-02)")]:

`public sealed class PolicySkipOptimizer`

Constructor takes:
- `IPolicyStore innerStore` -- the real store to delegate to on bloom filter hits
- `BloomFilterSkipIndex bloomFilter` -- the pre-built bloom filter

Fields:
- `private readonly IPolicyStore _innerStore`
- `private readonly BloomFilterSkipIndex _bloomFilter`
- `private long _skipCount` -- Interlocked counter for bloom filter skips (telemetry)
- `private long _fallThroughCount` -- Interlocked counter for bloom filter hits that went to store

Methods:

1. `public Task<bool> HasOverrideOptimizedAsync(PolicyLevel level, string path, CancellationToken ct = default)`:
   - First check `_bloomFilter.MayContain(level, path)`
   - If false: increment _skipCount, return Task.FromResult(false) -- O(1), no store hit
   - If true: increment _fallThroughCount, delegate to `_innerStore.HasOverrideAsync(level, path, ct)` -- bloom filter says "maybe", verify with store

2. `public Task<FeaturePolicy?> GetOptimizedAsync(string featureId, PolicyLevel level, string path, CancellationToken ct = default)`:
   - First check `_bloomFilter.MayContain(level, path)`
   - If false: return Task.FromResult<FeaturePolicy?>(null) -- definitely no override
   - If true: delegate to `_innerStore.GetAsync(featureId, level, path, ct)`

3. `public async Task RebuildFilterAsync(IReadOnlyList<string> featureIds, CancellationToken ct = default)`:
   - Clear existing filter
   - For each featureId, call _innerStore.ListOverridesAsync, add all (level, path) to filter
   - This is called when policies change (same trigger as PERF-06 cache invalidation)

4. `public (long Skips, long FallThroughs) GetStatistics()`:
   - Returns current skip and fall-through counts for observability

5. `public double SkipRatio`:
   - Returns _skipCount / (double)(_skipCount + _fallThroughCount) if total > 0, else 1.0
   - Should be >= 0.99 in normal deployments (99%+ paths have no overrides)

The skip optimizer does NOT implement IPolicyStore -- it is a companion that the fast-path engine (Plan 04) uses alongside the store. This avoids changing the store interface contract.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>PolicySkipOptimizer compiles, short-circuits store access when bloom filter says "no override", tracks skip ratio for telemetry</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
# Must show: Build succeeded. 0 Warning(s). 0 Error(s).
```

Verify PERF-02: MayContain returns false for paths never added (zero false negatives), returns true for paths that were added
Verify false positive rate: with 10K items and 1% target, bit array size ~96K bits, 7 hash functions
Verify PolicySkipOptimizer: HasOverrideOptimizedAsync returns false without hitting store when bloom says no
</verification>

<success_criteria>
- BloomFilterSkipIndex provides O(1) "has override?" with zero false negatives
- False positive rate ~1% via optimal bit array sizing and hash count
- PolicySkipOptimizer short-circuits store access for 99%+ of paths
- Filter rebuilt on policy changes, not on every operation
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/76-performance-optimization/76-02-SUMMARY.md`
</output>
