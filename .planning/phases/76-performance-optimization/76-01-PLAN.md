---
phase: 76-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyMaterializationEngine.cs
autonomous: true

must_haves:
  truths:
    - "First policy check after VDE open takes the same time as subsequent checks (no cold-start penalty)"
    - "Materialized cache pre-computes effective policies for all registered features at VDE open time"
    - "Double-buffered versioned swap replaces the entire cache atomically without blocking readers"
    - "Cache invalidation occurs only on policy change events, not on every operation"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs"
      provides: "Pre-computed effective policy cache with double-buffered atomic swap"
      contains: "class MaterializedPolicyCache"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyMaterializationEngine.cs"
      provides: "Engine that materializes all feature policies at VDE open time"
      contains: "class PolicyMaterializationEngine"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyMaterializationEngine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs"
      via: "Uses PolicyResolutionEngine.ResolveAsync to pre-compute effective policies"
      pattern: "IPolicyEngine|ResolveAsync"
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/VersionedPolicyCache.cs"
      via: "Extends double-buffered pattern from VersionedPolicyCache"
      pattern: "Interlocked\\.Exchange"
---

<objective>
Build the MaterializedPolicyCache that pre-computes effective policies at VDE open time so the first policy check after open has zero cold-start penalty.

Purpose: PERF-01 requires that first check = subsequent checks. By pre-resolving all features at open time and storing the results in an immutable snapshot, we eliminate lazy-resolution overhead from the hot path. PERF-06 requires recompilation only on policy changes.

Output: MaterializedPolicyCache (double-buffered pre-computed cache), PolicyMaterializationEngine (orchestrates pre-computation at open time and re-computation on change events).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
@DataWarehouse.SDK/Infrastructure/Policy/VersionedPolicyCache.cs
@DataWarehouse.SDK/Infrastructure/Policy/EffectivePolicy.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MaterializedPolicyCache with double-buffered atomic swap</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-01, PERF-06)")]:

1. `public sealed class MaterializedPolicyCacheSnapshot` -- immutable snapshot of pre-computed effective policies:
   - `public long Version { get; }` -- monotonically increasing version
   - `public DateTimeOffset MaterializedAt { get; }` -- when this snapshot was built
   - `public IReadOnlyDictionary<string, IEffectivePolicy> EffectivePolicies { get; }` -- keyed by composite "featureId:path"
   - Constructor takes all three, validates non-null dictionary
   - `public IEffectivePolicy? TryGetEffective(string featureId, string path)` -- builds key "featureId:path", returns from dictionary or null
   - `public bool HasPrecomputed(string featureId, string path)` -- returns true if key exists (O(1) check)

2. `public sealed class MaterializedPolicyCache` -- double-buffered cache holding pre-computed effective policies:
   - `private volatile MaterializedPolicyCacheSnapshot _current` -- initialized to empty snapshot at version 0
   - `private volatile MaterializedPolicyCacheSnapshot _previous` -- same as _current initially
   - `private long _version` -- Interlocked counter
   - Constructor: create empty snapshot (ImmutableDictionary), assign to both _current and _previous
   - `public MaterializedPolicyCacheSnapshot GetSnapshot()` -- returns _current (volatile read, no lock)
   - `public MaterializedPolicyCacheSnapshot GetPreviousSnapshot()` -- returns _previous
   - `public long CurrentVersion => Interlocked.Read(ref _version)`
   - `public void Publish(IReadOnlyDictionary<string, IEffectivePolicy> effectivePolicies)`:
     - Increment version via Interlocked.Increment
     - Create new MaterializedPolicyCacheSnapshot with new version, UtcNow, and policies converted to ImmutableDictionary if not already
     - Atomic swap: `Interlocked.Exchange(ref _current, newSnapshot)` captures old, then `Interlocked.Exchange(ref _previous, oldCurrent)`
   - `public bool IsStale(DateTimeOffset policyLastChanged)` -- returns true if _current.MaterializedAt < policyLastChanged

Use `System.Collections.Immutable.ImmutableDictionary` for the internal dictionary. Follow the same Interlocked.Exchange double-buffer pattern as VersionedPolicyCache.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>MaterializedPolicyCache compiles with double-buffered atomic swap, snapshot lookup is O(1) via dictionary key</done>
</task>

<task type="auto">
  <name>Task 2: PolicyMaterializationEngine for VDE-open-time pre-computation</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyMaterializationEngine.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyMaterializationEngine.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-01, PERF-06)")]:

`public sealed class PolicyMaterializationEngine`

Constructor takes:
- `IPolicyEngine engine` -- the resolution engine to invoke for each feature
- `MaterializedPolicyCache cache` -- the double-buffered cache to publish into
- `IReadOnlyList<string>? featureIds = null` -- optional fixed set of feature IDs to materialize; if null, reads from engine's active profile

Fields:
- `private readonly IPolicyEngine _engine`
- `private readonly MaterializedPolicyCache _cache`
- `private readonly IReadOnlyList<string>? _featureIds`
- `private volatile DateTimeOffset _lastPolicyChangeTime = DateTimeOffset.MinValue`
- `private readonly SemaphoreSlim _materializationLock = new(1, 1)` -- serialize re-materialization to avoid thundering herd

Methods:

1. `public async Task MaterializeAsync(string vdePath, CancellationToken ct = default)`:
   - This is called at VDE open time
   - Acquire _materializationLock (with ct)
   - try: Determine feature IDs -- use _featureIds if set, otherwise get from engine.GetActiveProfileAsync().FeaturePolicies.Keys
   - Create PolicyResolutionContext with Path = vdePath
   - For each featureId, call `_engine.ResolveAsync(featureId, context, ct)` and collect results
   - Build dictionary keyed by "featureId:vdePath"
   - Call `_cache.Publish(results)`
   - Update _lastPolicyChangeTime = DateTimeOffset.UtcNow
   - finally: release _materializationLock

2. `public async Task MaterializeMultiPathAsync(IReadOnlyList<string> paths, CancellationToken ct = default)`:
   - Pre-computes for multiple paths (VDE + containers + objects if known)
   - Same lock/build/publish pattern but iterates all paths x all featureIds
   - Keys are "featureId:path" for each combination

3. `public async Task RematerializeIfStaleAsync(string vdePath, CancellationToken ct = default)`:
   - Check `_cache.IsStale(_lastPolicyChangeTime)` -- if not stale, return immediately (PERF-06: no recomputation unless policy changed)
   - If stale, call MaterializeAsync

4. `public void NotifyPolicyChanged()`:
   - Sets `_lastPolicyChangeTime = DateTimeOffset.UtcNow` (volatile write)
   - Called by policy change event handlers (PERF-06)

5. `public IEffectivePolicy? TryGetCached(string featureId, string path)`:
   - Convenience method: calls `_cache.GetSnapshot().TryGetEffective(featureId, path)`
   - Returns null if not pre-computed (caller falls back to live resolution)

The SemaphoreSlim(1,1) serialization prevents multiple concurrent MaterializeAsync calls from doing redundant work. The volatile _lastPolicyChangeTime ensures PERF-06: recomputation only when policy actually changed.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>PolicyMaterializationEngine pre-computes all feature policies at VDE open, publishes to double-buffered cache, recomputes only on policy change notification</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
# Must show: Build succeeded. 0 Warning(s). 0 Error(s).
```

Verify PERF-01: MaterializeAsync pre-computes at open time, TryGetCached returns immediately
Verify PERF-06: RematerializeIfStaleAsync returns immediately when no policy change occurred
Verify double-buffer: Publish creates new snapshot, old becomes _previous, readers on old snapshot unaffected
</verification>

<success_criteria>
- MaterializedPolicyCache provides O(1) lookup of pre-computed effective policies
- Double-buffered atomic swap via Interlocked.Exchange (same pattern as VersionedPolicyCache)
- PolicyMaterializationEngine pre-computes at VDE open time via IPolicyEngine.ResolveAsync
- Recomputation only triggered by NotifyPolicyChanged() (PERF-06)
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/76-performance-optimization/76-01-SUMMARY.md`
</output>
