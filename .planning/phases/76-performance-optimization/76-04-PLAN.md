---
phase: 76-performance-optimization
plan: 04
type: execute
wave: 3
depends_on: ["76-01", "76-02", "76-03"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySimulator.cs
autonomous: true

must_haves:
  truths:
    - "VDE_ONLY deployments hit the 0ns path (return from materialized cache, no store or bloom filter check)"
    - "CONTAINER_STOP deployments hit the ~20ns path (bloom filter check + materialized cache)"
    - "FULL_CASCADE deployments hit the ~200ns path (full resolution with bloom filter skip optimization)"
    - "Check classification correctly routes each of the 94 feature checks to CONNECT_TIME, SESSION_CACHED, PER_OPERATION, DEFERRED, or PERIODIC"
    - "PolicyEngine.Simulate() returns what-if analysis results without modifying live engine state"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs"
      provides: "Three-tier fast-path policy engine with tier classification"
      contains: "class FastPathPolicyEngine"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs"
      provides: "Feature check timing classification (CONNECT_TIME, SESSION_CACHED, PER_OPERATION, DEFERRED, PERIODIC)"
      contains: "enum CheckTiming"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySimulator.cs"
      provides: "PolicyEngine.Simulate() what-if analysis without live changes"
      contains: "class PolicySimulator"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs"
      via: "VDE_ONLY tier reads directly from materialized cache"
      pattern: "MaterializedPolicyCache|TryGetCached"
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs"
      via: "CONTAINER_STOP tier checks bloom filter before store"
      pattern: "BloomFilterSkipIndex|MayContain|PolicySkipOptimizer"
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyDelegateCache.cs"
      via: "All tiers use compiled delegates for repeated checks"
      pattern: "PolicyDelegateCache|GetOrCompile"
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs"
      via: "FULL_CASCADE tier falls back to full resolution engine"
      pattern: "IPolicyEngine|ResolveAsync"
---

<objective>
Wire the three-tier fast path (VDE_ONLY/CONTAINER_STOP/FULL_CASCADE), implement check classification routing for all 94 feature checks, and build PolicyEngine.Simulate() for what-if analysis.

Purpose: PERF-04 requires measurably correct tier classification with 0ns/~20ns/~200ns paths. PERF-05 requires check classification (CONNECT_TIME, SESSION_CACHED, PER_OPERATION, DEFERRED, PERIODIC) to route each feature check. PERF-07 requires Simulate() for what-if analysis without live changes.

Output: FastPathPolicyEngine (three-tier engine combining materialized cache, bloom filter, compiled delegates, and full resolution), CheckClassification (timing classification for feature checks), PolicySimulator (what-if analysis).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/BloomFilterSkipIndex.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySkipOptimizer.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/CompiledPolicyDelegate.cs
@DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyDelegateCache.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CheckClassification enum and feature routing table</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/CheckClassification.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-05)")]:

1. `public enum CheckTiming` -- when a feature check should be evaluated:
   - `ConnectTime = 0` -- evaluated once at VDE open/connect; result cached for entire session (e.g., encryption algorithm selection, auth model)
   - `SessionCached = 1` -- evaluated once per session and cached; re-evaluated if policy changes mid-session (e.g., compression level, replication factor)
   - `PerOperation = 2` -- evaluated on every read/write operation (e.g., access control check, quota enforcement)
   - `Deferred = 3` -- evaluated asynchronously after the operation completes (e.g., audit logging, compliance recording)
   - `Periodic = 4` -- evaluated on a timer (e.g., integrity verification, key rotation check, sustainability metrics)

   Add [Description] attributes on each value.

2. `public enum DeploymentTier` -- determines which fast path a VDE uses:
   - `VdeOnly = 0` -- no overrides at any level; use materialized cache directly (0ns overhead)
   - `ContainerStop = 1` -- overrides exist only at container level or above; bloom filter + cache (~20ns)
   - `FullCascade = 2` -- overrides exist at object/chunk/block level; full resolution needed (~200ns)

   Add [Description] attributes on each value.

3. `public static class CheckClassificationTable` -- maps feature IDs to their check timing:

   - `private static readonly FrozenDictionary<string, CheckTiming> _classifications` -- built from a static initializer
   - Populate with representative feature classifications:
     - ConnectTime: "encryption", "auth_model", "key_management", "fips_mode", "air_gap_mode", "security_clearance", "mfa_policy", "zero_trust", "enclave_mode", "steganography", "forensic_watermark", "dead_drop", "canary", "honeypot", "sovereignty", "tamper_detection", "authority_chain"
     - SessionCached: "compression", "replication", "storage_backend", "tiering", "deduplication", "erasure_coding", "snapshot_policy", "branching", "cdp_interval", "cache_strategy", "indexing", "format_preference", "compute_runtime", "wasm_runtime", "container_runtime", "gpu_policy", "streaming_protocol", "data_transit", "network_qos"
     - PerOperation: "access_control", "quota", "rate_limit", "data_classification", "lineage_tracking", "quality_check", "schema_validation", "transformation", "routing", "load_balancing", "cost_routing"
     - Deferred: "audit_logging", "compliance_recording", "metrics_collection", "telemetry", "sustainability_tracking", "carbon_aware", "billing", "usage_analytics", "anomaly_detection", "threat_detection"
     - Periodic: "integrity_verification", "key_rotation", "certificate_renewal", "health_check", "capacity_planning", "defragmentation", "garbage_collection", "replication_sync", "backup_schedule", "retention_enforcement", "deprecation_check"
   - Fill to reach 94 total entries representing the full feature set
   - `public static CheckTiming GetTiming(string featureId)` -- returns classification, defaults to PerOperation for unknown features
   - `public static IReadOnlyList<string> GetFeaturesByTiming(CheckTiming timing)` -- returns all features with the given timing
   - `public static int TotalFeatures => _classifications.Count`

4. `public static class DeploymentTierClassifier`:
   - `public static DeploymentTier Classify(IPolicyStore store, string vdePath, CancellationToken ct = default)` -- async method:
     - Check HasOverrideAsync at Block, Chunk, Object levels for the path
     - If any override at Object/Chunk/Block: return FullCascade
     - Check at Container level: if any override, return ContainerStop
     - Otherwise return VdeOnly
   - `public static DeploymentTier ClassifyFromBloomFilter(BloomFilterSkipIndex filter, string vdePath)`:
     - Check MayContain at each level for the path
     - Same classification logic but O(1) via bloom filter

Use `System.Collections.Frozen.FrozenDictionary` for the classification table (zero-allocation lookups). Import via `using System.Collections.Frozen;`.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>CheckClassification compiles with 94 feature entries across 5 timing categories, DeploymentTierClassifier determines VDE_ONLY/CONTAINER_STOP/FULL_CASCADE</done>
</task>

<task type="auto">
  <name>Task 2: FastPathPolicyEngine and PolicySimulator</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs, DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySimulator.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/FastPathPolicyEngine.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-04, PERF-05)")]:

`public sealed class FastPathPolicyEngine : IPolicyEngine`

Constructor takes:
- `PolicyResolutionEngine resolutionEngine` -- the full cascade engine (fallback)
- `MaterializedPolicyCache materializedCache` -- pre-computed policies (Plan 01)
- `PolicyDelegateCache delegateCache` -- compiled delegates (Plan 03)
- `PolicySkipOptimizer? skipOptimizer = null` -- bloom filter optimizer (Plan 02), optional
- `PolicyMaterializationEngine? materializationEngine = null` -- for re-materialization (Plan 01), optional

Fields:
- All constructor params as private readonly
- `private volatile DeploymentTier _currentTier = DeploymentTier.VdeOnly` -- current fast-path tier
- `private readonly PolicySimulator _simulator` -- constructed internally with resolutionEngine

Methods:

`public async Task<IEffectivePolicy> ResolveAsync(string featureId, PolicyResolutionContext context, CancellationToken ct = default)`:
- Get check timing: `CheckClassificationTable.GetTiming(featureId)`
- Route by timing:
  - ConnectTime: always use delegateCache.GetOrCompile (already resolved at connect time)
  - SessionCached: use delegateCache.GetOrCompile (cached for session, invalidated on policy change)
  - PerOperation: route by deployment tier (see below)
  - Deferred: return from materializedCache snapshot (result will be used async)
  - Periodic: return from materializedCache snapshot (evaluated on timer)

- For PerOperation, route by _currentTier:
  - VdeOnly (0ns path): `delegateCache.GetOrCompile(featureId, context.Path)` -- direct delegate call, no store access
  - ContainerStop (~20ns path): if skipOptimizer is not null, call `skipOptimizer.HasOverrideOptimizedAsync` to check for overrides below container. If no override, use delegateCache. If override exists, fall through to full resolution.
  - FullCascade (~200ns path): delegate to `_resolutionEngine.ResolveAsync(featureId, context, ct)` -- full cascade walk

`public async Task<IReadOnlyDictionary<string, IEffectivePolicy>> ResolveAllAsync(PolicyResolutionContext context, CancellationToken ct = default)`:
- Get snapshot from materialized cache
- For each feature in active profile, call ResolveAsync
- Return dictionary

`public Task<OperationalProfile> GetActiveProfileAsync(CancellationToken ct = default)`:
- Delegate to _resolutionEngine

`public Task SetActiveProfileAsync(OperationalProfile profile, CancellationToken ct = default)`:
- Delegate to _resolutionEngine
- After set, call `_materializationEngine?.NotifyPolicyChanged()` to trigger re-materialization (PERF-06)

`public Task<IEffectivePolicy> SimulateAsync(string featureId, PolicyResolutionContext context, FeaturePolicy hypotheticalPolicy, CancellationToken ct = default)`:
- Delegate to `_simulator.SimulateAsync(featureId, context, hypotheticalPolicy, ct)` (PERF-07)

`public void SetDeploymentTier(DeploymentTier tier)`:
- Sets _currentTier (volatile write)
- Called after tier classification at VDE open

`public async Task InitializeForVdeAsync(string vdePath, CancellationToken ct = default)`:
- Materialize policies: `_materializationEngine?.MaterializeAsync(vdePath, ct)`
- Classify tier: use DeploymentTierClassifier.ClassifyFromBloomFilter if skipOptimizer available, else VdeOnly
- Set _currentTier
- Warm up delegate cache: `_delegateCache.WarmUp(featureIds, vdePath)`

---

Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicySimulator.cs` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-07)")]:

`public sealed class PolicySimulator`

Constructor takes `IPolicyEngine engine` (the real resolution engine).

Methods:

`public async Task<PolicySimulationResult> SimulateAsync(string featureId, PolicyResolutionContext context, FeaturePolicy hypotheticalPolicy, CancellationToken ct = default)`:
- Get current effective policy: `_engine.ResolveAsync(featureId, context, ct)`
- Get hypothetical effective policy: `_engine.SimulateAsync(featureId, context, hypotheticalPolicy, ct)`
- Build PolicySimulationResult comparing current vs hypothetical

`public async Task<PolicySimulationResult> SimulateProfileChangeAsync(OperationalProfile hypotheticalProfile, PolicyResolutionContext context, CancellationToken ct = default)`:
- Get current profile: `_engine.GetActiveProfileAsync(ct)`
- For each feature in BOTH current and hypothetical profiles, resolve current and simulate hypothetical
- Build aggregate PolicySimulationResult

`public sealed record PolicySimulationResult`:
- `required IEffectivePolicy CurrentPolicy { get; init; }` -- what policy is now
- `required IEffectivePolicy HypotheticalPolicy { get; init; }` -- what policy would be
- `int IntensityDelta => HypotheticalPolicy.EffectiveIntensity - CurrentPolicy.EffectiveIntensity`
- `bool AiAutonomyChanged => HypotheticalPolicy.EffectiveAiAutonomy != CurrentPolicy.EffectiveAiAutonomy`
- `bool CascadeChanged => HypotheticalPolicy.AppliedCascade != CurrentPolicy.AppliedCascade`
- `IReadOnlyList<string> ChangedParameters { get; init; }` -- parameter keys that differ
- `DateTimeOffset SimulatedAt { get; init; }`

`public sealed record AggregateSimulationResult`:
- `required IReadOnlyDictionary<string, PolicySimulationResult> FeatureResults { get; init; }` -- per-feature results
- `int FeaturesAffected => FeatureResults.Count(r => r.Value.IntensityDelta != 0 || r.Value.AiAutonomyChanged || r.Value.CascadeChanged)`
- `DateTimeOffset SimulatedAt { get; init; }`

The simulator NEVER modifies the live engine, store, or cache. It uses the existing SimulateAsync method on IPolicyEngine which already creates a hypothetical resolution chain without persisting.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>FastPathPolicyEngine routes by deployment tier (VDE_ONLY/CONTAINER_STOP/FULL_CASCADE) and check timing, PolicySimulator returns what-if without modifying live state</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
# Must show: Build succeeded. 0 Warning(s). 0 Error(s).
```

Verify PERF-04: VDE_ONLY tier uses delegate cache only (no store access), ContainerStop adds bloom filter check, FullCascade does full resolution
Verify PERF-05: 94 features classified across 5 timing categories, GetTiming returns correct classification
Verify PERF-07: SimulateAsync returns current vs hypothetical comparison without modifying live engine
</verification>

<success_criteria>
- FastPathPolicyEngine implements IPolicyEngine with three-tier routing
- VDE_ONLY path has zero store access (delegate cache only)
- CONTAINER_STOP path adds bloom filter check (~20ns overhead)
- FULL_CASCADE path delegates to full resolution engine (~200ns)
- CheckClassificationTable maps 94 features to 5 timing categories
- PolicySimulator provides what-if analysis without live changes
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/76-performance-optimization/76-04-SUMMARY.md`
</output>
