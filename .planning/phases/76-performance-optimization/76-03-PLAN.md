---
phase: 76-performance-optimization
plan: 03
type: execute
wave: 2
depends_on: ["76-01"]
files_modified:
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/CompiledPolicyDelegate.cs
  - DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyDelegateCache.cs
autonomous: true

must_haves:
  truths:
    - "Hot-path policy checks invoke a pre-compiled delegate instead of the full resolution algorithm"
    - "Compiled delegates are cached and reused until the materialized cache version changes"
    - "Recompilation is triggered by cache version change (which is triggered by policy change), not by every operation"
    - "Delegate invocation returns IEffectivePolicy directly without async overhead for cached paths"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/CompiledPolicyDelegate.cs"
      provides: "JIT-compiled policy delegates for hot-path feature checks"
      contains: "class CompiledPolicyDelegate"
    - path: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyDelegateCache.cs"
      provides: "Cache of compiled delegates keyed by feature+path, versioned to materialized cache"
      contains: "class PolicyDelegateCache"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/CompiledPolicyDelegate.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs"
      via: "Reads pre-computed effective policies from materialized cache snapshot"
      pattern: "MaterializedPolicyCacheSnapshot|TryGetEffective"
    - from: "DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyDelegateCache.cs"
      to: "DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs"
      via: "Invalidates delegates when cache version changes"
      pattern: "MaterializedPolicyCache|CurrentVersion"
---

<objective>
Build CompiledPolicyDelegate that JIT-compiles hot-path policies into direct delegates, eliminating the resolution algorithm overhead for repeated calls to the same feature+path.

Purpose: PERF-03 requires that repeated policy checks invoke a direct delegate rather than walking the cascade chain. Combined with PERF-01 (materialized cache) and PERF-06 (change-only recompilation), this makes the hot path a direct dictionary lookup + delegate call.

Output: CompiledPolicyDelegate (captures a snapshot lookup as a Func), PolicyDelegateCache (versioned cache of compiled delegates).
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Infrastructure/Policy/Performance/MaterializedPolicyCache.cs
@DataWarehouse.SDK/Infrastructure/Policy/EffectivePolicy.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CompiledPolicyDelegate for direct delegate invocation</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/CompiledPolicyDelegate.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/CompiledPolicyDelegate.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-03)")]:

1. `public sealed class CompiledPolicyDelegate` -- captures a pre-resolved effective policy as a direct delegate:

   Fields:
   - `private readonly Func<IEffectivePolicy> _compiledCheck` -- the compiled delegate
   - `public string FeatureId { get; }` -- which feature this delegate is for
   - `public string Path { get; }` -- which path this delegate is for
   - `public long SourceVersion { get; }` -- the materialized cache version this was compiled from
   - `public DateTimeOffset CompiledAt { get; }` -- when this delegate was compiled

   Constructor (private): takes featureId, path, sourceVersion, compiledAt, and the Func delegate.

   `public IEffectivePolicy Invoke()`:
   - Calls _compiledCheck() -- direct delegate invocation, no async, no resolution
   - This is the hot path: a single delegate call returning the pre-resolved policy

   Static factory methods:

   `public static CompiledPolicyDelegate CompileFromSnapshot(string featureId, string path, MaterializedPolicyCacheSnapshot snapshot)`:
   - Get the effective policy from snapshot: `snapshot.TryGetEffective(featureId, path)`
   - If found: capture the IEffectivePolicy in a closure: `() => capturedPolicy`
   - If not found: compile a delegate that returns a default EffectivePolicy (intensity 50, SuggestExplain, Inherit cascade, VDE level, empty chain, empty params, snapshot timestamp)
   - Return new CompiledPolicyDelegate with snapshot.Version as SourceVersion

   `public static CompiledPolicyDelegate CompileFromEffective(string featureId, string path, IEffectivePolicy effective, long version)`:
   - Direct capture: `() => effective`
   - Used when caller already has the resolved policy and just wants delegate wrapping

   `public bool IsStale(long currentVersion)`:
   - Returns `SourceVersion != currentVersion` -- delegate must be recompiled when materialized cache updates

2. `public delegate IEffectivePolicy PolicyCheckDelegate(string featureId, string path)` -- typed delegate for policy checks (alternative to Func for strong typing in the fast-path wiring).

The "JIT compilation" is not System.Reflection.Emit -- it is closure capture of the pre-resolved IEffectivePolicy into a direct Func<IEffectivePolicy>. This eliminates all resolution overhead: the delegate is a pointer to a method that returns a captured object. This is the standard high-performance .NET pattern for eliminating virtual dispatch and algorithm overhead on hot paths.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>CompiledPolicyDelegate compiles, Invoke() returns pre-resolved policy via direct delegate call with zero resolution overhead</done>
</task>

<task type="auto">
  <name>Task 2: PolicyDelegateCache with version-gated invalidation</name>
  <files>DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyDelegateCache.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Policy/Performance/PolicyDelegateCache.cs` in namespace `DataWarehouse.SDK.Infrastructure.Policy.Performance` with [SdkCompatibility("6.0.0", Notes = "Phase 76: Performance Optimization (PERF-03, PERF-06)")]:

`public sealed class PolicyDelegateCache`

Constructor takes:
- `MaterializedPolicyCache materializedCache` -- source of pre-computed policies

Fields:
- `private readonly MaterializedPolicyCache _materializedCache`
- `private readonly ConcurrentDictionary<string, CompiledPolicyDelegate> _delegates = new(StringComparer.Ordinal)`
- `private volatile long _compiledForVersion = -1` -- track which cache version delegates were compiled for
- `private long _hitCount` -- Interlocked counter
- `private long _missCount` -- Interlocked counter
- `private long _recompileCount` -- Interlocked counter

Methods:

1. `public IEffectivePolicy GetOrCompile(string featureId, string path)`:
   - Build key: $"{featureId}:{path}"
   - Check if entire cache needs invalidation: if `_materializedCache.CurrentVersion != _compiledForVersion`, call InvalidateAll()
   - Try _delegates.TryGetValue for the key
   - If found and not stale (delegate.SourceVersion == current version): increment _hitCount, return delegate.Invoke()
   - If not found or stale: compile new delegate from snapshot, store in _delegates, increment _missCount, return Invoke() result

2. `public void InvalidateAll()`:
   - Clear _delegates
   - Update _compiledForVersion to _materializedCache.CurrentVersion
   - Increment _recompileCount
   - Called when materialized cache version changes (PERF-06: only on policy change)

3. `public void Invalidate(string featureId, string path)`:
   - Remove single delegate from _delegates by key
   - For targeted invalidation when only one policy changed

4. `public void WarmUp(IReadOnlyList<string> featureIds, string path)`:
   - Pre-compile delegates for all given features at the given path
   - Called after MaterializeAsync to eliminate even the first-call miss
   - Gets snapshot once, iterates featureIds, compiles and stores each

5. `public (long Hits, long Misses, long Recompiles, int CachedDelegates) GetStatistics()`:
   - Returns telemetry counters and current delegate count

The cache key is the same "featureId:path" format used by MaterializedPolicyCache for consistency. Version-gated invalidation ensures delegates are recompiled exactly once per policy change (PERF-06), not on every operation.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>PolicyDelegateCache compiles, provides O(1) delegate lookup with version-gated invalidation, tracks hit/miss/recompile telemetry</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
# Must show: Build succeeded. 0 Warning(s). 0 Error(s).
```

Verify PERF-03: GetOrCompile returns pre-resolved policy via delegate invocation (no resolution algorithm)
Verify PERF-06: InvalidateAll only called when materialized cache version changes
Verify WarmUp: pre-compiles delegates so even first call after open is a hit
</verification>

<success_criteria>
- CompiledPolicyDelegate.Invoke() returns IEffectivePolicy via direct closure call
- PolicyDelegateCache.GetOrCompile is O(1) for cached delegates
- Version-gated invalidation ensures recompilation only on policy change
- WarmUp eliminates first-call miss after VDE open
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/76-performance-optimization/76-03-SUMMARY.md`
</output>
