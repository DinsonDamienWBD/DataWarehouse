---
phase: 64-moonshot-wiring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Moonshots/MoonshotConfiguration.cs
  - DataWarehouse.SDK/Moonshots/MoonshotConfigurationDefaults.cs
  - DataWarehouse.SDK/Moonshots/MoonshotConfigurationValidator.cs
autonomous: true

must_haves:
  truths:
    - "Every moonshot is fully configurable with strategy selection per moonshot"
    - "AllowUserToOverride flag controls whether users can change Instance-level defaults"
    - "Configuration follows Instance -> Tenant -> User hierarchy with inheritance"
    - "Default configuration enables all moonshots with sensible production defaults"
    - "Configuration validator rejects invalid combinations (e.g., sovereignty without tags)"
  artifacts:
    - path: "DataWarehouse.SDK/Moonshots/MoonshotConfiguration.cs"
      provides: "MoonshotConfiguration, MoonshotFeatureConfig, MoonshotStrategySelection, ConfigHierarchyLevel"
      min_lines: 200
    - path: "DataWarehouse.SDK/Moonshots/MoonshotConfigurationDefaults.cs"
      provides: "Static factory for production-default configuration for all 10 moonshots"
      min_lines: 120
    - path: "DataWarehouse.SDK/Moonshots/MoonshotConfigurationValidator.cs"
      provides: "IMoonshotConfigValidator, validation rules, dependency checks"
      min_lines: 100
  key_links:
    - from: "MoonshotConfiguration"
      to: "MoonshotPipelineTypes"
      via: "MoonshotId used as dictionary key for per-moonshot config"
      pattern: "MoonshotId"
    - from: "MoonshotConfigurationDefaults"
      to: "MoonshotConfiguration"
      via: "factory creates MoonshotConfiguration instances"
      pattern: "MoonshotConfiguration"
    - from: "MoonshotConfigurationValidator"
      to: "MoonshotConfiguration"
      via: "validates MoonshotConfiguration for dependency and constraint violations"
      pattern: "MoonshotConfiguration|ValidationResult"
---

<objective>
Define configuration types for all 10 moonshots with strategy selection, hierarchy inheritance, AllowUserToOverride, and validation.

Purpose: Every moonshot must be independently configurable with production defaults. The Instance->Tenant->User hierarchy ensures multi-tenant deployments can customize moonshot behavior at each level. AllowUserToOverride prevents sensitive moonshots (compliance, sovereignty) from being disabled by end users.

Output: Three files defining the complete configuration model, defaults, and validation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Primitives/Configuration/ConfigurationItem.cs
@DataWarehouse.SDK/Primitives/Configuration/ConfigurationChangeApi.cs
@DataWarehouse.SDK/Primitives/Configuration/ConfigurationPresets.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MoonshotConfiguration types with hierarchy and override control</name>
  <files>DataWarehouse.SDK/Moonshots/MoonshotConfiguration.cs</files>
  <action>
Create `DataWarehouse.SDK/Moonshots/MoonshotConfiguration.cs`:

- `ConfigHierarchyLevel` enum: `Instance = 0, Tenant = 1, User = 2`
- `MoonshotOverridePolicy` enum: `Locked = 0` (only Instance admin), `TenantOverridable = 1` (Tenant admins can change), `UserOverridable = 2` (any user can change)
- `MoonshotStrategySelection` record: `string StrategyName, IReadOnlyDictionary<string, string> StrategyParameters` -- which strategy implementation to use for a moonshot capability
- `MoonshotFeatureConfig` record:
  - `MoonshotId Id`
  - `bool Enabled` (master on/off switch)
  - `MoonshotOverridePolicy OverridePolicy`
  - `IReadOnlyDictionary<string, MoonshotStrategySelection> StrategySelections` -- key is capability name (e.g., "PlacementAlgorithm", "ClassifierModel"), value is strategy selection
  - `IReadOnlyDictionary<string, string> Settings` -- moonshot-specific key-value config (e.g., "ConsciousnessThreshold" = "50", "CarbonBudgetKgPerTB" = "100")
  - `IReadOnlyList<MoonshotId> RequiredDependencies` -- other moonshots this one requires
  - `ConfigHierarchyLevel DefinedAt` -- which level set this config
- `MoonshotConfiguration` class:
  - `IReadOnlyDictionary<MoonshotId, MoonshotFeatureConfig> Moonshots { get; init; }`
  - `ConfigHierarchyLevel Level { get; init; }`
  - `string? TenantId { get; init; }`
  - `string? UserId { get; init; }`
  - `MoonshotFeatureConfig GetEffectiveConfig(MoonshotId id)` -- returns effective config for this level
  - `MoonshotConfiguration MergeWith(MoonshotConfiguration child)` -- merge parent config with child (child overrides where OverridePolicy allows). If OverridePolicy is Locked and child tries to change, parent wins. If TenantOverridable, Tenant can change but User cannot. If UserOverridable, anyone can change.
  - `bool IsEnabled(MoonshotId id)` -- quick check
  - `MoonshotStrategySelection? GetStrategy(MoonshotId id, string capabilityName)` -- get strategy for moonshot capability

Follow existing ConfigurationItem patterns. Use immutable records where possible, class only for MoonshotConfiguration (needs merge logic).
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors. MoonshotConfiguration.MergeWith correctly handles Locked/TenantOverridable/UserOverridable policies.</verify>
  <done>MoonshotConfiguration supports Instance->Tenant->User hierarchy with AllowUserToOverride semantics via MoonshotOverridePolicy.</done>
</task>

<task type="auto">
  <name>Task 2: Configuration defaults and validator</name>
  <files>DataWarehouse.SDK/Moonshots/MoonshotConfigurationDefaults.cs, DataWarehouse.SDK/Moonshots/MoonshotConfigurationValidator.cs</files>
  <action>
**MoonshotConfigurationDefaults.cs** -- Static factory `MoonshotConfigurationDefaults`:
- `static MoonshotConfiguration CreateProductionDefaults()` -- returns config with ALL 10 moonshots enabled at Instance level with these defaults:
  1. UniversalTags: Enabled, UserOverridable, strategy "InvertedIndex" for query, "CrdtVersioning" for versioning
  2. DataConsciousness: Enabled, TenantOverridable, strategy "AiValueScoring" for value, "RegulatoryLiabilityScoring" for liability, setting "ConsciousnessThreshold" = "50"
  3. CompliancePassports: Enabled, Locked (compliance cannot be disabled by users), strategy "ContinuousAudit" for monitoring
  4. SovereigntyMesh: Enabled, Locked, strategy "DeclarativeZones" for enforcement, setting "DefaultZone" = "none" (must be explicitly set)
  5. ZeroGravityStorage: Enabled, TenantOverridable, strategy "CrushPlacement" for placement, "GravityAwareOptimizer" for optimization
  6. CryptoTimeLocks: Enabled, Locked, strategy "SoftwareTimeLock" for locking, setting "DefaultLockDuration" = "P30D" (30 days ISO 8601)
  7. SemanticSync: Enabled, UserOverridable, strategy "AiClassifier" for classification, "BandwidthAwareFidelity" for fidelity
  8. ChaosVaccination: Enabled, TenantOverridable, strategy "ControlledInjection" for injection, setting "MaxBlastRadius" = "10" (percent)
  9. CarbonAwareLifecycle: Enabled, TenantOverridable, strategy "CarbonIntensityApi" for measurement, setting "CarbonBudgetKgPerTB" = "100"
  10. UniversalFabric: Enabled, TenantOverridable, strategy "DwNamespaceRouter" for routing

- Dependencies: CompliancePassports requires UniversalTags. SovereigntyMesh requires CompliancePassports. SemanticSync requires DataConsciousness.

- `static MoonshotConfiguration CreateMinimalDefaults()` -- all moonshots disabled except UniversalTags and UniversalFabric (minimum viable deployment)

**MoonshotConfigurationValidator.cs** -- Define:
- `MoonshotConfigValidationResult` record: `bool IsValid, IReadOnlyList<MoonshotConfigValidationError> Errors`
- `MoonshotConfigValidationError` record: `MoonshotId? AffectedMoonshot, string Code, string Message, string? Suggestion`
- `IMoonshotConfigValidator` interface: `MoonshotConfigValidationResult Validate(MoonshotConfiguration config)`
- `MoonshotConfigurationValidator` class implementing `IMoonshotConfigValidator`:
  - Check: If moonshot A is enabled and depends on moonshot B, moonshot B must be enabled. Error code "DEP_MISSING".
  - Check: If OverridePolicy is Locked at Instance level, lower levels cannot enable/disable. Error code "OVERRIDE_VIOLATION".
  - Check: Strategy names are not null/empty when moonshot is enabled. Error code "MISSING_STRATEGY".
  - Check: Required settings for each moonshot are present. Error code "MISSING_SETTING".
  - Check: CryptoTimeLocks DefaultLockDuration is a valid ISO 8601 duration. Error code "INVALID_DURATION".
  - Check: ChaosVaccination MaxBlastRadius is 1-100. Error code "INVALID_RANGE".
  - Check: CarbonBudgetKgPerTB is positive. Error code "INVALID_BUDGET".
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors. Validator catches DEP_MISSING when SovereigntyMesh enabled but CompliancePassports disabled.</verify>
  <done>Production defaults enable all 10 moonshots with locked compliance/sovereignty. Validator catches dependency violations, missing strategies, and invalid settings.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors
- All 3 files exist in `DataWarehouse.SDK/Moonshots/`
- `MoonshotConfigurationDefaults.CreateProductionDefaults()` returns config with 10 enabled moonshots
- `MoonshotConfigurationValidator` catches invalid dependency chains
</verification>

<success_criteria>
Every moonshot has full configuration support with strategy selection, override policy, hierarchy merging, production defaults, and constraint validation.
</success_criteria>

<output>
After completion, create `.planning/phases/64-moonshot-wiring/64-02-SUMMARY.md`
</output>
