---
phase: 64-moonshot-wiring
plan: 06
type: execute
wave: 3
depends_on: ["64-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/TagConsciousnessWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/ComplianceSovereigntyWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/PlacementCarbonWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/SyncConsciousnessWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/TimeLockComplianceWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/ChaosImmunityWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/FabricPlacementWiring.cs
  - Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/CrossMoonshotWiringRegistrar.cs
autonomous: true

must_haves:
  truths:
    - "Tags auto-attach consciousness score as metadata tag on every scored object"
    - "Compliance passports reference sovereignty zone decisions in their evidence chain"
    - "Placement algorithm factors carbon budget into node selection"
    - "Semantic sync fidelity is driven by consciousness value score"
    - "Time-lock duration derives from compliance passport retention requirements"
    - "Chaos vaccination immune memory feeds back to sovereignty zone resilience"
    - "Universal fabric dw:// addresses encode placement node for direct routing"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/CrossMoonshotWiringRegistrar.cs"
      provides: "Registers all cross-moonshot bus subscriptions"
      min_lines: 60
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/TagConsciousnessWiring.cs"
      provides: "Wires consciousness scores to tag attachment"
      min_lines: 50
    - path: "Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/ComplianceSovereigntyWiring.cs"
      provides: "Wires sovereignty decisions to compliance evidence"
      min_lines: 50
  key_links:
    - from: "TagConsciousnessWiring"
      to: "consciousness.score.completed -> tags.auto.attach"
      via: "bus subscription bridges consciousness output to tag input"
      pattern: "consciousness\\.score\\.completed.*tags\\.auto"
    - from: "ComplianceSovereigntyWiring"
      to: "sovereignty.zone.check.completed -> compliance.passport.update"
      via: "sovereignty decision added to passport evidence"
      pattern: "sovereignty.*compliance\\.passport"
    - from: "PlacementCarbonWiring"
      to: "carbon.intensity.updated -> storage.placement.recalculate"
      via: "carbon data triggers placement recalculation"
      pattern: "carbon.*placement"
---

<objective>
Wire specific cross-moonshot interactions that go beyond the linear pipeline -- bidirectional feedback loops, event-driven updates, and enrichment flows.

Purpose: The pipeline (Plan 03) handles the linear ingest flow. But moonshots also interact outside the pipeline: consciousness scores become tags, sovereignty decisions become compliance evidence, carbon intensity changes trigger placement recalculation. These event-driven cross-moonshot wires ensure the system stays coherent as data and conditions change.

Output: 7 cross-moonshot wiring classes + 1 registrar in the CrossMoonshot/ subdirectory.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/64-moonshot-wiring/64-03-SUMMARY.md
@DataWarehouse.SDK/Moonshots/MoonshotPipelineTypes.cs
@DataWarehouse.SDK/MessageBus/IMessageBus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cross-moonshot event wiring (7 wiring classes)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/TagConsciousnessWiring.cs,
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/ComplianceSovereigntyWiring.cs,
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/PlacementCarbonWiring.cs,
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/SyncConsciousnessWiring.cs,
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/TimeLockComplianceWiring.cs,
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/ChaosImmunityWiring.cs,
    Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/FabricPlacementWiring.cs
  </files>
  <action>
Create `Moonshots/CrossMoonshot/` directory. Each wiring class follows a common pattern:
- Constructor: `(IMessageBus messageBus, MoonshotConfiguration config, ILogger logger)`
- `Task RegisterAsync(CancellationToken ct)` -- subscribe to bus topics
- `Task UnregisterAsync()` -- unsubscribe (cleanup)
- All cross-moonshot communication via message bus ONLY (no direct plugin references)

**1. TagConsciousnessWiring.cs**:
- Subscribe to `consciousness.score.completed`
- When a consciousness score is computed for an object, auto-attach system tags:
  - `dw:consciousness:value` = score value (0-100)
  - `dw:consciousness:grade` = grade (Critical/High/Medium/Low/Negligible)
  - `dw:consciousness:liability` = liability score
  - `dw:consciousness:action` = recommended action (Archive/Monitor/Protect/etc.)
- Request `tags.system.attach` with TagSource = System, objectId, tag key/values
- Enabled only if both UniversalTags and DataConsciousness moonshots are enabled in config

**2. ComplianceSovereigntyWiring.cs**:
- Subscribe to `sovereignty.zone.check.completed`
- When sovereignty zone check completes for an object, add sovereignty evidence to its compliance passport:
  - Request `compliance.passport.add-evidence` with objectId, evidence type "SovereigntyZoneCheck", zone ID, decision (Allow/Deny/Redirect), timestamp
- Subscribe to `sovereignty.zone.changed` (zone config updated)
  - Trigger re-evaluation of passports for objects in affected zone: publish `compliance.passport.re-evaluate` with zone filter

**3. PlacementCarbonWiring.cs**:
- Subscribe to `carbon.intensity.updated` (carbon intensity data refreshed)
- When carbon intensity changes significantly (>20% delta), publish `storage.placement.recalculate-batch` with affected storage class
- Subscribe to `carbon.budget.exceeded` (carbon budget threshold crossed)
  - Publish `storage.placement.prefer-renewable` to shift new placements to renewable-powered nodes

**4. SyncConsciousnessWiring.cs**:
- Subscribe to `consciousness.score.completed`
- Map consciousness value score to sync fidelity:
  - Value >= 80: FullFidelity (sync everything, real-time)
  - Value 50-79: StandardFidelity (sync with batch, 5-min delay)
  - Value 20-49: SummaryOnly (sync summaries, not raw data)
  - Value < 20: NoSync (don't sync, archive locally)
- Publish `semanticsync.fidelity.set` with objectId and fidelity level

**5. TimeLockComplianceWiring.cs**:
- Subscribe to `compliance.passport.issued`
- When passport is issued, check regulations for retention requirements:
  - If regulation requires retention (e.g., SOX 7 years, GDPR minimum), compute lock duration
  - Request `tamperproof.timelock.apply` with objectId and computed duration
  - If regulation requires immutability (e.g., SEC 17a-4), set VaccinationLevel to Maximum
- Subscribe to `compliance.passport.expired`
  - Check if time-lock can be released: request `tamperproof.timelock.release-if-eligible` with objectId

**6. ChaosImmunityWiring.cs**:
- Subscribe to `chaos.experiment.completed`
- When a chaos experiment completes with immune memory entry (fault was survived):
  - Publish `sovereignty.zone.resilience.update` with zone, fault type, and survival status
  - This feeds sovereignty zone resilience scoring -- zones that survive more faults get higher resilience scores
- Subscribe to `chaos.immune.memory.created`
  - Publish `moonshot.health.resilience.improved` for dashboard tracking

**7. FabricPlacementWiring.cs**:
- Subscribe to `storage.placement.completed`
- When placement decision is made for an object:
  - Encode placement node into dw:// address: `dw://node@{nodeId}/{objectId}`
  - Request `fabric.namespace.register` with objectId and dw:// address
- Subscribe to `storage.placement.migrated` (object moved to new node)
  - Request `fabric.namespace.update` to update dw:// address to new node

Each wiring class logs subscription/unsubscription, wraps all handlers in try/catch (failures in wiring should not crash the system), and checks moonshot enabled status before processing.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj` -- zero errors. All 7 files exist.</verify>
  <done>7 cross-moonshot event-driven wires connect consciousness-to-tags, sovereignty-to-compliance, carbon-to-placement, consciousness-to-sync, compliance-to-timelocks, chaos-to-sovereignty, and placement-to-fabric.</done>
</task>

<task type="auto">
  <name>Task 2: CrossMoonshotWiringRegistrar</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateDataGovernance/Moonshots/CrossMoonshot/CrossMoonshotWiringRegistrar.cs</files>
  <action>
**CrossMoonshotWiringRegistrar.cs**:
- Constructor: `(IMessageBus messageBus, MoonshotConfiguration config, ILoggerFactory loggerFactory)`
- Private list of all 7 wiring instances
- `async Task RegisterAllAsync(CancellationToken ct)`:
  1. Create each wiring instance with messageBus, config, and logger
  2. For each wiring: check if BOTH involved moonshots are enabled in config
  3. If both enabled: call `RegisterAsync(ct)`, log "Registered {WiringName}"
  4. If either disabled: log info "Skipping {WiringName} -- {MoonshotId} is disabled"
  5. Store registered wirings for cleanup
- `async Task UnregisterAllAsync()`:
  1. For each registered wiring: call `UnregisterAsync()`
  2. Log summary: "Unregistered {count} cross-moonshot wirings"
- `IReadOnlyList<string> GetActiveWirings()` -- returns names of currently active wirings (for dashboard/diagnostics)

This registrar is called during UltimateDataGovernance plugin initialization, after all moonshot plugins have registered their bus handlers.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj` -- zero errors.</verify>
  <done>Registrar activates cross-moonshot wires based on which moonshots are enabled. Disabled moonshots result in skipped wires.</done>
</task>

</tasks>

<verification>
- `dotnet build Plugins/DataWarehouse.Plugins.UltimateDataGovernance/DataWarehouse.Plugins.UltimateDataGovernance.csproj` -- zero errors
- 8 files exist in CrossMoonshot/
- Each wiring connects exactly 2 moonshots via bus events
- Registrar skips wirings for disabled moonshots
</verification>

<success_criteria>
Cross-moonshot event-driven interactions work bidirectionally. Tags reflect consciousness scores. Compliance incorporates sovereignty. Placement considers carbon. Fabric addresses track placement. All wiring is conditional on moonshot enabled status.
</success_criteria>

<output>
After completion, create `.planning/phases/64-moonshot-wiring/64-06-SUMMARY.md`
</output>
