---
phase: 12-aeds-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/WebSocketControlPlanePlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/MqttControlPlanePlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/GrpcControlPlanePlugin.cs
autonomous: true

user_setup:
  - service: mqtt_broker
    why: "MQTT control plane requires broker for pub/sub messaging"
    env_vars:
      - name: AEDS_MQTT_BROKER_URL
        source: "MQTT broker connection string (e.g., mqtt://localhost:1883 or cloud MQTT service)"
    dashboard_config:
      - task: "Install MQTT broker (optional for local testing)"
        location: "Mosquitto, EMQX, or cloud MQTT service (AWS IoT Core, Azure IoT Hub, HiveMQ Cloud)"
      - task: "Create AEDS topic for manifest distribution"
        location: "MQTT broker ACL configuration"

must_haves:
  truths:
    - "WebSocket control plane maintains persistent connection with heartbeat expiry"
    - "MQTT control plane publishes/subscribes to manifest topics with QoS 1"
    - "gRPC control plane streams manifests bidirectionally with cancellation support"
    - "All 3 transports implement IControlPlaneTransport with async enumerable manifest receiving"
    - "Reconnection logic with exponential backoff prevents connection storms"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/WebSocketControlPlanePlugin.cs"
      provides: "WebSocket persistent connection, manifest send/receive, heartbeat"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/MqttControlPlanePlugin.cs"
      provides: "MQTT pub/sub, QoS levels, topic subscription, persistent sessions"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/GrpcControlPlanePlugin.cs"
      provides: "gRPC bidirectional streaming, deadline propagation, channel management"
      min_lines: 200
  key_links:
    - from: "WebSocketControlPlanePlugin.EstablishConnectionAsync"
      to: "System.Net.WebSockets.ClientWebSocket"
      via: "native .NET WebSocket client"
      pattern: "ClientWebSocket.*ConnectAsync"
    - from: "MqttControlPlanePlugin.EstablishConnectionAsync"
      to: "MQTTnet.Client.MqttClient"
      via: "MQTTnet library"
      pattern: "MqttFactory.*CreateMqttClient"
    - from: "GrpcControlPlanePlugin.ListenForManifestsAsync"
      to: "Grpc.Net.Client streaming"
      via: "gRPC streaming RPC"
      pattern: "StreamingCall.*ResponseStream"
---

<objective>
Implement 3 Control Plane transport plugins (WebSocket, MQTT, gRPC streaming) for low-bandwidth signaling in AEDS, enabling persistent connections for manifest distribution and heartbeat monitoring.

Purpose: Provide multiple control plane options for different deployment scenarios (WebSocket for web, MQTT for IoT/edge, gRPC for high-performance RPC)
Output: 3 production-ready Control Plane transport plugins with reconnection logic and heartbeat management
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-aeds-system/12-RESEARCH.md

# AEDS SDK contracts
@DataWarehouse.SDK/Distribution/IAedsCore.cs
@DataWarehouse.SDK/Contracts/AedsPluginBases.cs

# Reference existing patterns
@Plugins/DataWarehouse.Plugins.AedsCore/Http2DataPlanePlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WebSocketControlPlanePlugin</name>
  <files>Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/WebSocketControlPlanePlugin.cs</files>
  <action>
Create `Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/WebSocketControlPlanePlugin.cs` with production-ready WebSocket control plane transport.

**Inherit from:** `ControlPlaneTransportPluginBase` (from AedsPluginBases.cs)

**TransportId:** `"websocket"`

**Implementation requirements:**

1. **EstablishConnectionAsync:**
   - Use `System.Net.WebSockets.ClientWebSocket` (native .NET 9, no external package)
   - Connect to `config.ServerUrl` (e.g., `wss://server.example.com/aeds/control`)
   - Set `Authorization` header with `config.AuthToken` if provided
   - After connection, start background heartbeat task (interval from `config.HeartbeatInterval`)
   - Start background receive loop listening for manifests
   - Implement exponential backoff reconnection: 1s, 2s, 4s, 8s, 16s, max 32s on disconnection

2. **TransmitManifestAsync:**
   - Serialize `IntentManifest` to JSON using `System.Text.Json`
   - Send as WebSocket text message
   - Throw `InvalidOperationException` if not connected

3. **ListenForManifestsAsync:**
   - Yield manifests received from WebSocket as `IAsyncEnumerable<IntentManifest>`
   - Use `System.Threading.Channels.Channel<IntentManifest>` for buffering received manifests
   - Deserialize JSON text messages to `IntentManifest`
   - Log and skip invalid messages (don't crash on malformed JSON)

4. **TransmitHeartbeatAsync:**
   - Serialize `HeartbeatMessage` to JSON
   - Send as WebSocket text message
   - Track last heartbeat sent timestamp for client-side timeout detection

5. **JoinChannelAsync / LeaveChannelAsync:**
   - Send control message: `{"type": "subscribe", "channelId": "..."}` / `{"type": "unsubscribe", "channelId": "..."}`
   - Server responds with acknowledgment (not awaited, fire-and-forget)

6. **CloseConnectionAsync:**
   - Cancel heartbeat task and receive loop
   - Call `ClientWebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure)`
   - Dispose WebSocket client

**Error handling:**
- Catch `WebSocketException` on send/receive → trigger reconnection
- Log all connection state transitions (Connected, Disconnected, Reconnecting)
- Implement heartbeat expiry: if no message received for 90 seconds, reconnect

**Threading:**
- Use `SemaphoreSlim` to protect send operations (WebSocket is not thread-safe for concurrent sends)
- Background tasks use `CancellationTokenSource` for clean shutdown

**No forbidden patterns:** Zero TODOs, zero NotImplementedException, zero placeholders.
  </action>
  <verify>
Build plugin: `dotnet build Plugins/DataWarehouse.Plugins.AedsCore/DataWarehouse.Plugins.AedsCore.csproj`
- Expect: 0 errors, 0 warnings
Grep for violations: `rg "TODO|NotImplementedException|simulate|placeholder" Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/WebSocketControlPlanePlugin.cs`
- Expect: 0 matches
Check base class usage: `rg "class WebSocketControlPlanePlugin.*ControlPlaneTransportPluginBase" Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/WebSocketControlPlanePlugin.cs`
- Expect: Correct inheritance
  </verify>
  <done>
WebSocketControlPlanePlugin.cs exists with production-ready WebSocket transport:
- Persistent connection with reconnection logic (exponential backoff)
- Heartbeat monitoring with 90-second timeout
- Async enumerable manifest receiving via Channel buffering
- Channel subscription via control messages
- Clean shutdown with cancellation token propagation
- Zero forbidden patterns (no TODOs, no stubs)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement MqttControlPlanePlugin and GrpcControlPlanePlugin</name>
  <files>
    Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/MqttControlPlanePlugin.cs
    Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/GrpcControlPlanePlugin.cs
  </files>
  <action>
Create 2 additional Control Plane transport plugins.

---

**MQTT Control Plane Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/MqttControlPlanePlugin.cs`

**Inherit from:** `ControlPlaneTransportPluginBase`

**TransportId:** `"mqtt"`

**Package:** MQTTnet 4.x (add to .csproj: `<PackageReference Include="MQTTnet" Version="4.*" />`)

**Implementation:**

1. **EstablishConnectionAsync:**
   - Use `MqttFactory().CreateMqttClient()`
   - Build connection options: server from `config.ServerUrl`, client ID from `config.ClientId`, credentials if provided
   - Enable persistent sessions with clean session = false
   - Set keep alive interval to `config.HeartbeatInterval`
   - Connect with `ConnectAsync(options, ct)`
   - Subscribe to personal topic: `aeds/client/{clientId}/manifests` (QoS 1)
   - Start heartbeat publishing loop (publish to `aeds/heartbeat/{clientId}`)

2. **TransmitManifestAsync:**
   - Serialize manifest to JSON
   - Publish to target topics: For broadcast → `aeds/channel/{channelId}`, for unicast → `aeds/client/{targetId}/manifests`
   - Use QoS 1 (at least once delivery)

3. **ListenForManifestsAsync:**
   - Buffer received messages via `Channel<IntentManifest>`
   - In MQTT message handler (ApplicationMessageReceivedAsync event), deserialize and write to channel
   - Yield from channel reader

4. **TransmitHeartbeatAsync:**
   - Publish heartbeat JSON to `aeds/heartbeat/{clientId}` topic (QoS 0 for performance)

5. **JoinChannelAsync / LeaveChannelAsync:**
   - Subscribe to `aeds/channel/{channelId}` topic (QoS 1)
   - Unsubscribe from topic

6. **CloseConnectionAsync:**
   - Unsubscribe from all topics
   - Disconnect with `DisconnectAsync()`
   - Dispose MQTT client

**Error handling:** MQTTnet handles reconnection automatically if `AutoReconnect = true` in options. Log disconnection events.

---

**gRPC Control Plane Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/GrpcControlPlanePlugin.cs`

**Inherit from:** `ControlPlaneTransportPluginBase`

**TransportId:** `"grpc"`

**Package:** Grpc.Net.Client 2.x (add to .csproj: `<PackageReference Include="Grpc.Net.Client" Version="2.*" />`)

**Implementation:**

1. **EstablishConnectionAsync:**
   - Create `GrpcChannel.ForAddress(config.ServerUrl)`
   - Create gRPC client stub (assume proto service `AedsControlPlane` with `StreamManifests` bidirectional streaming RPC)
   - Call `client.StreamManifests()` to establish bidirectional stream
   - Store `DuplexStreamingCall<ControlMessage, IntentManifest>` for send/receive
   - Start heartbeat send loop (send heartbeat messages to request stream)

2. **TransmitManifestAsync:**
   - Serialize manifest to protobuf `IntentManifestProto`
   - Write to gRPC request stream: `call.RequestStream.WriteAsync(manifestProto, ct)`

3. **ListenForManifestsAsync:**
   - Read from gRPC response stream: `await foreach (var manifestProto in call.ResponseStream.ReadAllAsync(ct))`
   - Deserialize protobuf to `IntentManifest` and yield

4. **TransmitHeartbeatAsync:**
   - Write heartbeat message to request stream

5. **JoinChannelAsync / LeaveChannelAsync:**
   - Send subscription control message to request stream

6. **CloseConnectionAsync:**
   - Complete request stream: `call.RequestStream.CompleteAsync()`
   - Dispose gRPC call
   - Shutdown GrpcChannel

**Proto stub:** For this phase, use JSON-over-gRPC instead of protobuf (simpler, no proto compilation). Send JSON strings as `bytes` in generic message wrapper.

**Error handling:** Catch `RpcException`, check status code (Unavailable → reconnect, Cancelled → clean shutdown)

---

**Common for both:**
- Zero TODOs, zero NotImplementedException
- Reconnection logic with exponential backoff (MQTT has built-in, gRPC needs manual retry)
- Heartbeat monitoring
- Channel buffering for async enumerable
  </action>
  <verify>
Build solution: `dotnet build Plugins/DataWarehouse.Plugins.AedsCore/DataWarehouse.Plugins.AedsCore.csproj`
- Expect: 0 errors
Check package references: `rg "PackageReference.*MQTTnet|Grpc.Net.Client" Plugins/DataWarehouse.Plugins.AedsCore/DataWarehouse.Plugins.AedsCore.csproj`
- Expect: Both packages added
Grep for violations: `rg "TODO|NotImplementedException" Plugins/DataWarehouse.Plugins.AedsCore/ControlPlane/`
- Expect: 0 matches
  </verify>
  <done>
2 additional Control Plane transports implemented:
- MqttControlPlanePlugin.cs: MQTT pub/sub with QoS 1, persistent sessions, auto-reconnect
- GrpcControlPlanePlugin.cs: gRPC bidirectional streaming with JSON-over-gRPC, manual reconnection
Both plugins inherit from ControlPlaneTransportPluginBase, implement all abstract methods, and have zero forbidden patterns.
  </done>
</task>

</tasks>

<verification>
- [ ] Build passes for AedsCore plugin project with 0 errors
- [ ] 3 Control Plane transport files exist in ControlPlane/ subfolder
- [ ] All 3 plugins inherit from ControlPlaneTransportPluginBase
- [ ] MQTTnet and Grpc.Net.Client packages added to .csproj
- [ ] Zero TODOs, NotImplementedException, or placeholders in any Control Plane plugin
- [ ] Reconnection logic implemented (WebSocket/gRPC manual, MQTT auto)
- [ ] Heartbeat monitoring with expiry detection (90 seconds)
</verification>

<success_criteria>
Phase 12 Plan 02 succeeds when:
1. 3 Control Plane transport plugins implemented (WebSocket, MQTT, gRPC)
2. All inherit from ControlPlaneTransportPluginBase and override abstract methods
3. Each transport uses recommended library (System.Net.WebSockets, MQTTnet 4.x, Grpc.Net.Client 2.x)
4. Persistent connections with reconnection logic (exponential backoff)
5. Heartbeat monitoring with 90-second timeout
6. Async enumerable manifest receiving via Channel<IntentManifest> buffering
7. Channel subscription/unsubscription implemented
8. Zero forbidden patterns (Rule 13 compliant)
9. Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-aeds-system/12-02-SUMMARY.md` with:
- 3 Control Plane transports implemented (WebSocket, MQTT, gRPC)
- Transport selection guidance (WebSocket for web, MQTT for IoT/edge, gRPC for RPC-heavy workloads)
- Reconnection strategies (exponential backoff intervals)
- Package dependencies (MQTTnet 4.x, Grpc.Net.Client 2.x)
</output>
