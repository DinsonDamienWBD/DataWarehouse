---
phase: 12-aeds-system
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/SwarmIntelligencePlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/DeltaSyncPlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PreCogPlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/MulePlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/GlobalDeduplicationPlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/NotificationPlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/CodeSigningPlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PolicyEnginePlugin.cs
  - Plugins/DataWarehouse.Plugins.AedsCore/Extensions/ZeroTrustPairingPlugin.cs
  - Metadata/TODO.md
autonomous: true

must_haves:
  truths:
    - "SwarmIntelligencePlugin coordinates P2P mesh distribution with peer discovery"
    - "DeltaSyncPlugin computes binary diffs for bandwidth-efficient updates"
    - "PreCogPlugin prefetches content using heuristics and AI predictions"
    - "MulePlugin integrates with tri-mode USB (T79) for air-gap manifest transport"
    - "GlobalDeduplicationPlugin tracks content hashes across clients to avoid duplicate transfers"
    - "NotificationPlugin delivers toast/modal notifications per NotificationTier"
    - "CodeSigningPlugin verifies release key signatures for Execute action"
    - "PolicyEnginePlugin evaluates client-side policy rules (network type, trust level, file size)"
    - "ZeroTrustPairingPlugin implements PIN-based client registration flow"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/SwarmIntelligencePlugin.cs"
      provides: "P2P mesh coordination, peer discovery, server-assisted peer list"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/DeltaSyncPlugin.cs"
      provides: "Binary diff computation (rsync algorithm), delta application"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PreCogPlugin.cs"
      provides: "Predictive prefetch with heuristics + AI delegation"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/MulePlugin.cs"
      provides: "Air-gap USB transport integration with tri-mode USB plugin"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/GlobalDeduplicationPlugin.cs"
      provides: "Content hash tracking, bloom filter for dedup checks"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/NotificationPlugin.cs"
      provides: "Toast/modal notifications with platform-specific rendering"
      min_lines: 100
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/CodeSigningPlugin.cs"
      provides: "Release key verification, certificate chain validation"
      min_lines: 150
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PolicyEnginePlugin.cs"
      provides: "Policy rule evaluation, condition parsing, action determination"
      min_lines: 200
    - path: "Plugins/DataWarehouse.Plugins.AedsCore/Extensions/ZeroTrustPairingPlugin.cs"
      provides: "PIN generation, client registration, trust elevation flow"
      min_lines: 100
  key_links:
    - from: "SwarmIntelligencePlugin.GetPeerListAsync"
      to: "ServerDispatcherPlugin"
      via: "message bus to request peer list"
      pattern: "messageBus.PublishAsync.*GetPeerList"
    - from: "PreCogPlugin.PredictContentAsync"
      to: "UniversalIntelligence (T90)"
      via: "message bus for AI prediction"
      pattern: "messageBus.PublishAsync.*intelligence.predict"
    - from: "MulePlugin.ExportManifestsAsync"
      to: "AirGapBridgePlugin (T79)"
      via: "message bus for USB write"
      pattern: "messageBus.PublishAsync.*airgap.export"
    - from: "CodeSigningPlugin.VerifyReleaseKeyAsync"
      to: "UltimateKeyManagement (T94)"
      via: "message bus for key retrieval"
      pattern: "messageBus.PublishAsync.*keymanagement.verify"
    - from: "PolicyEnginePlugin.EvaluateAsync"
      to: "IClientPolicyEngine interface"
      via: "implements IClientPolicyEngine"
      pattern: "class.*PolicyEnginePlugin.*IClientPolicyEngine"
---

<objective>
Implement 9 AEDS extension plugins that enhance distribution capabilities: swarm intelligence (P2P mesh), delta sync, PreCog (predictive prefetch), mule (air-gap transport), global deduplication, notifications, code signing, policy engine, zero-trust pairing.

Purpose: Complete the AEDS ecosystem with advanced features for bandwidth optimization, security, and edge distribution
Output: 9 production-ready extension plugins integrated with core AEDS infrastructure
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-aeds-system/12-RESEARCH.md

# AEDS SDK contracts
@DataWarehouse.SDK/Distribution/IAedsCore.cs
@DataWarehouse.SDK/Contracts/AedsPluginBases.cs

# Prior plan SUMMARYs (if needed for integration)
@.planning/phases/03-security-infrastructure/03-02-SUMMARY.md  # UltimateKeyManagement
@.planning/phases/10-advanced-storage-features/10-01-SUMMARY.md  # Tri-mode USB (T79)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SwarmIntelligencePlugin and DeltaSyncPlugin</name>
  <files>
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/SwarmIntelligencePlugin.cs
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/DeltaSyncPlugin.cs
  </files>
  <action>
Create 2 bandwidth-optimization extension plugins.

---

**Swarm Intelligence Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/SwarmIntelligencePlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** P2P mesh distribution - clients download from peers instead of central server to reduce bandwidth

**Implementation:**

1. **GetPeerListAsync(string payloadId, CancellationToken ct):**
   - Publish message to server via message bus: `{"topic": "aeds.get-peers", "payload": {"payloadId": "..."}}`
   - Server (ServerDispatcherPlugin) responds with list of clients that have the payload
   - Return `List<PeerInfo>` with peer addresses and availability status
   - Server-coordinated P2P (not DHT-based for simplicity)

2. **DownloadFromPeersAsync(string payloadId, List<PeerInfo> peers, DataPlaneConfig config, IProgress<TransferProgress>? progress, CancellationToken ct):**
   - Split payload into chunks (1 MB each)
   - Assign chunks to peers in round-robin
   - Download chunks concurrently (max 4 concurrent peer connections)
   - Reassemble chunks in correct order
   - Verify per-chunk hashes from `PayloadDescriptor.ChunkHashes`
   - Fallback to server if peer download fails

3. **AnnouncePeerAvailability(string payloadId, bool available):**
   - Publish message to server: `{"topic": "aeds.peer-announce", "payload": {"payloadId": "...", "available": true}}`
   - Server updates peer availability registry

**Capability check:** Only activate if `ClientCapabilities.P2PMesh` is enabled.

---

**Delta Sync Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/DeltaSyncPlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** Bandwidth optimization via binary diff - only transfer changed bytes

**Implementation:**

1. **ComputeDeltaAsync(string payloadId, string baseVersion, CancellationToken ct):**
   - Use rsync rolling hash algorithm for content-defined chunking
   - Compute diff between base version and new version
   - Return delta descriptor: `{"addedChunks": [...], "removedChunks": [...], "modifiedChunks": [...]}`
   - Use SharpCompress or custom implementation (SharpCompress is already in STACK.md)

2. **ApplyDeltaAsync(Stream baseStream, Stream deltaStream, CancellationToken ct):**
   - Read delta instructions from deltaStream
   - Apply changes to baseStream in-memory
   - Return reconstructed stream
   - Verify final hash matches target `PayloadDescriptor.ContentHash`

3. **IsWorthwhileAsync(long baseSize, long targetSize, long deltaSize):**
   - Return true if deltaSize < (targetSize * 0.5) — delta is worthwhile if <50% of full size
   - Used by ClientCourierPlugin to decide full vs delta download

**Capability check:** Only activate if `ClientCapabilities.DeltaSync` is enabled.

**Algorithms:**
- Rsync rolling hash: Adler-32 checksum with sliding window (chunk size 1 KB)
- Signature: Array of chunk hashes
- Delta: Instructions (copy from base offset, or insert new bytes)

---

**Common for both:**
- Zero TODOs, zero NotImplementedException
- Message bus integration for server communication
- Graceful degradation if server doesn't support P2P or delta
  </action>
  <verify>
Build solution: `dotnet build Plugins/DataWarehouse.Plugins.AedsCore/DataWarehouse.Plugins.AedsCore.csproj`
- Expect: 0 errors
Grep for violations: `rg "TODO|NotImplementedException|simulate" Plugins/DataWarehouse.Plugins.AedsCore/Extensions/SwarmIntelligencePlugin.cs Plugins/DataWarehouse.Plugins.AedsCore/Extensions/DeltaSyncPlugin.cs`
- Expect: 0 matches
Check message bus usage: `rg "messageBus.PublishAsync.*aeds\\.get-peers|aeds\\.peer-announce" Plugins/DataWarehouse.Plugins.AedsCore/Extensions/SwarmIntelligencePlugin.cs`
- Expect: Server communication via message bus
  </verify>
  <done>
2 bandwidth-optimization extensions implemented:
- SwarmIntelligencePlugin.cs: P2P mesh with server-assisted peer discovery, chunked peer downloads, peer availability announcements
- DeltaSyncPlugin.cs: Rsync rolling hash delta computation, delta application, worthwhile threshold check (50%)
Both plugins check client capabilities before activation and degrade gracefully if server doesn't support features.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement PreCogPlugin, MulePlugin, GlobalDeduplicationPlugin, NotificationPlugin</name>
  <files>
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PreCogPlugin.cs
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/MulePlugin.cs
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/GlobalDeduplicationPlugin.cs
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/NotificationPlugin.cs
  </files>
  <action>
Create 4 feature extension plugins.

---

**PreCog Plugin (Predictive Prefetch):**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PreCogPlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** Prefetch content before explicit manifest received using heuristics + AI

**Implementation:**

1. **PredictContentAsync(Dictionary<string, object> context, CancellationToken ct):**
   - Context includes: time of day, user ID, recent downloads, client capabilities
   - **Heuristic fallback:** Time-of-day patterns (e.g., software updates at 2 AM), historical download frequency
   - **AI delegation:** Publish to UniversalIntelligence (T90) via message bus: `{"topic": "intelligence.predict", "payload": {"context": ...}}`
   - AI returns predicted payloadIds with confidence scores
   - Return `List<PredictedContent>` sorted by confidence

2. **PrefetchAsync(string payloadId, CancellationToken ct):**
   - Download payload silently in background (ActionPrimitive.Passive)
   - Store in local cache
   - Log prefetch event for future pattern learning

3. **LearnFromDownload(string payloadId, DateTimeOffset timestamp, bool wasUseful):**
   - Record download pattern for heuristic improvement
   - If AI-predicted → send feedback to intelligence plugin

**Fallback:** If UniversalIntelligence unavailable, use heuristic-only mode (time-of-day + historical frequency).

---

**Mule Plugin (Air-Gap USB Transport):**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/MulePlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** Transfer manifests + payloads via USB for air-gapped networks

**Implementation:**

1. **ExportManifestsAsync(string[] manifestIds, string usbMountPath, CancellationToken ct):**
   - Serialize manifests to JSON
   - Write to `{usbMountPath}/.aeds/manifests/{manifestId}.json`
   - Copy payload files to `{usbMountPath}/.aeds/payloads/{payloadId}.bin`
   - Write index: `{usbMountPath}/.aeds/index.json` with list of manifests + payloads
   - Integrate with Tri-mode USB plugin (T79) via message bus: `{"topic": "airgap.export", "payload": {"path": "...", "manifestIds": [...]}}`

2. **ImportManifestsAsync(string usbMountPath, CancellationToken ct):**
   - Read index from USB
   - Deserialize manifests
   - Import payloads to local cache
   - Publish to ServerDispatcherPlugin: "Manifests received from mule"

3. **ValidateMuleIntegrity(string usbMountPath):**
   - Verify manifest signatures
   - Check payload ContentHashes
   - Return validation report

**Capability check:** Only activate if `ClientCapabilities.AirGapMule` is enabled.

---

**Global Deduplication Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/GlobalDeduplicationPlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** Track content hashes across all clients to avoid duplicate downloads

**Implementation:**

1. **CheckIfExistsLocally(string contentHash, CancellationToken ct):**
   - Query local bloom filter or hash index
   - Return true if content already downloaded by ANY client in network

2. **QueryServerForDedup(string contentHash, CancellationToken ct):**
   - Publish to server: `{"topic": "aeds.dedup-check", "payload": {"contentHash": "..."}}`
   - Server responds with list of clients that have content → enables P2P retrieval

3. **RegisterContentHash(string contentHash, string payloadId):**
   - Add to local bloom filter
   - Publish to server: "Client {clientId} now has content {contentHash}"

**Bloom filter:** Use `BloomFilter` from probabilistic storage (T85) if available, or implement simple hash set.

**Memory efficiency:** Bloom filter with 0.01% false positive rate for 100K entries → ~120 KB memory.

---

**Notification Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/NotificationPlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** Deliver toast/modal notifications per NotificationTier

**Implementation:**

1. **ShowNotificationAsync(IntentManifest manifest, CancellationToken ct):**
   - Read `manifest.NotificationTier`
   - Render notification:
     - **Silent:** Log only, no UI
     - **Toast:** Transient popup (Windows: toast notification API, Linux: libnotify, macOS: NSUserNotification)
     - **Modal:** Persistent dialog requiring acknowledgment

2. **Platform-specific rendering:**
   - Windows: Use `Microsoft.Toolkit.Uwp.Notifications` for toast (already in ecosystem if GUI uses MAUI)
   - Linux: Call `notify-send` via Process.Start
   - macOS: Call `osascript` for AppleScript notification
   - Cross-platform fallback: Console output with beep

3. **AcknowledgeNotification(string manifestId, bool userApproved):**
   - Record user response
   - If modal requires approval → return PolicyAction.Allow or Deny

**Capability check:** Only activate if `ClientCapabilities.ReceiveNotify` is enabled.

---

**Common for all 4:**
- Zero TODOs, zero NotImplementedException
- Graceful degradation when dependencies unavailable
- Message bus integration where needed
  </action>
  <verify>
Build solution: `dotnet build Plugins/DataWarehouse.Plugins.AedsCore/DataWarehouse.Plugins.AedsCore.csproj`
- Expect: 0 errors
Grep for violations: `rg "TODO|NotImplementedException" Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PreCogPlugin.cs Plugins/DataWarehouse.Plugins.AedsCore/Extensions/MulePlugin.cs Plugins/DataWarehouse.Plugins.AedsCore/Extensions/GlobalDeduplicationPlugin.cs Plugins/DataWarehouse.Plugins.AedsCore/Extensions/NotificationPlugin.cs`
- Expect: 0 matches
Check intelligence delegation: `rg "intelligence.predict" Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PreCogPlugin.cs`
- Expect: Message bus call to UniversalIntelligence
  </verify>
  <done>
4 feature extensions implemented:
- PreCogPlugin.cs: Predictive prefetch with heuristics + AI delegation, pattern learning
- MulePlugin.cs: Air-gap USB export/import with tri-mode USB integration, manifest + payload packaging
- GlobalDeduplicationPlugin.cs: Bloom filter-based dedup checking, server coordination for P2P retrieval
- NotificationPlugin.cs: Platform-specific toast/modal notifications (Windows/Linux/macOS)
All plugins check client capabilities and degrade gracefully if dependencies unavailable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement CodeSigningPlugin, PolicyEnginePlugin, ZeroTrustPairingPlugin, update TODO.md</name>
  <files>
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/CodeSigningPlugin.cs
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PolicyEnginePlugin.cs
    Plugins/DataWarehouse.Plugins.AedsCore/Extensions/ZeroTrustPairingPlugin.cs
    Metadata/TODO.md
  </files>
  <action>
Create 3 final security/policy extension plugins, then update TODO.md.

---

**Code Signing Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/CodeSigningPlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** Verify release key signatures for Execute action (critical security control)

**Implementation:**

1. **VerifyReleaseKeyAsync(IntentManifest manifest, CancellationToken ct):**
   - Extract signature from `manifest.Signature`
   - Validate `IsReleaseKey == true`
   - Retrieve public key from UltimateKeyManagement (T94) via message bus: `{"topic": "keymanagement.get-key", "payload": {"keyId": "..."}}`
   - Verify signature using algorithm specified (Ed25519, RSA-PSS-SHA256, ECDSA-P256-SHA256)
   - If certificate chain provided → validate chain to trusted root
   - Return `VerificationResult { Valid: bool, Reason: string, KeyDetails: KeyInfo }`

2. **Supported algorithms:**
   - **Ed25519:** Use `System.Security.Cryptography.Ed25519` (.NET 9 built-in)
   - **RSA-PSS-SHA256:** Use `RSA.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pss)`
   - **ECDSA-P256-SHA256:** Use `ECDsa.VerifyData(data, signature, HashAlgorithmName.SHA256)`

3. **ValidateCertificateChain(string[] certificateChain):**
   - Parse X.509 certificates from Base64 strings
   - Build chain from leaf to root
   - Verify each certificate signed by next in chain
   - Check root certificate is in trusted store

**Security:** This plugin enforces Execute action gating → MUST NOT allow unsigned Execute manifests.

---

**Policy Engine Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PolicyEnginePlugin.cs`

**Inherit from:** `FeaturePluginBase` and implements `IClientPolicyEngine`

**Purpose:** Client-side policy evaluation for controlling behavior (network type, trust level, file size limits)

**Implementation:**

1. **EvaluateAsync(IntentManifest manifest, PolicyContext context):**
   - Load policy rules from configuration
   - Evaluate each rule condition against context
   - Return `PolicyDecision { Allowed: bool, Reason: string, RequiredAction: PolicyAction }`

2. **Policy rule condition parsing:**
   - Simple expression evaluator: `"Priority > 80 AND NetworkType != Metered"`
   - Supported operators: `==`, `!=`, `>`, `<`, `>=`, `<=`, `AND`, `OR`, `NOT`
   - Supported variables: `Priority`, `FileSizeBytes`, `NetworkType`, `SourceTrustLevel`, `IsPeer`

3. **LoadPolicyAsync(string policyPath):**
   - Read JSON policy file with rule array
   - Parse rules into internal data structure
   - Validate rule syntax

4. **AddRule(PolicyRule rule):**
   - Programmatically add rule
   - Rules evaluated in order until first match

**Default policies:**
- "Execute action requires Trusted or higher" → Deny if `Action == Execute AND SourceTrustLevel < Trusted`
- "Block large downloads on metered networks" → Deny if `FileSizeBytes > 100_000_000 AND NetworkType == Metered`
- "Always allow critical priority" → Allow if `Priority >= 90`

---

**Zero-Trust Pairing Plugin:**

File: `Plugins/DataWarehouse.Plugins.AedsCore/Extensions/ZeroTrustPairingPlugin.cs`

**Inherit from:** `FeaturePluginBase`

**Purpose:** PIN-based client registration and trust elevation flow

**Implementation:**

1. **GeneratePairingPIN():**
   - Generate 6-digit PIN using cryptographically secure random: `RandomNumberGenerator.GetInt32(100000, 999999)`
   - Display to user (console or GUI)
   - PIN valid for 5 minutes

2. **RegisterClientAsync(string clientName, ClientCapabilities capabilities, CancellationToken ct):**
   - Generate client key pair (Ed25519 or RSA 2048-bit)
   - Create `ClientRegistration` with public key, PIN, capabilities
   - Send to server via message bus: `{"topic": "aeds.register-client", "payload": {...}}`
   - Server responds with `AedsClient` (TrustLevel = PendingVerification)

3. **ElevateTrustAsync(string clientId, string adminVerifiedPIN, ClientTrustLevel newLevel, CancellationToken ct):**
   - Admin verifies PIN (out-of-band: phone call, in-person, etc.)
   - Admin calls this method with verified PIN
   - Publish to server: `{"topic": "aeds.elevate-trust", "payload": {"clientId": "...", "pin": "...", "newLevel": "Trusted"}}`
   - Server validates PIN matches registration → updates trust level

4. **VerifyPairing(string clientId):**
   - Check if client trust level >= Trusted
   - Return pairing status

**Security:** PIN provides out-of-band verification. Never transmit PIN over control plane without TLS.

---

**Update TODO.md:**

After all 9 extensions implemented, update `Metadata/TODO.md`:

Find Task 60 (AEDS Core Infrastructure) and update sub-tasks:

- [x] AEDS.X1: SwarmIntelligencePlugin (P2P mesh distribution)
- [x] AEDS.X2: DeltaSyncPlugin (binary diff sync)
- [x] AEDS.X3: PreCogPlugin (predictive prefetch)
- [x] AEDS.X4: MulePlugin (air-gap USB transport)
- [x] AEDS.X5: GlobalDeduplicationPlugin (cross-client dedup)
- [x] AEDS.X6: NotificationPlugin (toast/modal notifications)
- [x] AEDS.X7: CodeSigningPlugin (release key verification)
- [x] AEDS.X8: PolicyEnginePlugin (client-side policy evaluation)
- [x] AEDS.X9: ZeroTrustPairingPlugin (PIN-based registration)

Add completion timestamp:
`**Phase 12 verified:** 2026-02-11 - All 9 AEDS extensions production-ready (12-04-SUMMARY.md)`
  </action>
  <verify>
Build solution: `dotnet build Plugins/DataWarehouse.Plugins.AedsCore/DataWarehouse.Plugins.AedsCore.csproj`
- Expect: 0 errors
Grep for violations: `rg "TODO|NotImplementedException" Plugins/DataWarehouse.Plugins.AedsCore/Extensions/CodeSigningPlugin.cs Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PolicyEnginePlugin.cs Plugins/DataWarehouse.Plugins.AedsCore/Extensions/ZeroTrustPairingPlugin.cs`
- Expect: 0 matches
Check IClientPolicyEngine implementation: `rg "class PolicyEnginePlugin.*IClientPolicyEngine" Plugins/DataWarehouse.Plugins.AedsCore/Extensions/PolicyEnginePlugin.cs`
- Expect: Correct interface implementation
Check TODO.md: `rg "AEDS.X[1-9].*\[x\]" Metadata/TODO.md`
- Expect: All 9 extension sub-tasks marked complete
  </verify>
  <done>
3 final security/policy extensions implemented:
- CodeSigningPlugin.cs: Release key verification with Ed25519/RSA-PSS/ECDSA support, certificate chain validation
- PolicyEnginePlugin.cs: Client-side policy rule evaluation with expression parser, default policies (metered network blocking, trust level gating)
- ZeroTrustPairingPlugin.cs: 6-digit PIN generation, client registration, trust elevation flow
TODO.md updated with all 9 AEDS extension sub-tasks marked [x] Complete with timestamp.
  </done>
</task>

</tasks>

<verification>
- [ ] Build passes for AedsCore plugin project with 0 errors
- [ ] 9 extension plugin files exist in Extensions/ subfolder
- [ ] All 9 plugins inherit from FeaturePluginBase
- [ ] SwarmIntelligencePlugin and DeltaSyncPlugin optimize bandwidth
- [ ] PreCogPlugin delegates to UniversalIntelligence with heuristic fallback
- [ ] MulePlugin integrates with tri-mode USB via message bus
- [ ] GlobalDeduplicationPlugin uses bloom filter for memory efficiency
- [ ] NotificationPlugin supports Windows/Linux/macOS platforms
- [ ] CodeSigningPlugin enforces release key verification for Execute action
- [ ] PolicyEnginePlugin implements IClientPolicyEngine with expression evaluator
- [ ] ZeroTrustPairingPlugin generates cryptographically secure PINs
- [ ] TODO.md shows all 9 AEDS extension sub-tasks marked [x]
- [ ] Zero TODOs, NotImplementedException, or placeholders in any extension
</verification>

<success_criteria>
Phase 12 Plan 04 succeeds when:
1. 9 AEDS extension plugins implemented in Extensions/ subfolder
2. Bandwidth optimization: SwarmIntelligencePlugin (P2P mesh), DeltaSyncPlugin (rsync diffs)
3. Predictive features: PreCogPlugin (heuristics + AI delegation to T90)
4. Air-gap support: MulePlugin (USB export/import with T79 integration)
5. Deduplication: GlobalDeduplicationPlugin (bloom filter, server coordination)
6. User experience: NotificationPlugin (toast/modal with platform-specific rendering)
7. Security: CodeSigningPlugin (release key verification with Ed25519/RSA/ECDSA), ZeroTrustPairingPlugin (PIN registration)
8. Policy: PolicyEnginePlugin (expression evaluator, default policies)
9. All extensions check client capabilities and degrade gracefully
10. Zero forbidden patterns (Rule 13 compliant)
11. TODO.md updated with all 9 extension sub-tasks marked [x]
12. Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-aeds-system/12-04-SUMMARY.md` with:
- 9 AEDS extension plugins implemented
- Bandwidth optimization: P2P mesh (reduces server load by 40-60%), delta sync (saves 50-80% bandwidth on updates)
- Security: Release key verification (prevents unauthorized code execution), zero-trust pairing (prevents rogue clients)
- Integration points: UniversalIntelligence for predictions, UltimateKeyManagement for signing keys, tri-mode USB for air-gap transport
- Client capability gating (extensions only activate if client supports feature)
</output>
