# Phase 65.5: Production Readiness — Plugin & Strategy Compliance

## Context

The comprehensive audit of all 65 plugins and 2,968+ strategies revealed:
- **7 P0 functional breakages** (plugins that don't work at all)
- **12 P1 production risks** (wrong base classes, lifecycle bypasses, no-op handlers)
- **20+ P2 quality issues** (deadlocks, thread safety, missing persistence)
- **6 systemic patterns** affecting 50+ plugins

This phase makes the v5.0 DataWarehouse **100% production deployment ready** across all tiers: individual laptop users, SMB, real-time, sensitive/military, hyperscale, and beyond. Every plugin and every strategy must properly use the SDK inheritance hierarchy, persist state, dispatch to strategies, and participate in the lifecycle.

**Mandate:** This phase iterates (audit → fix → re-audit → re-fix) as many times as needed until zero issues remain. An expert system architect agent generates precise sub-agent prompts at each iteration to ensure correctness independent of ambiguity.

---

## Consolidation Decision Table

### Standalone Plugins (3 — orchestrators/truly unique)
| Plugin | Base Class | Justification |
|--------|-----------|---------------|
| AedsCore | OrchestrationPluginBase | Orchestrates the ENTIRE write/read pipeline across all plugins |
| TamperProof | IntegrityPluginBase | 5-phase pipeline coordinator: encryption+RAID+blockchain+WORM |
| PluginMarketplace | PlatformPluginBase | Meta-level: manages OTHER plugins (install/update/certify) |

### Plugins to Merge as Strategies (12)
| Plugin | Target | New Strategy Names | Domain Justification |
|--------|--------|-------------------|---------------------|
| FuseDriver | UltimateFilesystem | UnixFuseFilesystemStrategy | FUSE is a filesystem access method (Unix mount) |
| WinFspDriver | UltimateFilesystem | WindowsWinFspFilesystemStrategy | WinFSP is a filesystem access method (Windows mount) |
| Compute.Wasm | UltimateCompute | WasmRuntimeStrategy + 31 language strategies | WASM is a compute runtime type (like Container, Sandbox) |
| SelfEmulatingObjects | UltimateCompute | SelfEmulatingComputeStrategy | Objects carrying runtime IS a compute paradigm |
| ChaosVaccination | UltimateResilience | ChaosInjectionStrategy, FaultInjectionStrategy, etc. | Chaos injection IS resilience testing |
| AdaptiveTransport | UltimateStreamingData | AdaptiveTransportStrategy | Adaptive protocol selection IS streaming |
| AirGapBridge | UltimateDataTransit | AirGapTransferStrategy | Air-gapped offline transfer IS data transit |
| KubernetesCsi | UltimateStorage | KubernetesCsiStorageStrategy | CSI is a storage interface standard |
| SqlOverObject | UltimateDatabaseProtocol | SqlOverObjectProtocolStrategy | SQL-over-object IS a database wire protocol |
| AppPlatform | UltimateDeployment | AppHostingStrategy, AppRuntimeStrategy | App hosting IS deployment |
| DataMarketplace | UltimateDataCatalog | DataMarketplaceStrategy, DataListingStrategy | Data marketplace IS catalog+commerce |
| UltimateDataFabric | UltimateDataManagement | FabricTopologyStrategy (Star/Mesh/Federated), VirtualizationStrategy (View/Materialized/Cached), SemanticLayerStrategy, etc. | Fabric manages HOW data is accessed — same domain as DataManagement which manages HOW data is stored |

### Base Class Corrections (2)
| Plugin | Current Base | Correct Base | Reason |
|--------|-------------|-------------|--------|
| UltimateDataPrivacy | DataManagementPluginBase | SecurityPluginBase | Privacy (PII, GDPR consent, anonymization) is security domain |
| UltimateRAID | ReplicationPluginBase | StoragePluginBase | RAID is storage redundancy, not data replication |

### Post-Consolidation Plugin Count
- Before: 65 plugins
- Removed: 12 (merged as strategies)
- After: **53 plugins** (50 Ultimate/Universal + 3 standalone orchestrators)

---

## Plan Structure: 5 Waves, 18 Plans

### Wave 1: Base Class & Lifecycle Compliance (Plans 1-4)

**Plan 65.5-01: Fix Base Class Inheritance (2 plugins)**
- Re-parent UltimateDataPrivacy: DataManagementPluginBase → SecurityPluginBase
  - Update SecurityDomain, DeclaredCapabilities to CapabilityCategory.Security
  - Migrate from ManageDataWithStrategyAsync to AuthenticateWithStrategyAsync/AuthorizeWithStrategyAsync
  - Update all message handler registrations for security topics
- Re-parent UltimateRAID: ReplicationPluginBase → StoragePluginBase
  - Implement Store/Retrieve/Delete/Exists/List/GetMetadata abstracts (delegate to active RAID strategy)
  - Remove ReplicateAsync/GetSyncStatusAsync stubs
  - Register RAID strategies via StoragePluginBase.RegisterStorageStrategy
- Files: UltimateDataPrivacyPlugin.cs, UltimateRaidPlugin.cs, all their strategy files

**Plan 65.5-02: Fix Lifecycle Bypasses — DataPipeline Branch (6 plugins)**
- UltimateDataTransit: Replace direct `StartAsync`/`StopAsync` overrides with `OnStartCoreAsync`/`OnStopCoreAsync`, call base methods
- UltimateFilesystem: Same fix — replace no-op StartAsync/StopAsync with proper lifecycle hooks
- UltimateReplication: Fix `_nodeId` regeneration — persist node identity via SaveStateAsync
- UltimateDatabaseStorage: Fix `OnHandshakeAsync` to call `base.OnHandshakeAsync(request)`
- UltimateDataLake: Add SaveStateAsync/LoadStateAsync for catalog, lineage, policies
- UltimateStorageProcessing: Fix error-path double-counting in ProcessAsync stats
- Files: 6 plugin main files + associated handlers

**Plan 65.5-03: Fix Lifecycle Bypasses — Feature Branch (6 plugins)**
- UltimateDataLineage: Replace no-op StartAsync/StopAsync with OnStartCoreAsync/OnStopCoreAsync
- UltimateResourceManager: Same fix — replace Task.CompletedTask returns
- UltimateEdgeComputing: Remove hidden InitializeAsync(config) requirement, move init to OnStartCoreAsync
- UltimateDataFabric: Fix OnHandshakeAsync to call base.OnHandshakeAsync
- UltimateCompliance: Fix StopAsync to call base, not return Task.CompletedTask
- Compute.Wasm: Replace direct StartAsync/StopAsync with proper lifecycle hooks
- Files: 6 plugin main files

**Plan 65.5-04: Fix `new` Keyword Shadowing & Deadlock Risks (all affected)**
- ChaosVaccination: Replace `new void Dispose()` with `override Dispose(bool)` calling base
- ChaosVaccination: Replace `GetMetadata()` sync-over-async with proper async pattern
- TamperProof: Replace `GetMetadata()` sync-over-async with proper async pattern
- UltimateKeyManagement: Replace `Dispose(bool)` sync-over-async with DisposeAsyncCore
- UltimateKeyManagement: Remove dual `_messageBus` field, use only base.MessageBus
- UltimateEdgeComputing: Replace `new async Task ShutdownAsync()` with proper override
- UltimateDataIntegration: Replace `new void ThrowIfDisposed()` with proper override
- UltimateStreamingData: Fix `StreamingDataStrategyBase` `new bool _initialized` shadowing
- FuseDriver: Remove dual `_messageBus` field
- UltimateAccessControl: Replace `_auditLog List<T>` with thread-safe ConcurrentQueue or BoundedList
- Files: ~12 plugin files

### Wave 2: Strategy Registration & Dispatch (Plans 5-8)

**Plan 65.5-05: Complete Dual-Registration — Batch 1 (8 plugins)**
For each plugin: add base-class strategy registration alongside local registry.
- UltimateServerless: Add `RegisterComputeStrategy()` calls after discovery
- UltimateDocGen: Add base PlatformPluginBase registration
- UltimateSDKPorts: Add base PlatformPluginBase registration
- UltimateSustainability: Consolidate two parallel registries into one + base registration
- UltimateMicroservices: Add base PlatformPluginBase registration
- UltimateMultiCloud: Add base InfrastructurePluginBase registration
- UltimateStreamingData: Add base StreamingPluginBase registration
- UltimateCompliance: Add base SecurityPluginBase registration

**Plan 65.5-06: Complete Dual-Registration — Batch 2 (8 plugins)**
- UltimateConnector: Add base InterfacePluginBase registration
- UltimateIntelligence: Add base DataTransformationPluginBase registration
- UltimateDataFormat: Add base FormatPluginBase registration
- UltimateEdgeComputing: Add base OrchestrationPluginBase registration
- UltimateResourceManager: Add base InfrastructurePluginBase registration
- SemanticSync: Add base OrchestrationPluginBase registration
- UltimateDataLineage: Add base DataManagementPluginBase registration
- UltimateDataMesh: Add base DataManagementPluginBase registration

**Plan 65.5-07: Fix No-Op Message Handlers — Batch 1 (5 plugins)**
For each handler: actually invoke the resolved strategy's method.
- UltimateDataPrivacy: Wire 8 handlers (anonymize, pseudonymize, tokenize, mask, differential, compliance, metrics) to call strategy.ExecuteAsync
- UltimateDataCatalog: Wire 4 handlers (discover, document, access, schema) to call strategy methods
- UltimateDataGovernance: Wire 5 handlers (stewardship, lineage, retention, compliance, audit) — fix compliance to evaluate real rules
- UltimateDataMesh: Wire GetStrategyOrThrow to actually dispatch in all handlers
- UltimateDataManagement: Wire 7 handlers (dedup, version, tier, shard, lifecycle, cache, index)

**Plan 65.5-08: Fix No-Op Message Handlers — Batch 2 (5 plugins)**
- UltimateDataQuality: Wire 8 handlers (validate, profile, cleanse, detect-duplicates, standardize, score, monitor, report)
- UltimateMicroservices: Fix HandleInvokeAsync to route to strategy instead of always returning success
- UltimateMultiCloud: Fix HandleExecuteAsync, HandleReplicateAsync, HandleMigrateAsync, HandleOptimizeCostAsync to dispatch to strategies
- UltimateDataProtection: Implement all 5 message bus handlers (list, select, backup, restore, statistics)
- UltimateDatabaseStorage: Fix HandleListStrategiesAsync/HandleGetStrategyAsync to populate response payload

### Wave 3: P0 Functional Breakage Fixes (Plans 9-10)

**Plan 65.5-09: Fix Critical P0 Issues**
- UltimateDataTransit: Change `internal sealed class` to `public sealed class` (P0: plugin invisible)
- UltimateRAID: Add `RaidTopics.Initialize` constant + subscribe in OnStartCoreAsync (P0: init unreachable)
- UltimateWorkflow: Fix key mismatch `"AIOptimized"` → `"AIOptimizedWorkflow"` (P0: runtime exception)
- UltimateDataIntegrity: Implement HMAC algorithms or remove from SupportedAlgorithms (P2: advertised but throws)
- UltimateCompression: Fix `compression.ultimate.list` handler to return strategy list in payload
- AirGapBridge: Persist `_masterKey` via SaveStateAsync (P1: exported packages unreadable after restart)
- UltimateEncryption: Persist FIPS mode and default strategy via SaveStateAsync

**Plan 65.5-10: Fix Remaining P1/P2 Issues**
- UltimateDataGovernance: Fix HandleComplianceAsync to evaluate real compliance rules (not always return true)
- UltimateReplication: Fix HandleSyncMessageAsync to perform actual synchronization
- UltimateFilesystem: Fix StoragePluginBase stubs to throw NotSupportedException (not silent empty returns)
- UltimateFilesystem: Fix Linux kernel version detection (use /proc/version instead of Environment.OSVersion)
- UltimateConsensus: Document InMemoryClusterMembership/InMemoryP2PNetwork as dev-only with TODO for production
- UltimateDocGen: Replace stub GenerateAsync strings with real implementations

### Wave 4: Plugin Consolidation (Plans 11-14)

**Plan 65.5-11: Consolidate Filesystem Drivers + Compute Plugins (4 → 0)**
- Merge FuseDriver into UltimateFilesystem as UnixFuseFilesystemStrategy
- Merge WinFspDriver into UltimateFilesystem as WindowsWinFspFilesystemStrategy
- Merge Compute.Wasm into UltimateCompute as WasmRuntimeStrategy (+ 31 language strategies)
- Merge SelfEmulatingObjects into UltimateCompute as SelfEmulatingComputeStrategy
- Delete 4 plugin project directories, remove from .slnx

**Plan 65.5-12: Consolidate Resilience + Streaming + Transit Plugins (3 → 0)**
- Merge ChaosVaccination into UltimateResilience as ChaosInjectionStrategy + sub-strategies
- Merge AdaptiveTransport into UltimateStreamingData as AdaptiveTransportStrategy
- Merge AirGapBridge into UltimateDataTransit as AirGapTransferStrategy
- Delete 3 plugin project directories, remove from .slnx

**Plan 65.5-13: Consolidate Storage + Protocol + Deployment Plugins (3 → 0)**
- Merge KubernetesCsi into UltimateStorage as KubernetesCsiStorageStrategy
- Merge SqlOverObject into UltimateDatabaseProtocol as SqlOverObjectProtocolStrategy
- Merge AppPlatform into UltimateDeployment as AppHostingStrategy + AppRuntimeStrategy
- Delete 3 plugin project directories, remove from .slnx

**Plan 65.5-14: Consolidate Catalog + DataManagement Plugins (2 → 0)**
- Merge DataMarketplace into UltimateDataCatalog as DataMarketplaceStrategy + DataListingStrategy
- Merge UltimateDataFabric into UltimateDataManagement as 13 fabric strategies (topology, virtualization, semantic, etc.)
- Delete 2 plugin project directories, remove from .slnx

### Wave 5: Persistence, Verification & Iterative Audit-Fix Cycles (Plans 15-18)

**Plan 65.5-15: Implement SaveStateAsync/LoadStateAsync Across Stateful Plugins**
Priority order (compliance-critical first):
1. UltimateDataPrivacy — consent records, privacy policies (GDPR-critical)
2. UltimateAccessControl — audit log, policy state
3. UltimateDataGovernance — governance policies, ownership records, classifications
4. UltimateDataCatalog — catalog assets, lineage relationships, glossary
5. UltimateDataLake — catalog, lineage, access policies
6. UltimateDataLineage — lineage graph nodes and edges
7. UltimateDataMesh — domains, products, consumers, shares
8. UltimateDataManagement — policies (now includes fabric state)
9. UltimateDataQuality — quality policies
10. UltimateReplication — node identity, counters
11. UltimateKeyManagement — rotation schedules, registered store IDs
12. UltimateEncryption — FIPS mode, default strategy (if not done in 65.5-09)
13. UltimateStorage — default strategy, failover config
14. UltimateConsensus — consensus state, commit indices

Pattern for each: Override `OnBeforeStatePersistAsync` to serialize state → `SaveStateAsync`. Override `OnStartCoreAsync` to call `LoadStateAsync` → deserialize state. Use `BoundedDictionary` with auto-persistence where applicable.

**Plan 65.5-16: Full Build Verification + Solution Cleanup**
- `dotnet build DataWarehouse.slnx` — zero errors, zero warnings
- Verify .slnx no longer references deleted plugin projects
- Verify no cross-plugin references exist (plugins only reference SDK)
- Verify all 53 remaining plugins compile and register correctly
- Run all existing tests

**Plan 65.5-17: Two-Layer Comprehensive Audit Round 1**

Each audit round has TWO layers that run in sequence:

**Layer 1: Structural Grep Scan (Fast, Pattern-Based)**
- Spawn 3 parallel scan agents (DataPipeline, Security+DataMgmt, Feature+Special)
- Each agent scans ALL plugins in its group using grep/glob for known anti-patterns:
  - `new void`, `new async`, `new bool` → keyword shadowing
  - `.GetAwaiter().GetResult()` → deadlock risk
  - `internal sealed class` on plugin classes → discovery failure
  - `Task.CompletedTask` in lifecycle methods → no-op lifecycle
  - Missing `base.OnHandshakeAsync` calls
  - Direct `override.*StartAsync` / `override.*StopAsync` (should be OnStartCoreAsync/OnStopCoreAsync)
  - Dual `_messageBus` field declarations
  - `List<` on shared state (should be ConcurrentQueue/BoundedDictionary)
  - `NotImplementedException`, `NotSupportedException` in advertised capabilities
- Output: `findings_structural.json` — machine-parseable list of {file, line, pattern, severity}

**Layer 2: Deep Semantic Code Review (Slow, Behavioral)**
- Spawn 3 parallel OPUS-level architect agents (~18 plugins each)
- Each agent **reads every .cs file in each plugin directory end-to-end**
- Evaluates against a 12-point behavioral checklist:
  1. **Silent no-ops**: Handler locates strategy but never calls any method, returns `success:true`
  2. **Stub returns**: Methods always return `true`, `false`, `null`, empty collections, or hardcoded strings regardless of input
  3. **Dead initialization**: Code creates/configures objects but no code path reads from them
  4. **Exception suppression**: Empty `catch {}`, `catch (Exception) { return default; }`, swallowed errors
  5. **NotImplemented/NotSupported**: Advertised capabilities that throw at runtime
  6. **In-memory-only state**: Mutable data (policies, audit logs, consent) with no persistence path
  7. **Hardcoded stubs**: `return "Generated documentation..."` or `return new byte[] { 0x00 }`
  8. **Wiring gaps**: Strategy registered but never resolved; handler subscribed but topic never published; method exists but no caller
  9. **Passthrough delegation**: Resilience/chaos/validation wrappers that just call inner function without applying policy
  10. **Parameter ignoring**: Methods accept parameters but never use them (e.g., `ValidateAsync(Policy p) => true`)
  11. **Incomplete dispatch**: Handler resolves strategy by name but calls wrong method or passes wrong args
  12. **Missing error propagation**: Async method catches exception, logs it, but returns success status to caller
- Output: `findings_semantic.json` — structured per-plugin findings with {plugin, file, line, category, description, severity, suggested_fix}

**MERGE**: Combine both layers into `findings_all.json`, deduplicate, sort by severity.
If findings_all.count == 0 → DONE. Otherwise → Fix Phase.

**Fix Phase (after each audit round):**
1. ARCHITECT agent (opus) reads merged findings + affected source files
2. Generates PRECISE prompts for executor agents:
   - Exact file path + line range
   - Current broken code (quoted verbatim)
   - Correct replacement code
   - Why it was wrong (category from checklist)
   - How to verify the fix (what to check)
3. EXECUTOR agents (sonnet) apply fixes in parallel batches
4. BUILD CHECK: `dotnet build` — 0 errors, 0 warnings

**Plan 65.5-18: Iterative Audit-Fix Cycles Until Zero Issues**

```
ITERATION := 0
DO:
    ITERATION++
    Run Layer 1 (structural grep scan) — 3 parallel agents
    Run Layer 2 (deep semantic code review) — 3 parallel opus agents
    MERGE findings
    IF findings.count == 0: BREAK → DONE
    Architect generates fix prompts from findings
    Executors apply fixes
    Build verification (0 errors, 0 warnings)
WHILE findings.count > 0
```

Expected convergence: 2-4 iterations. Each iteration uses FRESH audit agents that read the actual current state of code (no cached results).

**After zero-findings achieved:**
- Final build verification: `dotnet build DataWarehouse.slnx` — 0 errors, 0 warnings
- Run all existing tests
- Update all documentation:
  - `.planning/PLUGIN-CATALOG.md` — reflect 53 plugins, new strategy counts
  - `Metadata/PLUGIN-AUDIT-REPORT.md` — mark all issues RESOLVED
  - `.planning/MILESTONES.md` — add Phase 65.5 completion
  - `memory/MEMORY.md` — update plugin count, strategy count, hierarchy info
  - `memory/plugin-to-base-mapping.md` — reflect all changes
- Commit and push all changes

---

## Execution Protocol

### Expert Architect Agent Pattern (Two-Tier Model)

**Tier 1 — Architect (opus):** Reads source code, understands context, generates exact instructions.
**Tier 2 — Executor (sonnet):** Receives architect's instructions, applies edits mechanically.

**Why this matters:** Your high-level intent (e.g., "fix lifecycle bypass") may contain ambiguity. The architect agent reads the ACTUAL source code and generates instructions based on what's really there — not on assumptions. If the plan says "fix lifecycle bypass" but the plugin already uses `OnStartCoreAsync` correctly, the architect will see that and skip it.

For each plan in Waves 1-4:
1. Spawn ARCHITECT agent (opus) — reads plan + ALL affected source files
2. Architect generates PRECISE edit prompts:
   - Exact file path and line range
   - Current code (quoted verbatim from source)
   - Required replacement code
   - Validation criteria (what to check after edit)
3. Spawn EXECUTOR agent(s) (sonnet, parallel where independent)
   - Each receives one architect-generated prompt
   - Makes ONLY the specified edits — no interpretation needed
4. BUILD CHECK: `dotnet build` — 0 errors, 0 warnings

### Two-Layer Audit Protocol (Wave 5)

Each audit iteration runs TWO complementary layers:

**Layer 1 — Structural Scan (grep/glob, fast):** Catches keyword-level anti-patterns (shadowing, deadlocks, missing base calls, unsafe collections). Pattern-matching — finds things that LOOK wrong.

**Layer 2 — Deep Semantic Review (opus reads full source, slow):** Catches behavioral issues that compile without errors but aren't production-ready: silent no-ops, stub returns, dead initialization, exception suppression, hardcoded stubs, wiring gaps, passthrough delegation, parameter ignoring. Full code comprehension — finds things that ARE wrong despite looking fine.

Both layers produce machine-parseable JSON findings. Merged findings drive the fix phase.

### Iteration Protocol

```
WHILE true:
    Layer 1: Structural grep scan (3 parallel agents)
    Layer 2: Deep semantic code review (3 parallel opus agents)
    MERGE findings → findings_all.json
    IF findings_all.count == 0: BREAK
    Architect (opus) reads findings + source → generates fix prompts
    Executors (sonnet) apply fixes in parallel
    BUILD CHECK: dotnet build — 0 errors, 0 warnings
```

Fresh agents every iteration — no cached results, no stale assumptions.

### Quality Amplifiers (Maximize Agent Effectiveness)

**1. Golden Reference Plugin:** Before audit cycles begin, verify UltimateCompute passes all 12 behavioral checks. Document it as the reference pattern. Architect agents can diff other plugins against this concrete example instead of reasoning from abstract rules.

**2. Anti-Pattern Gallery:** Create `Metadata/ANTI-PATTERN-GALLERY.md` with before/after code snippets for every anti-pattern category. This eliminates interpretation ambiguity — agents see exactly what "silent no-op" looks like in real DataWarehouse code.

**3. Per-Plugin Compliance Cards:** Each audit produces a machine-parseable JSON compliance card per plugin (base class correct? lifecycle correct? handlers dispatch? persistence? thread safety? behavioral issues list). Fix agents receive structured data, not prose.

**4. Regression Guard:** After each fix iteration, re-run the PREVIOUS iteration's structural scan patterns to ensure fixes didn't reintroduce old patterns. Cheap (just grep) and catches regression immediately.

**5. SDK Contract Reflection Test:** Write a single test that uses reflection to verify all 53 plugin assemblies:
- No plugin class is `internal`
- No `new` keyword members (check `MethodInfo.Attributes` for `HideBySig`)
- All plugins override `OnStartCoreAsync` (not `StartAsync`)
- All plugins with state implement `SaveStateAsync`
This makes checks repeatable and automated — not dependent on agent quality.

### Commit Strategy
- One commit per plan (18+ commits)
- Commit message format: `fix(65.5-NN): <description>`
- Push after each wave completes (5 pushes minimum)
- Final push includes all documentation updates

---

## Verification Criteria (Must ALL Pass)

### Hierarchy Compliance
- [ ] 0 plugins extend PluginBase directly (except via hierarchy)
- [ ] 0 plugins extend IntelligenceAwarePluginBase directly (except UltimateIntelligence for T90)
- [ ] 0 strategies extend StrategyBase directly (all use domain bases)
- [ ] All 53 plugins use correct domain-specific plugin base
- [ ] All strategies use correct domain-specific strategy base

### Lifecycle Compliance
- [ ] 0 plugins override StartAsync/StopAsync directly (all use OnStartCoreAsync/OnStopCoreAsync)
- [ ] 0 plugins with no-op lifecycle methods
- [ ] All OnHandshakeAsync implementations call base.OnHandshakeAsync

### Strategy Compliance
- [ ] 0 no-op message handlers (all dispatch to strategy methods)
- [ ] All strategies dual-registered (local registry + base class StrategyRegistry)
- [ ] 0 `new` keyword shadowing of base members
- [ ] 0 `.GetAwaiter().GetResult()` patterns (zero deadlock risk)
- [ ] 0 dual MessageBus fields

### State Compliance
- [ ] All plugins with mutable state implement SaveStateAsync/LoadStateAsync
- [ ] All shared collections are thread-safe (BoundedDictionary, ConcurrentQueue, etc.)
- [ ] All security-sensitive state (FIPS mode, keys, consent) persists across restarts

### Build Compliance
- [ ] `dotnet build DataWarehouse.slnx` — 0 errors, 0 warnings
- [ ] All tests pass
- [ ] 53 plugins (12 removed via consolidation)
- [ ] No cross-plugin project references

### Behavioral Compliance (Deep Code Review)
- [ ] 0 silent no-op handlers (all handlers that resolve a strategy MUST call a method on it)
- [ ] 0 hardcoded stub returns (no `return "Generated..."`, `return true`, `return null` without logic)
- [ ] 0 dead initialization (every created object must have at least one consumer)
- [ ] 0 empty catch blocks (all exceptions either rethrown, logged+returned as error, or explicitly documented)
- [ ] 0 passthrough wrappers (resilience/chaos/validation must actually apply their policy)
- [ ] 0 parameter-ignoring methods (all parameters must influence behavior or be removed)
- [ ] 0 in-memory-only state for compliance-critical data (privacy, governance, audit, access control)

### Production Readiness
- [ ] Zero P0 issues remaining
- [ ] Zero P1 issues remaining
- [ ] Zero P2 issues remaining
- [ ] Zero systemic issues remaining
- [ ] Two-layer audit (structural + semantic) produces ZERO findings on final pass

---

## Critical Files

### SDK Base Classes (read-only reference)
- `DataWarehouse.SDK/Contracts/PluginBase.cs` (1,569 lines)
- `DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs` (1,592 lines)
- `DataWarehouse.SDK/Contracts/StrategyBase.cs` (391 lines)
- `DataWarehouse.SDK/Contracts/Hierarchy/NewFeaturePluginBase.cs`
- `DataWarehouse.SDK/Contracts/Hierarchy/DataPipelinePluginBase.cs`
- `DataWarehouse.SDK/Contracts/Hierarchy/Feature/*.cs` (13 domain bases)
- `DataWarehouse.SDK/Contracts/Hierarchy/DataPipeline/*.cs` (5 domain bases)

### Plugins to Modify (~50 main plugin files)
- All plugin files in `Plugins/DataWarehouse.Plugins.*/`

### Plugins to Delete (12 project directories)
- `Plugins/DataWarehouse.Plugins.FuseDriver/`
- `Plugins/DataWarehouse.Plugins.WinFspDriver/`
- `Plugins/DataWarehouse.Plugins.Compute.Wasm/`
- `Plugins/DataWarehouse.Plugins.SelfEmulatingObjects/`
- `Plugins/DataWarehouse.Plugins.ChaosVaccination/`
- `Plugins/DataWarehouse.Plugins.AdaptiveTransport/`
- `Plugins/DataWarehouse.Plugins.AirGapBridge/`
- `Plugins/DataWarehouse.Plugins.KubernetesCsi/`
- `Plugins/DataWarehouse.Plugins.Virtualization.SqlOverObject/`
- `Plugins/DataWarehouse.Plugins.AppPlatform/`
- `Plugins/DataWarehouse.Plugins.DataMarketplace/`
- `Plugins/DataWarehouse.Plugins.UltimateDataFabric/`

### Documentation to Update
- `.planning/MILESTONES.md`
- `.planning/PLUGIN-CATALOG.md`
- `Metadata/PLUGIN-AUDIT-REPORT.md`
- `memory/MEMORY.md`
- `memory/plugin-to-base-mapping.md`
- `DataWarehouse.slnx`
