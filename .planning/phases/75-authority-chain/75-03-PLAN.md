---
phase: 75-authority-chain
plan: 03
type: execute
wave: 3
depends_on: ["75-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/Policy/QuorumTypes.cs
  - DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs
  - DataWarehouse.SDK/Infrastructure/Authority/QuorumVetoHandler.cs
autonomous: true

must_haves:
  truths:
    - "Quorum requires exactly N-of-M super admin approvals before executing a protected action"
    - "Quorum actions include: override AI, change security policy, disable AI, modify quorum, delete VDE, export keys, disable audit"
    - "Destructive quorum actions have a 24hr cooling-off period during which any super admin can veto"
    - "Approval window is configurable and enforced (default 24hrs)"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Policy/QuorumTypes.cs"
      provides: "QuorumRequest, QuorumApproval, QuorumVeto, IQuorumService interface"
      contains: "IQuorumService"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs"
      provides: "N-of-M approval engine with configurable thresholds"
      contains: "class QuorumEngine"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/QuorumVetoHandler.cs"
      provides: "24hr cooling-off period with veto capability"
      contains: "class QuorumVetoHandler"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs"
      via: "Records quorum decision at Quorum authority level (Priority 0)"
      pattern: "IAuthorityResolver|RecordDecisionAsync"
    - from: "DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs"
      via: "Uses existing QuorumPolicy and QuorumAction types"
      pattern: "QuorumPolicy|QuorumAction"
---

<objective>
Build the super admin quorum system: configurable N-of-M approval for protected actions, with a 24hr cooling-off period and veto mechanism for destructive operations.

Purpose: AUTH-04, AUTH-05, AUTH-07 require configurable quorum (e.g., 3-of-5), defined protected actions, and a time-lock with veto capability on destructive actions.

Output: QuorumTypes contract, N-of-M approval engine, cooling-off/veto handler.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/75-authority-chain/75-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Quorum contract types and IQuorumService interface</name>
  <files>DataWarehouse.SDK/Contracts/Policy/QuorumTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Policy/QuorumTypes.cs` in namespace `DataWarehouse.SDK.Contracts.Policy` with [SdkCompatibility("6.0.0", Notes = "Phase 75: Quorum System (AUTH-04, AUTH-05, AUTH-07)")]:

1. `enum QuorumRequestState` with [Description] attributes:
   - `Collecting = 0` -- gathering approvals
   - `Approved = 1` -- N-of-M approvals reached
   - `CoolingOff = 2` -- approved but in 24hr cooling-off for destructive actions
   - `Vetoed = 3` -- any super admin vetoed during cooling-off (terminal)
   - `Executed = 4` -- action was executed (terminal)
   - `Expired = 5` -- approval window expired before reaching quorum (terminal)
   - `Denied = 6` -- explicitly denied (terminal)

2. `sealed record QuorumApproval`:
   - `required string ApprovalId { get; init; }` -- GUID
   - `required string ApproverId { get; init; }` -- super admin ID
   - `required string ApproverDisplayName { get; init; }`
   - `required DateTimeOffset ApprovedAt { get; init; }`
   - `string? ApprovalMethod { get; init; }` -- "password", "yubikey", "smartcard" (Phase 75-04 will use this)
   - `string? Comment { get; init; }`

3. `sealed record QuorumVeto`:
   - `required string VetoId { get; init; }`
   - `required string VetoedBy { get; init; }` -- super admin who vetoed
   - `required DateTimeOffset VetoedAt { get; init; }`
   - `required string Reason { get; init; }` -- must explain why

4. `sealed record QuorumRequest`:
   - `required string RequestId { get; init; }` -- GUID
   - `required QuorumAction Action { get; init; }` -- from PolicyEnums.cs (existing enum)
   - `required string RequestedBy { get; init; }`
   - `required string Justification { get; init; }`
   - `required DateTimeOffset RequestedAt { get; init; }`
   - `required QuorumRequestState State { get; init; }`
   - `required int RequiredApprovals { get; init; }` -- the N in N-of-M
   - `required int TotalMembers { get; init; }` -- the M in N-of-M
   - `IReadOnlyList<QuorumApproval> Approvals { get; init; }` -- default empty list
   - `QuorumVeto? Veto { get; init; }` -- non-null if vetoed
   - `required TimeSpan ApprovalWindow { get; init; }` -- how long to collect approvals
   - `required TimeSpan CoolingOffPeriod { get; init; }` -- 24hr default for destructive actions
   - `DateTimeOffset? CoolingOffEndsAt { get; init; }` -- when cooling-off expires (set when entering CoolingOff)
   - `DateTimeOffset? ExecutedAt { get; init; }`
   - `Dictionary<string, string>? ActionParameters { get; init; }` -- action-specific data

5. `sealed record QuorumConfiguration`:
   - `required int RequiredApprovals { get; init; }` -- e.g., 3
   - `required int TotalMembers { get; init; }` -- e.g., 5
   - `TimeSpan ApprovalWindow { get; init; } = TimeSpan.FromHours(24)`
   - `TimeSpan DestructiveCoolingOff { get; init; } = TimeSpan.FromHours(24)` -- 24hr cooling-off
   - `QuorumAction[] DestructiveActions { get; init; }` -- actions that require cooling-off; default = { DeleteVde, ExportKeys, DisableAudit, DisableAi }
   - `IReadOnlyList<string> MemberIds { get; init; }` -- list of super admin IDs eligible for quorum

6. `interface IQuorumService`:
   - `Task<QuorumRequest> InitiateQuorumAsync(QuorumAction action, string requestedBy, string justification, Dictionary<string, string>? parameters = null, CancellationToken ct = default)`
   - `Task<QuorumRequest> ApproveAsync(string requestId, string approverId, string approverName, string? method = null, string? comment = null, CancellationToken ct = default)`
   - `Task<QuorumRequest> VetoAsync(string requestId, string vetoedBy, string reason, CancellationToken ct = default)`
   - `Task<QuorumRequest> GetRequestAsync(string requestId, CancellationToken ct = default)`
   - `Task<IReadOnlyList<QuorumRequest>> GetPendingRequestsAsync(CancellationToken ct = default)`
   - `Task CheckExpirationsAsync(CancellationToken ct = default)` -- expire requests past approval window, execute requests past cooling-off
   - `Task<bool> IsActionProtectedAsync(QuorumAction action, CancellationToken ct = default)` -- checks if action requires quorum per configured ProtectedActions

Use existing `QuorumPolicy`, `QuorumAction` from PolicyTypes.cs and PolicyEnums.cs. Do NOT duplicate.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>All quorum types compile, IQuorumService interface has full lifecycle methods</done>
</task>

<task type="auto">
  <name>Task 2: Quorum engine and cooling-off veto handler</name>
  <files>DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs, DataWarehouse.SDK/Infrastructure/Authority/QuorumVetoHandler.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Authority/QuorumVetoHandler.cs` in namespace `DataWarehouse.SDK.Infrastructure.Authority` with [SdkCompatibility("6.0.0")]:

`public sealed class QuorumVetoHandler`

Constructor takes `QuorumConfiguration config`.

- `bool IsDestructiveAction(QuorumAction action)` -- returns true if action is in config.DestructiveActions
- `QuorumRequest EnterCoolingOff(QuorumRequest approved)` -- transitions Approved -> CoolingOff, sets CoolingOffEndsAt = now + DestructiveCoolingOff
- `QuorumRequest ApplyVeto(QuorumRequest request, string vetoedBy, string reason)` -- validates State==CoolingOff, creates QuorumVeto, transitions to Vetoed
- `bool IsCoolingOffComplete(QuorumRequest request)` -- true if State==CoolingOff and CoolingOffEndsAt <= now

---

Create `DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs`:

`public sealed class QuorumEngine : IQuorumService`

Constructor takes: `IAuthorityResolver authorityResolver, QuorumConfiguration config, QuorumVetoHandler vetoHandler`

Internal storage: `ConcurrentDictionary<string, QuorumRequest>` keyed by RequestId.

Implement `InitiateQuorumAsync`:
- Validate action is in the configured QuorumPolicy.ProtectedActions (use IsActionProtectedAsync)
- Create QuorumRequest with State=Collecting, empty Approvals list
- Store and return

Implement `ApproveAsync`:
- Get request, validate State==Collecting
- Validate approverId is in config.MemberIds
- Validate approverId has not already approved (no duplicate approvals)
- Validate requestedBy != approverId (requester cannot approve their own request)
- Add QuorumApproval to the Approvals list
- If Approvals.Count >= RequiredApprovals:
  - If vetoHandler.IsDestructiveAction(request.Action): transition to CoolingOff via vetoHandler.EnterCoolingOff
  - Else: transition directly to Approved, then immediately to Executed (non-destructive actions execute immediately)
  - Call authorityResolver.RecordDecisionAsync("Quorum", action.ToString(), requestedBy, justification)
- Store updated request and return

Implement `VetoAsync`:
- Get request, validate State==CoolingOff
- Validate vetoedBy is in config.MemberIds
- Delegate to vetoHandler.ApplyVeto
- Store and return

Implement `CheckExpirationsAsync`:
- For Collecting requests: if RequestedAt + ApprovalWindow < now, transition to Expired
- For CoolingOff requests: if vetoHandler.IsCoolingOffComplete(request) and no veto, transition to Executed (set ExecutedAt=now)

Implement `IsActionProtectedAsync`:
- Check if the action exists in config's QuorumPolicy ProtectedActions or config's list of actions. Use the QuorumAction enum values from PolicyEnums.cs.

Use `SemaphoreSlim(1,1)` per request ID for thread safety on approval/veto operations.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>QuorumEngine enforces N-of-M approval, prevents self-approval and duplicate approval, destructive actions have 24hr cooling-off with veto, non-destructive actions execute immediately on quorum</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
```

Verify:
- 3-of-5 quorum: 3 approvals from 5 members triggers Approved
- 2-of-5 does not trigger (stays Collecting)
- Self-approval rejected (requester cannot approve own request)
- Duplicate approval rejected
- Destructive action (DeleteVde) enters 24hr CoolingOff after approval
- Non-destructive action executes immediately after approval
- Veto during cooling-off transitions to Vetoed (terminal)
- Expired approval window transitions to Expired (terminal)
</verification>

<success_criteria>
- Configurable N-of-M quorum (default 3-of-5) enforced
- All 7 QuorumAction values supported as protectable actions
- 24hr cooling-off on destructive actions with veto by any super admin
- Quorum decisions registered at Quorum authority level (Priority 0, highest)
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/75-authority-chain/75-03-SUMMARY.md`
</output>
