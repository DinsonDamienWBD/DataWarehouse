---
phase: 75-authority-chain
plan: 02
type: execute
wave: 2
depends_on: ["75-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/Policy/EscalationTypes.cs
  - DataWarehouse.SDK/Infrastructure/Authority/EscalationStateMachine.cs
  - DataWarehouse.SDK/Infrastructure/Authority/EscalationRecordStore.cs
autonomous: true

must_haves:
  truths:
    - "Emergency AI override activates within the configured window (default 15 min) and auto-reverts on timeout"
    - "Admin can confirm escalation (makes it permanent) or revert it (restores prior state)"
    - "EscalationRecord is immutable with a tamper-proof SHA256 hash; any modification invalidates the record"
    - "Escalation state machine transitions: Pending -> Active -> Confirmed|Reverted|TimedOut"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Policy/EscalationTypes.cs"
      provides: "EscalationRecord, EscalationState enum, IEscalationService interface"
      contains: "IEscalationService"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/EscalationStateMachine.cs"
      provides: "State machine with countdown, confirm, revert, timeout transitions"
      contains: "class EscalationStateMachine"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/EscalationRecordStore.cs"
      provides: "Immutable record storage with hash verification"
      contains: "class EscalationRecordStore"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Authority/EscalationStateMachine.cs"
      to: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs"
      via: "Records escalation as AiEmergency authority decision"
      pattern: "IAuthorityResolver|RecordDecisionAsync"
    - from: "DataWarehouse.SDK/Infrastructure/Authority/EscalationRecordStore.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/EscalationTypes.cs"
      via: "Stores and verifies EscalationRecord immutability"
      pattern: "EscalationRecord|ComputeHash"
---

<objective>
Build the emergency escalation system: a time-bounded AI override with a state machine (Pending -> Active -> Confirmed/Reverted/TimedOut) and immutable tamper-proof escalation records.

Purpose: AUTH-01, AUTH-02, AUTH-03 require emergency AI override with countdown timer, admin confirm/revert flow, and tamper-proof hash on every EscalationRecord.

Output: EscalationTypes contract, state machine engine, immutable record store with SHA256 hash verification.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/75-authority-chain/75-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Escalation contract types</name>
  <files>DataWarehouse.SDK/Contracts/Policy/EscalationTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Policy/EscalationTypes.cs` in namespace `DataWarehouse.SDK.Contracts.Policy` with [SdkCompatibility("6.0.0", Notes = "Phase 75: Emergency Escalation (AUTH-01, AUTH-02, AUTH-03)")]:

1. `enum EscalationState` with [Description] attributes:
   - `Pending = 0` -- escalation requested, awaiting activation
   - `Active = 1` -- AI override is active, countdown running
   - `Confirmed = 2` -- admin confirmed, override is permanent (terminal)
   - `Reverted = 3` -- admin reverted, prior state restored (terminal)
   - `TimedOut = 4` -- countdown expired, auto-reverted (terminal)

2. `sealed record EscalationRecord` -- IMMUTABLE once created:
   - `required string EscalationId { get; init; }` -- GUID
   - `required string RequestedBy { get; init; }` -- actor who requested escalation
   - `required string Reason { get; init; }` -- why the escalation is needed
   - `required string AffectedFeatureId { get; init; }` -- which feature/policy is being overridden
   - `required EscalationState State { get; init; }`
   - `required DateTimeOffset RequestedAt { get; init; }`
   - `DateTimeOffset? ActivatedAt { get; init; }`
   - `DateTimeOffset? ResolvedAt { get; init; }` -- when Confirmed/Reverted/TimedOut
   - `string? ResolvedBy { get; init; }` -- who confirmed/reverted (null for timeout)
   - `required TimeSpan OverrideWindow { get; init; }` -- how long the override lasts (default 15 min)
   - `string? PreviousPolicySnapshot { get; init; }` -- JSON of policy before override for revert
   - `string? OverridePolicySnapshot { get; init; }` -- JSON of the override policy
   - `required string RecordHash { get; init; }` -- SHA256 tamper-proof hash of all fields above

   Add static method `ComputeHash(...)` that takes all fields except RecordHash, serializes them to a canonical string (sorted field names, UTC timestamps), and returns SHA256 hex string. Use `System.Security.Cryptography.SHA256`.

   Add instance method `bool VerifyIntegrity()` that recomputes the hash from its own fields and returns true only if it matches RecordHash.

3. `sealed record EscalationConfiguration`:
   - `TimeSpan DefaultOverrideWindow { get; init; } = TimeSpan.FromMinutes(15)`
   - `TimeSpan MaxOverrideWindow { get; init; } = TimeSpan.FromHours(4)`
   - `int MaxConcurrentEscalations { get; init; } = 3`
   - `bool RequireReason { get; init; } = true`

4. `interface IEscalationService`:
   - `Task<EscalationRecord> RequestEscalationAsync(string requestedBy, string reason, string featureId, TimeSpan? overrideWindow = null, CancellationToken ct = default)`
   - `Task<EscalationRecord> ActivateEscalationAsync(string escalationId, string policySnapshotJson, string overridePolicyJson, CancellationToken ct = default)`
   - `Task<EscalationRecord> ConfirmEscalationAsync(string escalationId, string confirmedBy, CancellationToken ct = default)`
   - `Task<EscalationRecord> RevertEscalationAsync(string escalationId, string revertedBy, CancellationToken ct = default)`
   - `Task<EscalationRecord> GetEscalationAsync(string escalationId, CancellationToken ct = default)`
   - `Task<IReadOnlyList<EscalationRecord>> GetActiveEscalationsAsync(CancellationToken ct = default)`
   - `Task CheckTimeoutsAsync(CancellationToken ct = default)` -- checks all Active escalations, transitions expired ones to TimedOut
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>All escalation types compile, EscalationRecord has ComputeHash and VerifyIntegrity methods</done>
</task>

<task type="auto">
  <name>Task 2: Escalation state machine and immutable record store</name>
  <files>DataWarehouse.SDK/Infrastructure/Authority/EscalationStateMachine.cs, DataWarehouse.SDK/Infrastructure/Authority/EscalationRecordStore.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Authority/EscalationRecordStore.cs` in namespace `DataWarehouse.SDK.Infrastructure.Authority` with [SdkCompatibility("6.0.0")]:

`public sealed class EscalationRecordStore`

Internal storage: `ConcurrentDictionary<string, EscalationRecord>` keyed by EscalationId.

- `void Store(EscalationRecord record)` -- verifies record.VerifyIntegrity() before storing; throws InvalidOperationException("Tamper detected: EscalationRecord hash is invalid") if verification fails. If a record with the same ID already exists, throw InvalidOperationException("EscalationRecord is immutable and cannot be replaced; create a new state transition record").
- Actually, records transition states -- so Store should allow storing records with new state but same EscalationId, keyed as `{EscalationId}:{State}` internally. The latest state is returned by Get.
- `EscalationRecord? Get(string escalationId)` -- returns the most recent state record for this ID
- `IReadOnlyList<EscalationRecord> GetByState(EscalationState state)` -- returns all records currently in the given state
- `IReadOnlyList<EscalationRecord> GetHistory(string escalationId)` -- returns all state transitions for an escalation, ordered by timestamp
- `bool VerifyChainIntegrity(string escalationId)` -- verifies ALL records for this escalation pass VerifyIntegrity()

---

Create `DataWarehouse.SDK/Infrastructure/Authority/EscalationStateMachine.cs`:

`public sealed class EscalationStateMachine : IEscalationService`

Constructor takes: `IAuthorityResolver authorityResolver, EscalationRecordStore store, EscalationConfiguration? config = null`

State transition rules (enforce strictly, throw InvalidOperationException on invalid transition):
- `Pending -> Active` (via ActivateEscalationAsync)
- `Active -> Confirmed` (via ConfirmEscalationAsync)
- `Active -> Reverted` (via RevertEscalationAsync)
- `Active -> TimedOut` (via CheckTimeoutsAsync when ActivatedAt + OverrideWindow < now)
- NO other transitions allowed (Confirmed, Reverted, TimedOut are terminal)

Implement `RequestEscalationAsync`:
- Validate: RequireReason and reason is not empty, overrideWindow <= MaxOverrideWindow
- Check MaxConcurrentEscalations against store.GetByState(Active).Count
- Create EscalationRecord with State=Pending, compute hash, store it
- Return the record

Implement `ActivateEscalationAsync`:
- Get current record, validate State==Pending
- Create new record with State=Active, ActivatedAt=now, policy snapshots, compute hash, store
- Call authorityResolver.RecordDecisionAsync("AiEmergency", featureId, requestedBy, reason) to register the authority decision
- Set AuthorityContextPropagator.SetContext with the AiEmergency decision
- Return new record

Implement `ConfirmEscalationAsync`:
- Get current record, validate State==Active
- Create new record with State=Confirmed, ResolvedAt=now, ResolvedBy=confirmedBy, compute hash, store
- Return new record

Implement `RevertEscalationAsync`:
- Get current record, validate State==Active
- Create new record with State=Reverted, ResolvedAt=now, ResolvedBy=revertedBy, compute hash, store
- Clear AuthorityContextPropagator if the reverted escalation was the current context
- Return new record

Implement `CheckTimeoutsAsync`:
- Get all Active escalations from store
- For each: if ActivatedAt + OverrideWindow < DateTimeOffset.UtcNow, transition to TimedOut
- TimedOut records have ResolvedAt=now, ResolvedBy=null (system auto-revert)

Use `SemaphoreSlim(1,1)` for state transitions to prevent race conditions on the same escalation.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>State machine enforces Pending->Active->Confirmed|Reverted|TimedOut transitions, records are immutable with SHA256 hash verification, timeout auto-reverts expired escalations</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
```

Verify:
- EscalationRecord.VerifyIntegrity() returns true for unmodified records
- Modifying any field and calling VerifyIntegrity() returns false (tamper detection)
- State machine rejects invalid transitions (e.g., Pending -> Confirmed throws)
- Timeout check correctly auto-reverts expired Active escalations
- MaxConcurrentEscalations is enforced
</verification>

<success_criteria>
- Emergency AI override has configurable time window (default 15 min)
- State machine enforces: Pending -> Active -> Confirmed/Reverted/TimedOut
- EscalationRecord has SHA256 tamper-proof hash that detects any modification
- Timeout auto-reverts without admin action
- Integrates with IAuthorityResolver from Plan 01
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/75-authority-chain/75-02-SUMMARY.md`
</output>
