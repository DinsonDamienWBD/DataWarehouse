---
phase: 75-authority-chain
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs
  - DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs
  - DataWarehouse.SDK/Infrastructure/Authority/AuthorityContextPropagator.cs
autonomous: true

must_haves:
  truths:
    - "Authority resolution enforces Quorum > AiEmergency > Admin > SystemDefaults ordering"
    - "Lower-authority levels cannot override decisions made at a higher authority level"
    - "Authority context propagates through policy resolution calls"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs"
      provides: "AuthorityResolution record, AuthorityDecision record, IAuthorityResolver interface"
      contains: "IAuthorityResolver"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs"
      provides: "Resolution order enforcement engine"
      contains: "class AuthorityResolutionEngine"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityContextPropagator.cs"
      provides: "AsyncLocal-based authority context propagation"
      contains: "class AuthorityContextPropagator"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs"
      via: "Uses existing AuthorityChain and AuthorityLevel records"
      pattern: "AuthorityChain|AuthorityLevel"
    - from: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs"
      to: "DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs"
      via: "Implements IAuthorityResolver"
      pattern: "IAuthorityResolver"
---

<objective>
Build the authority chain model and resolution engine that enforces the strict priority ordering: Quorum > AiEmergency > Admin > SystemDefaults.

Purpose: AUTH-09 requires that authority resolution order is enforced and lower authorities cannot override higher ones. This is the foundation all other Phase 75 plans depend on.

Output: Contract types (IAuthorityResolver, AuthorityDecision, AuthorityResolution), resolution engine, context propagator.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/PolicyEnums.cs
@DataWarehouse.SDK/Contracts/Policy/IPolicyEngine.cs
@DataWarehouse.SDK/Infrastructure/Policy/PolicyResolutionEngine.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Authority contract types and IAuthorityResolver interface</name>
  <files>DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs` in namespace `DataWarehouse.SDK.Contracts.Policy` with [SdkCompatibility("6.0.0", Notes = "Phase 75: Authority Chain (AUTH-09)")]:

1. `sealed record AuthorityDecision` -- represents a decision made at a specific authority level:
   - `required string DecisionId { get; init; }` -- unique ID (GUID string)
   - `required string AuthorityLevelName { get; init; }` -- "Quorum", "AiEmergency", "Admin", "SystemDefaults"
   - `required int AuthorityPriority { get; init; }` -- 0=highest (from AuthorityLevel.Priority)
   - `required string Action { get; init; }` -- what was decided (e.g., "OverrideEncryptionPolicy")
   - `required DateTimeOffset Timestamp { get; init; }`
   - `string? DecisionReason { get; init; }` -- human-readable reason
   - `string? ActorId { get; init; }` -- who made the decision
   - `bool IsActive { get; init; } = true` -- can be superseded by higher authority

2. `sealed record AuthorityResolution` -- result of resolving which authority wins:
   - `required AuthorityDecision WinningDecision { get; init; }`
   - `IReadOnlyList<AuthorityDecision> OverriddenDecisions { get; init; }` -- lower-priority decisions that were suppressed
   - `required AuthorityChain Chain { get; init; }` -- the chain used for resolution
   - `required DateTimeOffset ResolvedAt { get; init; }`

3. `interface IAuthorityResolver`:
   - `Task<AuthorityResolution> ResolveAsync(string action, IReadOnlyList<AuthorityDecision> decisions, AuthorityChain? chain = null, CancellationToken ct = default)` -- given competing decisions for the same action, returns which one wins based on authority ordering
   - `Task<bool> CanOverrideAsync(AuthorityDecision proposed, AuthorityDecision existing, CancellationToken ct = default)` -- returns true only if proposed.AuthorityPriority < existing.AuthorityPriority (lower number = higher authority)
   - `Task<AuthorityDecision> RecordDecisionAsync(string authorityLevelName, string action, string? actorId = null, string? reason = null, CancellationToken ct = default)` -- creates and stores a new AuthorityDecision

4. `sealed record AuthorityConfiguration` -- configurable settings:
   - `AuthorityChain Chain { get; init; }` -- defaults to AuthorityChain.Default()
   - `bool StrictEnforcement { get; init; } = true` -- when true, throw if lower tries to override higher
   - `TimeSpan DecisionRetentionPeriod { get; init; }` -- how long to keep decisions, default 90 days

Use existing `AuthorityChain` and `AuthorityLevel` from PolicyTypes.cs -- do NOT duplicate them. Import them via the same namespace.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>AuthorityTypes.cs compiles with all 4 types, references existing AuthorityChain/AuthorityLevel from PolicyTypes.cs</done>
</task>

<task type="auto">
  <name>Task 2: Authority resolution engine and context propagator</name>
  <files>DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs, DataWarehouse.SDK/Infrastructure/Authority/AuthorityContextPropagator.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs` in namespace `DataWarehouse.SDK.Infrastructure.Authority` with [SdkCompatibility("6.0.0", Notes = "Phase 75: Authority Chain (AUTH-09)")]:

`public sealed class AuthorityResolutionEngine : IAuthorityResolver`

Constructor takes `AuthorityConfiguration? config = null` (defaults to new AuthorityConfiguration()).

Internal state: `ConcurrentDictionary<string, List<AuthorityDecision>>` keyed by action name for decision history.

Implement `ResolveAsync`:
- Group decisions by action, sort by AuthorityPriority ascending (lowest number = highest authority)
- The winning decision is the one with the lowest AuthorityPriority
- All decisions with higher AuthorityPriority numbers go into OverriddenDecisions
- If no decisions provided, throw ArgumentException
- Use the configured chain (parameter > config default > AuthorityChain.Default())

Implement `CanOverrideAsync`:
- Return true ONLY if proposed.AuthorityPriority < existing.AuthorityPriority
- If StrictEnforcement is true and proposed.AuthorityPriority >= existing.AuthorityPriority, return false (never allow equal priority to override)

Implement `RecordDecisionAsync`:
- Create AuthorityDecision with new GUID, timestamp = DateTimeOffset.UtcNow
- Validate authorityLevelName exists in the configured chain's Levels (throw ArgumentException if not)
- Look up the Priority from the chain's AuthorityLevel by name
- Store in the ConcurrentDictionary under the action key
- Return the created decision

Add helper method: `public IReadOnlyList<AuthorityDecision> GetDecisionHistory(string action)` -- returns all decisions for an action, newest first.

Add helper method: `public void PurgeExpiredDecisions()` -- removes decisions older than DecisionRetentionPeriod.

---

Create `DataWarehouse.SDK/Infrastructure/Authority/AuthorityContextPropagator.cs`:

`public static class AuthorityContextPropagator`

Uses `AsyncLocal<AuthorityDecision?>` to propagate the current active authority decision through async call chains.

- `public static AuthorityDecision? Current { get => _current.Value; }`
- `public static IDisposable SetContext(AuthorityDecision decision)` -- sets the AsyncLocal value, returns IDisposable that restores the previous value on dispose (scope pattern)
- `public static void Clear()` -- sets AsyncLocal to null

The IDisposable returned is a private nested `AuthorityScope` class that captures the previous value and restores it on Dispose.
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>AuthorityResolutionEngine enforces strict priority ordering (lower number wins), CanOverride returns false for equal or lower authority, context propagates via AsyncLocal</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
# Must show: Build succeeded. 0 Warning(s). 0 Error(s).
```

Verify resolution ordering logic:
- Decision at Priority 0 (Quorum) always wins over Priority 1, 2, 3
- CanOverrideAsync(Priority=2, Priority=1) returns false (Admin cannot override AiEmergency)
- CanOverrideAsync(Priority=0, Priority=2) returns true (Quorum can override Admin)
- RecordDecisionAsync with invalid level name throws ArgumentException
</verification>

<success_criteria>
- IAuthorityResolver interface and all supporting types compile
- AuthorityResolutionEngine correctly enforces Quorum > AiEmergency > Admin > SystemDefaults
- Lower authority CANNOT override higher authority (CanOverrideAsync enforces this)
- Context propagation works via AsyncLocal pattern
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/75-authority-chain/75-01-SUMMARY.md`
</output>
