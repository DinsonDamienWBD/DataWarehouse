---
phase: 75-authority-chain
plan: 04
type: execute
wave: 4
depends_on: ["75-01", "75-02", "75-03"]
files_modified:
  - DataWarehouse.SDK/Contracts/Policy/HardwareTokenTypes.cs
  - DataWarehouse.SDK/Infrastructure/Authority/HardwareTokenValidator.cs
  - DataWarehouse.SDK/Infrastructure/Authority/DeadManSwitch.cs
  - DataWarehouse.SDK/Infrastructure/Authority/AuthorityChainFacade.cs
autonomous: true

must_haves:
  truths:
    - "YubiKey and smart card hardware tokens are accepted as quorum approval mechanisms"
    - "Dead man's switch triggers auto-lock to maximum security after N days without super admin activity"
    - "Authority chain facade integrates all components: resolution, escalation, quorum, tokens, dead man's switch"
    - "All AUTH-01 through AUTH-09 requirements are satisfied by the combined system"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Policy/HardwareTokenTypes.cs"
      provides: "IHardwareTokenValidator, HardwareTokenType enum, TokenValidationResult"
      contains: "IHardwareTokenValidator"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/HardwareTokenValidator.cs"
      provides: "Token validation engine for YubiKey OTP and smart card certificate"
      contains: "class HardwareTokenValidator"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/DeadManSwitch.cs"
      provides: "Inactivity monitoring with auto-lock to max security"
      contains: "class DeadManSwitch"
    - path: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityChainFacade.cs"
      provides: "Unified entry point integrating all authority subsystems"
      contains: "class AuthorityChainFacade"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Authority/HardwareTokenValidator.cs"
      to: "DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs"
      via: "Token validation used during quorum approval"
      pattern: "IHardwareTokenValidator|ApprovalMethod"
    - from: "DataWarehouse.SDK/Infrastructure/Authority/DeadManSwitch.cs"
      to: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs"
      via: "Records SystemDefaults auto-lock decision on inactivity"
      pattern: "IAuthorityResolver|RecordDecisionAsync"
    - from: "DataWarehouse.SDK/Infrastructure/Authority/AuthorityChainFacade.cs"
      to: "DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs"
      via: "Delegates quorum operations"
      pattern: "IQuorumService"
---

<objective>
Add hardware token support (YubiKey, smart card) for quorum approval, implement the dead man's switch for inactivity auto-lock, and create the unified AuthorityChainFacade that ties all authority subsystems together.

Purpose: AUTH-06 (hardware tokens), AUTH-08 (dead man's switch), and integration of all AUTH-01 through AUTH-09 into a single usable facade.

Output: Hardware token types/validator, dead man's switch, authority chain facade.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/75-authority-chain/75-01-SUMMARY.md
@.planning/phases/75-authority-chain/75-02-SUMMARY.md
@.planning/phases/75-authority-chain/75-03-SUMMARY.md
@DataWarehouse.SDK/Contracts/Policy/PolicyTypes.cs
@DataWarehouse.SDK/Contracts/Policy/AuthorityTypes.cs
@DataWarehouse.SDK/Contracts/Policy/EscalationTypes.cs
@DataWarehouse.SDK/Contracts/Policy/QuorumTypes.cs
@DataWarehouse.SDK/Infrastructure/Authority/AuthorityResolutionEngine.cs
@DataWarehouse.SDK/Infrastructure/Authority/EscalationStateMachine.cs
@DataWarehouse.SDK/Infrastructure/Authority/QuorumEngine.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hardware token types, validator, and dead man's switch</name>
  <files>DataWarehouse.SDK/Contracts/Policy/HardwareTokenTypes.cs, DataWarehouse.SDK/Infrastructure/Authority/HardwareTokenValidator.cs, DataWarehouse.SDK/Infrastructure/Authority/DeadManSwitch.cs</files>
  <action>
Create `DataWarehouse.SDK/Contracts/Policy/HardwareTokenTypes.cs` in namespace `DataWarehouse.SDK.Contracts.Policy` with [SdkCompatibility("6.0.0", Notes = "Phase 75: Hardware Tokens & Dead Man's Switch (AUTH-06, AUTH-08)")]:

1. `enum HardwareTokenType` with [Description]:
   - `YubiKeyOtp = 0` -- YubiKey one-time password (Yubico OTP)
   - `YubiKeyFido2 = 1` -- YubiKey FIDO2/WebAuthn
   - `SmartCardPiv = 2` -- PIV smart card with X.509 certificate
   - `SmartCardCac = 3` -- DoD Common Access Card (CAC)
   - `TpmAttestation = 4` -- TPM-based remote attestation

2. `sealed record HardwareTokenChallenge`:
   - `required string ChallengeId { get; init; }` -- GUID
   - `required HardwareTokenType TokenType { get; init; }`
   - `required string ChallengeData { get; init; }` -- nonce or challenge bytes as base64
   - `required DateTimeOffset IssuedAt { get; init; }`
   - `required TimeSpan ValidFor { get; init; }` -- default 5 minutes

3. `sealed record TokenValidationResult`:
   - `required bool IsValid { get; init; }`
   - `required HardwareTokenType TokenType { get; init; }`
   - `string? TokenSerialNumber { get; init; }`
   - `string? CertificateSubject { get; init; }` -- for smart cards
   - `string? FailureReason { get; init; }`
   - `required DateTimeOffset ValidatedAt { get; init; }`
   - Static factory methods: `Success(HardwareTokenType type, string? serial, string? certSubject)` and `Failure(HardwareTokenType type, string reason)`

4. `interface IHardwareTokenValidator`:
   - `Task<HardwareTokenChallenge> CreateChallengeAsync(HardwareTokenType tokenType, CancellationToken ct = default)`
   - `Task<TokenValidationResult> ValidateResponseAsync(string challengeId, string responseData, CancellationToken ct = default)`
   - `bool IsTokenTypeSupported(HardwareTokenType tokenType)`

5. `sealed record DeadManSwitchConfiguration`:
   - `TimeSpan InactivityThreshold { get; init; } = TimeSpan.FromDays(30)` -- N days before auto-lock
   - `TimeSpan WarningPeriod { get; init; } = TimeSpan.FromDays(7)` -- warn N days before lock
   - `bool Enabled { get; init; } = true`
   - `string[] MonitoredActivityTypes { get; init; }` -- default = { "QuorumApproval", "EscalationConfirm", "PolicyChange", "Login" }

---

Create `DataWarehouse.SDK/Infrastructure/Authority/HardwareTokenValidator.cs`:

`public sealed class HardwareTokenValidator : IHardwareTokenValidator`

Constructor takes no dependencies (real hardware interaction is via strategy pattern -- this is the framework).

Internal: `ConcurrentDictionary<string, HardwareTokenChallenge>` for pending challenges.

`CreateChallengeAsync`: Generate 32-byte random nonce using `RandomNumberGenerator.Fill`, base64 encode, create challenge with 5-min validity, store it.

`ValidateResponseAsync`:
- Look up challenge by ID, remove from dictionary (single-use)
- Validate not expired (IssuedAt + ValidFor >= now)
- Validate response based on TokenType:
  - YubiKeyOtp: Validate OTP format (44 chars, modhex encoding). Production would call Yubico cloud validation API -- here validate format and structure with clear comment noting production would call `api.yubico.com/wsapi/2.0/verify`. Return Success with extracted serial.
  - YubiKeyFido2: Validate CBOR attestation structure exists and is non-empty. Comment noting production FIDO2 ceremony verification. Return Success.
  - SmartCardPiv/Cac: Validate base64 response decodes to valid X.509 DER structure (try `new X509Certificate2(Convert.FromBase64String(responseData))`). Extract Subject. Return Success with CertificateSubject.
  - TpmAttestation: Validate TPM attestation blob is non-empty and at least 256 bytes. Comment noting production would verify TPM quote. Return Success.
- On any validation failure: return Failure with descriptive reason.

`IsTokenTypeSupported`: Return true for all HardwareTokenType values (all supported).

---

Create `DataWarehouse.SDK/Infrastructure/Authority/DeadManSwitch.cs`:

`public sealed class DeadManSwitch`

Constructor takes: `IAuthorityResolver authorityResolver, DeadManSwitchConfiguration? config = null`

Internal state:
- `ConcurrentDictionary<string, DateTimeOffset>` -- maps activityType to last activity timestamp
- `volatile bool _isLocked` -- true if auto-lock has triggered
- `volatile bool _warningIssued`

Methods:
- `void RecordActivity(string activityType, string actorId)` -- updates last activity timestamp for this type. If _isLocked, throw InvalidOperationException("System is locked by dead man's switch; super admin must authenticate to unlock"). Only record if activityType is in MonitoredActivityTypes.
- `Task<DeadManSwitchStatus> CheckStatusAsync(CancellationToken ct = default)` -- returns status record with: IsLocked, IsWarning, LastActivityAt, DaysUntilLock, DaysSinceLastActivity
- `Task CheckAndEnforceAsync(CancellationToken ct = default)` -- the main check method:
  - Find the most recent activity across all types
  - If no activity ever recorded, use switch creation time
  - If elapsed > InactivityThreshold: set _isLocked=true, call authorityResolver.RecordDecisionAsync("SystemDefaults", "DeadManSwitch.AutoLock", null, "No super admin activity for {N} days")
  - If elapsed > InactivityThreshold - WarningPeriod: set _warningIssued=true
- `Task UnlockAsync(string superAdminId, CancellationToken ct = default)` -- resets _isLocked, records activity, records authority decision "DeadManSwitch.Unlock"

`sealed record DeadManSwitchStatus`:
- `bool IsLocked { get; init; }`
- `bool IsWarning { get; init; }`
- `DateTimeOffset? LastActivityAt { get; init; }`
- `int DaysUntilLock { get; init; }` -- 0 if locked, negative if overdue
- `int DaysSinceLastActivity { get; init; }`
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>Hardware token validator supports YubiKey and smart card challenge-response, dead man's switch monitors inactivity and auto-locks after configured days</done>
</task>

<task type="auto">
  <name>Task 2: Authority chain facade integrating all subsystems</name>
  <files>DataWarehouse.SDK/Infrastructure/Authority/AuthorityChainFacade.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Authority/AuthorityChainFacade.cs` in namespace `DataWarehouse.SDK.Infrastructure.Authority` with [SdkCompatibility("6.0.0", Notes = "Phase 75: Authority Chain Facade (AUTH-01 through AUTH-09)")]:

`public sealed class AuthorityChainFacade`

Constructor takes all subsystems:
- `IAuthorityResolver authorityResolver`
- `IEscalationService escalationService`
- `IQuorumService quorumService`
- `IHardwareTokenValidator hardwareTokenValidator`
- `DeadManSwitch deadManSwitch`

Expose all subsystems as read-only properties:
- `public IAuthorityResolver Authority { get; }`
- `public IEscalationService Escalation { get; }`
- `public IQuorumService Quorum { get; }`
- `public IHardwareTokenValidator HardwareTokens { get; }`
- `public DeadManSwitch DeadManSwitch { get; }`

High-level convenience methods:

1. `async Task<AuthorityResolution> ResolveAuthorityAsync(string action, CancellationToken ct = default)`:
   - Check dead man's switch status first -- if locked, only Quorum-level decisions can proceed
   - Gather all active decisions for this action from the authority resolver
   - Resolve using authority chain ordering
   - Return resolution

2. `async Task<QuorumRequest> RequestProtectedActionAsync(QuorumAction action, string requestedBy, string justification, CancellationToken ct = default)`:
   - Record activity on dead man's switch
   - Delegate to quorumService.InitiateQuorumAsync
   - Return request

3. `async Task<QuorumRequest> ApproveWithHardwareTokenAsync(string requestId, string approverId, string approverName, HardwareTokenType tokenType, string tokenResponse, CancellationToken ct = default)`:
   - Create challenge and validate token via hardwareTokenValidator
   - If validation fails, throw InvalidOperationException with TokenValidationResult.FailureReason
   - If validation succeeds, call quorumService.ApproveAsync with method = tokenType.ToString()
   - Record activity on dead man's switch
   - Return updated request

4. `async Task<EscalationRecord> EmergencyOverrideAsync(string requestedBy, string reason, string featureId, TimeSpan? window = null, CancellationToken ct = default)`:
   - Record activity on dead man's switch
   - Delegate to escalationService.RequestEscalationAsync
   - Return record

5. `async Task RunMaintenanceAsync(CancellationToken ct = default)`:
   - Call escalationService.CheckTimeoutsAsync
   - Call quorumService.CheckExpirationsAsync
   - Call deadManSwitch.CheckAndEnforceAsync
   - This method should be called periodically (e.g., every minute by a background timer)

Static factory method:
`public static AuthorityChainFacade CreateDefault(AuthorityConfiguration? authorityConfig = null, EscalationConfiguration? escalationConfig = null, QuorumConfiguration? quorumConfig = null, DeadManSwitchConfiguration? deadManConfig = null)`
- Wires up all components with default configurations
- Creates AuthorityResolutionEngine, EscalationRecordStore, EscalationStateMachine, QuorumVetoHandler, QuorumEngine, HardwareTokenValidator, DeadManSwitch
- Returns fully wired facade
  </action>
  <verify>dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore 2>&1 | tail -5</verify>
  <done>AuthorityChainFacade wires all subsystems, CreateDefault() produces fully functional authority chain, hardware token approval works through facade, dead man's switch integrates with all operations</done>
</task>

</tasks>

<verification>
```bash
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj 2>&1 | tail -3
```

Full integration verification:
- AuthorityChainFacade.CreateDefault() returns working facade with all subsystems
- ApproveWithHardwareTokenAsync validates token before recording approval
- EmergencyOverrideAsync creates escalation and records AiEmergency decision
- RunMaintenanceAsync checks timeouts, expirations, and dead man's switch
- Dead man's switch auto-locks after configured inactivity period
- Locked system only allows Quorum-level operations
</verification>

<success_criteria>
- YubiKey OTP and smart card PIV/CAC tokens accepted for quorum approval
- Dead man's switch triggers auto-lock after N days of inactivity
- AuthorityChainFacade integrates all: resolution, escalation, quorum, tokens, dead man's switch
- CreateDefault() factory produces fully wired system with no external dependencies
- All AUTH-01 through AUTH-09 requirements addressed by the combined system
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/75-authority-chain/75-04-SUMMARY.md`
</output>
