---
phase: 86-adaptive-index-engine
plan: 10
type: execute
wave: 2
depends_on: ["86-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DisruptorRingBuffer.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DisruptorMessageBus.cs
autonomous: true
must_haves:
  truths:
    - "Pre-allocated ring buffer avoids GC pressure on hot path"
    - "Cache-line padding prevents false sharing between producer/consumer sequences"
    - "Sequence barriers coordinate multi-consumer progress"
    - "Channel<T> fallback preserved for non-hot paths"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DisruptorRingBuffer.cs"
      provides: "LMAX Disruptor-style ring buffer"
      exports: ["DisruptorRingBuffer"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DisruptorMessageBus.cs"
      provides: "High-throughput message bus using Disruptor pattern"
      exports: ["DisruptorMessageBus"]
  key_links:
    - from: "DisruptorMessageBus"
      to: "DisruptorRingBuffer"
      via: "publishes via ring buffer Publish method"
      pattern: "_ringBuffer\\.Publish"
---

<objective>
Implement LMAX Disruptor-style message bus: pre-allocated ring buffer, cache-line padding, sequence barriers, configurable wait strategies. Replaces Channel<T> on hot paths while preserving Channel<T> as fallback.

Purpose: The adaptive index engine needs ultra-low-latency inter-component messaging (morph notifications, cache invalidations, metric updates). The Disruptor pattern achieves 10M+ msgs/sec with P99 < 10us via mechanical sympathy (cache-line alignment, pre-allocation, lock-free sequences).
Output: 2 files implementing the Disruptor ring buffer and message bus.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Disruptor ring buffer with cache-line padding and sequence barriers</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DisruptorRingBuffer.cs
  </files>
  <action>
    **DisruptorRingBuffer.cs**: Generic `DisruptorRingBuffer<T>` where T : struct.

    1. **Ring buffer core**:
       - `T[] _entries` — pre-allocated array, power-of-two size (default 65536 = 2^16)
       - `int _indexMask` — `bufferSize - 1` for fast modulo via bitwise AND
       - Constructor validates power-of-two, pre-fills array with `default(T)`

    2. **Sequence counters** with cache-line padding:
       - `PaddedSequence` struct: `[StructLayout(LayoutKind.Explicit, Size = 128)]` with `[FieldOffset(56)] long Value` (center of 128 bytes to pad both sides from 64-byte cache line neighbors)
       - `_cursor` (PaddedSequence): publisher's committed sequence
       - `_gatingSequences` (PaddedSequence[]): per-consumer progress tracking

    3. **Publish**:
       - `long Next()`: Claims next sequence number via `Interlocked.Increment` on claim counter. Waits (spin) if ring buffer is full (claimed - min(gating) >= bufferSize).
       - `ref T this[long sequence]`: Returns ref to pre-allocated slot for direct write (zero-copy).
       - `void Publish(long sequence)`: Makes entry visible by advancing `_cursor` to sequence. Uses `Volatile.Write` for release semantics.

    4. **Consume** via `SequenceBarrier`:
       - `SequenceBarrier(DisruptorRingBuffer<T> ring, PaddedSequence cursorRef)` — tracks a consumer's dependency
       - `long WaitFor(long sequence, IWaitStrategy waitStrategy)`: Blocks until cursor >= sequence
       - `IWaitStrategy` interface with implementations:
         - `BusySpinWaitStrategy`: `Thread.SpinWait` — lowest latency, highest CPU
         - `YieldingWaitStrategy`: `Thread.Yield` after N spins — good balance
         - `SleepingWaitStrategy`: `Thread.Sleep(0)` then `Thread.Sleep(1)` — lowest CPU
         - `BlockingWaitStrategy`: `ManualResetEventSlim` — for non-hot paths

    5. **BatchEventProcessor<T>**:
       - Processes events in batches from `nextSequence` to `availableSequence`
       - Calls `Action<T, long> handler` for each event
       - Updates its gating sequence after batch processing
       - Runs on dedicated thread via `Task.Factory.StartNew(TaskCreationOptions.LongRunning)`
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>DisruptorRingBuffer provides pre-allocated, cache-line-padded, lock-free ring buffer with sequence barriers and configurable wait strategies.</done>
</task>

<task type="auto">
  <name>Task 2: Disruptor message bus with Channel<T> fallback</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DisruptorMessageBus.cs
  </files>
  <action>
    **DisruptorMessageBus.cs**: High-throughput internal message bus for AIE components.

    1. **IndexMessage** struct: `IndexMessageType Type` (enum: MorphStarted, MorphCompleted, CacheInvalidation, MetricUpdate, ShardSplit, ShardMerge), `long Payload1`, `long Payload2`, `int ShardId`, `long Timestamp`.

    2. **DisruptorMessageBus**: Wraps `DisruptorRingBuffer<IndexMessage>`.
       - `Publish(IndexMessage msg)`: Claims sequence, writes message, publishes. Returns immediately (fire-and-forget for producer).
       - `Subscribe(IndexMessageType type, Action<IndexMessage> handler)`: Registers handler for specific message type. Internally creates a `BatchEventProcessor` filtered by type.
       - `Subscribe(Action<IndexMessage> handler)`: All messages.
       - `Unsubscribe(IDisposable subscription)`: Removes handler.
       - `long PublishedCount` — total published via `Interlocked.Read`
       - `long ProcessedCount` — total processed across all consumers

    3. **Channel<T> fallback**:
       - `DisruptorMessageBus(bool useDisruptor = true, int ringSize = 65536)`
       - When `useDisruptor = false`, internally uses `Channel.CreateBounded<IndexMessage>(ringSize)` with `BoundedChannelFullMode.Wait`
       - Same `Publish`/`Subscribe` API — callers don't know which backend
       - Auto-detect: if `Environment.ProcessorCount < 4`, default to Channel<T> (Disruptor benefits require multicore)

    4. **Metrics**:
       - `long MessagesPerSecond` — computed via sliding window (count deltas over 1-second intervals)
       - `long P99LatencyTicks` — tracked via sorted insertion of last 1000 latencies (measured as publish-to-process Stopwatch ticks)

    Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-10 Disruptor message bus")]`.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>DisruptorMessageBus provides 10M+ msg/sec internal messaging for AIE components with automatic Channel<T> fallback on low-core systems.</done>
</task>

</tasks>

<verification>
- Both files exist under `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- PaddedSequence uses StructLayout with 128-byte size for cache-line isolation
- Wait strategies provide latency/CPU trade-off options
</verification>

<success_criteria>
- Ring buffer is pre-allocated with power-of-two size
- Cache-line padding prevents false sharing (128-byte padded sequences)
- Sequence barriers coordinate producer-consumer progress
- Channel<T> fallback activated on < 4 cores or explicit opt-out
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/86-adaptive-index-engine/86-10-SUMMARY.md`
</output>
