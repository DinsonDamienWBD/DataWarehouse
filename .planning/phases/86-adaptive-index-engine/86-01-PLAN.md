---
phase: 86-adaptive-index-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IAdaptiveIndex.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphLevel.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DirectPointerIndex.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/SortedArrayIndex.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/ArtIndex.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/ArtNode.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/AdaptiveIndexEngine.cs
autonomous: true
must_haves:
  truths:
    - "IAdaptiveIndex provides same API surface as IBTreeIndex plus morph-level awareness"
    - "DirectPointerIndex handles 1 object with O(1) lookup"
    - "SortedArrayIndex handles up to threshold objects with binary search O(log n)"
    - "ART index handles large key sets with O(k) lookup where k is key length"
    - "AdaptiveIndexEngine selects correct level based on object count"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IAdaptiveIndex.cs"
      provides: "Adaptive index contract extending IBTreeIndex"
      exports: ["IAdaptiveIndex"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphLevel.cs"
      provides: "Enum for 7 morph levels (0-6)"
      exports: ["MorphLevel"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/AdaptiveIndexEngine.cs"
      provides: "Orchestrator that delegates to correct level implementation"
      exports: ["AdaptiveIndexEngine"]
  key_links:
    - from: "AdaptiveIndexEngine"
      to: "IAdaptiveIndex implementations"
      via: "MorphLevel-based dispatch"
      pattern: "switch.*MorphLevel"
---

<objective>
Build the foundational adaptive index infrastructure: IAdaptiveIndex interface, MorphLevel enum (7 levels), and implementations for Levels 0-2 (Direct Pointer, Sorted Array, ART with Node4/16/48/256).

Purpose: Establishes the morphing index contract and the three simplest levels that handle small-to-medium datasets. All subsequent levels (3-6) build on this interface.
Output: 7 new files in AdaptiveIndex/ directory; AdaptiveIndexEngine orchestrator that auto-selects level.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/VirtualDiskEngine/Index/IBTreeIndex.cs
@DataWarehouse.SDK/VirtualDiskEngine/Index/BTree.cs
@DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/IBlockAllocator.cs
@DataWarehouse.SDK/VirtualDiskEngine/Journal/IWriteAheadLog.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: IAdaptiveIndex contract, MorphLevel enum, and Level 0-1 implementations</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IAdaptiveIndex.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphLevel.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/DirectPointerIndex.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/SortedArrayIndex.cs
  </files>
  <action>
    Create directory `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`.

    1. **MorphLevel.cs**: Enum with 7 values: `DirectPointer = 0`, `SortedArray = 1`, `AdaptiveRadixTree = 2`, `BeTree = 3`, `LearnedIndex = 4`, `BeTreeForest = 5`, `DistributedRouting = 6`. Add `[Description]` attributes for each.

    2. **IAdaptiveIndex.cs**: Interface extending `IBTreeIndex` (from existing codebase). Add:
       - `MorphLevel CurrentLevel { get; }`
       - `long ObjectCount { get; }`
       - `Task MorphToAsync(MorphLevel targetLevel, CancellationToken ct = default)` — explicit morph
       - `Task<MorphLevel> RecommendLevelAsync(CancellationToken ct = default)` — advisory
       - `event Action<MorphLevel, MorphLevel>? LevelChanged` — old, new
       Namespace: `DataWarehouse.SDK.VirtualDiskEngine.AdaptiveIndex`. Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-01")]`.

    3. **DirectPointerIndex.cs** (Level 0): Stores a single `(byte[] Key, long Value)?`. Throws if inserting second entry (caller should morph up). Implements all IBTreeIndex methods. RangeQuery yields the single entry if within range. CountAsync returns 0 or 1. Thread-safe via lock.

    4. **SortedArrayIndex.cs** (Level 1): Backed by `List<(byte[] Key, long Value)>` kept sorted by key (use `ByteArrayComparer`). Binary search for lookup/insert/delete. RangeQuery via BinarySearch for start then enumerate. Configurable `MaxCapacity` (default 10_000). When count exceeds MaxCapacity, callers should morph up. Include a static `ByteArrayComparer : IComparer<byte[]>` inner class comparing lexicographically. Thread-safe via ReaderWriterLockSlim.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>IAdaptiveIndex interface exists extending IBTreeIndex. MorphLevel enum has 7 values. DirectPointerIndex handles 0-1 entries. SortedArrayIndex handles up to 10K entries with binary search. All implement IAdaptiveIndex.</done>
</task>

<task type="auto">
  <name>Task 2: ART index (Level 2) and AdaptiveIndexEngine orchestrator</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/ArtNode.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/ArtIndex.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/AdaptiveIndexEngine.cs
  </files>
  <action>
    1. **ArtNode.cs**: Adaptive Radix Tree node types as nested sealed classes within abstract `ArtNode`:
       - `Node4`: 4 keys + 4 children, linear scan
       - `Node16`: 16 keys + 16 children, SIMD scan via `Vector128` if `Sse2.IsSupported`, else linear
       - `Node48`: 256-byte child-index array + 48 children pointers, O(1) lookup
       - `Node256`: 256 children pointers, O(1) lookup
       - Path compression: store shared prefix bytes in node, skip during traversal
       - Lazy expansion: single-child paths compressed to leaf with full key
       - Growth: Node4 -> Node16 -> Node48 -> Node256 when capacity exceeded
       - Shrink: reverse direction when children removed below threshold
       All nodes store `byte[] Prefix` and `int PrefixLength` for path compression. Leaf node stores `byte[] Key, long Value`.

    2. **ArtIndex.cs** (Level 2): Implements `IAdaptiveIndex`. Root is `ArtNode?`. Insert navigates/creates path, grows nodes as needed. Delete removes and shrinks. Lookup follows compressed path. RangeQuery does in-order DFS traversal with start/end bounds. Uses `ReaderWriterLockSlim` for concurrency. ObjectCount tracked via `long _count`.

    3. **AdaptiveIndexEngine.cs**: The main orchestrator implementing `IAdaptiveIndex`. Constructor takes `IBlockDevice`, `IBlockAllocator`, `IWriteAheadLog`, `long rootBlockNumber`, `int blockSize` (same as BTree). Internally holds the current `IAdaptiveIndex` implementation. Configurable thresholds: `Level0Max = 1`, `Level1Max = 10_000`, `Level2Max = 1_000_000`. After each Insert/Delete, checks if count crossed a threshold and auto-morphs (both up and down). MorphToAsync migrates data from old index to new by iterating all entries. Fires `LevelChanged` event. All IBTreeIndex methods delegate to current implementation. MorphLevel transitions are WAL-journaled via a morph-start/morph-complete marker (write marker to WAL before and after migration). For now, Levels 3-6 throw `NotSupportedException("Level N not yet implemented")` in the factory method.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>ART index with Node4/16/48/256, path compression, SIMD Node16 search is implemented. AdaptiveIndexEngine orchestrates Levels 0-2 with auto-morph on insert/delete thresholds. Levels 3-6 are stubbed as NotSupportedException.</done>
</task>

</tasks>

<verification>
- All 7 files exist under `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- IAdaptiveIndex extends IBTreeIndex
- AdaptiveIndexEngine auto-selects Level 0 for 0-1 objects, Level 1 for 2-10K, Level 2 for 10K-1M
</verification>

<success_criteria>
- IAdaptiveIndex contract established with morph-level awareness
- Levels 0, 1, 2 fully implemented and functional
- ART Node16 uses SIMD when available, scalar fallback otherwise
- AdaptiveIndexEngine auto-morphs between levels 0-2 based on object count
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/86-adaptive-index-engine/86-01-SUMMARY.md`
</output>
