---
phase: 86-adaptive-index-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTree.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTreeNode.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTreeMessage.cs
autonomous: true
must_haves:
  truths:
    - "Be-tree batches writes in message buffers, flushing on overflow"
    - "Tombstone propagation correctly marks deleted keys"
    - "Sequential insert of 10M keys uses far fewer I/Os than standard B-tree"
    - "On-disk format serializes nodes with message buffers"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTreeNode.cs"
      provides: "Be-tree node with epsilon-sized message buffer"
      exports: ["BeTreeNode"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTree.cs"
      provides: "Level 3 Be-tree implementation"
      exports: ["BeTree"]
  key_links:
    - from: "BeTree"
      to: "IBlockDevice"
      via: "block read/write for node persistence"
      pattern: "ReadBlockAsync|WriteBlockAsync"
    - from: "BeTree"
      to: "IWriteAheadLog"
      via: "WAL-protected structural modifications"
      pattern: "_wal\\.Write"
---

<objective>
Implement Level 3: Be-tree (Buffered epsilon tree) with epsilon=0.5 message buffers, batched flush cascading, tombstone propagation, and on-disk node format.

Purpose: The Be-tree is the workhorse index for medium-to-large datasets (1M-100M objects). Its write-optimized design batches insertions in internal node buffers, flushing cascading down only when buffers overflow, achieving O(log_B(N)/epsilon) I/Os per write vs O(log_B(N)) for B-trees.
Output: 3 files implementing the full Be-tree with WAL-protected operations.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/Index/IBTreeIndex.cs
@DataWarehouse.SDK/VirtualDiskEngine/Index/BTree.cs
@DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/IBlockAllocator.cs
@DataWarehouse.SDK/VirtualDiskEngine/Journal/IWriteAheadLog.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Be-tree message types and node structure</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTreeMessage.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTreeNode.cs
  </files>
  <action>
    1. **BeTreeMessage.cs**: A message buffered in internal Be-tree nodes.
       - `BeTreeMessageType` enum: `Insert`, `Update`, `Delete` (tombstone), `Upsert`
       - `BeTreeMessage` record struct: `BeTreeMessageType Type`, `byte[] Key`, `long Value`, `long Timestamp` (monotonic for ordering)
       - Messages sorted by key, then by timestamp descending (newest first) for resolution
       - Static `Resolve(IReadOnlyList<BeTreeMessage> messages)` method: given all messages for a key, returns the effective state (value or deleted). Delete wins if most recent. Insert/Upsert sets value.

    2. **BeTreeNode.cs**: On-disk node for Be-tree.
       - `bool IsLeaf` property
       - Leaf: stores sorted `List<(byte[] Key, long Value)>` entries (like B-tree leaf)
       - Internal: stores sorted pivot keys `List<byte[]>`, child block pointers `List<long>`, and a message buffer `List<BeTreeMessage>`
       - `int BufferCapacity` — computed as `blockSize^epsilon` where epsilon = 0.5 (sqrt of block size in entries). For 4KB blocks with ~100 entries/block: buffer capacity ~10.
       - `bool IsBufferFull => Messages.Count >= BufferCapacity`
       - Serialization: `byte[] Serialize(int blockSize)` and `static BeTreeNode Deserialize(byte[] data)` — format: [IsLeaf:1][EntryCount:4][BufferCount:4][Entries...][Messages...][Pivots...][Children...]
       - Use big-endian for all multi-byte integers in on-disk format
       - `long BlockNumber` for tracking which block this node occupies
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>BeTreeMessage supports Insert/Update/Delete/Upsert with timestamp-based resolution. BeTreeNode supports both leaf (sorted entries) and internal (pivots + children + message buffer) with serialization.</done>
</task>

<task type="auto">
  <name>Task 2: Be-tree core implementation (Level 3)</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BeTree.cs
  </files>
  <action>
    **BeTree.cs**: Implements `IAdaptiveIndex` as Level 3 (MorphLevel.BeTree).

    Constructor: `IBlockDevice device`, `IBlockAllocator allocator`, `IWriteAheadLog wal`, `long rootBlockNumber`, `int blockSize`, `double epsilon = 0.5`.

    Core operations:
    - **InsertAsync**: Add `BeTreeMessage(Insert, key, value, nextTimestamp)` to root's buffer. If root buffer full, flush cascade. WAL-protect the buffer write.
    - **DeleteAsync**: Add `BeTreeMessage(Delete, key, 0, nextTimestamp)` to root's buffer. Flush if full.
    - **LookupAsync**: Search from root. At each internal node, collect pending messages for key from buffer, then descend to correct child. At leaf, find entry. Apply message resolution (pending messages override leaf value). If resolved to Delete, return null.
    - **RangeQueryAsync**: In-order traversal collecting entries. At each internal node, merge buffer messages with child results. Yield entries in sorted order, applying message resolution per-key.
    - **UpdateAsync**: Add Upsert message.
    - **CountAsync**: Full tree traversal counting resolved live entries (expensive but correct).

    Flush cascade:
    - When an internal node's buffer is full, partition messages by child range and push each partition to the corresponding child's buffer. If a child's buffer also overflows, recursively flush.
    - Leaf flush: apply messages directly — Insert adds entry, Delete removes entry, Upsert sets value. Split leaf if over capacity (same as B-tree split).
    - Node split: when a node (internal or leaf) exceeds capacity, split at median. Promote median key to parent. WAL-protect the split.

    Node cache: `BoundedDictionary<long, BeTreeNode>` with `MaxCachedNodes = 2000`. Read-through from device, write-through on modification.

    Thread safety: `ReaderWriterLockSlim` — readers concurrent, single writer.

    `ObjectCount`: maintained as `long _count`, incremented on Insert (after resolution confirms new key), decremented on Delete.

    Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-02 Be-tree")]`.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>Be-tree Level 3 fully implemented with epsilon=0.5 message buffers, batched flush cascade, tombstone propagation, on-disk serialization, WAL protection, and node caching.</done>
</task>

</tasks>

<verification>
- All 3 files exist under `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- BeTree implements IAdaptiveIndex with CurrentLevel = MorphLevel.BeTree
- Message buffer capacity derived from block size and epsilon
</verification>

<success_criteria>
- Be-tree write path buffers messages in internal nodes, flushing on overflow
- Tombstone propagation via Delete messages with timestamp resolution
- On-disk format serializes/deserializes nodes with message buffers
- WAL-protected structural modifications (splits, flushes)
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/86-adaptive-index-engine/86-02-SUMMARY.md`
</output>
