---
phase: 86-adaptive-index-engine
plan: 09
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BwTree.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BwTreeMappingTable.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BwTreeDeltaRecord.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/EpochManager.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/Masstree.cs
autonomous: true
must_haves:
  truths:
    - "Bw-Tree uses lock-free CAS updates via mapping table indirection"
    - "Delta record chains provide append-only modification without page overwrites"
    - "Epoch-based GC safely reclaims unreachable delta records"
    - "Masstree provides O(k/8) lookup for namespace paths via 8-byte key slicing"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BwTree.cs"
      provides: "Lock-free Bw-Tree metadata cache"
      exports: ["BwTree"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/Masstree.cs"
      provides: "8-byte-slice trie for hot-path namespace lookups"
      exports: ["Masstree"]
  key_links:
    - from: "BwTree"
      to: "BwTreeMappingTable"
      via: "logical-to-physical page mapping"
      pattern: "_mappingTable\\.Get|CompareExchange"
    - from: "BwTree"
      to: "EpochManager"
      via: "epoch protection for GC"
      pattern: "_epochManager\\.Enter|Exit|AddGarbage"
---

<objective>
Implement Bw-Tree lock-free metadata cache (mapping table, delta record chains, CAS updates, epoch-based GC) and Masstree hot-path namespace lookup (8-byte key slicing, optimistic readers).

Purpose: Bw-Tree serves as the lock-free metadata cache for the adaptive index, enabling concurrent readers/writers without locks. Masstree accelerates namespace path lookups (e.g., /data/users/profiles) by slicing keys into 8-byte segments, enabling extremely fast trie traversal for hot paths.
Output: 5 files implementing Bw-Tree and Masstree data structures.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/Index/IBTreeIndex.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bw-Tree with mapping table, delta records, and epoch-based GC</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BwTreeDeltaRecord.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BwTreeMappingTable.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/EpochManager.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/BwTree.cs
  </files>
  <action>
    1. **BwTreeDeltaRecord.cs**: Base abstract class for delta records prepended to page chains.
       - `DeltaRecordType` enum: `Insert`, `Delete`, `Update`, `Split`, `Merge`, `RemoveNode`, `Consolidation`
       - Abstract `BwTreeDeltaRecord`: `DeltaRecordType Type`, `BwTreeDeltaRecord? Next` (chain pointer)
       - Concrete: `InsertDeltaRecord(byte[] Key, long Value, BwTreeDeltaRecord? Next)`, `DeleteDeltaRecord(byte[] Key, BwTreeDeltaRecord? Next)`, `SplitDeltaRecord(byte[] SeparatorKey, long NewSiblingPageId, BwTreeDeltaRecord? Next)`, `MergeDeltaRecord(long MergedPageId, BwTreeDeltaRecord? Next)`, `ConsolidationRecord` (terminal, holds consolidated page data: sorted entries + children)
       - Each record is immutable after creation (fields are readonly)

    2. **BwTreeMappingTable.cs**: Lock-free logical-to-physical page mapping.
       - Internal array of `object?[]` (delta record chain heads) indexed by logical page ID
       - `Get(long pageId)` returns current chain head
       - `CompareExchange(long pageId, object? expected, object? newValue)` — wraps `Interlocked.CompareExchange`
       - Auto-grows array (copy-on-resize with CAS on the array reference itself)
       - `long AllocatePageId()` — returns next available logical page ID via `Interlocked.Increment`

    3. **EpochManager.cs**: Epoch-based garbage collection for safe memory reclamation.
       - Global epoch counter (`long`, incremented periodically)
       - Per-thread epoch entry via `ThreadLocal<EpochEntry>` or `[ThreadStatic]`
       - `Enter()`: thread records current global epoch
       - `Exit()`: thread clears epoch
       - `AddGarbage(object garbage, long epoch)`: registers object for collection at epoch
       - `TryCollect()`: finds min active epoch across all threads, collects all garbage from epochs below min
       - Garbage stored in `ConcurrentQueue<(object Item, long Epoch)>`
       - `BumpEpoch()`: increments global epoch, called periodically (e.g., every 256 operations)

    4. **BwTree.cs**: Lock-free Bw-Tree implementation. Generic `BwTree<TKey, TValue>` where TKey : IComparable<TKey>.
       - Uses `BwTreeMappingTable` for all page access
       - **Lookup**: Get chain head from mapping table, traverse delta records for key, fall through to base page
       - **Insert**: Create `InsertDeltaRecord`, CAS prepend to chain. Retry on CAS failure.
       - **Delete**: Create `DeleteDeltaRecord`, CAS prepend. Retry on CAS failure.
       - **Consolidation**: When chain length exceeds threshold (default 8), consolidate: read all deltas, create new base page, CAS replace chain with `ConsolidationRecord`. Register old chain in epoch GC.
       - **Split**: When consolidated page exceeds capacity, create `SplitDeltaRecord` on old page and new sibling page. Update parent via CAS delta. Uses the Bw-Tree two-phase split protocol (split delta on child, then index delta on parent).
       - **Merge**: Reverse of split for underpopulated pages.
       - RangeQuery: leaf-level scan with delta overlay
       - Epoch: call `_epochManager.Enter()` before any operation, `Exit()` after
       - Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-09 Bw-Tree")]`
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>Bw-Tree provides lock-free concurrent access via mapping table indirection and CAS updates. Delta record chains enable append-only page modification. Epoch-based GC safely reclaims unreachable delta records.</done>
</task>

<task type="auto">
  <name>Task 2: Masstree hot-path namespace lookup</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/Masstree.cs
  </files>
  <action>
    **Masstree.cs**: A trie of B+-trees for fast namespace path lookups, slicing keys into 8-byte segments.

    Structure:
    - `MasstreeLayer`: A B+-tree over 8-byte key slices at one trie level
    - Each leaf in layer N can point to a `MasstreeLayer` at layer N+1 (for keys longer than 8*N bytes) or directly to a value (for keys that end at this layer)
    - `MasstreeNode`: internal (sorted 8-byte keys + children) or leaf (sorted 8-byte keys + values/next-layer pointers)

    Key slicing:
    - Key bytes split into 8-byte chunks. Key `/data/users` = chunk[0] = `/data/us`, chunk[1] = `ers\0\0\0\0\0` (zero-padded)
    - `ulong` comparison for each 8-byte slice (fast single-instruction compare)
    - Endianness: big-endian encoding of 8-byte slices so lexicographic byte order = numeric order

    Operations:
    - **Lookup(byte[] key)**: Slice key, traverse layers. At each layer, do B+-tree lookup on 8-byte slice. If found leaf with next-layer pointer, descend. If found value, return.
    - **Insert(byte[] key, long value)**: Navigate to correct layer/position. If key slice not found, insert. If layer doesn't exist, create new MasstreeLayer.
    - **Delete(byte[] key)**: Remove from leaf. If layer becomes empty, remove layer.
    - **PrefixScan(byte[] prefix)**: All keys with given prefix. Navigate to the layer/position matching prefix, then enumerate all descendants.

    Concurrency:
    - Optimistic read: version counter per node. Reader reads version, reads data, re-reads version. If changed, retry.
    - Writer: lock node, increment version, modify, unlock, increment version.
    - `Interlocked` for version counters, `SpinLock` for writer locks (short critical sections)

    Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-09 Masstree")]`.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>Masstree provides O(k/8) lookup for namespace paths via 8-byte key slicing. Optimistic readers enable high concurrent read throughput. PrefixScan supports namespace enumeration.</done>
</task>

</tasks>

<verification>
- All 5 files exist under `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- BwTree uses Interlocked.CompareExchange for all page updates (no locks on data path)
- EpochManager tracks per-thread epochs for safe garbage collection
- Masstree slices keys into 8-byte ulong segments for fast comparison
</verification>

<success_criteria>
- Bw-Tree lock-free metadata cache operational with CAS-based updates
- Delta record chain consolidation triggers at configurable threshold
- Epoch-based GC reclaims unreachable records safely
- Masstree 8-byte key slicing with optimistic readers for namespace lookups
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/86-adaptive-index-engine/86-09-SUMMARY.md`
</output>
