---
phase: 86-adaptive-index-engine
plan: 12
type: execute
wave: 4
depends_on: ["86-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IoUringBindings.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IoUringBlockDevice.cs
autonomous: true
must_haves:
  truths:
    - "io_uring on Linux provides 5x+ throughput over async file I/O"
    - "Registered buffers eliminate per-I/O kernel buffer copies"
    - "SQPoll enables kernel-side submission without syscalls"
    - "Graceful fallback on non-Linux (Windows/macOS) to standard async I/O"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IoUringBindings.cs"
      provides: "P/Invoke bindings to liburing.so"
      exports: ["IoUringBindings"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IoUringBlockDevice.cs"
      provides: "IBlockDevice implementation using io_uring"
      exports: ["IoUringBlockDevice"]
  key_links:
    - from: "IoUringBlockDevice"
      to: "IoUringBindings"
      via: "P/Invoke calls to liburing"
      pattern: "IoUringBindings\\."
---

<objective>
Implement io_uring native integration: LibraryImport bindings to liburing.so, NativeMemory.AlignedAlloc pre-pinned pages, ring-per-thread, registered buffers, SQPoll, NVMe passthrough (IORING_OP_URING_CMD), and graceful non-Linux fallback.

Purpose: io_uring is the fastest Linux I/O interface, enabling batched submissions with zero-copy via registered buffers. For the adaptive index, this means 5x+ throughput improvement for block reads/writes on NVMe devices.
Output: 2 files implementing io_uring bindings and block device.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/VirtualDiskEngine/FileBlockDevice.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: io_uring P/Invoke bindings</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IoUringBindings.cs
  </files>
  <action>
    **IoUringBindings.cs**: Low-level P/Invoke bindings to liburing.so using `[LibraryImport]`.

    1. **Structs** (matching liburing C structs with `[StructLayout(LayoutKind.Sequential)]`):
       - `IoUringParams`: flags, sq_entries, cq_entries, sq_thread_idle, features, etc.
       - `IoUringSqe`: opcode, flags, fd, off, addr, len, user_data, etc. (64 bytes)
       - `IoUringCqe`: user_data, res, flags (16 bytes)
       - `IoUring`: wrapped ring fd and mmap pointers

    2. **P/Invoke methods** with `[LibraryImport("liburing", SetLastError = true)]`:
       - `io_uring_queue_init_params(uint entries, ref IoUring ring, ref IoUringParams p)` -> int
       - `io_uring_queue_exit(ref IoUring ring)` -> void
       - `io_uring_get_sqe(ref IoUring ring)` -> nint (pointer to IoUringSqe)
       - `io_uring_submit(ref IoUring ring)` -> int (number submitted)
       - `io_uring_wait_cqe(ref IoUring ring, out nint cqe)` -> int
       - `io_uring_peek_batch_cqe(ref IoUring ring, nint* cqes, uint count)` -> uint
       - `io_uring_cqe_seen(ref IoUring ring, nint cqe)` -> void
       - `io_uring_register_buffers(ref IoUring ring, nint iovecs, uint nr_iovecs)` -> int
       - `io_uring_unregister_buffers(ref IoUring ring)` -> int
       - `io_uring_register_files(ref IoUring ring, int* fds, uint nr_fds)` -> int

    3. **SQE prep helpers** (static methods):
       - `PrepRead(nint sqe, int fd, nint buf, uint nbytes, long offset)`: Sets opcode IORING_OP_READ
       - `PrepWrite(nint sqe, int fd, nint buf, uint nbytes, long offset)`: Sets opcode IORING_OP_WRITE
       - `PrepReadFixed(nint sqe, int fd, nint buf, uint nbytes, long offset, int bufIndex)`: IORING_OP_READ_FIXED (registered buffer)
       - `PrepWriteFixed(nint sqe, int fd, nint buf, uint nbytes, long offset, int bufIndex)`: IORING_OP_WRITE_FIXED
       - `PrepUringCmd(nint sqe, int fd, nint cmdBuf, uint cmdLen)`: IORING_OP_URING_CMD for NVMe passthrough

    4. **Constants**: IORING_OP_READ = 22, IORING_OP_WRITE = 23, IORING_OP_READ_FIXED = 4, IORING_OP_WRITE_FIXED = 5, IORING_OP_URING_CMD = 80, IORING_SETUP_SQPOLL = 1 << 1, etc.

    5. **Availability check**: `static bool IsAvailable` — checks `RuntimeInformation.IsOSPlatform(OSPlatform.Linux)` and attempts `NativeLibrary.TryLoad("liburing", out _)`.

    Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-12 io_uring")]`.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>IoUringBindings provides complete P/Invoke surface for io_uring including queue management, SQE prep, registered buffers, and NVMe passthrough. Availability detection included.</done>
</task>

<task type="auto">
  <name>Task 2: IoUringBlockDevice with registered buffers and fallback</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IoUringBlockDevice.cs
  </files>
  <action>
    **IoUringBlockDevice.cs**: `IBlockDevice` implementation using io_uring for maximum I/O throughput.

    Constructor: `string filePath`, `int blockSize`, `int queueDepth = 256`, `bool useSqPoll = false`.

    1. **Initialization**:
       - Open file via `open()` P/Invoke with `O_DIRECT` flag (bypass page cache for direct I/O)
       - Initialize io_uring ring with queueDepth entries
       - If useSqPoll, set `IORING_SETUP_SQPOLL` flag (kernel submits without syscall)
       - Pre-allocate registered buffers: `NativeMemory.AlignedAlloc(blockSize, 4096)` for queueDepth buffers, register with `io_uring_register_buffers`
       - `_bufferPool` tracks available pre-registered buffers (ConcurrentQueue<int> of buffer indices)

    2. **ReadBlockAsync(long blockNumber, byte[] buffer)**:
       - Acquire registered buffer index from pool
       - Get SQE, prep read-fixed at offset = blockNumber * blockSize
       - Set user_data to correlation ID (for completion matching)
       - Submit ring
       - Wait for CQE with matching user_data
       - Copy from registered buffer to managed buffer
       - Return buffer index to pool
       - If io_uring unavailable: fall back to `RandomAccess.ReadAsync`

    3. **WriteBlockAsync(long blockNumber, byte[] data)**:
       - Acquire registered buffer, copy data to it
       - Prep write-fixed
       - Submit and wait for completion
       - Return buffer to pool
       - Fallback: `RandomAccess.WriteAsync`

    4. **Batch operations** — `ReadBlocksAsync(long[] blockNumbers, byte[][] buffers)`:
       - Submit all reads in single `io_uring_submit` call
       - Collect all CQEs via `peek_batch_cqe`
       - Much faster than individual reads (amortizes syscall overhead)

    5. **NVMe passthrough** — `NvmePassthroughAsync(byte[] command, byte[] data)`:
       - Uses IORING_OP_URING_CMD for raw NVMe commands on block devices
       - Only available on raw block devices (not regular files)
       - Auto-detected via device path `/dev/nvme*`

    6. **Fallback strategy**:
       - `static IBlockDevice Create(string path, int blockSize)` factory method:
         - If `IoUringBindings.IsAvailable`: return IoUringBlockDevice
         - Else: return `FileBlockDevice` (existing implementation)
       - Callers use factory, never construct directly

    7. **Dispose**: Unregister buffers, free NativeMemory, queue_exit, close fd.

    Thread safety: Ring-per-thread design. `[ThreadStatic] static IoUring?` per-thread ring. If thread count > configured max (default ProcessorCount), shared ring with `SemaphoreSlim`.

    Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-12 io_uring block device")]`.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>IoUringBlockDevice provides 5x+ throughput via registered buffers, batched submissions, and SQPoll. Graceful fallback to FileBlockDevice on non-Linux. Ring-per-thread design for scalability.</done>
</task>

</tasks>

<verification>
- Both files exist under `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- IoUringBindings.IsAvailable returns false on Windows (no runtime crash)
- Factory method returns FileBlockDevice on non-Linux
</verification>

<success_criteria>
- io_uring bindings cover all needed operations (read/write/fixed/uring_cmd)
- Registered buffers pre-allocated and pooled for zero-copy I/O
- Ring-per-thread avoids contention
- Graceful non-Linux fallback to standard async I/O
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/86-adaptive-index-engine/86-12-SUMMARY.md`
</output>
