---
phase: 86-adaptive-index-engine
plan: 07
type: execute
wave: 3
depends_on: ["86-01", "86-02", "86-03", "86-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphTransition.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphTransitionEngine.cs
autonomous: true
must_haves:
  truths:
    - "Forward morphing migrates all entries from old to new index level"
    - "Backward morphing compacts and demotes when object count drops"
    - "Every morph transition is WAL-journaled, copy-on-write, crash-safe"
    - "In-progress morph is cancellable with progress observability"
    - "Zero downtime: old index serves reads during migration"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphTransitionEngine.cs"
      provides: "Bidirectional morph transition orchestrator"
      exports: ["MorphTransitionEngine"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphTransition.cs"
      provides: "Transition state and protocol types"
      exports: ["MorphTransition", "MorphTransitionState"]
  key_links:
    - from: "MorphTransitionEngine"
      to: "IWriteAheadLog"
      via: "WAL-journaled morph start/complete/abort markers"
      pattern: "_wal\\.Write.*MorphMarker"
    - from: "MorphTransitionEngine"
      to: "IAdaptiveIndex"
      via: "reads from old index, writes to new"
      pattern: "source\\.RangeQueryAsync|target\\.InsertAsync"
---

<objective>
Implement bidirectional morph transitions: forward morph protocol, backward morph protocol (compaction + demotion), WAL-journaled CoW transitions, crash recovery, cancellation, and progress observability.

Purpose: The morph engine handles the actual data migration between index levels. It must be zero-downtime (old index serves reads during migration), crash-safe (WAL-journaled with restart recovery), and cancellable (long morphs on large indexes can be interrupted).
Output: 2 files implementing the morph transition engine.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/86-adaptive-index-engine/86-01-SUMMARY.md
@.planning/phases/86-adaptive-index-engine/86-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Morph transition types and state machine</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphTransition.cs
  </files>
  <action>
    **MorphTransition.cs**: Types for morph transition lifecycle.

    1. **MorphTransitionState** enum: `NotStarted`, `Preparing`, `Migrating`, `Verifying`, `Switching`, `Completed`, `Aborted`, `CrashRecovery`.

    2. **MorphDirection** enum: `Forward` (lower to higher level), `Backward` (higher to lower level).

    3. **MorphTransition** class: Tracks a single morph transition.
       - `Guid TransitionId`
       - `MorphLevel SourceLevel`, `MorphLevel TargetLevel`
       - `MorphDirection Direction`
       - `MorphTransitionState State`
       - `long TotalEntries` — total entries to migrate
       - `long MigratedEntries` — entries migrated so far (Interlocked)
       - `double Progress => TotalEntries == 0 ? 1.0 : (double)MigratedEntries / TotalEntries`
       - `DateTimeOffset StartTime`, `DateTimeOffset? EndTime`
       - `TimeSpan Elapsed => (EndTime ?? DateTimeOffset.UtcNow) - StartTime`
       - `CancellationTokenSource Cts` — for cancellation
       - `string? ErrorMessage` — set on abort/failure
       - `event Action<MorphTransitionState>? StateChanged`

    4. **MorphWalMarker** record struct: WAL entry for morph transitions.
       - `MorphWalMarkerType Type` enum: `MorphStart`, `MorphCheckpoint`, `MorphComplete`, `MorphAbort`
       - `Guid TransitionId`
       - `MorphLevel SourceLevel`, `MorphLevel TargetLevel`
       - `long CheckpointedEntries` — entries confirmed migrated at this checkpoint
       - `long TargetRootBlock` — root block of the new index being built
       - Serialize/Deserialize methods for WAL integration (fixed 64-byte record)

    5. **MorphProgress** record: Snapshot of transition progress for observability.
       - `Guid TransitionId`, `MorphTransitionState State`, `double Progress`, `long MigratedEntries`, `long TotalEntries`, `TimeSpan Elapsed`, `double EntriesPerSecond`
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>MorphTransition state machine, WAL markers, and progress types defined. Supports forward and backward morph directions with full lifecycle tracking.</done>
</task>

<task type="auto">
  <name>Task 2: MorphTransitionEngine with CoW, crash recovery, and cancellation</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/MorphTransitionEngine.cs
  </files>
  <action>
    **MorphTransitionEngine.cs**: Orchestrates morph transitions between index levels.

    Constructor: `IBlockDevice device`, `IBlockAllocator allocator`, `IWriteAheadLog wal`, `int blockSize`.

    **Forward morph** — `ExecuteForwardMorphAsync(IAdaptiveIndex source, MorphLevel targetLevel, CancellationToken ct)`:
    1. Create new target index at targetLevel (factory method)
    2. Write WAL MorphStart marker
    3. State = Migrating. Iterate source.RangeQueryAsync(null, null) in batches of 10,000:
       - Insert each entry into target index
       - Increment MigratedEntries
       - Every 100,000 entries: write WAL MorphCheckpoint marker (enables resume after crash)
       - Check ct.IsCancellationRequested between batches
    4. State = Verifying. Compare counts: target.CountAsync == source.CountAsync
    5. State = Switching. Atomically swap: write WAL MorphComplete marker, return target index (caller sets as active)
    6. State = Completed. Old source index blocks can be freed (deferred GC).

    **Backward morph** — `ExecuteBackwardMorphAsync(IAdaptiveIndex source, MorphLevel targetLevel, CancellationToken ct)`:
    - Same protocol as forward morph but targetLevel < sourceLevel
    - Additional compaction step: if source is Forest (Level 5), first merge all shards into single shard, then morph shard down
    - If source is ALEX (Level 4), deactivate learned overlay, morph backing Be-tree to target

    **Zero-downtime protocol**:
    - During migration, the OLD index continues serving all reads and writes
    - New writes that arrive during migration are dual-written: to old index AND queued for target
    - After main migration completes, drain the queue into target
    - `_pendingWrites` ConcurrentQueue for dual-write buffer

    **Crash recovery** — `RecoverFromCrashAsync(IWriteAheadLog wal)`:
    - Scan WAL for MorphStart markers without matching MorphComplete/MorphAbort
    - For each incomplete transition:
      - Find latest MorphCheckpoint marker to get progress
      - If checkpointed entries > 0: resume migration from checkpoint
      - If no checkpoint: discard partial target, keep source (abort transition)
    - Write MorphAbort for truly unrecoverable transitions

    **Cancellation**:
    - Checks CancellationToken between batches
    - On cancel: write MorphAbort WAL marker, free target index blocks, return null
    - Source index remains active and unmodified

    **Progress observability**:
    - `MorphProgress GetProgress()` — returns current snapshot
    - `event Action<MorphProgress>? ProgressUpdated` — fires every 10,000 entries

    Thread safety: `SemaphoreSlim(1,1)` for morph execution (only one morph at a time). Concurrent reads continue on source.

    Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-07 Morph transitions")]`.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>MorphTransitionEngine handles forward and backward morphs with WAL-journaled checkpoints, crash recovery, cancellation, zero-downtime dual-write, and progress observability.</done>
</task>

</tasks>

<verification>
- Both files exist under `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- WAL markers cover full lifecycle: Start -> Checkpoint(s) -> Complete/Abort
- Crash recovery resumes from latest checkpoint or aborts cleanly
</verification>

<success_criteria>
- Forward morphing migrates all entries to higher-level index
- Backward morphing compacts and demotes to lower-level index
- WAL-journaled with checkpoint markers every 100K entries
- Crash recovery resumes or cleanly aborts incomplete transitions
- Zero downtime via dual-write protocol during migration
- Cancellation stops migration cleanly without corrupting source
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/86-adaptive-index-engine/86-07-SUMMARY.md`
</output>
