---
phase: 86-adaptive-index-engine
plan: 08
type: execute
wave: 3
depends_on: ["86-01", "86-02", "86-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexRaid.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexStriping.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexMirroring.cs
  - DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexTiering.cs
autonomous: true
must_haves:
  truths:
    - "4-stripe index shows >= 2.5x read throughput over single-stripe"
    - "Mirroring provides redundant copies with sync/async write modes"
    - "Sharding allows per-shard AIE at different morph levels"
    - "Tiering places hot keys in ART L1, warm in Be-tree L2, cold in archive L3"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexRaid.cs"
      provides: "Index RAID orchestrator"
      exports: ["IndexRaid"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexStriping.cs"
      provides: "N-way parallel read/write striping"
      exports: ["IndexStriping"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexTiering.cs"
      provides: "Hot/warm/cold tiered access"
      exports: ["IndexTiering"]
  key_links:
    - from: "IndexRaid"
      to: "IndexStriping/IndexMirroring/IndexTiering"
      via: "composes RAID modes"
      pattern: "_striping|_mirroring|_tiering"
---

<objective>
Implement Index RAID: Striping (N-way parallel read/write), Mirroring (M copies with sync/async), Sharding (per-shard AIE with boundary auto-adjustment), and Tiering (L1 ART / L2 Be-tree / L3 learned with count-min sketch promotion/demotion).

Purpose: Just as storage RAID improves disk performance and reliability, Index RAID parallelizes and replicates the adaptive index. Striping multiplies throughput, mirroring adds redundancy, and tiering optimizes for access patterns.
Output: 4 files implementing the Index RAID system.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/86-adaptive-index-engine/86-01-SUMMARY.md
@.planning/phases/86-adaptive-index-engine/86-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Index Striping and Mirroring</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexStriping.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexMirroring.cs
  </files>
  <action>
    1. **IndexStriping.cs**: N-way parallel index striping implementing `IAdaptiveIndex`.
       - Constructor: `int stripeCount`, `Func<int, IAdaptiveIndex> stripeFactory` (creates per-stripe index)
       - `IAdaptiveIndex[] _stripes` — the N stripe indexes
       - Key-to-stripe assignment: `XxHash64(key) % stripeCount` (deterministic, uniform)
       - **LookupAsync**: Route to correct stripe, single read. O(1) routing + O(index) lookup.
       - **InsertAsync**: Route to correct stripe, insert. Parallel inserts to different stripes possible.
       - **DeleteAsync**: Route to correct stripe, delete.
       - **RangeQueryAsync**: Fan out to ALL stripes in parallel (Task.WhenAll), merge-sort results. Each stripe handles its portion concurrently.
       - **CountAsync**: Sum across all stripes (parallel).
       - `int StripeCount => _stripes.Length`
       - **Auto-tuned N**: `static int RecommendStripeCount()` — returns `Math.Min(Environment.ProcessorCount, 16)`. Caller can override.
       - `CurrentLevel`: returns the morph level of stripe 0 (all stripes should be at same level for striping)
       - `ObjectCount`: sum of all stripes
       - Thread safety: Each stripe is independently thread-safe. No cross-stripe locking.

    2. **IndexMirroring.cs**: M-copy index mirroring implementing `IAdaptiveIndex`.
       - Constructor: `int mirrorCount`, `Func<int, IAdaptiveIndex> mirrorFactory`, `MirrorWriteMode mode` (enum: `Synchronous`, `Asynchronous`)
       - `IAdaptiveIndex[] _mirrors` — the M mirror copies
       - `IAdaptiveIndex _primary` — mirrors[0], serves all reads
       - **LookupAsync**: Read from primary only (mirrors are backup).
       - **InsertAsync**:
         - Synchronous: `Task.WhenAll(mirrors.Select(m => m.InsertAsync(key, value)))` — all mirrors must succeed.
         - Asynchronous: Write primary, fire-and-forget to secondaries with retry queue.
       - **DeleteAsync**: Same pattern as Insert.
       - **RangeQueryAsync**: Delegate to primary.
       - **Rebuild(int mirrorIndex)**: Full copy from primary to degraded mirror. Background, non-blocking.
       - `MirrorHealth[] GetHealth()`: Per-mirror status (Healthy, Degraded, Rebuilding).
       - `_asyncRetryQueue` ConcurrentQueue for failed async writes, processed by background task.
       - Thread safety: Primary has its own locks. Secondary writes are independent.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>IndexStriping distributes keys across N stripes for parallel throughput. IndexMirroring maintains M copies with sync/async write modes and rebuild support.</done>
</task>

<task type="auto">
  <name>Task 2: Index Tiering and RAID orchestrator</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexTiering.cs
    DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/IndexRaid.cs
  </files>
  <action>
    1. **IndexTiering.cs**: Hot/warm/cold tiered index access implementing `IAdaptiveIndex`.
       - Three tiers:
         - `L1Hot`: ART index (fast in-memory, limited capacity)
         - `L2Warm`: Be-tree (balanced, medium capacity)
         - `L3Cold`: Backing store (learned index or disk, large capacity)
       - **Count-Min Sketch** for access frequency tracking:
         - `CountMinSketch` inner class: `int[4][]` arrays (4 hash functions), width = 65536
         - `void Increment(byte[] key)`: Hash with 4 seeds, increment counters
         - `int Estimate(byte[] key)`: Min of 4 counters
         - Decay: every 60 seconds, halve all counters (prevents stale hot entries)
       - **LookupAsync**: Check L1 first (hot). If hit, return (<=1us). If miss, check L2 (warm, <=100us). If miss, check L3 (cold, <=10ms). Increment access counter. If L2/L3 hit and frequency above promotion threshold, promote to L1.
       - **InsertAsync**: Insert into L2 (warm default). Promotion/demotion happens asynchronously.
       - **Promotion**: When access count > `_promotionThreshold` (default 10), copy from L2/L3 to L1.
       - **Demotion**: When L1 exceeds `_l1MaxEntries` (default 100K), evict least-frequent entries to L2. When L2 exceeds max, demote to L3.
       - **Background tier management**: Timer-based (every 30s), scans L1 for entries below frequency threshold, demotes. Non-blocking.
       - Thread safety: Per-tier locks (independent).

    2. **IndexRaid.cs**: Composes striping, mirroring, and tiering into unified RAID configurations.
       - `IndexRaidMode` enum: `Stripe`, `Mirror`, `StripeMirror`, `Tiered`, `StripeTiered`
       - `IndexRaid` factory class:
         - `static IAdaptiveIndex CreateStriped(int n, ...)`: N-stripe
         - `static IAdaptiveIndex CreateMirrored(int m, ...)`: M-mirror
         - `static IAdaptiveIndex CreateStripeMirror(int n, int m, ...)`: Stripe across N groups, each group mirrored M times (like RAID 10)
         - `static IAdaptiveIndex CreateTiered(...)`: 3-tier hot/warm/cold
         - `static IAdaptiveIndex CreateStripeTiered(int n, ...)`: Stripe across N groups, each group tiered
       - `IndexRaidConfig` class: serializable configuration specifying mode + parameters. JSON serialization for persistence.
       - All factory methods return `IAdaptiveIndex` — callers don't know the internal structure.

    Add `[SdkCompatibility("6.0.0", Notes = "Phase 86: AIE-08 Index RAID")]`.
  </action>
  <verify>Build: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj --no-restore` compiles with zero errors.</verify>
  <done>IndexTiering provides hot/warm/cold access tiers with count-min sketch promotion/demotion. IndexRaid composes striping, mirroring, and tiering into RAID-like configurations.</done>
</task>

</tasks>

<verification>
- All 4 files exist under `DataWarehouse.SDK/VirtualDiskEngine/AdaptiveIndex/`
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` succeeds with zero errors
- IndexStriping fans out reads in parallel across N stripes
- IndexMirroring writes to M copies synchronously or asynchronously
- IndexTiering uses count-min sketch for promotion/demotion decisions
</verification>

<success_criteria>
- 4-stripe index enables parallel read/write across stripes
- Mirroring provides sync/async redundancy with rebuild support
- Tiering separates hot (ART) / warm (Be-tree) / cold (archive) access paths
- Count-min sketch tracks access frequency for tier promotion decisions
- RAID factory composes modes transparently behind IAdaptiveIndex
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/86-adaptive-index-engine/86-08-SUMMARY.md`
</output>
