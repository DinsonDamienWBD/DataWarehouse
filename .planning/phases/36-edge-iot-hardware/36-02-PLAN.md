---
phase: 36-edge-iot-hardware
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Edge/Protocols/IMqttClient.cs
  - DataWarehouse.SDK/Edge/Protocols/MqttClient.cs
  - DataWarehouse.SDK/Edge/Protocols/MqttConnectionSettings.cs
  - DataWarehouse.SDK/Edge/Protocols/MqttMessage.cs
  - Plugins/DataWarehouse.Plugins.UltimateStreaming/Strategies/MqttStreamingStrategy.cs
  - DataWarehouse.SDK/DataWarehouse.SDK.csproj
  - Plugins/DataWarehouse.Plugins.UltimateStreaming/DataWarehouse.Plugins.UltimateStreaming.csproj
autonomous: true

must_haves:
  truths:
    - "IMqttClient provides connect/disconnect/publish/subscribe operations with QoS 0/1/2 support"
    - "MqttClient wraps MQTTnet library with DataWarehouse semantics"
    - "Connection settings support TLS with client certificates and mutual authentication"
    - "Auto-reconnect with exponential backoff when connection lost"
    - "Retained messages and will messages supported"
    - "Topic-based routing with wildcard subscriptions (+, #)"
    - "MqttStreamingStrategy integrates MqttClient as UltimateStreaming strategy"
    - "All MQTT operations are async and cancellable"
  artifacts:
    - path: "DataWarehouse.SDK/Edge/Protocols/IMqttClient.cs"
      provides: "MQTT client interface with pub/sub operations"
      min_lines: 40
    - path: "DataWarehouse.SDK/Edge/Protocols/MqttClient.cs"
      provides: "MQTTnet wrapper implementation"
      min_lines: 250
    - path: "DataWarehouse.SDK/Edge/Protocols/MqttConnectionSettings.cs"
      provides: "MQTT connection configuration (broker, port, TLS, auth)"
      min_lines: 60
    - path: "DataWarehouse.SDK/Edge/Protocols/MqttMessage.cs"
      provides: "MQTT message record with topic, payload, QoS, retain flag"
      min_lines: 30
    - path: "Plugins/DataWarehouse.Plugins.UltimateStreaming/Strategies/MqttStreamingStrategy.cs"
      provides: "UltimateStreaming strategy using MqttClient"
      min_lines: 120
  key_links:
    - from: "MqttClient"
      to: "MQTTnet.Client.MqttClient"
      via: "Wraps MQTTnet client library"
      pattern: "using MQTTnet"
    - from: "MqttStreamingStrategy"
      to: "MqttClient"
      via: "Uses MqttClient for pub/sub streaming"
      pattern: "new MqttClient"
    - from: "MqttClient"
      to: "MqttConnectionSettings"
      via: "Uses settings to configure connection"
      pattern: "MqttConnectionSettings"
---

<objective>
Implement production-ready MQTT client (EDGE-02) wrapping MQTTnet with QoS 0/1/2, TLS mutual auth, auto-reconnect, and integrate as UltimateStreaming strategy.

Purpose: Enable DataWarehouse to communicate with MQTT brokers for edge/IoT messaging. MQTT is the de facto standard for IoT device communication. This integration allows DataWarehouse to publish sensor data, subscribe to commands, and participate in MQTT-based event-driven architectures.

Output:
- `IMqttClient` interface with async pub/sub operations
- `MqttClient` implementation wrapping MQTTnet
- Connection settings with TLS/auth configuration
- `MqttStreamingStrategy` integrating MQTT into UltimateStreaming plugin
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/36-edge-iot-hardware/36-RESEARCH.md
@Plugins/DataWarehouse.Plugins.UltimateStreaming/Strategies/KafkaStreamingStrategy.cs
@DataWarehouse.SDK/Contracts/Streaming/StreamingStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MQTT Client Interfaces and Types</name>
  <files>
    DataWarehouse.SDK/Edge/Protocols/IMqttClient.cs
    DataWarehouse.SDK/Edge/Protocols/MqttConnectionSettings.cs
    DataWarehouse.SDK/Edge/Protocols/MqttMessage.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Edge.Protocols`:

**MqttMessage.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: MQTT message record (EDGE-02)")]
public sealed record MqttMessage
{
    public required string Topic { get; init; }
    public required byte[] Payload { get; init; }
    public MqttQualityOfServiceLevel QoS { get; init; } = MqttQualityOfServiceLevel.AtMostOnce;
    public bool Retain { get; init; } = false;
    public IReadOnlyDictionary<string, string>? UserProperties { get; init; }
}

public enum MqttQualityOfServiceLevel
{
    AtMostOnce = 0,   // QoS 0 - fire and forget
    AtLeastOnce = 1,  // QoS 1 - acknowledged delivery
    ExactlyOnce = 2   // QoS 2 - guaranteed single delivery
}
```

Add XML docs explaining QoS levels.

**MqttConnectionSettings.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: MQTT connection settings (EDGE-02)")]
public sealed record MqttConnectionSettings
{
    public required string BrokerAddress { get; init; }
    public int Port { get; init; } = 1883; // Default MQTT port
    public string? ClientId { get; init; } // Auto-generated if null
    public string? Username { get; init; }
    public string? Password { get; init; }
    public bool UseTls { get; init; } = false;
    public string? TlsCertificatePath { get; init; } // Client certificate for mutual TLS
    public string? TlsCertificatePassword { get; init; }
    public bool AllowUntrustedCertificates { get; init; } = false;
    public TimeSpan KeepAlive { get; init; } = TimeSpan.FromSeconds(60);
    public bool CleanSession { get; init; } = true;
    public MqttMessage? WillMessage { get; init; } // Last will and testament
    public TimeSpan ConnectTimeout { get; init; } = TimeSpan.FromSeconds(10);
    public bool AutoReconnect { get; init; } = true;
    public TimeSpan ReconnectDelay { get; init; } = TimeSpan.FromSeconds(5);
    public int MaxReconnectAttempts { get; init; } = 10; // 0 = infinite
}
```

Add XML docs for all properties. Explain CleanSession, WillMessage, AutoReconnect behavior.

**IMqttClient.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: MQTT client interface (EDGE-02)")]
public interface IMqttClient : IAsyncDisposable
{
    /// <summary>Connects to the MQTT broker.</summary>
    Task ConnectAsync(MqttConnectionSettings settings, CancellationToken ct = default);

    /// <summary>Disconnects from the broker gracefully.</summary>
    Task DisconnectAsync(CancellationToken ct = default);

    /// <summary>Publishes a message to a topic.</summary>
    Task PublishAsync(MqttMessage message, CancellationToken ct = default);

    /// <summary>Subscribes to one or more topics (supports wildcards +, #).</summary>
    /// <param name="topics">Topic filters (e.g., "sensor/+/temperature", "command/#").</param>
    /// <param name="qos">QoS level for subscriptions.</param>
    Task SubscribeAsync(IEnumerable<string> topics, MqttQualityOfServiceLevel qos, CancellationToken ct = default);

    /// <summary>Unsubscribes from topics.</summary>
    Task UnsubscribeAsync(IEnumerable<string> topics, CancellationToken ct = default);

    /// <summary>Event fired when a message is received on subscribed topics.</summary>
    event EventHandler<MqttMessageReceivedEventArgs>? OnMessageReceived;

    /// <summary>Event fired when connection is lost.</summary>
    event EventHandler<MqttConnectionLostEventArgs>? OnConnectionLost;

    /// <summary>Event fired when reconnection succeeds.</summary>
    event EventHandler? OnReconnected;

    /// <summary>Gets whether the client is currently connected.</summary>
    bool IsConnected { get; }
}

public sealed record MqttMessageReceivedEventArgs(MqttMessage Message);
public sealed record MqttConnectionLostEventArgs(string Reason, Exception? Exception);
```

Add XML documentation for all members. Explain wildcard patterns (+ = single level, # = multi-level).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify 3 files exist. Grep for `IMqttClient`, `MqttConnectionSettings`, `MqttMessage`.
  </verify>
  <done>
IMqttClient interface defined with async connect/disconnect/publish/subscribe operations. MqttMessage record holds topic, payload, QoS, retain flag. MqttConnectionSettings configures broker address, TLS, auth, auto-reconnect. Event-based message reception and connection status.
  </done>
</task>

<task type="auto">
  <name>Task 2: MqttClient Implementation (MQTTnet wrapper)</name>
  <files>
    DataWarehouse.SDK/Edge/Protocols/MqttClient.cs
    DataWarehouse.SDK/DataWarehouse.SDK.csproj
  </files>
  <action>
**Step 1: Add NuGet package MQTTnet**

Edit `DataWarehouse.SDK/DataWarehouse.SDK.csproj`:
Add `<PackageReference Include="MQTTnet" Version="4.3.7" />` to the ItemGroup with other packages.

**Step 2: MqttClient.cs**

Create in namespace `DataWarehouse.SDK.Edge.Protocols`:

Sealed class implementing `IMqttClient`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 36: MQTTnet wrapper (EDGE-02)")]`.

Fields:
- `MQTTnet.Client.IMqttClient _client` (MQTTnet client)
- `MqttConnectionSettings? _currentSettings`
- `CancellationTokenSource? _reconnectCts`
- `SemaphoreSlim _connectLock = new(1, 1)`
- `bool _disposed`

Events:
```csharp
public event EventHandler<MqttMessageReceivedEventArgs>? OnMessageReceived;
public event EventHandler<MqttConnectionLostEventArgs>? OnConnectionLost;
public event EventHandler? OnReconnected;
```

Constructor:
```csharp
public MqttClient()
{
    var factory = new MqttFactory();
    _client = factory.CreateMqttClient();

    // Register MQTTnet event handlers
    _client.ApplicationMessageReceivedAsync += OnMqttMessageReceivedAsync;
    _client.DisconnectedAsync += OnMqttDisconnectedAsync;
}
```

Implementation:

**ConnectAsync**:
```csharp
public async Task ConnectAsync(MqttConnectionSettings settings, CancellationToken ct = default)
{
    await _connectLock.WaitAsync(ct);
    try
    {
        _currentSettings = settings;

        var optionsBuilder = new MqttClientOptionsBuilder()
            .WithTcpServer(settings.BrokerAddress, settings.Port)
            .WithClientId(settings.ClientId ?? Guid.NewGuid().ToString())
            .WithKeepAlivePeriod(settings.KeepAlive)
            .WithCleanSession(settings.CleanSession);

        if (!string.IsNullOrEmpty(settings.Username))
            optionsBuilder.WithCredentials(settings.Username, settings.Password);

        if (settings.UseTls)
        {
            var tlsOptions = new MqttClientTlsOptionsBuilder()
                .WithAllowUntrustedCertificates(settings.AllowUntrustedCertificates);

            if (!string.IsNullOrEmpty(settings.TlsCertificatePath))
            {
                var cert = new X509Certificate2(settings.TlsCertificatePath, settings.TlsCertificatePassword);
                tlsOptions.WithClientCertificates(new[] { cert });
            }

            optionsBuilder.WithTlsOptions(tlsOptions.Build());
        }

        if (settings.WillMessage is not null)
        {
            optionsBuilder.WithWillTopic(settings.WillMessage.Topic)
                .WithWillPayload(settings.WillMessage.Payload)
                .WithWillQualityOfServiceLevel((MQTTnet.Protocol.MqttQualityOfServiceLevel)settings.WillMessage.QoS)
                .WithWillRetain(settings.WillMessage.Retain);
        }

        var options = optionsBuilder.Build();
        var result = await _client.ConnectAsync(options, ct);

        if (result.ResultCode != MqttClientConnectResultCode.Success)
        {
            throw new InvalidOperationException($"MQTT connection failed: {result.ResultCode} - {result.ReasonString}");
        }
    }
    finally
    {
        _connectLock.Release();
    }
}
```

**DisconnectAsync**:
```csharp
public async Task DisconnectAsync(CancellationToken ct = default)
{
    _reconnectCts?.Cancel();
    _reconnectCts = null;

    if (_client.IsConnected)
    {
        await _client.DisconnectAsync(new MqttClientDisconnectOptionsBuilder().Build(), ct);
    }
}
```

**PublishAsync**:
```csharp
public async Task PublishAsync(MqttMessage message, CancellationToken ct = default)
{
    var mqttMsg = new MqttApplicationMessageBuilder()
        .WithTopic(message.Topic)
        .WithPayload(message.Payload)
        .WithQualityOfServiceLevel((MQTTnet.Protocol.MqttQualityOfServiceLevel)message.QoS)
        .WithRetainFlag(message.Retain)
        .Build();

    if (message.UserProperties is not null)
    {
        foreach (var prop in message.UserProperties)
        {
            mqttMsg.UserProperties.Add(new MqttUserProperty(prop.Key, prop.Value));
        }
    }

    await _client.PublishAsync(mqttMsg, ct);
}
```

**SubscribeAsync**:
```csharp
public async Task SubscribeAsync(IEnumerable<string> topics, MqttQualityOfServiceLevel qos, CancellationToken ct = default)
{
    var subscribeOptions = new MqttClientSubscribeOptionsBuilder();
    foreach (var topic in topics)
    {
        subscribeOptions.WithTopicFilter(topic, (MQTTnet.Protocol.MqttQualityOfServiceLevel)qos);
    }

    await _client.SubscribeAsync(subscribeOptions.Build(), ct);
}
```

**UnsubscribeAsync**:
```csharp
public async Task UnsubscribeAsync(IEnumerable<string> topics, CancellationToken ct = default)
{
    var unsubscribeOptions = new MqttClientUnsubscribeOptionsBuilder();
    foreach (var topic in topics)
    {
        unsubscribeOptions.WithTopicFilter(topic);
    }

    await _client.UnsubscribeAsync(unsubscribeOptions.Build(), ct);
}
```

**IsConnected**:
```csharp
public bool IsConnected => _client?.IsConnected ?? false;
```

**Event Handlers**:

```csharp
private Task OnMqttMessageReceivedAsync(MqttApplicationMessageReceivedEventArgs args)
{
    var message = new MqttMessage
    {
        Topic = args.ApplicationMessage.Topic,
        Payload = args.ApplicationMessage.Payload ?? Array.Empty<byte>(),
        QoS = (MqttQualityOfServiceLevel)args.ApplicationMessage.QualityOfServiceLevel,
        Retain = args.ApplicationMessage.Retain
    };

    OnMessageReceived?.Invoke(this, new MqttMessageReceivedEventArgs(message));
    return Task.CompletedTask;
}

private async Task OnMqttDisconnectedAsync(MqttClientDisconnectedEventArgs args)
{
    OnConnectionLost?.Invoke(this, new MqttConnectionLostEventArgs(args.Reason.ToString(), args.Exception));

    // Auto-reconnect logic
    if (_currentSettings?.AutoReconnect == true && !_disposed)
    {
        _reconnectCts = new CancellationTokenSource();
        await ReconnectAsync(_reconnectCts.Token);
    }
}

private async Task ReconnectAsync(CancellationToken ct)
{
    if (_currentSettings is null) return;

    int attempt = 0;
    while (!ct.IsCancellationRequested && !_client.IsConnected)
    {
        attempt++;
        if (_currentSettings.MaxReconnectAttempts > 0 && attempt > _currentSettings.MaxReconnectAttempts)
        {
            break;
        }

        try
        {
            // Exponential backoff: delay = baseDelay * 2^(attempt-1), max 60 seconds
            var delay = TimeSpan.FromMilliseconds(
                Math.Min(_currentSettings.ReconnectDelay.TotalMilliseconds * Math.Pow(2, attempt - 1), 60000));
            await Task.Delay(delay, ct);

            await ConnectAsync(_currentSettings, ct);
            OnReconnected?.Invoke(this, EventArgs.Empty);
            break;
        }
        catch (Exception)
        {
            // Retry on next iteration
        }
    }
}
```

**DisposeAsync**:
```csharp
public async ValueTask DisposeAsync()
{
    if (_disposed) return;
    _disposed = true;

    _reconnectCts?.Cancel();
    _reconnectCts?.Dispose();

    if (_client.IsConnected)
    {
        await _client.DisconnectAsync();
    }

    _client?.Dispose();
    _connectLock?.Dispose();
}
```

Wrap all MQTTnet calls in try/catch with graceful error handling. Use MQTTnet 4.x API (latest stable). Thread-safe via `_connectLock` for connection operations.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify MQTTnet package restored. Grep for `using MQTTnet` in MqttClient. Grep for `MqttClientOptionsBuilder` to confirm MQTTnet usage.
  </verify>
  <done>
MqttClient wraps MQTTnet with async connect/disconnect/pub/sub operations. TLS with client certificates supported. Auto-reconnect with exponential backoff. Events for message reception, connection loss, and reconnection. Thread-safe connection management via semaphore.
  </done>
</task>

<task type="auto">
  <name>Task 3: MqttStreamingStrategy Integration</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateStreaming/Strategies/MqttStreamingStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateStreaming/DataWarehouse.Plugins.UltimateStreaming.csproj
  </files>
  <action>
**Step 1: Add SDK reference**

Edit `Plugins/DataWarehouse.Plugins.UltimateStreaming/DataWarehouse.Plugins.UltimateStreaming.csproj`:
Verify it already has `<ProjectReference Include="..\..\DataWarehouse.SDK\DataWarehouse.SDK.csproj" />`. If not, add it.

**Step 2: MqttStreamingStrategy.cs**

Create in namespace `DataWarehouse.Plugins.UltimateStreaming.Strategies`:

Sealed class extending `StreamingStrategy`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 36: MQTT streaming strategy (EDGE-02)")]`.

Fields:
- `IMqttClient _mqttClient`
- `MqttConnectionSettings _connectionSettings`
- `List<string> _subscribedTopics`
- `ConcurrentQueue<MqttMessage> _incomingMessages`

Constructor:
```csharp
public MqttStreamingStrategy(MqttConnectionSettings connectionSettings)
{
    _connectionSettings = connectionSettings;
    _mqttClient = new DataWarehouse.SDK.Edge.Protocols.MqttClient();
    _subscribedTopics = new();
    _incomingMessages = new();

    _mqttClient.OnMessageReceived += (sender, args) =>
    {
        _incomingMessages.Enqueue(args.Message);
    };
}
```

Override abstract methods from `StreamingStrategy`:

**PublishAsync** (publish data to MQTT topic):
```csharp
public override async Task PublishAsync(byte[] data, string topic, CancellationToken ct = default)
{
    var message = new MqttMessage
    {
        Topic = topic,
        Payload = data,
        QoS = MqttQualityOfServiceLevel.AtLeastOnce,
        Retain = false
    };

    await _mqttClient.PublishAsync(message, ct);
}
```

**SubscribeAsync** (subscribe to MQTT topics):
```csharp
public override async Task SubscribeAsync(string[] topics, CancellationToken ct = default)
{
    await _mqttClient.SubscribeAsync(topics, MqttQualityOfServiceLevel.AtLeastOnce, ct);
    _subscribedTopics.AddRange(topics);
}
```

**ConsumeAsync** (consume incoming messages):
```csharp
public override Task<byte[]?> ConsumeAsync(CancellationToken ct = default)
{
    if (_incomingMessages.TryDequeue(out var message))
    {
        return Task.FromResult<byte[]?>(message.Payload);
    }
    return Task.FromResult<byte[]?>(null);
}
```

**ConnectAsync** (connect to broker):
```csharp
public override async Task ConnectAsync(CancellationToken ct = default)
{
    await _mqttClient.ConnectAsync(_connectionSettings, ct);
}
```

**DisconnectAsync**:
```csharp
public override async Task DisconnectAsync(CancellationToken ct = default)
{
    await _mqttClient.DisconnectAsync(ct);
}
```

**Dispose**:
```csharp
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        _mqttClient?.DisposeAsync().AsTask().Wait();
    }
    base.Dispose(disposing);
}
```

Add XML docs explaining this strategy enables MQTT pub/sub for UltimateStreaming. Note: Connection settings must be configured via constructor or configuration system.

Check `StreamingStrategy` base class API to ensure method signatures match. Adjust as needed to conform to existing base class contract.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.UltimateStreaming/DataWarehouse.Plugins.UltimateStreaming.csproj` -- zero new errors. Grep for `MqttClient` in strategy. Verify strategy extends StreamingStrategy base class.
  </verify>
  <done>
MqttStreamingStrategy integrates MqttClient into UltimateStreaming plugin. Publish/subscribe operations route to MQTT broker. Incoming messages queued for consumption. Connection management delegated to MqttClient. Proper disposal via IDisposable pattern.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. `dotnet build Plugins/DataWarehouse.Plugins.UltimateStreaming/DataWarehouse.Plugins.UltimateStreaming.csproj` compiles with zero new errors
3. MQTTnet NuGet package (v4.3.7+) is referenced in SDK
4. IMqttClient interface defined with async pub/sub operations
5. MqttClient wraps MQTTnet with TLS, auto-reconnect, QoS 0/1/2
6. MqttConnectionSettings configures broker, TLS, auth, auto-reconnect
7. MqttStreamingStrategy extends StreamingStrategy base class
8. Event-based message reception and connection status notifications
9. All public APIs have XML documentation
</verification>

<success_criteria>
- MQTT client can connect to broker with username/password auth
- TLS with client certificates (mutual auth) supported
- Publish messages with QoS 0/1/2
- Subscribe to topics with wildcard patterns (+, #)
- Auto-reconnect with exponential backoff when connection lost
- Retained messages and will messages supported
- MqttStreamingStrategy integrates MQTT into UltimateStreaming plugin
- Zero new build errors
- MQTTnet v4.3.7+ NuGet package added
</success_criteria>

<output>
After completion, create `.planning/phases/36-edge-iot-hardware/36-02-SUMMARY.md`
</output>
