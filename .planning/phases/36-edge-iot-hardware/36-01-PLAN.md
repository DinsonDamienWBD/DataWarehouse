---
phase: 36-edge-iot-hardware
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Edge/Bus/IGpioBusController.cs
  - DataWarehouse.SDK/Edge/Bus/II2cBusController.cs
  - DataWarehouse.SDK/Edge/Bus/ISpiBusController.cs
  - DataWarehouse.SDK/Edge/Bus/GpioBusController.cs
  - DataWarehouse.SDK/Edge/Bus/I2cBusController.cs
  - DataWarehouse.SDK/Edge/Bus/SpiBusController.cs
  - DataWarehouse.SDK/Edge/Bus/NullBusController.cs
  - DataWarehouse.SDK/Edge/Bus/BusControllerFactory.cs
  - DataWarehouse.SDK/Edge/Bus/PinMapping.cs
  - DataWarehouse.SDK/Edge/EdgeConstants.cs
autonomous: true

must_haves:
  truths:
    - "IGpioBusController provides read/write access to GPIO pins with event-based interrupts"
    - "II2cBusController provides I2C device communication with read/write/transfer operations"
    - "ISpiBusController provides SPI full-duplex transfer operations"
    - "GpioBusController wraps System.Device.Gpio.GpioController with DataWarehouse semantics"
    - "I2cBusController and SpiBusController wrap System.Device.Gpio I2C/SPI devices"
    - "NullBusController provides graceful fallback on non-IoT platforms (returns errors, no throws)"
    - "BusControllerFactory selects real or null controllers based on platform capability"
    - "Pin mapping supports Raspberry Pi 4/5, BeagleBone Black, Jetson Nano"
    - "All bus controllers are IDisposable with proper cleanup"
  artifacts:
    - path: "DataWarehouse.SDK/Edge/Bus/IGpioBusController.cs"
      provides: "GPIO pin read/write/interrupt interface"
      min_lines: 30
    - path: "DataWarehouse.SDK/Edge/Bus/II2cBusController.cs"
      provides: "I2C device communication interface"
      min_lines: 25
    - path: "DataWarehouse.SDK/Edge/Bus/ISpiBusController.cs"
      provides: "SPI full-duplex transfer interface"
      min_lines: 20
    - path: "DataWarehouse.SDK/Edge/Bus/GpioBusController.cs"
      provides: "System.Device.Gpio wrapper for GPIO"
      min_lines: 150
    - path: "DataWarehouse.SDK/Edge/Bus/I2cBusController.cs"
      provides: "System.Device.Gpio wrapper for I2C"
      min_lines: 100
    - path: "DataWarehouse.SDK/Edge/Bus/SpiBusController.cs"
      provides: "System.Device.Gpio wrapper for SPI"
      min_lines: 80
    - path: "DataWarehouse.SDK/Edge/Bus/NullBusController.cs"
      provides: "Graceful fallback for all three bus types"
      min_lines: 60
    - path: "DataWarehouse.SDK/Edge/Bus/BusControllerFactory.cs"
      provides: "Factory selecting real or null controllers based on platform"
      min_lines: 40
    - path: "DataWarehouse.SDK/Edge/Bus/PinMapping.cs"
      provides: "Board-specific pin number mappings (RPi, BeagleBone, Jetson)"
      min_lines: 80
  key_links:
    - from: "BusControllerFactory"
      to: "GpioBusController"
      via: "Creates real controller when gpio capability detected"
      pattern: "new GpioBusController"
    - from: "BusControllerFactory"
      to: "NullBusController"
      via: "Creates null controller when capability absent"
      pattern: "new NullBusController"
    - from: "GpioBusController"
      to: "System.Device.Gpio.GpioController"
      via: "Wraps System.Device.Gpio GpioController"
      pattern: "using System\\.Device\\.Gpio"
    - from: "PinMapping"
      to: "GpioBusController"
      via: "Provides board-specific pin number translation"
      pattern: "PinMapping\\.GetPhysicalPin"
---

<objective>
Implement GPIO/I2C/SPI bus abstractions (EDGE-01) wrapping System.Device.Gpio with DataWarehouse plugin semantics and graceful fallback for non-IoT platforms.

Purpose: Enable DataWarehouse plugins to access hardware buses on edge/IoT devices (Raspberry Pi, BeagleBone, Jetson). This foundational layer allows sensor reading, actuator control, and peripheral communication. All higher-level edge features (camera, mesh networks, flash storage) will use these bus controllers.

Output:
- `IGpioBusController`, `II2cBusController`, `ISpiBusController` interfaces
- Real implementations wrapping System.Device.Gpio
- Null implementations for graceful fallback
- Factory with platform capability detection
- Pin mapping configuration for common boards
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS-v3.md
@.planning/phases/36-edge-iot-hardware/36-RESEARCH.md
@DataWarehouse.SDK/Hardware/IHardwareProbe.cs
@DataWarehouse.SDK/Hardware/IPlatformCapabilityRegistry.cs
@DataWarehouse.SDK/Hardware/HardwareDeviceType.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bus Controller Interfaces and Constants</name>
  <files>
    DataWarehouse.SDK/Edge/Bus/IGpioBusController.cs
    DataWarehouse.SDK/Edge/Bus/II2cBusController.cs
    DataWarehouse.SDK/Edge/Bus/ISpiBusController.cs
    DataWarehouse.SDK/Edge/EdgeConstants.cs
  </files>
  <action>
Create in namespace `DataWarehouse.SDK.Edge.Bus`:

**EdgeConstants.cs**:
```csharp
namespace DataWarehouse.SDK.Edge;

[SdkCompatibility("3.0.0", Notes = "Phase 36: Edge/IoT constants")]
public static class EdgeConstants
{
    public const int DefaultI2cBusId = 1; // /dev/i2c-1 on Linux
    public const int DefaultSpiBusId = 0; // /dev/spidev0.0 on Linux
    public const int DefaultGpioChip = 0; // /dev/gpiochip0 on Linux

    public const int MaxGpioPins = 256;
    public const int MaxI2cDeviceAddress = 127;
    public const int MaxSpiChipSelect = 15;
}
```

**IGpioBusController.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: GPIO bus controller interface (EDGE-01)")]
public interface IGpioBusController : IDisposable
{
    /// <summary>Opens a GPIO pin for read or write.</summary>
    /// <param name="pinNumber">Physical pin number (board-specific).</param>
    /// <param name="mode">Input, Output, InputPullUp, InputPullDown.</param>
    void OpenPin(int pinNumber, PinMode mode);

    /// <summary>Closes a previously opened pin.</summary>
    void ClosePin(int pinNumber);

    /// <summary>Reads the current value of an input pin.</summary>
    PinValue Read(int pinNumber);

    /// <summary>Writes a value to an output pin.</summary>
    void Write(int pinNumber, PinValue value);

    /// <summary>Registers a callback for pin value change events (interrupts).</summary>
    /// <param name="pinNumber">Pin to monitor.</param>
    /// <param name="edge">Rising, Falling, or Both edges.</param>
    /// <param name="callback">Action invoked on edge detection.</param>
    void RegisterCallback(int pinNumber, PinEventEdge edge, Action<PinValueChangedEventArgs> callback);

    /// <summary>Unregisters all callbacks for the specified pin.</summary>
    void UnregisterCallback(int pinNumber);

    /// <summary>Checks if a pin is currently open.</summary>
    bool IsPinOpen(int pinNumber);
}

// Supporting types (use System.Device.Gpio types or define equivalents)
public enum PinMode { Input, Output, InputPullUp, InputPullDown }
public enum PinValue { Low = 0, High = 1 }
public enum PinEventEdge { Rising, Falling, Both }
public sealed record PinValueChangedEventArgs(int PinNumber, PinEventEdge Edge);
```

Add XML documentation for all members. If System.Device.Gpio already defines PinMode/PinValue/PinEventEdge, reference those types instead of redefining.

**II2cBusController.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: I2C bus controller interface (EDGE-01)")]
public interface II2cBusController : IDisposable
{
    /// <summary>Opens a connection to an I2C device.</summary>
    /// <param name="busId">I2C bus ID (e.g., 1 for /dev/i2c-1).</param>
    /// <param name="deviceAddress">7-bit I2C device address (0-127).</param>
    II2cDevice OpenDevice(int busId, int deviceAddress);
}

public interface II2cDevice : IDisposable
{
    /// <summary>Reads bytes from the I2C device.</summary>
    void Read(Span<byte> buffer);

    /// <summary>Writes bytes to the I2C device.</summary>
    void Write(ReadOnlySpan<byte> data);

    /// <summary>Writes data then reads response (combined transaction).</summary>
    void WriteRead(ReadOnlySpan<byte> writeBuffer, Span<byte> readBuffer);
}
```

**ISpiBusController.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: SPI bus controller interface (EDGE-01)")]
public interface ISpiBusController : IDisposable
{
    /// <summary>Opens a connection to an SPI device.</summary>
    /// <param name="busId">SPI bus ID.</param>
    /// <param name="chipSelect">Chip select line (0-15).</param>
    /// <param name="clockFrequency">SPI clock frequency in Hz.</param>
    /// <param name="mode">SPI mode (0-3, defines CPOL and CPHA).</param>
    ISpiDevice OpenDevice(int busId, int chipSelect, int clockFrequency, SpiMode mode);
}

public interface ISpiDevice : IDisposable
{
    /// <summary>Performs a full-duplex SPI transfer (simultaneous write and read).</summary>
    void Transfer(ReadOnlySpan<byte> writeBuffer, Span<byte> readBuffer);

    /// <summary>Writes data to the SPI device (read buffer ignored).</summary>
    void Write(ReadOnlySpan<byte> data);

    /// <summary>Reads data from the SPI device (write buffer is zeros).</summary>
    void Read(Span<byte> buffer);
}

public enum SpiMode { Mode0 = 0, Mode1 = 1, Mode2 = 2, Mode3 = 3 }
```

All interfaces follow IDisposable pattern. Add XML documentation to all public types.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify 4 files exist. Grep for `IGpioBusController`, `II2cBusController`, `ISpiBusController`.
  </verify>
  <done>
IGpioBusController, II2cBusController, ISpiBusController interfaces defined with read/write/transfer operations. Supporting types (PinMode, PinValue, SpiMode) defined. EdgeConstants provides default bus IDs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Real Bus Controller Implementations (System.Device.Gpio wrappers)</name>
  <files>
    DataWarehouse.SDK/Edge/Bus/GpioBusController.cs
    DataWarehouse.SDK/Edge/Bus/I2cBusController.cs
    DataWarehouse.SDK/Edge/Bus/SpiBusController.cs
    DataWarehouse.SDK/Edge/Bus/PinMapping.cs
    DataWarehouse.SDK/DataWarehouse.SDK.csproj
  </files>
  <action>
**Step 1: Add NuGet package System.Device.Gpio**

Edit `DataWarehouse.SDK/DataWarehouse.SDK.csproj`:
Add `<PackageReference Include="System.Device.Gpio" Version="3.2.0" />` to the ItemGroup with other packages.

**Step 2: GpioBusController.cs**

Create in namespace `DataWarehouse.SDK.Edge.Bus`:

Sealed class implementing `IGpioBusController`. Mark with `[SdkCompatibility("3.0.0", Notes = "Phase 36: GPIO wrapper (EDGE-01)")]`.

Fields:
- `GpioController _controller` (System.Device.Gpio.GpioController)
- `Dictionary<int, Action<PinValueChangedEventArgs>> _callbacks`
- `PinMapping _pinMapping`
- `bool _disposed`

Constructor:
```csharp
public GpioBusController(PinMapping? pinMapping = null)
{
    _pinMapping = pinMapping ?? PinMapping.RaspberryPi4; // default to RPi4
    _controller = new GpioController(PinNumberingScheme.Logical); // Use logical (BCM) numbering
    _callbacks = new();
}
```

Implementation:
- `OpenPin(int pinNumber, PinMode mode)`: Translate physical pin to logical pin via `_pinMapping.GetLogicalPin(pinNumber)`. Call `_controller.OpenPin(logicalPin, mode)`.
- `Read(int pinNumber)`: Translate pin, call `_controller.Read(logicalPin)`.
- `Write(int pinNumber, PinValue value)`: Translate pin, call `_controller.Write(logicalPin, value)`.
- `RegisterCallback(int pinNumber, PinEventEdge edge, Action<PinValueChangedEventArgs> callback)`:
  - Translate pin
  - Store callback in `_callbacks[logicalPin]`
  - Register with `_controller.RegisterCallbackForPinValueChangedEvent(logicalPin, edge, (sender, args) => callback(new PinValueChangedEventArgs(pinNumber, args.ChangeType)))`
- `UnregisterCallback(int pinNumber)`: Translate pin, call `_controller.UnregisterCallbackForPinValueChangedEvent(logicalPin)`, remove from `_callbacks`.
- `IsPinOpen(int pinNumber)`: Translate pin, call `_controller.IsPinOpen(logicalPin)`.
- `Dispose()`: Close all open pins, dispose `_controller`.

Wrap all calls in try/catch (PlatformNotSupportedException, IOException) with graceful error messages. If System.Device.Gpio throws, log error and degrade gracefully (return default values, don't propagate exception).

**Step 3: I2cBusController.cs**

Sealed class implementing `II2cBusController`. Uses `System.Device.I2c.I2cDevice`.

```csharp
public II2cDevice OpenDevice(int busId, int deviceAddress)
{
    var settings = new I2cConnectionSettings(busId, deviceAddress);
    var device = System.Device.I2c.I2cDevice.Create(settings);
    return new I2cDeviceWrapper(device);
}
```

Create inner class `I2cDeviceWrapper` implementing `II2cDevice`:
- Wraps `System.Device.I2c.I2cDevice`
- `Read(Span<byte> buffer)`: Calls wrapped device.Read(buffer)
- `Write(ReadOnlySpan<byte> data)`: Calls wrapped device.Write(data)
- `WriteRead(...)`: Calls wrapped device.WriteRead(...)
- Dispose: Disposes wrapped device

Wrap I2C operations in try/catch (IOException) with graceful error handling.

**Step 4: SpiBusController.cs**

Sealed class implementing `ISpiBusController`. Uses `System.Device.Spi.SpiDevice`.

```csharp
public ISpiDevice OpenDevice(int busId, int chipSelect, int clockFrequency, SpiMode mode)
{
    var settings = new SpiConnectionSettings(busId, chipSelect)
    {
        ClockFrequency = clockFrequency,
        Mode = (System.Device.Spi.SpiMode)mode // cast to System.Device.Spi.SpiMode
    };
    var device = System.Device.Spi.SpiDevice.Create(settings);
    return new SpiDeviceWrapper(device);
}
```

Create inner class `SpiDeviceWrapper` implementing `ISpiDevice`:
- Wraps `System.Device.Spi.SpiDevice`
- `Transfer(...)`: Calls wrapped device.TransferFullDuplex(writeBuffer, readBuffer)
- `Write(...)`: Calls wrapped device.Write(data)
- `Read(...)`: Calls wrapped device.Read(buffer)
- Dispose: Disposes wrapped device

**Step 5: PinMapping.cs**

Create a record type or class that provides pin number translation:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Board-specific pin mappings")]
public sealed class PinMapping
{
    private readonly Dictionary<int, int> _physicalToLogical;

    public string BoardName { get; }

    private PinMapping(string boardName, Dictionary<int, int> mapping)
    {
        BoardName = boardName;
        _physicalToLogical = mapping;
    }

    public int GetLogicalPin(int physicalPin)
    {
        if (_physicalToLogical.TryGetValue(physicalPin, out var logical))
            return logical;
        throw new ArgumentException($"Invalid physical pin {physicalPin} for board {BoardName}");
    }

    public static PinMapping RaspberryPi4 => new("Raspberry Pi 4", new()
    {
        // Map physical pins to BCM GPIO numbers
        [3] = 2, [5] = 3, [7] = 4, [8] = 14, [10] = 15,
        [11] = 17, [12] = 18, [13] = 27, [15] = 22, [16] = 23,
        [18] = 24, [19] = 10, [21] = 9, [22] = 25, [23] = 11,
        [24] = 8, [26] = 7, [29] = 5, [31] = 6, [32] = 12,
        [33] = 13, [35] = 19, [36] = 16, [37] = 26, [38] = 20,
        [40] = 21
    });

    public static PinMapping RaspberryPi5 => RaspberryPi4; // Same GPIO mapping

    public static PinMapping BeagleBoneBlack => new("BeagleBone Black", new()
    {
        // Example: P8 header pins
        // Full mapping requires BeagleBone-specific GPIO numbering
        // Placeholder for now
    });

    public static PinMapping JetsonNano => new("Jetson Nano", new()
    {
        // Example: Jetson Nano 40-pin header
        // Placeholder for now
    });
}
```

Use accurate Raspberry Pi 4/5 mappings (BCM GPIO numbers). BeagleBone and Jetson mappings can be placeholders (add XML doc noting "partial implementation, extend as needed").

Thread safety: All controllers use internal locking where necessary (e.g., around callback registration).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify System.Device.Gpio package restored. Grep for `using System.Device.Gpio` in GpioBusController. Grep for `PinMapping.RaspberryPi4` in GpioBusController constructor.
  </verify>
  <done>
GpioBusController wraps System.Device.Gpio.GpioController with pin mapping translation. I2cBusController and SpiBusController wrap System.Device I2C/SPI devices. PinMapping provides Raspberry Pi 4/5, BeagleBone, and Jetson mappings. All implementations have error handling and IDisposable cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Null Bus Controllers and Factory</name>
  <files>
    DataWarehouse.SDK/Edge/Bus/NullBusController.cs
    DataWarehouse.SDK/Edge/Bus/BusControllerFactory.cs
  </files>
  <action>
**NullBusController.cs**:

Create in namespace `DataWarehouse.SDK.Edge.Bus`:

Implement all three null controllers in a single file for simplicity:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Null bus controllers for non-IoT platforms")]
public sealed class NullGpioBusController : IGpioBusController
{
    public void OpenPin(int pinNumber, PinMode mode) { /* no-op */ }
    public void ClosePin(int pinNumber) { /* no-op */ }
    public PinValue Read(int pinNumber) => PinValue.Low;
    public void Write(int pinNumber, PinValue value) { /* no-op */ }
    public void RegisterCallback(int pinNumber, PinEventEdge edge, Action<PinValueChangedEventArgs> callback) { /* no-op */ }
    public void UnregisterCallback(int pinNumber) { /* no-op */ }
    public bool IsPinOpen(int pinNumber) => false;
    public void Dispose() { /* no-op */ }
}

public sealed class NullI2cBusController : II2cBusController
{
    public II2cDevice OpenDevice(int busId, int deviceAddress) => new NullI2cDevice();
    public void Dispose() { /* no-op */ }
}

public sealed class NullI2cDevice : II2cDevice
{
    public void Read(Span<byte> buffer) => buffer.Clear();
    public void Write(ReadOnlySpan<byte> data) { /* no-op */ }
    public void WriteRead(ReadOnlySpan<byte> writeBuffer, Span<byte> readBuffer) => readBuffer.Clear();
    public void Dispose() { /* no-op */ }
}

public sealed class NullSpiBusController : ISpiBusController
{
    public ISpiDevice OpenDevice(int busId, int chipSelect, int clockFrequency, SpiMode mode) => new NullSpiDevice();
    public void Dispose() { /* no-op */ }
}

public sealed class NullSpiDevice : ISpiDevice
{
    public void Transfer(ReadOnlySpan<byte> writeBuffer, Span<byte> readBuffer) => readBuffer.Clear();
    public void Write(ReadOnlySpan<byte> data) { /* no-op */ }
    public void Read(Span<byte> buffer) => buffer.Clear();
    public void Dispose() { /* no-op */ }
}
```

All null implementations return default/empty values and perform no-ops. Never throw exceptions. Add XML docs noting "Graceful fallback for platforms without hardware bus support."

**BusControllerFactory.cs**:

Create in namespace `DataWarehouse.SDK.Edge.Bus`:

Static class with factory methods:

```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Bus controller factory (EDGE-01)")]
public static class BusControllerFactory
{
    /// <summary>
    /// Creates a GPIO bus controller, using real implementation if gpio capability is present,
    /// otherwise returns a null controller.
    /// </summary>
    public static IGpioBusController CreateGpioController(IPlatformCapabilityRegistry? registry = null, PinMapping? pinMapping = null)
    {
        // Check if platform has GPIO capability
        bool hasGpio = registry?.HasCapability("gpio") ?? false;

        if (!hasGpio)
        {
            // Also check if running on known IoT platform
            hasGpio = OperatingSystem.IsLinux() && Directory.Exists("/sys/class/gpio");
        }

        return hasGpio
            ? new GpioBusController(pinMapping)
            : new NullGpioBusController();
    }

    /// <summary>
    /// Creates an I2C bus controller.
    /// </summary>
    public static II2cBusController CreateI2cController(IPlatformCapabilityRegistry? registry = null)
    {
        bool hasI2c = registry?.HasCapability("i2c") ?? false;

        if (!hasI2c)
        {
            hasI2c = OperatingSystem.IsLinux() && Directory.Exists("/sys/class/i2c-adapter");
        }

        return hasI2c
            ? new I2cBusController()
            : new NullI2cBusController();
    }

    /// <summary>
    /// Creates an SPI bus controller.
    /// </summary>
    public static ISpiBusController CreateSpiController(IPlatformCapabilityRegistry? registry = null)
    {
        bool hasSpi = registry?.HasCapability("spi") ?? false;

        if (!hasSpi)
        {
            hasSpi = OperatingSystem.IsLinux() && Directory.Exists("/sys/class/spi_master");
        }

        return hasSpi
            ? new SpiBusController()
            : new NullSpiBusController();
    }
}
```

Factory uses `IPlatformCapabilityRegistry.HasCapability` (from Phase 32) to detect hardware. Falls back to directory existence checks on Linux. Returns null controllers when capability absent. Accepts optional registry parameter (if null, performs capability detection itself).

Add XML documentation for all factory methods.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `NullGpioBusController` in factory. Grep for `HasCapability("gpio")` in factory. Verify factory returns null controllers when capability absent.
  </verify>
  <done>
NullGpioBusController, NullI2cBusController, NullSpiBusController provide graceful no-op fallback. BusControllerFactory selects real or null controllers based on platform capability detection via IPlatformCapabilityRegistry or filesystem checks. All null implementations never throw.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. All 10 new files exist in DataWarehouse.SDK/Edge/Bus/
3. System.Device.Gpio NuGet package (v3.2.0+) is referenced
4. IGpioBusController, II2cBusController, ISpiBusController interfaces defined
5. GpioBusController, I2cBusController, SpiBusController wrap System.Device.Gpio
6. Null controllers provide graceful fallback
7. BusControllerFactory uses IPlatformCapabilityRegistry for capability detection
8. PinMapping provides Raspberry Pi 4/5 GPIO mappings
9. All controllers implement IDisposable
10. All public APIs have XML documentation
</verification>

<success_criteria>
- GPIO read/write operations work via System.Device.Gpio wrapper
- I2C and SPI device communication supported via System.Device wrappers
- Pin mapping translates physical pins to logical (BCM) GPIO numbers on Raspberry Pi
- Null controllers provide graceful fallback on non-IoT platforms (no throws, returns defaults)
- Factory selects real controllers when gpio/i2c/spi capability detected, null otherwise
- All implementations have proper IDisposable cleanup
- Zero new build errors
- System.Device.Gpio v3.2.0+ NuGet package added
</success_criteria>

<output>
After completion, create `.planning/phases/36-edge-iot-hardware/36-01-SUMMARY.md`
</output>
