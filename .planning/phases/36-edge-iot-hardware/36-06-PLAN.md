---
phase: 36-edge-iot-hardware
plan: 06
type: execute
wave: 3
depends_on: []
files_modified:
  - DataWarehouse.SDK/Edge/Memory/BoundedMemoryRuntime.cs
  - DataWarehouse.SDK/Edge/Memory/MemoryBudgetTracker.cs
  - DataWarehouse.SDK/Edge/Memory/MemorySettings.cs
  - DataWarehouse.SDK/Hosting/PluginLoader.cs
autonomous: true

must_haves:
  truths:
    - "BoundedMemoryRuntime enforces configurable memory ceiling (e.g., 64MB, 128MB)"
    - "All allocations >1KB route through ArrayPool<byte>"
    - "Zero-allocation hot paths for read/write operations"
    - "GC pressure monitoring triggers proactive cleanup"
    - "Plugin loading respects memory budget (reject if insufficient)"
    - "Per-plugin memory tracking via weak references"
    - "Run with 64MB ceiling -- no OOM, zero Gen2 GC collections under load"
  artifacts:
    - path: "DataWarehouse.SDK/Edge/Memory/BoundedMemoryRuntime.cs"
      provides: "Bounded memory runtime with ceiling enforcement"
      min_lines: 150
    - path: "DataWarehouse.SDK/Edge/Memory/MemoryBudgetTracker.cs"
      provides: "Memory budget tracking and GC pressure monitoring"
      min_lines: 100
    - path: "DataWarehouse.SDK/Edge/Memory/MemorySettings.cs"
      provides: "Memory configuration (ceiling, pool sizes, GC thresholds)"
      min_lines: 40
---

<objective>
Implement memory-constrained runtime (EDGE-06) with bounded memory mode, ArrayPool allocation, zero-alloc hot paths, GC pressure monitoring, and plugin memory budgeting for resource-constrained edge devices.

Purpose: Enable DataWarehouse to run on devices with limited memory (64MB-256MB). Enforces memory ceiling, uses pooled allocations, and rejects operations when budget insufficient. Critical for embedded systems and edge gateways.

Output: Bounded memory runtime, memory tracker, ArrayPool integration, plugin budget enforcement.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/REQUIREMENTS-v3.md
@.planning/phases/36-edge-iot-hardware/36-RESEARCH.md
@DataWarehouse.SDK/Hosting/PluginLoader.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Memory Settings and Tracker</name>
  <files>
    DataWarehouse.SDK/Edge/Memory/MemorySettings.cs
    DataWarehouse.SDK/Edge/Memory/MemoryBudgetTracker.cs
  </files>
  <action>
Create namespace `DataWarehouse.SDK.Edge.Memory`:

**MemorySettings.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Memory settings (EDGE-06)")]
public sealed record MemorySettings
{
    public long MemoryCeiling { get; init; } = 128 * 1024 * 1024; // 128MB default
    public int ArrayPoolMaxArraySize { get; init; } = 1024 * 1024; // 1MB
    public double GcPressureThreshold { get; init; } = 0.85; // 85% of ceiling
    public bool Enabled { get; init; } = false; // Opt-in
}
```

**MemoryBudgetTracker.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Memory budget tracker (EDGE-06)")]
public sealed class MemoryBudgetTracker
{
    private readonly MemorySettings _settings;
    private readonly ArrayPool<byte> _arrayPool;
    private long _allocatedBytes;

    public MemoryBudgetTracker(MemorySettings settings)
    {
        _settings = settings;
        _arrayPool = ArrayPool<byte>.Create(_settings.ArrayPoolMaxArraySize, 50);
    }

    public long CurrentUsage => GC.GetTotalMemory(forceFullCollection: false);
    public long Ceiling => _settings.MemoryCeiling;
    public double UsageRatio => (double)CurrentUsage / Ceiling;
    public bool IsAboveThreshold => UsageRatio >= _settings.GcPressureThreshold;

    public byte[] Rent(int size)
    {
        if (!_settings.Enabled) return new byte[size];

        if (CurrentUsage + size > Ceiling)
        {
            // Trigger GC and retry
            GC.Collect(2, GCCollectionMode.Forced, blocking: true, compacting: true);
            if (CurrentUsage + size > Ceiling)
                throw new OutOfMemoryException($"Memory ceiling exceeded: {CurrentUsage + size} > {Ceiling}");
        }

        Interlocked.Add(ref _allocatedBytes, size);
        return _arrayPool.Rent(size);
    }

    public void Return(byte[] array, bool clearArray = false)
    {
        if (!_settings.Enabled) return;
        Interlocked.Add(ref _allocatedBytes, -array.Length);
        _arrayPool.Return(array, clearArray);
    }

    public void TriggerProactiveCleanup()
    {
        if (IsAboveThreshold)
        {
            GC.Collect(1, GCCollectionMode.Optimized);
        }
    }
}
```
  </action>
  <verify>
Verify files exist. Grep for `MemoryBudgetTracker`, `MemorySettings`.
  </verify>
  <done>
Memory settings with configurable ceiling. Budget tracker with ArrayPool integration and GC pressure monitoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bounded Memory Runtime</name>
  <files>
    DataWarehouse.SDK/Edge/Memory/BoundedMemoryRuntime.cs
  </files>
  <action>
**BoundedMemoryRuntime.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Bounded memory runtime (EDGE-06)")]
public sealed class BoundedMemoryRuntime : IDisposable
{
    private static readonly Lazy<BoundedMemoryRuntime> _instance = new(() => new BoundedMemoryRuntime());
    public static BoundedMemoryRuntime Instance => _instance.Value;

    private MemoryBudgetTracker? _tracker;
    private MemorySettings _settings = new();
    private Timer? _monitorTimer;

    private BoundedMemoryRuntime() { }

    public void Initialize(MemorySettings settings)
    {
        _settings = settings;
        if (!settings.Enabled) return;

        _tracker = new MemoryBudgetTracker(settings);

        // Start periodic memory monitoring
        _monitorTimer = new Timer(
            callback: _ => _tracker.TriggerProactiveCleanup(),
            state: null,
            dueTime: TimeSpan.FromSeconds(10),
            period: TimeSpan.FromSeconds(10));
    }

    public byte[] RentBuffer(int size) => _tracker?.Rent(size) ?? new byte[size];

    public void ReturnBuffer(byte[] buffer, bool clear = false) => _tracker?.Return(buffer, clear);

    public bool CanAllocate(int size)
    {
        if (!_settings.Enabled) return true;
        return _tracker!.CurrentUsage + size <= _tracker.Ceiling;
    }

    public long CurrentMemoryUsage => _tracker?.CurrentUsage ?? GC.GetTotalMemory(false);

    public void Dispose()
    {
        _monitorTimer?.Dispose();
    }
}
```

Add XML docs. Explain singleton pattern for global memory management.
  </action>
  <verify>
Build SDK. Grep for `BoundedMemoryRuntime`.
  </verify>
  <done>
Bounded memory runtime enforces ceiling, provides ArrayPool access, monitors GC pressure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Plugin Memory Budget Enforcement</name>
  <files>
    DataWarehouse.SDK/Hosting/PluginLoader.cs
  </files>
  <action>
Edit existing `PluginLoader.cs` to add memory budget check during plugin loading:

Find the `LoadPlugin` or `LoadPluginAsync` method. Before instantiating the plugin, add:

```csharp
// Memory budget check (EDGE-06)
var estimatedPluginMemory = 10 * 1024 * 1024; // 10MB estimate per plugin
if (!BoundedMemoryRuntime.Instance.CanAllocate(estimatedPluginMemory))
{
    throw new InvalidOperationException($"Insufficient memory budget to load plugin {pluginName}. " +
        $"Current usage: {BoundedMemoryRuntime.Instance.CurrentMemoryUsage}, Estimate: {estimatedPluginMemory}");
}
```

Add XML doc noting: "When BoundedMemoryRuntime is enabled, plugin loading checks available memory budget. Plugins are rejected if estimated memory requirement exceeds available budget."

Also add a using directive: `using DataWarehouse.SDK.Edge.Memory;`
  </action>
  <verify>
Build SDK. Grep for `BoundedMemoryRuntime.Instance.CanAllocate` in PluginLoader.
  </verify>
  <done>
Plugin loader enforces memory budget. Plugins rejected when memory insufficient.
  </done>
</task>

</tasks>

<verification>
- SDK builds with zero errors
- BoundedMemoryRuntime singleton initialized with settings
- Memory ceiling enforced via budget tracker
- ArrayPool used for allocations >1KB
- GC pressure monitoring with proactive cleanup
- Plugin loader checks memory budget before loading
</verification>

<success_criteria>
- Run DataWarehouse with 64MB ceiling -- no OOM
- Process 10K read/write operations with zero Gen2 GC collections
- ArrayPool reuse reduces allocation pressure
- Plugin load rejected when memory budget insufficient
- Periodic monitoring triggers GC when approaching threshold
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-edge-iot-hardware/36-06-SUMMARY.md`
</output>
