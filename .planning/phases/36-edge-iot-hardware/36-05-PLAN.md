---
phase: 36-edge-iot-hardware
plan: 05
type: execute
wave: 3
depends_on: [33-01]
files_modified:
  - DataWarehouse.SDK/Edge/Flash/IFlashTranslationLayer.cs
  - DataWarehouse.SDK/Edge/Flash/FlashTranslationLayer.cs
  - DataWarehouse.SDK/Edge/Flash/WearLevelingStrategy.cs
  - DataWarehouse.SDK/Edge/Flash/BadBlockManager.cs
  - DataWarehouse.SDK/Edge/Flash/FlashDevice.cs
autonomous: true

must_haves:
  truths:
    - "IFlashTranslationLayer provides wear-leveling across flash blocks"
    - "Bad-block management marks and skips defective blocks"
    - "Garbage collection reclaims invalidated pages"
    - "Write amplification factor <2.0 under mixed workloads"
    - "Extends Phase 33 VDE IBlockDevice for flash-specific optimizations"
    - "Raw NAND/NOR access via /dev/mtd* on Linux"
  artifacts:
    - path: "DataWarehouse.SDK/Edge/Flash/IFlashTranslationLayer.cs"
      provides: "FTL interface extending IBlockDevice"
      min_lines: 30
    - path: "DataWarehouse.SDK/Edge/Flash/FlashTranslationLayer.cs"
      provides: "FTL implementation with wear-leveling and GC"
      min_lines: 250
    - path: "DataWarehouse.SDK/Edge/Flash/WearLevelingStrategy.cs"
      provides: "Wear-leveling block selection algorithm"
      min_lines: 100
    - path: "DataWarehouse.SDK/Edge/Flash/BadBlockManager.cs"
      provides: "Bad-block detection and tracking"
      min_lines: 80
    - path: "DataWarehouse.SDK/Edge/Flash/FlashDevice.cs"
      provides: "Raw NAND/NOR device abstraction"
      min_lines: 120
---

<objective>
Implement Flash Translation Layer (EDGE-05) with wear-leveling, bad-block management, and garbage collection for raw NAND/NOR flash access on edge devices.

Purpose: Enable DataWarehouse to use raw flash storage efficiently on embedded systems. FTL distributes writes evenly across flash blocks to maximize device lifespan, manages defective blocks, and reclaims space. Extends Phase 33 VDE with flash-specific optimizations.

Output: FTL interface, wear-leveling, bad-block manager, garbage collector, raw flash device abstraction.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/REQUIREMENTS-v3.md
@.planning/phases/36-edge-iot-hardware/36-RESEARCH.md
@DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: FTL Interfaces and Types</name>
  <files>
    DataWarehouse.SDK/Edge/Flash/IFlashTranslationLayer.cs
    DataWarehouse.SDK/Edge/Flash/FlashDevice.cs
  </files>
  <action>
Create namespace `DataWarehouse.SDK.Edge.Flash`:

**IFlashTranslationLayer.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Flash translation layer interface (EDGE-05)")]
public interface IFlashTranslationLayer : VirtualDiskEngine.IBlockDevice
{
    int EraseBlockSize { get; } // Flash erase block size (e.g., 128KB)
    long TotalBlocks { get; }
    long UsableBlocks { get; } // Total - bad blocks
    int BadBlockCount { get; }
    double WriteAmplificationFactor { get; }
    Task GarbageCollectAsync(CancellationToken ct = default);
    Task<IReadOnlyList<int>> GetBadBlocksAsync(CancellationToken ct = default);
}
```

**FlashDevice.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Raw flash device abstraction (EDGE-05)")]
public interface IFlashDevice : IAsyncDisposable
{
    int EraseBlockSize { get; }
    long TotalBlocks { get; }
    Task EraseBlockAsync(long blockNumber, CancellationToken ct = default);
    Task ReadPageAsync(long blockNumber, int pageOffset, Memory<byte> buffer, CancellationToken ct = default);
    Task WritePageAsync(long blockNumber, int pageOffset, ReadOnlyMemory<byte> data, CancellationToken ct = default);
    Task<bool> IsBlockBadAsync(long blockNumber, CancellationToken ct = default);
    Task MarkBlockBadAsync(long blockNumber, CancellationToken ct = default);
}

internal sealed class LinuxMtdFlashDevice : IFlashDevice
{
    private readonly string _devicePath; // /dev/mtd0
    private readonly SafeFileHandle _handle;
    private readonly int _eraseBlockSize;
    private readonly long _totalBlocks;

    public LinuxMtdFlashDevice(string devicePath)
    {
        _devicePath = devicePath;
        // Open /dev/mtdX with O_RDWR | O_SYNC
        // Query MEMGETINFO ioctl for erase block size, total size
        // Implementation requires Linux-specific P/Invoke
        throw new NotImplementedException("Linux MTD access requires platform-specific implementation");
    }

    public int EraseBlockSize => _eraseBlockSize;
    public long TotalBlocks => _totalBlocks;

    public Task EraseBlockAsync(long blockNumber, CancellationToken ct = default)
    {
        // MEMERASE ioctl
        throw new NotImplementedException();
    }

    public Task ReadPageAsync(long blockNumber, int pageOffset, Memory<byte> buffer, CancellationToken ct = default)
    {
        // pread at block offset + page offset
        throw new NotImplementedException();
    }

    public Task WritePageAsync(long blockNumber, int pageOffset, ReadOnlyMemory<byte> data, CancellationToken ct = default)
    {
        // pwrite at block offset + page offset
        throw new NotImplementedException();
    }

    public Task<bool> IsBlockBadAsync(long blockNumber, CancellationToken ct = default)
    {
        // MEMGETBADBLOCK ioctl
        throw new NotImplementedException();
    }

    public Task MarkBlockBadAsync(long blockNumber, CancellationToken ct = default)
    {
        // MEMSETBADBLOCK ioctl
        throw new NotImplementedException();
    }

    public ValueTask DisposeAsync()
    {
        _handle?.Dispose();
        return ValueTask.CompletedTask;
    }
}
```

Note: LinuxMtdFlashDevice is a stub. Full implementation requires Linux `<mtd/mtd-user.h>` ioctls via P/Invoke, which is complex and platform-specific. Add XML doc: "Stub implementation -- production use requires Linux MTD ioctl bindings."
  </action>
  <verify>
Verify files exist. Grep for `IFlashTranslationLayer`, `IFlashDevice`.
  </verify>
  <done>
FTL interface extends IBlockDevice with flash-specific operations. Raw flash device abstraction defined (stub for Linux MTD).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wear-Leveling and Bad-Block Management</name>
  <files>
    DataWarehouse.SDK/Edge/Flash/WearLevelingStrategy.cs
    DataWarehouse.SDK/Edge/Flash/BadBlockManager.cs
  </files>
  <action>
**WearLevelingStrategy.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Wear-leveling strategy (EDGE-05)")]
internal sealed class WearLevelingStrategy
{
    private readonly Dictionary<long, int> _blockEraseCount = new();
    private readonly Random _random = new();

    public long SelectBlockForWrite(IEnumerable<long> availableBlocks)
    {
        // Wear-leveling algorithm: select block with lowest erase count
        // If multiple blocks have same count, pick randomly
        var minCount = int.MaxValue;
        var candidates = new List<long>();

        foreach (var block in availableBlocks)
        {
            var count = _blockEraseCount.GetValueOrDefault(block, 0);
            if (count < minCount)
            {
                minCount = count;
                candidates.Clear();
                candidates.Add(block);
            }
            else if (count == minCount)
            {
                candidates.Add(block);
            }
        }

        var selected = candidates[_random.Next(candidates.Count)];
        _blockEraseCount[selected] = _blockEraseCount.GetValueOrDefault(selected, 0) + 1;
        return selected;
    }

    public int GetEraseCount(long blockNumber) => _blockEraseCount.GetValueOrDefault(blockNumber, 0);

    public double GetAverageEraseCount()
    {
        if (_blockEraseCount.Count == 0) return 0;
        return _blockEraseCount.Values.Average();
    }
}
```

**BadBlockManager.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: Bad-block manager (EDGE-05)")]
internal sealed class BadBlockManager
{
    private readonly HashSet<long> _badBlocks = new();
    private readonly IFlashDevice _flashDevice;

    public BadBlockManager(IFlashDevice flashDevice)
    {
        _flashDevice = flashDevice;
    }

    public async Task ScanBadBlocksAsync(CancellationToken ct = default)
    {
        for (long block = 0; block < _flashDevice.TotalBlocks; block++)
        {
            if (await _flashDevice.IsBlockBadAsync(block, ct))
            {
                _badBlocks.Add(block);
            }
        }
    }

    public async Task MarkBadAsync(long blockNumber, CancellationToken ct = default)
    {
        _badBlocks.Add(blockNumber);
        await _flashDevice.MarkBlockBadAsync(blockNumber, ct);
    }

    public bool IsBad(long blockNumber) => _badBlocks.Contains(blockNumber);

    public IReadOnlyList<long> GetBadBlocks() => _badBlocks.ToList();

    public int BadBlockCount => _badBlocks.Count;
}
```
  </action>
  <verify>
Verify files exist. Grep for `WearLevelingStrategy`, `BadBlockManager`.
  </verify>
  <done>
Wear-leveling selects blocks with lowest erase count. Bad-block manager tracks and marks defective blocks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Flash Translation Layer Implementation</name>
  <files>
    DataWarehouse.SDK/Edge/Flash/FlashTranslationLayer.cs
  </files>
  <action>
**FlashTranslationLayer.cs**:
```csharp
[SdkCompatibility("3.0.0", Notes = "Phase 36: FTL implementation (EDGE-05)")]
public sealed class FlashTranslationLayer : IFlashTranslationLayer
{
    private readonly IFlashDevice _flashDevice;
    private readonly WearLevelingStrategy _wearLeveling;
    private readonly BadBlockManager _badBlockManager;
    private readonly Dictionary<long, long> _logicalToPhysical = new(); // Logical block -> physical block
    private readonly HashSet<long> _freeBlocks = new();
    private readonly HashSet<long> _dirtyBlocks = new(); // Blocks with invalidated pages
    private long _writeCount;
    private long _eraseCount;

    public int BlockSize => 4096; // Logical block size
    public long BlockCount { get; }
    public int EraseBlockSize => _flashDevice.EraseBlockSize;
    public long TotalBlocks => _flashDevice.TotalBlocks;
    public long UsableBlocks => TotalBlocks - _badBlockManager.BadBlockCount;
    public int BadBlockCount => _badBlockManager.BadBlockCount;
    public double WriteAmplificationFactor => _eraseCount == 0 ? 0 : (double)_writeCount / _eraseCount;

    public FlashTranslationLayer(IFlashDevice flashDevice, long logicalBlockCount)
    {
        _flashDevice = flashDevice;
        _wearLeveling = new WearLevelingStrategy();
        _badBlockManager = new BadBlockManager(flashDevice);
        BlockCount = logicalBlockCount;

        // Initialize free blocks (all physical blocks minus bad blocks)
        for (long i = 0; i < flashDevice.TotalBlocks; i++)
        {
            if (!_badBlockManager.IsBad(i))
                _freeBlocks.Add(i);
        }
    }

    public async Task ReadBlockAsync(long blockNumber, Memory<byte> buffer, CancellationToken ct = default)
    {
        if (!_logicalToPhysical.TryGetValue(blockNumber, out var physicalBlock))
        {
            buffer.Span.Clear(); // Unwritten block returns zeros
            return;
        }

        await _flashDevice.ReadPageAsync(physicalBlock, 0, buffer, ct);
    }

    public async Task WriteBlockAsync(long blockNumber, ReadOnlyMemory<byte> data, CancellationToken ct = default)
    {
        // Flash write requires erase-before-write. If block is already mapped, mark old physical block dirty.
        if (_logicalToPhysical.TryGetValue(blockNumber, out var oldPhysical))
        {
            _dirtyBlocks.Add(oldPhysical);
        }

        // Allocate new physical block via wear-leveling
        var newPhysical = _wearLeveling.SelectBlockForWrite(_freeBlocks);
        _freeBlocks.Remove(newPhysical);

        // Erase block before write (NAND requirement)
        await _flashDevice.EraseBlockAsync(newPhysical, ct);
        _eraseCount++;

        // Write data
        await _flashDevice.WritePageAsync(newPhysical, 0, data, ct);
        _writeCount++;

        _logicalToPhysical[blockNumber] = newPhysical;
    }

    public Task FlushAsync(CancellationToken ct = default) => Task.CompletedTask;

    public async Task GarbageCollectAsync(CancellationToken ct = default)
    {
        // Reclaim dirty blocks: erase and return to free pool
        foreach (var dirtyBlock in _dirtyBlocks.ToList())
        {
            await _flashDevice.EraseBlockAsync(dirtyBlock, ct);
            _eraseCount++;
            _dirtyBlocks.Remove(dirtyBlock);
            _freeBlocks.Add(dirtyBlock);
        }
    }

    public Task<IReadOnlyList<int>> GetBadBlocksAsync(CancellationToken ct = default) =>
        Task.FromResult<IReadOnlyList<int>>(_badBlockManager.GetBadBlocks().Select(b => (int)b).ToList());

    public async ValueTask DisposeAsync()
    {
        await _flashDevice.DisposeAsync();
    }
}
```

Add XML docs. Explain WAF calculation, garbage collection trigger logic (could be threshold-based, e.g., when dirty blocks > 10%).
  </action>
  <verify>
Build SDK. Grep for `FlashTranslationLayer`, `IFlashTranslationLayer`.
  </verify>
  <done>
FTL implements wear-leveling, bad-block skipping, and garbage collection. WAF tracked via write/erase counters.
  </done>
</task>

</tasks>

<verification>
- SDK builds with zero errors
- FTL extends IBlockDevice from Phase 33
- Wear-leveling distributes writes evenly
- Bad-block manager marks and skips defective blocks
- Garbage collection reclaims dirty blocks
- WAF calculation implemented
</verification>

<success_criteria>
- Write 10x device capacity with even wear distribution
- Mark 5% blocks bad -- capacity reduced, no data loss
- Garbage collection reclaims invalidated pages
- WAF <2.0 under mixed read/write workload
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-edge-iot-hardware/36-05-SUMMARY.md`
</output>
