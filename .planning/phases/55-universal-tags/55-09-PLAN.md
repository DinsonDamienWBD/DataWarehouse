---
phase: 55-universal-tags
plan: 09
type: execute
wave: 4
depends_on: ["55-05", "55-08"]
files_modified:
  - DataWarehouse.SDK/Tags/ITagQueryApi.cs
  - DataWarehouse.SDK/Tags/DefaultTagQueryApi.cs
  - DataWarehouse.SDK/Tags/TagQueryExpression.cs
autonomous: true

must_haves:
  truths:
    - "Tag query API supports composable filter expressions (AND, OR, NOT)"
    - "Queries leverage the inverted index for performance"
    - "API supports both tag-centric and object-centric queries"
  artifacts:
    - path: "DataWarehouse.SDK/Tags/TagQueryExpression.cs"
      provides: "Composable query expression tree (AND, OR, NOT, leaf filters)"
      min_lines: 60
    - path: "DataWarehouse.SDK/Tags/ITagQueryApi.cs"
      provides: "High-level query interface"
      min_lines: 30
    - path: "DataWarehouse.SDK/Tags/DefaultTagQueryApi.cs"
      provides: "Implementation that compiles expressions to index queries"
      min_lines: 100
  key_links:
    - from: "DataWarehouse.SDK/Tags/DefaultTagQueryApi.cs"
      to: "DataWarehouse.SDK/Tags/ITagIndex.cs"
      via: "Queries inverted index for matching objects"
      pattern: "ITagIndex"
    - from: "DataWarehouse.SDK/Tags/DefaultTagQueryApi.cs"
      to: "DataWarehouse.SDK/Tags/InMemoryTagStore.cs"
      via: "Loads full tags for matched objects"
      pattern: "ITagStore"
---

<objective>
Build the high-level tag query API with composable expression trees.

Purpose: The inverted index (Plan 08) provides raw tag lookups. The query API adds composable expressions (AND/OR/NOT), object-centric views, and aggregation -- what consumers actually need.
Output: Query expression types, query API interface, default implementation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-universal-tags/55-05-SUMMARY.md
@.planning/phases/55-universal-tags/55-08-SUMMARY.md
@DataWarehouse.SDK/Tags/ITagIndex.cs
@DataWarehouse.SDK/Tags/TagIndexEntry.cs
@DataWarehouse.SDK/Tags/InMemoryTagStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create composable tag query expressions</name>
  <files>DataWarehouse.SDK/Tags/TagQueryExpression.cs</files>
  <action>
Create `DataWarehouse.SDK/Tags/TagQueryExpression.cs` in namespace `DataWarehouse.SDK.Tags`.

Abstract record `TagQueryExpression` with concrete subtypes:
- `TagFilterExpression(TagFilter Filter)` -- leaf: single tag filter
- `AndExpression(IReadOnlyList<TagQueryExpression> Children)` -- all must match
- `OrExpression(IReadOnlyList<TagQueryExpression> Children)` -- any must match
- `NotExpression(TagQueryExpression Inner)` -- negation

Static builder methods on `TagQueryExpression`:
- `static TagQueryExpression Where(TagKey key, TagFilterOperator op, TagValue? value = null)` -- creates TagFilterExpression
- `static TagQueryExpression HasTag(TagKey key)` -- shortcut for Exists
- `static TagQueryExpression HasTag(string ns, string name)` -- convenience overload
- `static TagQueryExpression TagEquals(TagKey key, TagValue value)` -- shortcut for Equals
- `TagQueryExpression And(TagQueryExpression other)` -- instance method, returns AndExpression
- `TagQueryExpression Or(TagQueryExpression other)` -- instance method, returns OrExpression
- `TagQueryExpression Negate()` -- instance method, returns NotExpression

Enum `TagQuerySortField { ObjectKey, TagKey, TagValue, ModifiedUtc, CreatedUtc }`.

Record `TagQueryRequest`:
- `TagQueryExpression Expression`
- `int Skip` (default: 0)
- `int Take` (default: 100)
- `TagQuerySortField SortBy` (default: ObjectKey)
- `bool Descending` (default: false)
- `bool IncludeTagValues` (default: true) -- if false, return only object keys
- `IReadOnlySet<TagKey>? ProjectTags` -- only return these tags (null = all)

Record `TagQueryResult`:
- `IReadOnlyList<TagQueryResultItem> Items`
- `long TotalCount`
- `TimeSpan QueryDuration`

Record `TagQueryResultItem`:
- `string ObjectKey`
- `TagCollection? Tags` -- null if IncludeTagValues=false
- `IReadOnlyDictionary<TagKey, TagValue>? ProjectedTags` -- if ProjectTags specified

Mark all with `[SdkCompatibility("5.0.0", Notes = "Phase 55: Tag query expressions")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>TagQueryExpression tree supports AND/OR/NOT with builder pattern, TagQueryRequest has pagination/sort/projection.</done>
</task>

<task type="auto">
  <name>Task 2: Implement query API with expression compilation</name>
  <files>DataWarehouse.SDK/Tags/ITagQueryApi.cs, DataWarehouse.SDK/Tags/DefaultTagQueryApi.cs</files>
  <action>
**ITagQueryApi.cs** (namespace `DataWarehouse.SDK.Tags`):
```csharp
public interface ITagQueryApi
{
    Task<TagQueryResult> QueryAsync(TagQueryRequest request, CancellationToken ct = default);
    Task<long> CountAsync(TagQueryExpression expression, CancellationToken ct = default);
    Task<IReadOnlyDictionary<TagValue, long>> AggregateAsync(TagKey tagKey, int topN = 50, CancellationToken ct = default);
    Task<IReadOnlyDictionary<TagKey, long>> GetTagDistributionAsync(int topN = 50, CancellationToken ct = default);
}
```

**DefaultTagQueryApi.cs** (namespace `DataWarehouse.SDK.Tags`):

Class `DefaultTagQueryApi : ITagQueryApi`:
- Constructor: `(ITagIndex index, ITagStore store)`
- `QueryAsync`:
  1. Compile `TagQueryExpression` to one or more `TagIndexQuery` calls:
     - `TagFilterExpression` -> direct `ITagIndex.QueryAsync`
     - `AndExpression` -> intersect results from child queries
     - `OrExpression` -> union results from child queries
     - `NotExpression` -> get all, subtract inner results (expensive, warn via logging)
  2. Apply pagination (Skip/Take) after merging
  3. If `IncludeTagValues`, load tags from `ITagStore` for matched objects
  4. If `ProjectTags`, filter to only requested tags
  5. Sort by SortBy field
  6. Return TagQueryResult
- `CountAsync`: like QueryAsync but with CountOnly=true on index queries, returns count
- `AggregateAsync`: get all objects with the tag, group by value, return top N values with counts. For string values, direct grouping. For number values, bucketize.
- `GetTagDistributionAsync`: delegate to `ITagIndex.GetTagDistributionAsync`

**Optimization notes** (document in code comments):
- AND queries: evaluate smallest cardinality filter first (use CountByTagAsync to estimate)
- OR queries: evaluate largest cardinality filter first (early termination on Take)
- NOT queries: log warning about full-scan cost

Mark with `[SdkCompatibility("5.0.0", Notes = "Phase 55: Tag query API")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>DefaultTagQueryApi compiles expression trees to index queries, supports AND/OR/NOT, pagination, projection, aggregation.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- Expression tree supports arbitrary nesting of AND/OR/NOT
- Query optimizer evaluates smallest filter first for AND
- Aggregation groups by tag value
</verification>

<success_criteria>
- Composable expressions: `HasTag("compliance", "gdpr").And(TagEquals(key, val))`
- Pagination with total count
- Tag projection for bandwidth efficiency
- Value aggregation for analytics
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-universal-tags/55-09-SUMMARY.md`
</output>
