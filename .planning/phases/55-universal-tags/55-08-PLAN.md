---
phase: 55-universal-tags
plan: 08
type: execute
wave: 4
depends_on: ["55-05"]
files_modified:
  - DataWarehouse.SDK/Tags/ITagIndex.cs
  - DataWarehouse.SDK/Tags/InvertedTagIndex.cs
  - DataWarehouse.SDK/Tags/TagIndexEntry.cs
autonomous: true

must_haves:
  truths:
    - "Inverted index maps TagKey->ObjectKeys for O(1) tag-to-object lookups"
    - "Index supports value-based filtering (exact match, range, prefix)"
    - "Index is designed for 1B objects with bounded memory via sharding"
  artifacts:
    - path: "DataWarehouse.SDK/Tags/ITagIndex.cs"
      provides: "Interface for tag indexing and querying"
      min_lines: 30
    - path: "DataWarehouse.SDK/Tags/InvertedTagIndex.cs"
      provides: "In-memory inverted index with sharding and bloom filters"
      min_lines: 120
    - path: "DataWarehouse.SDK/Tags/TagIndexEntry.cs"
      provides: "Index entry types, query filters, results"
      min_lines: 50
  key_links:
    - from: "DataWarehouse.SDK/Tags/InvertedTagIndex.cs"
      to: "DataWarehouse.SDK/Tags/TagEvents.cs"
      via: "Index updated on tag events"
      pattern: "TagAttachedEvent|TagDetachedEvent"
    - from: "DataWarehouse.SDK/Tags/InvertedTagIndex.cs"
      to: "DataWarehouse.SDK/Tags/ITagIndex.cs"
      via: "Implements ITagIndex"
      pattern: "ITagIndex"
---

<objective>
Build the inverted tag index for efficient tag-to-object lookups at scale.

Purpose: Finding "all objects tagged compliance:gdpr=true" across 1B objects requires an inverted index, not linear scan. This is the foundation for the Tag Query API (Plan 09).
Output: Tag index contract, inverted index implementation, index entry types.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-universal-tags/55-05-SUMMARY.md
@DataWarehouse.SDK/Tags/TagTypes.cs
@DataWarehouse.SDK/Tags/TagEvents.cs
@DataWarehouse.SDK/Tags/InMemoryTagStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define tag index contracts and entry types</name>
  <files>DataWarehouse.SDK/Tags/TagIndexEntry.cs, DataWarehouse.SDK/Tags/ITagIndex.cs</files>
  <action>
**TagIndexEntry.cs** (namespace `DataWarehouse.SDK.Tags`):

Record `TagIndexEntry(string ObjectKey, TagKey TagKey, TagValueKind ValueKind, DateTimeOffset IndexedAt)`.

Enum `TagFilterOperator { Equals, NotEquals, GreaterThan, LessThan, GreaterOrEqual, LessOrEqual, Contains, StartsWith, Exists, NotExists, In, Between }`.

Record `TagFilter`:
- `TagKey TagKey`
- `TagFilterOperator Operator`
- `TagValue? Value` -- for comparison operators
- `TagValue? UpperBound` -- for Between
- `IReadOnlySet<TagValue>? Values` -- for In

Record `TagIndexQuery`:
- `IReadOnlyList<TagFilter> Filters` -- AND semantics
- `int Skip` (default: 0)
- `int Take` (default: 100, max: 10000)
- `string? ObjectKeyPrefix` -- scope to objects with prefix
- `bool CountOnly` (default: false) -- return count without object keys

Record `TagIndexResult`:
- `IReadOnlyList<string> ObjectKeys`
- `long TotalCount` -- total matches (may be > ObjectKeys.Count due to Take)
- `TimeSpan QueryDuration`
- `bool IsApproximate` -- true if count is estimated (e.g., bloom filter pre-filter)

**ITagIndex.cs** (namespace `DataWarehouse.SDK.Tags`):
```csharp
public interface ITagIndex
{
    Task IndexAsync(string objectKey, Tag tag, CancellationToken ct = default);
    Task RemoveAsync(string objectKey, TagKey tagKey, CancellationToken ct = default);
    Task<TagIndexResult> QueryAsync(TagIndexQuery query, CancellationToken ct = default);
    Task<long> CountByTagAsync(TagKey tagKey, CancellationToken ct = default);
    Task RebuildAsync(IAsyncEnumerable<(string ObjectKey, TagCollection Tags)> source, CancellationToken ct = default);
    Task<IReadOnlyDictionary<TagKey, long>> GetTagDistributionAsync(int topN = 50, CancellationToken ct = default);
}
```

Mark all with `[SdkCompatibility("5.0.0", Notes = "Phase 55: Tag index types")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>ITagIndex has index/remove/query/count/rebuild/distribution. TagFilter supports 12 operators. TagIndexQuery has pagination and count-only mode.</done>
</task>

<task type="auto">
  <name>Task 2: Implement inverted tag index with sharding</name>
  <files>DataWarehouse.SDK/Tags/InvertedTagIndex.cs</files>
  <action>
Create `DataWarehouse.SDK/Tags/InvertedTagIndex.cs` in namespace `DataWarehouse.SDK.Tags`.

Class `InvertedTagIndex : ITagIndex`:

**Internal structure** (designed for 1B objects):
- `int ShardCount` (constructor parameter, default: 256)
- `ConcurrentDictionary<TagKey, ConcurrentDictionary<int, HashSet<string>>>[]` -- array of ShardCount shard dictionaries. Each shard owns a range of object keys (shard = objectKey.GetHashCode() % ShardCount).
- Shard-level locking via `ReaderWriterLockSlim[]` (one per shard) for write operations. Reads use concurrent collections.

**IndexAsync**:
1. Compute shard = objectKey.GetHashCode() & 0x7FFFFFFF % ShardCount
2. Get or create TagKey entry in shard's dictionary
3. Add objectKey to the shard's HashSet
4. O(1) amortized

**RemoveAsync**:
1. Compute shard
2. Remove objectKey from shard's TagKey entry
3. Clean up empty entries

**QueryAsync**:
1. For each filter in query.Filters:
   - `Exists`/`NotExists`: check TagKey presence across all shards
   - `Equals`: scan shard entries (future: value index)
   - For value-based operators on unindexed values: iterate matching object keys
2. Intersect results across filters (AND semantics)
3. Apply ObjectKeyPrefix filter
4. Apply Skip/Take pagination
5. Return TagIndexResult with total count

**CountByTagAsync**: sum counts across all shards for TagKey.

**RebuildAsync**: clear all shards, iterate source, index each tag.

**GetTagDistributionAsync**: count total entries per TagKey across shards, return top N.

**Memory optimization**: For shards with >100K entries per TagKey, use `HashSet<string>` with pre-allocated capacity. Track approximate memory usage via entry count * average key length.

Mark with `[SdkCompatibility("5.0.0", Notes = "Phase 55: Inverted tag index")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>InvertedTagIndex shards across 256 buckets, supports all filter operators, provides rebuild and distribution APIs.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- Index supports 12 filter operators
- Sharding distributes load across 256 buckets
- RebuildAsync can re-index from any IAsyncEnumerable source
</verification>

<success_criteria>
- Inverted index provides O(1) amortized tag-to-object lookups
- Sharding bounds per-shard memory for 1B object scale
- Query supports AND filters with pagination
- Tag distribution API for monitoring tag usage patterns
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-universal-tags/55-08-SUMMARY.md`
</output>
