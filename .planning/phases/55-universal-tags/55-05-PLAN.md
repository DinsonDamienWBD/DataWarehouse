---
phase: 55-universal-tags
plan: 05
type: execute
wave: 2
depends_on: ["55-01", "55-02"]
files_modified:
  - DataWarehouse.SDK/Tags/InMemoryTagSchemaRegistry.cs
  - DataWarehouse.SDK/Tags/InMemoryTagStore.cs
  - DataWarehouse.SDK/Tags/DefaultTagAttachmentService.cs
autonomous: true

must_haves:
  truths:
    - "In-memory schema registry can register, version, query, and delete schemas"
    - "In-memory tag store provides persistence for tag collections per object"
    - "Default tag attachment service validates against schemas before persisting"
  artifacts:
    - path: "DataWarehouse.SDK/Tags/InMemoryTagSchemaRegistry.cs"
      provides: "ConcurrentDictionary-backed ITagSchemaRegistry"
      min_lines: 60
    - path: "DataWarehouse.SDK/Tags/InMemoryTagStore.cs"
      provides: "ITagStore interface and in-memory implementation"
      min_lines: 80
    - path: "DataWarehouse.SDK/Tags/DefaultTagAttachmentService.cs"
      provides: "ITagAttachmentService that validates, stores, and emits events"
      min_lines: 100
  key_links:
    - from: "DataWarehouse.SDK/Tags/DefaultTagAttachmentService.cs"
      to: "DataWarehouse.SDK/Tags/TagSchemaValidator.cs"
      via: "Validates tags against schema before store"
      pattern: "TagSchemaValidator\\.Validate"
    - from: "DataWarehouse.SDK/Tags/DefaultTagAttachmentService.cs"
      to: "DataWarehouse.SDK/Tags/InMemoryTagStore.cs"
      via: "Persists via ITagStore"
      pattern: "ITagStore"
---

<objective>
Build SDK-level in-memory implementations of the tag schema registry, tag store, and attachment service.

Purpose: Provides working implementations that can be used immediately in tests and single-node deployments. Plugins can later provide distributed/persistent implementations via the same interfaces.
Output: Three implementation files in DataWarehouse.SDK/Tags/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-universal-tags/55-01-SUMMARY.md
@.planning/phases/55-universal-tags/55-02-SUMMARY.md
@DataWarehouse.SDK/Tags/ITagSchemaRegistry.cs
@DataWarehouse.SDK/Tags/ITagAttachmentService.cs
@DataWarehouse.SDK/Tags/TagSchemaValidator.cs
@DataWarehouse.SDK/Tags/TagEvents.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement in-memory tag schema registry</name>
  <files>DataWarehouse.SDK/Tags/InMemoryTagSchemaRegistry.cs</files>
  <action>
Create `DataWarehouse.SDK/Tags/InMemoryTagSchemaRegistry.cs` in namespace `DataWarehouse.SDK.Tags`.

Class `InMemoryTagSchemaRegistry : ITagSchemaRegistry`:
- Backed by `ConcurrentDictionary<string, TagSchema>` keyed on SchemaId
- Secondary index: `ConcurrentDictionary<TagKey, string>` mapping TagKey to SchemaId for `GetByTagKeyAsync`
- `RegisterAsync`: validates SchemaId non-empty, stores schema, updates TagKey index. Throws if SchemaId already exists.
- `GetAsync`: O(1) lookup by SchemaId
- `GetByTagKeyAsync`: O(1) lookup via TagKey index
- `ListAsync`: filters by namespace prefix if provided, yields all matching schemas
- `AddVersionAsync`: appends version to existing schema's Versions list. If rule is `Compatible`, validates new version doesn't change RequiredKind. If `Additive`, validates only new constraints added (no removals/tightening). If `Breaking`, allows anything. If `None`, rejects.
- `DeleteAsync`: removes from both dictionaries
- `CountAsync`: returns count
- Thread-safe via ConcurrentDictionary operations

Mark with `[SdkCompatibility("5.0.0", Notes = "Phase 55: In-memory tag schema registry")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>InMemoryTagSchemaRegistry implements all ITagSchemaRegistry methods, thread-safe, with TagKey secondary index.</done>
</task>

<task type="auto">
  <name>Task 2: Implement tag store and default attachment service</name>
  <files>DataWarehouse.SDK/Tags/InMemoryTagStore.cs, DataWarehouse.SDK/Tags/DefaultTagAttachmentService.cs</files>
  <action>
**InMemoryTagStore.cs** (namespace `DataWarehouse.SDK.Tags`):

Interface `ITagStore`:
```csharp
public interface ITagStore
{
    Task<Tag?> GetTagAsync(string objectKey, TagKey tagKey, CancellationToken ct = default);
    Task<TagCollection> GetAllTagsAsync(string objectKey, CancellationToken ct = default);
    Task SetTagAsync(string objectKey, Tag tag, CancellationToken ct = default);
    Task RemoveTagAsync(string objectKey, TagKey tagKey, CancellationToken ct = default);
    Task SetTagsAsync(string objectKey, IEnumerable<Tag> tags, CancellationToken ct = default);
    Task<IReadOnlyList<string>> FindObjectsByTagAsync(TagKey tagKey, TagValue? value, int limit, CancellationToken ct = default);
}
```

Class `InMemoryTagStore : ITagStore`:
- `ConcurrentDictionary<string, ConcurrentDictionary<TagKey, Tag>>` -- objectKey -> tags
- `FindObjectsByTagAsync`: linear scan (in-memory only, Plan 08 builds inverted index)
- Thread-safe, handles empty collections gracefully

**DefaultTagAttachmentService.cs** (namespace `DataWarehouse.SDK.Tags`):

Class `DefaultTagAttachmentService : ITagAttachmentService`:
- Constructor: `(ITagStore store, ITagSchemaRegistry? schemaRegistry = null, IMessageBus? messageBus = null)`
- `AttachAsync`:
  1. If schemaRegistry provided, look up schema by tagKey. If found, validate value using `TagSchemaValidator.Validate`. Throw `TagValidationException` on failure.
  2. Check ACL: if existing tag exists and caller's source doesn't have Write permission, throw `UnauthorizedAccessException`.
  3. Create `Tag` with version=1, timestamps=now
  4. Store via `ITagStore.SetTagAsync`
  5. If messageBus provided, publish `TagAttachedEvent` to `TagTopics.TagAttached`
  6. Return the created Tag
- `DetachAsync`: similar flow -- check ACL (Delete permission), remove from store, publish `TagDetachedEvent`
- `UpdateAsync`: get existing tag, validate new value, increment version, store, publish `TagUpdatedEvent` with old and new
- `GetAsync`/`GetAllAsync`: delegate to store
- `BulkAttachAsync`: iterate tags, validate all first (fail-fast), then store all, publish `TagsBulkUpdatedEvent`
- `FindObjectsByTagAsync`: delegate to store

Define `TagValidationException : Exception` with `TagValidationResult Result` property.

Mark all with `[SdkCompatibility("5.0.0", Notes = "Phase 55: Tag store and attachment service")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>DefaultTagAttachmentService validates against schema, respects ACL, emits events on message bus, delegates persistence to ITagStore. InMemoryTagStore is thread-safe.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- DefaultTagAttachmentService wires schema validation, ACL checks, event publishing
- InMemoryTagStore is thread-safe via ConcurrentDictionary
</verification>

<success_criteria>
- ITagStore interface defined with CRUD + search
- InMemoryTagSchemaRegistry passes register/get/version/delete workflows
- DefaultTagAttachmentService validates -> stores -> publishes for all operations
- TagValidationException carries structured validation errors
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-universal-tags/55-05-SUMMARY.md`
</output>
