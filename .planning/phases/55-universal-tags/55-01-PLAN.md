---
phase: 55-universal-tags
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Tags/TagTypes.cs
  - DataWarehouse.SDK/Tags/TagValueTypes.cs
  - DataWarehouse.SDK/Tags/TagSource.cs
  - DataWarehouse.SDK/Tags/TagAcl.cs
autonomous: true

must_haves:
  truths:
    - "Tag types define a rich type system with string, color, object, pointer, link, paragraph, number, list, tree values"
    - "Every tag has a source (User, Plugin, AI, System) and per-tag ACL"
    - "Tags are versioned with monotonic version counters"
    - "Tag values are discriminated unions, not untyped object bags"
  artifacts:
    - path: "DataWarehouse.SDK/Tags/TagTypes.cs"
      provides: "Core Tag record, TagKey, TagCollection, TagVersion"
      min_lines: 100
    - path: "DataWarehouse.SDK/Tags/TagValueTypes.cs"
      provides: "TagValue discriminated union with all 10 value types"
      min_lines: 80
    - path: "DataWarehouse.SDK/Tags/TagSource.cs"
      provides: "TagSource enum and TagSourceInfo record"
      min_lines: 30
    - path: "DataWarehouse.SDK/Tags/TagAcl.cs"
      provides: "TagAcl, TagPermission, per-tag access control"
      min_lines: 50
  key_links:
    - from: "DataWarehouse.SDK/Tags/TagTypes.cs"
      to: "DataWarehouse.SDK/Tags/TagValueTypes.cs"
      via: "Tag.Value property typed as TagValue"
      pattern: "TagValue"
    - from: "DataWarehouse.SDK/Tags/TagTypes.cs"
      to: "DataWarehouse.SDK/Tags/TagSource.cs"
      via: "Tag.Source property typed as TagSourceInfo"
      pattern: "TagSourceInfo"
---

<objective>
Define the complete SDK tag type system -- the foundational types that every other plan depends on.

Purpose: All tag infrastructure (schema registry, storage integration, propagation, policy, query) depends on having well-defined, strongly-typed tag primitives in the SDK. This must land first.
Output: Four files in DataWarehouse.SDK/Tags/ defining the complete tag data model.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs (StorageObjectMetadata record at line ~289)
@DataWarehouse.SDK/Primitives/Metadata/MetadataTypes.cs (existing MetadataEntry, MetadataScope)
@DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs (existing CRDT types for reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tag value type system</name>
  <files>DataWarehouse.SDK/Tags/TagValueTypes.cs</files>
  <action>
Create `DataWarehouse.SDK/Tags/TagValueTypes.cs` in namespace `DataWarehouse.SDK.Tags`.

Define an abstract record `TagValue` as a discriminated union (sealed hierarchy) with these concrete types:
- `StringTagValue(string Value)` -- plain text
- `ColorTagValue(byte R, byte G, byte B, byte A = 255)` -- RGBA color, with `ToHex()` method
- `ObjectTagValue(IReadOnlyDictionary<string, TagValue> Properties)` -- nested key-value
- `PointerTagValue(string TargetObjectId, string? TargetTagKey = null)` -- cross-object reference
- `LinkTagValue(Uri Url, string? Label = null)` -- external URL
- `ParagraphTagValue(string Text, string Format = "plain")` -- long-form text with format hint (plain, markdown, html)
- `NumberTagValue(decimal Value, string? Unit = null)` -- numeric with optional unit
- `ListTagValue(IReadOnlyList<TagValue> Items)` -- ordered list of any TagValue
- `TreeTagValue(string Label, IReadOnlyList<TreeTagValue> Children)` -- recursive tree
- `BoolTagValue(bool Value)` -- boolean (useful for flags)

Each concrete type must be `sealed record`. Add a `TagValueKind` enum mirroring all types. Add `abstract TagValueKind Kind { get; }` to `TagValue` base. Add static factory methods on `TagValue`: `TagValue.String("foo")`, `TagValue.Number(42)`, etc.

Mark with `[SdkCompatibility("5.0.0", Notes = "Phase 55: Universal tag value types")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>All 11 TagValue subtypes compile, each has Kind property, static factory methods exist.</done>
</task>

<task type="auto">
  <name>Task 2: Create core tag types, source, and ACL</name>
  <files>DataWarehouse.SDK/Tags/TagTypes.cs, DataWarehouse.SDK/Tags/TagSource.cs, DataWarehouse.SDK/Tags/TagAcl.cs</files>
  <action>
**TagSource.cs** (namespace `DataWarehouse.SDK.Tags`):
- Enum `TagSource { User, Plugin, AI, System }`.
- Record `TagSourceInfo(TagSource Source, string? SourceId = null, string? SourceName = null)` -- SourceId is the plugin ID, user principal, AI model ID, or "system". SourceName is human-readable.

**TagAcl.cs** (namespace `DataWarehouse.SDK.Tags`):
- Flags enum `TagPermission { None = 0, Read = 1, Write = 2, Delete = 4, Admin = 8, All = Read | Write | Delete | Admin }`.
- Record `TagAclEntry(string PrincipalId, TagPermission Permissions)`.
- Record `TagAcl` with:
  - `IReadOnlyList<TagAclEntry> Entries` (explicit ACL entries)
  - `TagPermission DefaultPermission { get; init; } = TagPermission.Read` (fallback for unlisted principals)
  - Method `TagPermission GetEffectivePermission(string principalId)` -- checks entries first, falls back to default
  - Static `TagAcl.ReadOnly` and `TagAcl.FullAccess` constants

**TagTypes.cs** (namespace `DataWarehouse.SDK.Tags`):
- Record `TagKey(string Namespace, string Name)` with `ToString()` returning `"{Namespace}:{Name}"` and `static TagKey Parse(string)`.
- Record `Tag` with properties:
  - `TagKey Key` -- the qualified tag key
  - `TagValue Value` -- the typed value
  - `TagSourceInfo Source` -- who created/last modified
  - `TagAcl Acl` -- per-tag access control
  - `long Version` -- monotonic version counter (starts at 1)
  - `DateTimeOffset CreatedUtc`
  - `DateTimeOffset ModifiedUtc`
  - `string? SchemaId` -- optional link to TagSchemaRegistry schema
- Record `TagCollection` -- wraps `IReadOnlyDictionary<TagKey, Tag>` with:
  - Indexer `Tag? this[TagKey key]`
  - `Tag? Get(string ns, string name)` convenience
  - `IEnumerable<Tag> GetByNamespace(string ns)`
  - `IEnumerable<Tag> GetBySource(TagSource source)`
  - `int Count`
  - `bool ContainsKey(TagKey key)`
  - Builder pattern: `TagCollectionBuilder` with `Add(Tag)`, `Remove(TagKey)`, `Build()` returning `TagCollection`

Mark all with `[SdkCompatibility("5.0.0", Notes = "Phase 55: Universal tag types")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>Tag, TagKey, TagCollection, TagSource, TagSourceInfo, TagAcl, TagAclEntry all compile and reference TagValue types from Task 1.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- All types are in namespace `DataWarehouse.SDK.Tags`
- No references to plugin projects (SDK-only)
</verification>

<success_criteria>
- 4 files created in DataWarehouse.SDK/Tags/
- TagValue discriminated union has 11 concrete types
- Tag record has Key, Value, Source, Acl, Version, timestamps, SchemaId
- TagCollection provides query helpers (by namespace, by source)
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-universal-tags/55-01-SUMMARY.md`
</output>
