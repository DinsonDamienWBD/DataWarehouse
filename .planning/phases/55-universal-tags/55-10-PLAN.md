---
phase: 55-universal-tags
plan: 10
type: execute
wave: 5
depends_on: ["55-03", "55-05"]
files_modified:
  - DataWarehouse.SDK/Tags/CrdtTagCollection.cs
  - DataWarehouse.SDK/Tags/TagMergeStrategy.cs
  - DataWarehouse.SDK/Tags/TagVersionVector.cs
autonomous: true

must_haves:
  truths:
    - "Tag collections support CRDT-based conflict resolution for multi-node concurrent writes"
    - "Merge strategy is configurable per tag: LWW, multi-value, or custom"
    - "Version vectors track causal ordering across nodes"
  artifacts:
    - path: "DataWarehouse.SDK/Tags/CrdtTagCollection.cs"
      provides: "CRDT-backed TagCollection with merge operations"
      min_lines: 100
    - path: "DataWarehouse.SDK/Tags/TagMergeStrategy.cs"
      provides: "Per-tag merge strategies (LWW, multi-value, union)"
      min_lines: 60
    - path: "DataWarehouse.SDK/Tags/TagVersionVector.cs"
      provides: "Version vector for causal ordering of tag updates"
      min_lines: 50
  key_links:
    - from: "DataWarehouse.SDK/Tags/CrdtTagCollection.cs"
      to: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs"
      via: "Uses SdkORSet for tag key tracking, SdkLWWRegister for values"
      pattern: "SdkORSet|SdkLWWRegister"
    - from: "DataWarehouse.SDK/Tags/CrdtTagCollection.cs"
      to: "DataWarehouse.SDK/Tags/TagMergeStrategy.cs"
      via: "Selects merge strategy per tag"
      pattern: "ITagMergeStrategy"
---

<objective>
Build CRDT-based tag versioning for conflict-free multi-node tag writes.

Purpose: In a distributed DataWarehouse cluster, two nodes may concurrently add/modify tags on the same object. CRDT-based tag collections ensure eventual consistency without coordination.
Output: CRDT tag collection, per-tag merge strategies, version vectors.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-universal-tags/55-03-SUMMARY.md
@.planning/phases/55-universal-tags/55-05-SUMMARY.md
@DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs (SdkORSet, SdkLWWRegister with pruning)
@DataWarehouse.SDK/Tags/TagTypes.cs
@DataWarehouse.SDK/Tags/InMemoryTagStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create version vectors and merge strategies</name>
  <files>DataWarehouse.SDK/Tags/TagVersionVector.cs, DataWarehouse.SDK/Tags/TagMergeStrategy.cs</files>
  <action>
**TagVersionVector.cs** (namespace `DataWarehouse.SDK.Tags`):

Record `TagVersionVector`:
- `IReadOnlyDictionary<string, long> NodeVersions` -- nodeId -> monotonic counter
- `long GetVersion(string nodeId)` -- returns 0 if node not present
- `TagVersionVector Increment(string nodeId)` -- returns new vector with nodeId version incremented
- `bool Dominates(TagVersionVector other)` -- true if this >= other for ALL nodes
- `bool Concurrent(TagVersionVector other)` -- true if neither dominates
- `static TagVersionVector Merge(TagVersionVector a, TagVersionVector b)` -- max per node
- `byte[] Serialize()` / `static TagVersionVector Deserialize(byte[] data)`
- Internal JSON serialization via System.Text.Json

**TagMergeStrategy.cs** (namespace `DataWarehouse.SDK.Tags`):

Enum `TagMergeMode { LastWriterWins, MultiValue, Union, Custom }`:
- `LastWriterWins` -- higher timestamp wins (like LWW register)
- `MultiValue` -- keep all concurrent values (for manual resolution)
- `Union` -- for ListTagValue, union the lists; for other types, fall back to LWW
- `Custom` -- use provided merge function

Interface `ITagMergeStrategy`:
```csharp
public interface ITagMergeStrategy
{
    Tag Merge(Tag local, Tag remote, TagVersionVector localVersion, TagVersionVector remoteVersion);
}
```

Implementations:
- `LwwTagMergeStrategy : ITagMergeStrategy` -- compares ModifiedUtc, higher wins, nodeId tiebreaker
- `MultiValueTagMergeStrategy : ITagMergeStrategy` -- wraps both values in a ListTagValue
- `UnionTagMergeStrategy : ITagMergeStrategy` -- for ListTagValue, unions items; otherwise LWW
- `TagMergeStrategyFactory` static class with `ITagMergeStrategy Create(TagMergeMode mode)` and `ITagMergeStrategy Default => LwwTagMergeStrategy`

Mark all with `[SdkCompatibility("5.0.0", Notes = "Phase 55: CRDT tag versioning")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>TagVersionVector supports increment/dominates/concurrent/merge. Three merge strategy implementations compile.</done>
</task>

<task type="auto">
  <name>Task 2: Implement CRDT-backed tag collection</name>
  <files>DataWarehouse.SDK/Tags/CrdtTagCollection.cs</files>
  <action>
Create `DataWarehouse.SDK/Tags/CrdtTagCollection.cs` in namespace `DataWarehouse.SDK.Tags`.

Class `CrdtTagCollection`:
- **Internal state**:
  - `SdkORSet _tagKeys` -- tracks which TagKeys are present (add/remove with OR-Set semantics)
  - `ConcurrentDictionary<TagKey, (Tag Tag, TagVersionVector Version)>` -- current tag values with version vectors
  - `string _nodeId` -- this node's identifier
  - `ConcurrentDictionary<TagKey, TagMergeMode> _mergeOverrides` -- per-tag merge mode overrides

- Constructor: `CrdtTagCollection(string nodeId, TagMergeMode defaultMode = TagMergeMode.LastWriterWins)`

- **Write operations**:
  - `void Set(TagKey key, Tag tag)` -- add key to ORSet, store tag with incremented version vector
  - `void Remove(TagKey key)` -- remove from ORSet (tombstone semantics)
  - `void SetMergeMode(TagKey key, TagMergeMode mode)` -- override merge strategy for this tag

- **Read operations**:
  - `Tag? Get(TagKey key)` -- returns tag if key is in ORSet Elements
  - `TagCollection ToTagCollection()` -- materializes current state as immutable TagCollection
  - `IReadOnlySet<TagKey> Keys` -- from ORSet.Elements mapped to TagKey

- **Merge** (the core CRDT operation):
  - `CrdtTagCollection Merge(CrdtTagCollection other)`:
    1. Merge ORSets: `_tagKeys.Merge(other._tagKeys)` -- handles add/remove conflicts
    2. For each key present in merged ORSet Elements:
       a. If only in local or only in remote: take that value
       b. If in both: check version vectors
          - If local dominates: keep local
          - If remote dominates: keep remote
          - If concurrent: apply merge strategy (LWW default, or per-tag override)
    3. Merge version vectors: `TagVersionVector.Merge(local, remote)`
    4. Return new CrdtTagCollection with merged state

- **Serialization**:
  - `byte[] Serialize()` -- serialize ORSet + tag values + version vectors
  - `static CrdtTagCollection Deserialize(byte[] data, string nodeId)` -- reconstruct

- **Pruning integration**:
  - `OrSetPruneResult Prune(OrSetPruneOptions options, IReadOnlySet<string> activeNodes)` -- delegates to OrSetPruner, also removes orphaned tag values

Mark with `[SdkCompatibility("5.0.0", Notes = "Phase 55: CRDT tag collection")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>CrdtTagCollection merges ORSet for key presence + per-key merge strategies for values. Serialization round-trips. Pruning delegates to OrSetPruner from Plan 03.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- Concurrent adds to different tags: both survive merge
- Concurrent removes: OR-Set semantics (add wins if concurrent with remove)
- Concurrent value updates: resolved by merge strategy
- Pruning reduces tombstone footprint
</verification>

<success_criteria>
- CrdtTagCollection.Merge is commutative, associative, idempotent
- Version vectors correctly detect dominance and concurrency
- Per-tag merge mode override works (e.g., LWW for strings, Union for lists)
- ORSet pruning integrates with tag collection pruning
- Zero build errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-universal-tags/55-10-SUMMARY.md`
</output>
