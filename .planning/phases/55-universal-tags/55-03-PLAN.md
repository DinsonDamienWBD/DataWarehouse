---
phase: 55-universal-tags
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtRegistry.cs
  - DataWarehouse.SDK/Infrastructure/Distributed/Replication/OrSetPruning.cs
autonomous: true

must_haves:
  truths:
    - "ORSet tombstone growth is bounded by periodic garbage collection"
    - "Pruning preserves OR-Set semantics (no phantom re-adds)"
    - "Pruning is safe for concurrent operations via causal stability threshold"
  artifacts:
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/OrSetPruning.cs"
      provides: "ORSetPruner with GC logic, causal stability, metrics"
      min_lines: 80
    - path: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs"
      provides: "SdkORSet with pruning hooks and tag count tracking"
      contains: "Prune"
  key_links:
    - from: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/OrSetPruning.cs"
      to: "DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs"
      via: "Prunes SdkORSet internal state"
      pattern: "SdkORSet"
---

<objective>
Fix P0-12: ORSet unbounded tombstone growth. Add GC/pruning to SdkORSet so it can be used as the CRDT backing for tag collections at 1B object scale.

Purpose: Without pruning, ORSet's remove-set grows unbounded. At 1B objects with tag churn, this would consume unbounded memory. This is a prerequisite for using CRDT-based tag versioning (Plan 10).
Output: ORSet pruning logic, updated SdkORSet with prune method, pruning metrics.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs (SdkORSet class)
@DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtRegistry.cs
@DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtReplicationSync.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ORSet pruning infrastructure</name>
  <files>DataWarehouse.SDK/Infrastructure/Distributed/Replication/OrSetPruning.cs</files>
  <action>
Create `DataWarehouse.SDK/Infrastructure/Distributed/Replication/OrSetPruning.cs` in namespace `DataWarehouse.SDK.Infrastructure.Distributed`.

**OrSetPruneResult** record:
- `int TagsRemoved` -- number of tombstone tags GC'd from remove-set
- `int ElementsCompacted` -- number of elements whose add-set was compacted
- `long BytesBefore` / `long BytesAfter` -- approximate memory savings
- `DateTimeOffset PrunedAt`

**OrSetPruneOptions** record:
- `TimeSpan CausalStabilityThreshold` -- only prune tombstones older than this (default: 5 minutes). A tombstone is "causally stable" when all nodes have observed it.
- `int MaxTombstonesBeforePrune` -- trigger prune when remove-set exceeds this count (default: 10000)
- `bool CompactAddSet` -- also compact add-set tags for elements with only one surviving tag (default: true)

**OrSetPruner** static class:
- `static OrSetPruneResult Prune(SdkORSet orSet, OrSetPruneOptions options, IReadOnlySet<string> knownActiveNodes)`
  - For each element in the remove-set: if ALL tags for that element in the add-set are also in the remove-set (element fully removed), AND the tombstone has been present longer than CausalStabilityThreshold, remove BOTH the add-set and remove-set entries for that element entirely.
  - For elements still present: if CompactAddSet is true and an element has only 1 surviving tag (1 in add-set not in remove-set), replace the add-set with just that 1 tag and clear the remove-set for that element. This is the "compaction" that prevents tag accumulation for stable elements.
  - Return metrics.

To support timestamp tracking on tombstones, add a `_removeTimestamps` dictionary to SdkORSet (see Task 2).

Mark with `[SdkCompatibility("5.0.0", Notes = "Phase 55: P0-12 ORSet pruning")]`.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors.</verify>
  <done>OrSetPruner.Prune compiles, OrSetPruneOptions has causal stability threshold, OrSetPruneResult has metrics.</done>
</task>

<task type="auto">
  <name>Task 2: Extend SdkORSet with pruning hooks and tombstone timestamps</name>
  <files>DataWarehouse.SDK/Infrastructure/Distributed/Replication/SdkCrdtTypes.cs, DataWarehouse.SDK/Infrastructure/Distributed/Replication/CrdtRegistry.cs</files>
  <action>
Modify `SdkORSet` in `SdkCrdtTypes.cs`:

1. Add `internal ConcurrentDictionary<string, DateTimeOffset> _removeTimestamps = new()` -- tracks when each remove-set tag was added. Key format: `"{element}:{tag}"`.

2. In `Remove()` method: when adding tags to `_removeSet`, also record `DateTimeOffset.UtcNow` in `_removeTimestamps` for each tag being tombstoned.

3. In `Merge()` method: merge `_removeTimestamps` using Math.Min (earliest known removal wins -- conservative).

4. Add `internal int TombstoneCount` property: returns total count of all tags across all elements in `_removeSet`.

5. Add `internal void PruneElement(string element)` method: removes the element from both `_addSet` and `_removeSet` and cleans up `_removeTimestamps`.

6. Add `internal void CompactElement(string element, string survivingTag)` method: replaces the add-set for an element with just the surviving tag, clears its remove-set, and cleans up timestamps.

7. Update `Serialize()` and `Deserialize()` to include `_removeTimestamps` in the JSON (add a "removeTimestamps" field to `ORSetData`). Ensure backward compatibility: if the field is missing during deserialization, treat all tombstones as having `DateTimeOffset.MinValue` (always eligible for pruning).

8. In `CrdtRegistry.cs`: no changes needed (SdkORSet type is already registered).

Preserve ALL existing SdkORSet behavior. The pruning methods are additive -- they do not change the semantics of Add/Remove/Merge/Elements.
  </action>
  <verify>Build DataWarehouse.SDK project: `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- 0 errors. Run existing tests: `dotnet test` -- all pass (no regressions).</verify>
  <done>SdkORSet tracks tombstone timestamps, has PruneElement/CompactElement internal methods, serialization is backward-compatible, all existing tests pass.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` passes with 0 errors
- `dotnet test` -- all existing CRDT tests pass (no regressions)
- SdkORSet.TombstoneCount returns correct count
- Serialization round-trip preserves tombstone timestamps
</verification>

<success_criteria>
- ORSet pruning is bounded by CausalStabilityThreshold (no phantom re-adds)
- Compaction reduces per-element tag count from O(writes) to O(1) for stable elements
- Backward-compatible serialization (old ORSet data deserializes without error)
- Zero build errors, zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/55-universal-tags/55-03-SUMMARY.md`
</output>
