---
phase: 42
plan: 05
title: "Gap Closure — Quick Wins (80-99% features)"
depends_on: ["42-01", "42-02", "42-03", "42-04"]
wave: 2
---

# Plan 42-05: Gap Closure — Quick Wins (80-99% features)

## Goal

Take all features scored 80-99% from Plans 42-01 through 42-04 and implement the remaining work to bring them to 100% production-ready status.

## Scope

**Input**: All verification reports from Plans 42-01, 42-02, 42-03, 42-04

**Target**: Features scored 80-99% (core logic done, needs polish)

**Expected count**: ~200-400 features (estimate based on 3,808 total features × ~10% in 80-99% range)

**Typical gaps**:
- Error handling missing (try-catch, validation)
- Edge case handling (null checks, boundary conditions)
- XML documentation missing on public APIs
- Unit tests missing or incomplete
- Logging missing (info, warning, error)
- Resource disposal missing (IDisposable, using statements)
- Configuration validation missing
- Timeout handling missing

## Tasks

### Task 1: Extract Quick Wins from Verification Reports
- Read all domain verification reports (17 files total)
- Extract all features scored 80-99%
- Group by domain for efficient execution
- Prioritize by impact:
  1. Security features (Domain 3)
  2. Data Pipeline features (Domain 1)
  3. Storage features (Domain 2)
  4. Governance features (Domain 15)
  5. All other domains

### Task 2: Implement Domain 1 (Data Pipeline) Quick Wins
- For each 80-99% feature in Domain 1:
  - Read current implementation
  - Identify specific gaps (from verification report)
  - Add missing error handling
  - Add missing validation
  - Add missing XML documentation
  - Add missing unit tests
  - Verify feature is now 100%
- Record completion to `.planning/phases/42-feature-verification-matrix/quick-wins-domain-01-closure.md`

### Task 3: Implement Domain 2 (Storage) Quick Wins
- Same approach for Domain 2 features
- Record completion to `.planning/phases/42-feature-verification-matrix/quick-wins-domain-02-closure.md`

### Task 4: Implement Domain 3 (Security) Quick Wins
- Same approach for Domain 3 features
- Record completion to `.planning/phases/42-feature-verification-matrix/quick-wins-domain-03-closure.md`

### Task 5: Implement Domain 4-17 Quick Wins (Grouped)
- Same approach for remaining domains
- Record completion to `.planning/phases/42-feature-verification-matrix/quick-wins-domains-04-17-closure.md`

### Task 6: Verification Pass
- Re-run verification for all quick win features
- Confirm all are now 100%
- Update Feature Verification Matrix with new scores
- Generate final quick wins report

## Implementation Guidelines

### Error Handling Template

```csharp
/// <summary>
/// [Description]
/// </summary>
/// <exception cref="ArgumentNullException">Thrown when [param] is null.</exception>
/// <exception cref="ArgumentException">Thrown when [param] is invalid.</exception>
/// <exception cref="InvalidOperationException">Thrown when [condition].</exception>
public async Task<Result> MethodAsync(string param, CancellationToken ct)
{
    // Validation
    if (param == null)
        throw new ArgumentNullException(nameof(param));
    if (string.IsNullOrWhiteSpace(param))
        throw new ArgumentException("Parameter cannot be empty.", nameof(param));

    try
    {
        // Core logic (already exists at 80-99%)
        var result = await CoreLogicAsync(param, ct);

        _logger.LogInformation("Operation succeeded for {Param}", param);
        return result;
    }
    catch (OperationCanceledException)
    {
        _logger.LogWarning("Operation cancelled for {Param}", param);
        throw;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Operation failed for {Param}", param);
        throw new InvalidOperationException($"Failed to process {param}", ex);
    }
}
```

### Unit Test Template

```csharp
[Fact]
public async Task MethodAsync_WithValidInput_ReturnsExpectedResult()
{
    // Arrange
    var sut = CreateSystemUnderTest();
    var input = "valid";

    // Act
    var result = await sut.MethodAsync(input, CancellationToken.None);

    // Assert
    Assert.NotNull(result);
    Assert.Equal("expected", result.Value);
}

[Fact]
public async Task MethodAsync_WithNullInput_ThrowsArgumentNullException()
{
    // Arrange
    var sut = CreateSystemUnderTest();

    // Act & Assert
    await Assert.ThrowsAsync<ArgumentNullException>(() =>
        sut.MethodAsync(null, CancellationToken.None));
}

[Fact]
public async Task MethodAsync_WithCancellation_ThrowsOperationCanceledException()
{
    // Arrange
    var sut = CreateSystemUnderTest();
    var cts = new CancellationTokenSource();
    cts.Cancel();

    // Act & Assert
    await Assert.ThrowsAsync<OperationCanceledException>(() =>
        sut.MethodAsync("input", cts.Token));
}
```

### XML Documentation Template

```csharp
/// <summary>
/// [One-line description of what the method does].
/// </summary>
/// <param name="param1">[Description of param1].</param>
/// <param name="param2">[Description of param2].</param>
/// <param name="ct">Cancellation token to cancel the operation.</param>
/// <returns>
/// A task representing the asynchronous operation. The task result contains [description].
/// </returns>
/// <exception cref="ArgumentNullException">Thrown when [param] is null.</exception>
/// <exception cref="InvalidOperationException">Thrown when [condition].</exception>
/// <remarks>
/// [Additional details about behavior, dependencies, or usage].
/// </remarks>
public async Task<Result> MethodAsync(string param1, int param2, CancellationToken ct)
{
    // Implementation
}
```

## Success Criteria

- [ ] All 80-99% features identified and extracted from verification reports
- [ ] All Domain 1 quick wins brought to 100%
- [ ] All Domain 2 quick wins brought to 100%
- [ ] All Domain 3 quick wins brought to 100%
- [ ] All other domains' quick wins brought to 100%
- [ ] Verification pass confirms all quick wins are now 100%
- [ ] Feature Verification Matrix updated with new scores
- [ ] Final quick wins closure report generated

## Output

**Closure Reports** (4 files):
- `.planning/phases/42-feature-verification-matrix/quick-wins-domain-01-closure.md`
- `.planning/phases/42-feature-verification-matrix/quick-wins-domain-02-closure.md`
- `.planning/phases/42-feature-verification-matrix/quick-wins-domain-03-closure.md`
- `.planning/phases/42-feature-verification-matrix/quick-wins-domains-04-17-closure.md`

**Final Report**:
- `.planning/phases/42-feature-verification-matrix/quick-wins-final-report.md`

**Format** (per closure report):
```markdown
# Quick Wins Closure Report: Domain N

## Summary
- Total Quick Wins: NNN
- Features Completed: NNN
- Features Remaining: NNN

## Completed Features

### Plugin: [Plugin Name]

- [x] 100% Feature Name — (Was: 85%, Now: 100%)
  - **Location**: `Plugins/X/Strategies/FeatureStrategy.cs`
  - **Changes Made**:
    - Added error handling (try-catch, validation)
    - Added XML documentation
    - Added unit tests (3 test methods)
    - Added logging (info, error)
  - **Verification**: All tests pass, no gaps remaining

[... for each completed feature ...]
```

## Dependencies

- **42-01**: Domain 1-4 verification (must complete first)
- **42-02**: Domain 5-8 verification (must complete first)
- **42-03**: Domain 9-13 verification (must complete first)
- **42-04**: Domain 14-17 verification (must complete first)

## Notes

- This is implementation work (unlike Plans 01-04 which are verification only)
- Focus on polish, not core logic (core logic already exists at 80-99%)
- Be efficient: add missing pieces, don't refactor unnecessarily
- Run tests after each feature to verify 100% status
- Update verification reports as features reach 100%
- Quick wins should be fast (1-2 hours per feature max)
