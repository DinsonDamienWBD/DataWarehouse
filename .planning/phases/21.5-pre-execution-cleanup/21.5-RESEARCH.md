# Phase 21.5: Pre-Execution Cleanup - Research

**Researched:** 2026-02-13
**Domain:** C# codebase cleanup -- type consolidation, serializer migration, solution completeness
**Confidence:** HIGH

## Summary

This research systematically investigated every file that Phase 21.5 will touch. The codebase has exactly the duplicate type problem described in the roadmap: `OperatingMode`, `ConnectionType`, `ConnectionTarget`, `InstallConfiguration`, and `EmbeddedConfiguration` exist in 3-4 locations with subtle differences. The Newtonsoft.Json usage is concentrated in 5 files in DataWarehouse.Shared plus the UniversalDashboards plugin. Two plugin projects (AirGapBridge, DataMarketplace) exist on disk but are missing from DataWarehouse.slnx.

**Critical discovery:** The CLI project **excludes** all files under `Commands/` via `<Compile Remove="Commands\**" />` and instead **links** `Metadata/Adapter/*.cs` as its Integration types. This means ConnectCommand.cs, InstallCommand.cs, EmbeddedCommand.cs, and StorageCommands.cs are NOT compiled -- they are dead code. The CLI commands that reference `DataWarehouse.Integration` resolve to the Metadata/Adapter linked files, not to the CLI's own Integration folder. The CLI's `Integration/` folder (OperatingMode.cs, IKernelAdapter.cs, AdapterFactory.cs, AdapterRunner.cs) is also dead code -- never compiled, never imported.

**Primary recommendation:** Use Launcher's versions as the canonical source (most complete: has `Service` mode, `Cluster` connection, TLS, auth token, timeouts, factory methods). Create SDK Hosting types as the single source of truth, then update imports everywhere.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| System.Text.Json | (built-in .NET 10) | JSON serialization | Built-in, no extra dependency, AOT-friendly |
| Newtonsoft.Json | 13.0.4 | Legacy JSON (to be removed) | Being removed in this phase |

### Supporting
No new libraries needed. This phase is purely mechanical cleanup.

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| System.Text.Json | Keep Newtonsoft.Json | Would increase dependency surface, conflicts with SUPPLY-04 (<=6 direct PackageReferences) |

**Installation:**
No new packages needed. Newtonsoft.Json PackageReference will be **removed** from DataWarehouse.Shared.csproj.

## Architecture Patterns

### Recommended Project Structure for SDK Hosting
```
DataWarehouse.SDK/
├── Hosting/
│   ├── OperatingMode.cs          # enum: Install, Connect, Embedded, Service
│   ├── ConnectionType.cs          # enum: Local, Remote, Cluster
│   ├── ConnectionTarget.cs        # class with factory methods
│   ├── InstallConfiguration.cs    # class for install mode config
│   └── EmbeddedConfiguration.cs   # class for embedded mode config
```

Namespace: `DataWarehouse.SDK.Hosting`

This follows the existing SDK pattern where domain-specific types live in subdirectories (e.g., `SDK/Security/`, `SDK/Governance/`, `SDK/Primitives/`).

### Pattern: Type Consolidation
**What:** Move shared types to a single canonical location in SDK, update all consumers to reference SDK types.
**When to use:** When the same type is defined in 3+ locations with subtle differences.
**Example:**
```csharp
// SDK canonical type (superset of all variants)
namespace DataWarehouse.SDK.Hosting;

public enum OperatingMode
{
    Install,    // All locations have this
    Connect,    // All locations have this
    Embedded,   // All locations have this
    Service     // Only Launcher has this -- SUPERSET
}
```

### Anti-Patterns to Avoid
- **Changing Shared's ConnectionTarget properties mid-flight:** The Shared version uses `Address`/`Port` while Launcher uses `Host`/`Port`/`LocalPath`/`AuthToken`/`UseTls`/`TimeoutSeconds`. The SDK type must use the Launcher's richer property set, and Shared's code must be adapted to use those properties.
- **Forgetting the two OperatingMode enums:** `SDK.Primitives.OperatingMode` (Laptop/Workstation/Server/Hyperscale) is for kernel scaling. `SDK.Hosting.OperatingMode` (Install/Connect/Embedded/Service) is for host application modes. These are DIFFERENT concepts -- both must coexist.

## Detailed Type Analysis

### 1. OperatingMode Enum (Hosting variant)

| Location | Namespace | Values | Notes |
|----------|-----------|--------|-------|
| Launcher/Integration/OperatingMode.cs | `DataWarehouse.Launcher.Integration` | Install, Connect, Embedded, **Service** | **CANONICAL** -- has Service mode |
| CLI/Integration/OperatingMode.cs | `DataWarehouse.CLI.Integration` | Install, Connect, Embedded | Dead code (excluded by csproj) |
| Metadata/Adapter/OperatingMode.cs | `DataWarehouse.Integration` | Install, Connect, Embedded | Linked into CLI; missing Service |
| SDK/Primitives/Enums.cs | `DataWarehouse.SDK.Primitives` | Laptop, Workstation, Server, Hyperscale | **DIFFERENT CONCEPT** -- kernel scaling mode |

**Action:** Create `DataWarehouse.SDK.Hosting.OperatingMode` with values: Install, Connect, Embedded, Service (Launcher superset).

### 2. ConnectionType Enum

| Location | Namespace | Values | Notes |
|----------|-----------|--------|-------|
| Launcher/Integration/OperatingMode.cs | `DataWarehouse.Launcher.Integration` | Local, Remote, **Cluster** | **CANONICAL** -- has Cluster |
| CLI/Integration/OperatingMode.cs | `DataWarehouse.CLI.Integration` | Local, Remote, Cluster | Dead code |
| Metadata/Adapter/OperatingMode.cs | `DataWarehouse.Integration` | Local, Remote, Cluster | Linked into CLI |
| Shared/InstanceManager.cs | `DataWarehouse.Shared` | Local, Remote, **InProcess** | Different! Has InProcess, no Cluster |

**Action:** Create `DataWarehouse.SDK.Hosting.ConnectionType` as superset: Local, Remote, InProcess, Cluster.

### 3. ConnectionTarget Class

| Location | Namespace | Properties | Factory Methods |
|----------|-----------|------------|-----------------|
| Launcher/Integration/OperatingMode.cs | `DataWarehouse.Launcher.Integration` | Type, Host, Port, LocalPath, AuthToken, UseTls, TimeoutSeconds | Local(), Remote() |
| CLI/Integration/OperatingMode.cs | `DataWarehouse.CLI.Integration` | Type, Host, Port, LocalPath, AuthToken, UseTls, TimeoutSeconds | Local(), Remote() |
| Metadata/Adapter/OperatingMode.cs | `DataWarehouse.Integration` | Type, Host, Port, LocalPath, AuthToken, UseTls, TimeoutSeconds | Local(), Remote() |
| Shared/InstanceManager.cs | `DataWarehouse.Shared` | **Name**, Type, **Address**, Port, **Metadata** | None |

**Key differences in Shared's version:**
- Uses `Name` (string) -- not in Launcher version
- Uses `Address` (string) instead of `Host`
- Uses `Metadata` (Dictionary<string,string>) -- not in Launcher version
- Missing: LocalPath, AuthToken, UseTls, TimeoutSeconds, factory methods

**Action:** Create SDK version with superset: Name, Type, Host, Port, LocalPath, AuthToken, UseTls, TimeoutSeconds, Metadata + factory methods. Adapt Shared's code to use `Host` instead of `Address` (or add `Address` as alias).

### 4. InstallConfiguration Class

| Location | Namespace | Properties |
|----------|-----------|------------|
| Launcher/Integration/OperatingMode.cs | `DataWarehouse.Launcher.Integration` | InstallPath, DataPath, IncludedPlugins, CreateService, AutoStart, InitialConfig, CreateDefaultAdmin, AdminUsername, AdminPassword |
| CLI/Integration/OperatingMode.cs | `DataWarehouse.CLI.Integration` | Identical to Launcher |
| Metadata/Adapter/OperatingMode.cs | `DataWarehouse.Integration` | Identical to Launcher |

All three are identical. Straightforward consolidation.

### 5. EmbeddedConfiguration Class

| Location | Namespace | Properties |
|----------|-----------|------------|
| Launcher/Integration/OperatingMode.cs | `DataWarehouse.Launcher.Integration` | PersistData, DataPath, MaxMemoryMb, ExposeHttp, HttpPort, Plugins |
| CLI/Integration/OperatingMode.cs | `DataWarehouse.CLI.Integration` | Identical to Launcher |
| Metadata/Adapter/OperatingMode.cs | `DataWarehouse.Integration` | Identical to Launcher |

All three are identical. Straightforward consolidation.

## Namespace Import Analysis

### CLI Commands -- What They Import

| File | Import Statement | Resolves To | Status |
|------|-----------------|-------------|--------|
| ConnectCommand.cs | `using DataWarehouse.Integration;` | Metadata/Adapter (linked) | **EXCLUDED from build** (`<Compile Remove="Commands\**" />`) |
| InstallCommand.cs | `using DataWarehouse.Integration;` | Metadata/Adapter (linked) | **EXCLUDED from build** |
| EmbeddedCommand.cs | `using DataWarehouse.Integration;` | Metadata/Adapter (linked) | **EXCLUDED from build** |
| StorageCommands.cs | `using DataWarehouse.Kernel;` + `using DataWarehouse.SDK.Primitives;` | Kernel + SDK | **EXCLUDED from build** |

**Critical finding:** The CLI.csproj has `<Compile Remove="Commands\**" />` which excludes ALL files under `Commands/`. The CLI's actual command handling is in DataWarehouse.Shared (it is a thin wrapper). The Commands/ folder files are dead code that was superseded when business logic moved to Shared.

### Launcher -- What Uses Integration Types

| File | Import | Uses |
|------|--------|------|
| Program.cs | `using DataWarehouse.Launcher.Integration;` | AdapterFactory, ServiceHost, ServiceOptions |
| DataWarehouseAdapter.cs | `using DataWarehouse.Launcher.Integration;` | IKernelAdapter, AdapterOptions, KernelState, SDK.Primitives.OperatingMode |
| DataWarehouseHost.cs | (same file/namespace) | OperatingMode, ConnectionTarget, ConnectionType, InstallConfiguration, EmbeddedConfiguration |
| InstanceConnection.cs | (same file/namespace) | ConnectionTarget, ConnectionType |
| ServiceHost.cs | (same file/namespace) | AdapterOptions, AdapterRunner |
| EmbeddedAdapter.cs | (same file/namespace) | IKernelAdapter, AdapterOptions, KernelState |

### Shared -- What Uses Types

| File | Uses |
|------|------|
| InstanceManager.cs | ConnectionTarget (Shared version), ConnectionType (Shared version), ConnectionProfile |
| MessageBridge.cs | ConnectionTarget (Shared version), ConnectionType (Shared version) |
| CapabilityManager.cs | InstanceCapabilities (Shared.Models version) |

### GUI -- What Uses Types

| File | Uses |
|------|------|
| Connections.razor | InstanceManager (Shared), local ConnectionProfile class (defined in @code block) |

The GUI's Connections.razor uses `InstanceManager.ConnectRemoteAsync()` and `InstanceManager.ConnectLocalAsync()` which use Shared's ConnectionTarget internally. It does NOT directly import any Integration types.

## Newtonsoft.Json Usage in Shared

### Files Using Newtonsoft.Json (5 source files + 1 csproj + 1 doc)

| File | Usages | Specific Calls |
|------|--------|----------------|
| **InstanceManager.cs** | 4 calls | `JsonConvert.SerializeObject` (2x), `JsonConvert.DeserializeObject` (2x) |
| **MessageBridge.cs** | 2 calls | `JsonConvert.SerializeObject` (1x), `JsonConvert.DeserializeObject` (1x) |
| **CapabilityManager.cs** | 2 calls | `JsonConvert.SerializeObject` (1x), `JsonConvert.DeserializeObject` (1x) |
| **Services/ComplianceReportService.cs** | 30 calls | `JsonConvert.SerializeObject` (15x), `JsonConvert.DeserializeObject` (15x) |
| **Services/DeveloperToolsService.cs** | 18 calls | `JsonConvert.SerializeObject` (9x), `JsonConvert.DeserializeObject` (9x) |
| **DataWarehouse.Shared.csproj** | 1 ref | `<PackageReference Include="Newtonsoft.Json" Version="13.0.4" />` |
| IMPLEMENTATION_SUMMARY.md | 1 mention | Documentation reference |

**Total: 56 Newtonsoft.Json calls across 5 source files.**

### Migration Pattern

All usages follow the same pattern:
```csharp
// Current (Newtonsoft)
var json = JsonConvert.SerializeObject(obj);
var result = JsonConvert.DeserializeObject<T>(json);

// Target (System.Text.Json)
var json = System.Text.Json.JsonSerializer.Serialize(obj);
var result = System.Text.Json.JsonSerializer.Deserialize<T>(json);
```

Special cases:
- `Formatting.Indented` -> `new JsonSerializerOptions { WriteIndented = true }`
- Some usages serialize an `object` from a dictionary then deserialize to a typed object -- this is a round-trip pattern that works the same with System.Text.Json but may need `JsonSerializerOptions { PropertyNameCaseInsensitive = true }` for deserialization.

### UniversalDashboards Plugin -- Also Uses Newtonsoft.Json

| File | Usages |
|------|--------|
| DashboardStrategyBase.cs | `JsonConvert.SerializeObject` (1x), `JsonConvert.DeserializeObject<T>` (1x) |
| Strategies/Export/ExportStrategies.cs | `JsonConvert.SerializeObject` (1x) |
| DataWarehouse.Plugins.UniversalDashboards.csproj | `<PackageReference Include="Newtonsoft.Json" Version="13.0.4" />` |

**Total: 3 Newtonsoft.Json calls in UniversalDashboards plugin.** This plugin has its own PackageReference so it is independent of Shared's migration, but should also be migrated per PRECLEAN-05.

## Solution File Completeness

### Current State: DataWarehouse.slnx

Projects in solution: **67 projects** (counted from slnx file)

### Missing from Solution (found on disk but NOT in slnx)

| Project | Path | Status |
|---------|------|--------|
| **DataWarehouse.Plugins.AirGapBridge** | `Plugins/DataWarehouse.Plugins.AirGapBridge/DataWarehouse.Plugins.AirGapBridge.csproj` | EXISTS on disk, NOT in slnx |
| **DataWarehouse.Plugins.DataMarketplace** | `Plugins/DataWarehouse.Plugins.DataMarketplace/DataWarehouse.Plugins.DataMarketplace.csproj` | EXISTS on disk, NOT in slnx |

Total .csproj on disk: **69** (confirmed via find command)
Total in slnx: **67**
Difference: **2** (AirGapBridge + DataMarketplace)

### slnx Addition Format
```xml
<!-- Add to /Plugins/ folder in DataWarehouse.slnx -->
<Project Path="Plugins/DataWarehouse.Plugins.AirGapBridge/DataWarehouse.Plugins.AirGapBridge.csproj" />
<Project Path="Plugins/DataWarehouse.Plugins.DataMarketplace/DataWarehouse.Plugins.DataMarketplace.csproj" />
```

## SDK Hosting Namespace

### Current State
The directory `DataWarehouse.SDK/Hosting/` does **NOT exist** yet. It must be created.

### Existing SDK Directory Structure (for pattern reference)
```
DataWarehouse.SDK/
├── AI/
├── Attributes/
├── Compliance/
├── Configuration/
├── Connectors/
├── Contracts/
├── Database/
├── Distribution/
├── Extensions/
├── Governance/
├── Hardware/
├── Infrastructure/
├── IO/
├── Licensing/
├── Mathematics/
├── Performance/
├── Primitives/           # Has OperatingMode (Laptop/Workstation/Server/Hyperscale)
├── Replication/
├── Scale/
├── Security/
├── Services/
├── Storage/
├── Sustainability/
├── Utilities/
├── Validation/
└── Virtualization/
```

Pattern: Each directory corresponds to a namespace under `DataWarehouse.SDK.*` with one or more `.cs` files.

### IMPORTANT: Two Different OperatingMode Enums

| Enum | Namespace | Values | Purpose |
|------|-----------|--------|---------|
| `SDK.Primitives.OperatingMode` | `DataWarehouse.SDK.Primitives` | Laptop, Workstation, Server, Hyperscale | Kernel scaling mode (how many resources to use) |
| `SDK.Hosting.OperatingMode` (new) | `DataWarehouse.SDK.Hosting` | Install, Connect, Embedded, Service | Host application mode (what the app does) |

These are semantically different. The `DataWarehouseAdapter.cs` in Launcher already references `SDK.Primitives.OperatingMode` with full qualification (`SDK.Primitives.OperatingMode.Laptop` etc.), so adding `SDK.Hosting.OperatingMode` will not create ambiguity as long as consumers use the correct namespace import.

## Dead Code Verification

### CLI/Integration/ -- ALL DEAD CODE (confirmed)

| File | Status | Evidence |
|------|--------|---------|
| `CLI/Integration/OperatingMode.cs` | **DEAD** | CLI.csproj has `<Compile Remove="Commands\**" />` AND zero `using DataWarehouse.CLI.Integration` in any file |
| `CLI/Integration/IKernelAdapter.cs` | **DEAD** | Same -- excluded from compilation, zero imports |
| `CLI/Integration/AdapterFactory.cs` | **DEAD** | Same -- excluded from compilation, zero imports |
| `CLI/Integration/AdapterRunner.cs` | **DEAD** | Same -- excluded from compilation, zero imports |

**Wait:** The `<Compile Remove="Commands\**" />` only excludes `Commands/` subdirectory. The `Integration/` directory is NOT excluded by this rule. Let me reconsider.

**Correction:** The `<Compile Remove="Commands\**" />` pattern removes `Commands/` files, not `Integration/` files. The CLI/Integration files ARE compiled. However, the CLI also has `<Compile Include="..\Metadata\Adapter\*.cs" Link="Integration\%(Filename)%(Extension)" />` which links Metadata/Adapter files into the `Integration/` virtual folder.

This means CLI has BOTH:
1. Its own `CLI/Integration/*.cs` files (compiled, namespace `DataWarehouse.CLI.Integration`)
2. Linked `Metadata/Adapter/*.cs` files (compiled, namespace `DataWarehouse.Integration`)

The CLI Command files (`ConnectCommand.cs` etc.) ARE excluded from compilation via `<Compile Remove="Commands\**" />` and ARE dead code. But the CLI/Integration files themselves compile and could theoretically be used by non-Command code.

**Grep confirms:** Zero files in CLI import `DataWarehouse.CLI.Integration` (grep returned no matches). So CLI/Integration files compile but are never used by any code that is itself compiled. They are dead code.

### CLI/Commands/ -- ALL DEAD CODE (confirmed)

| File | Status | Evidence |
|------|--------|---------|
| `CLI/Commands/ConnectCommand.cs` | **DEAD** | Excluded by `<Compile Remove="Commands\**" />` |
| `CLI/Commands/InstallCommand.cs` | **DEAD** | Same |
| `CLI/Commands/EmbeddedCommand.cs` | **DEAD** | Same |
| `CLI/Commands/StorageCommands.cs` | **DEAD** | Same |

### Launcher/Integration/OperatingMode.cs -- ACTIVE (used)

Used by DataWarehouseHost.cs (same namespace, no import needed). Will be **replaced** by SDK version and deleted.

### Launcher/Integration/ Other Files -- ACTIVE (used)

All Launcher/Integration files are actively used by Launcher's own code (DataWarehouseHost, ServiceHost, EmbeddedAdapter, etc.).

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JSON serialization | Custom serializer | System.Text.Json (built-in) | Handles edge cases, maintained by Microsoft, AOT-compatible |
| Type aliasing | Wrapper classes | Direct `using` alias or namespace import | Simpler, no maintenance overhead |

## Common Pitfalls

### Pitfall 1: Shared's ConnectionTarget Has Different Properties
**What goes wrong:** Shared uses `Address` and `Name` instead of `Host`/`LocalPath`. Blindly replacing the type will break `ConnectRemoteAsync`, `ConnectLocalAsync`, `ConnectInProcessAsync`, and `MessageBridge.ConnectAsync`.
**Why it happens:** Shared's ConnectionTarget was designed independently from Launcher's.
**How to avoid:** SDK's ConnectionTarget must include `Name` property. Map `Address` to `Host` in the adapted code. Update `ConnectRemoteAsync` to use `Host` instead of `Address`.
**Warning signs:** Compile errors in InstanceManager.cs and MessageBridge.cs after type swap.

### Pitfall 2: Two OperatingMode Enums in SDK
**What goes wrong:** Adding `SDK.Hosting.OperatingMode` creates ambiguity with `SDK.Primitives.OperatingMode` if both namespaces are imported.
**Why it happens:** Two different concepts share the same type name.
**How to avoid:** Consumers must use explicit namespace qualification or only import one. The DataWarehouseAdapter.cs already uses `SDK.Primitives.OperatingMode` with full qualification -- this pattern should continue.
**Warning signs:** CS0104 "ambiguous reference" compiler errors.

### Pitfall 3: Newtonsoft.Json Round-Trip Serialization Pattern
**What goes wrong:** Shared uses a pattern of `JsonConvert.SerializeObject(dictValue)` then `JsonConvert.DeserializeObject<T>(json)` to extract typed objects from `Dictionary<string, object>`. System.Text.Json handles `object` differently -- it deserializes `object` values as `JsonElement`, not as primitive types.
**Why it happens:** System.Text.Json's `object` deserialization returns `JsonElement` by default, not the underlying type.
**How to avoid:** Use `JsonSerializer.Serialize(dictValue)` followed by `JsonSerializer.Deserialize<T>(json)`. This works because the intermediate JSON string is the same. For the `Dictionary<string, object>` response patterns, the serialization step handles `JsonElement` objects correctly.
**Warning signs:** `InvalidCastException` or unexpected `JsonElement` types at runtime.

### Pitfall 4: ConnectionType.InProcess vs ConnectionType.Cluster
**What goes wrong:** The SDK superset includes both `InProcess` (from Shared) and `Cluster` (from Launcher). MessageBridge.ConnectAsync uses `InProcess` in a switch statement. This must be preserved.
**Why it happens:** Different code paths handle different connection types.
**How to avoid:** The consolidated enum MUST include both values. Verify all switch statements handle the full set.
**Warning signs:** Unhandled enum values in switch expressions.

### Pitfall 5: CLI Metadata/Adapter Linked Files
**What goes wrong:** The CLI links Metadata/Adapter/*.cs files as its Integration types. After consolidation, these files must be updated to use SDK types OR the link must change to reference SDK directly.
**Why it happens:** The Metadata/Adapter files use namespace `DataWarehouse.Integration` which is what existing (dead) Command files import.
**How to avoid:** After moving types to SDK, update Metadata/Adapter files to reference SDK types. The linked compile inclusion means CLI will automatically get the updated code.
**Warning signs:** Compile errors in CLI if Metadata/Adapter files reference types that no longer exist.

## Code Examples

### SDK Type Creation Pattern
```csharp
// DataWarehouse.SDK/Hosting/OperatingMode.cs
namespace DataWarehouse.SDK.Hosting;

/// <summary>
/// Operating modes for DataWarehouse host applications.
/// </summary>
public enum OperatingMode
{
    Install,
    Connect,
    Embedded,
    Service
}
```

### System.Text.Json Migration Pattern
```csharp
// Before (Newtonsoft.Json)
using Newtonsoft.Json;
var json = JsonConvert.SerializeObject(obj);
var result = JsonConvert.DeserializeObject<T>(json);
var prettyJson = JsonConvert.SerializeObject(obj, Formatting.Indented);

// After (System.Text.Json)
using System.Text.Json;
var json = JsonSerializer.Serialize(obj);
var result = JsonSerializer.Deserialize<T>(json);
var prettyJson = JsonSerializer.Serialize(obj, new JsonSerializerOptions { WriteIndented = true });
```

### Shared ConnectionTarget Adaptation
```csharp
// Before (Shared's ConnectionTarget)
new ConnectionTarget
{
    Name = $"Remote ({host}:{port})",
    Type = ConnectionType.Remote,
    Address = host,
    Port = port
};

// After (SDK's ConnectionTarget)
new ConnectionTarget
{
    Name = $"Remote ({host}:{port})",
    Type = ConnectionType.Remote,
    Host = host,
    Port = port
};
```

## Verified Impact Map (Refined from ROADMAP)

### Plan 21.5-01: Type Consolidation

**CREATE (5 files):**
```
DataWarehouse.SDK/Hosting/OperatingMode.cs          -- Install/Connect/Embedded/Service
DataWarehouse.SDK/Hosting/ConnectionType.cs          -- Local/Remote/InProcess/Cluster
DataWarehouse.SDK/Hosting/ConnectionTarget.cs        -- Merged superset (Host/Port/LocalPath/AuthToken/UseTls/TimeoutSeconds/Name/Metadata + factory methods)
DataWarehouse.SDK/Hosting/InstallConfiguration.cs    -- Identical across sources
DataWarehouse.SDK/Hosting/EmbeddedConfiguration.cs   -- Identical across sources
```

**UPDATE (import namespace to DataWarehouse.SDK.Hosting):**
```
DataWarehouse.Launcher/Integration/DataWarehouseHost.cs    -- uses all hosting types
DataWarehouse.Launcher/Integration/InstanceConnection.cs   -- uses ConnectionTarget, ConnectionType
DataWarehouse.Shared/InstanceManager.cs                    -- MAJOR CHANGE: replace inline types, adapt property names
DataWarehouse.Shared/MessageBridge.cs                      -- uses ConnectionType (switch statements)
Metadata/Adapter/OperatingMode.cs                          -- update to re-export SDK types or add using
Metadata/Adapter/DataWarehouseHost.cs                      -- update imports
Metadata/Adapter/InstanceConnection.cs                     -- update imports
```

**DELETE (dead code):**
```
DataWarehouse.CLI/Integration/OperatingMode.cs       -- dead: compiles but zero imports
DataWarehouse.CLI/Integration/IKernelAdapter.cs      -- dead: compiles but zero imports
DataWarehouse.CLI/Integration/AdapterFactory.cs      -- dead: compiles but zero imports
DataWarehouse.CLI/Integration/AdapterRunner.cs       -- dead: compiles but zero imports
DataWarehouse.Launcher/Integration/OperatingMode.cs  -- replaced by SDK version (types move to SDK)
```

**KEEP (Launcher Integration types that stay in Launcher):**
```
DataWarehouse.Launcher/Integration/IKernelAdapter.cs      -- used by Launcher, not a shared type
DataWarehouse.Launcher/Integration/AdapterFactory.cs       -- used by Launcher
DataWarehouse.Launcher/Integration/AdapterRunner.cs        -- used by Launcher
DataWarehouse.Launcher/Integration/EmbeddedAdapter.cs      -- used by Launcher
DataWarehouse.Launcher/Integration/ServiceHost.cs          -- used by Launcher
DataWarehouse.Launcher/Integration/InstanceConnection.cs   -- IInstanceConnection + implementations stay in Launcher
DataWarehouse.Launcher/Integration/DataWarehouseHost.cs    -- stays in Launcher, just update imports
```

**SPECIAL (Shared/InstanceManager.cs):**
- Remove inline `ConnectionType` enum (Local/Remote/InProcess) -- use SDK's
- Remove inline `ConnectionTarget` class -- use SDK's
- Keep `ConnectionProfile` class (unique to Shared, not duplicated)
- Adapt `ConnectRemoteAsync`: `Address = host` becomes `Host = host`
- Adapt `ConnectLocalAsync`: `Address = path` becomes `Host = path` or `LocalPath = path`
- Adapt `ConnectInProcessAsync`: `Address = "localhost"` becomes `Host = "localhost"`

### Plan 21.5-02: Newtonsoft.Json Migration

**Files to migrate (5 Shared + 1 plugin = 6 total):**
```
DataWarehouse.Shared/InstanceManager.cs              -- 4 calls
DataWarehouse.Shared/MessageBridge.cs                -- 2 calls
DataWarehouse.Shared/CapabilityManager.cs            -- 2 calls
DataWarehouse.Shared/Services/ComplianceReportService.cs -- 30 calls
DataWarehouse.Shared/Services/DeveloperToolsService.cs   -- 18 calls
Plugins/DataWarehouse.Plugins.UniversalDashboards/DashboardStrategyBase.cs -- 2 calls
Plugins/DataWarehouse.Plugins.UniversalDashboards/Strategies/Export/ExportStrategies.cs -- 1 call
```

**PackageReference to remove (2):**
```
DataWarehouse.Shared/DataWarehouse.Shared.csproj: <PackageReference Include="Newtonsoft.Json" Version="13.0.4" />
Plugins/DataWarehouse.Plugins.UniversalDashboards/DataWarehouse.Plugins.UniversalDashboards.csproj: <PackageReference Include="Newtonsoft.Json" Version="13.0.4" />
```

### Plan 21.5-03: Solution Completeness

**Add to DataWarehouse.slnx (2 lines):**
```xml
<Project Path="Plugins/DataWarehouse.Plugins.AirGapBridge/DataWarehouse.Plugins.AirGapBridge.csproj" />
<Project Path="Plugins/DataWarehouse.Plugins.DataMarketplace/DataWarehouse.Plugins.DataMarketplace.csproj" />
```

## Open Questions

1. **Metadata/Adapter update strategy**
   - What we know: Metadata/Adapter files are linked into CLI via `<Compile Include>`. They use namespace `DataWarehouse.Integration`.
   - What's unclear: Should the files be updated to import and re-export SDK types (keeping `DataWarehouse.Integration` namespace for backward compatibility), or should the namespace change to `DataWarehouse.SDK.Hosting`?
   - Recommendation: Update Metadata/Adapter files to use `DataWarehouse.SDK.Hosting` types directly. The CLI's linked compile will pick up the changes. Since the CLI Commands are dead code (excluded from build), no consumer of `DataWarehouse.Integration` namespace actually compiles. Change the namespace.

2. **Shared's ConnectionTarget.Name property**
   - What we know: Shared uses `Name` on ConnectionTarget for display purposes. Launcher does not have `Name`.
   - What's unclear: Is `Name` needed going forward?
   - Recommendation: Include `Name` in the SDK type. It is a useful display property that costs nothing.

3. **Shared's ConnectionTarget.Metadata property**
   - What we know: Shared has `Dictionary<string, string> Metadata` on ConnectionTarget. No code writes to it.
   - What's unclear: Is it used by anything?
   - Recommendation: Include it in the SDK type for forward compatibility. It is a flexible extension point.

## Sources

### Primary (HIGH confidence)
- Direct file reads of all source files listed above (verified 2026-02-13)
- `DataWarehouse.CLI/DataWarehouse.CLI.csproj` -- confirmed `<Compile Remove="Commands\**" />` and linked Metadata/Adapter files
- `DataWarehouse.slnx` -- counted 67 projects, confirmed 2 missing
- `find` command -- confirmed 69 .csproj files on disk
- `grep` results -- confirmed all Newtonsoft.Json usage locations

### Secondary (MEDIUM confidence)
- None needed -- all findings are from direct codebase investigation

### Tertiary (LOW confidence)
- None

## Metadata

**Confidence breakdown:**
- Type definitions: **HIGH** -- every file read and analyzed, all properties documented
- Dead code identification: **HIGH** -- verified via csproj exclusion rules AND grep for imports
- Newtonsoft.Json usage: **HIGH** -- exhaustive grep across all files
- Solution completeness: **HIGH** -- file count verified via find command
- Migration patterns: **HIGH** -- standard System.Text.Json migration, well-documented by Microsoft

**Research date:** 2026-02-13
**Valid until:** No expiration -- this is a codebase-specific investigation, not dependent on external sources
