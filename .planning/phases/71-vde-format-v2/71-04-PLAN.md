---
phase: 71-vde-format-v2
plan: 04
type: execute
wave: 3
depends_on: ["71-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleManifest.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleConfig.cs
autonomous: true

must_haves:
  truths:
    - "All 19 modules are defined with correct bit positions, abbreviations, block type tags, inode byte sizes"
    - "32-bit ModuleManifest correctly sets/clears/queries individual module bits"
    - "Nibble-encoded ModuleConfig (16 bytes) round-trips 32 module config levels (0-15) cleanly"
    - "Module registry provides inode byte contribution for any module combination"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs"
      provides: "All 19 module definitions with metadata"
      exports: ["VdeModule", "ModuleId", "ModuleRegistry"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleManifest.cs"
      provides: "32-bit module manifest with bit operations"
      exports: ["ModuleManifestField"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleConfig.cs"
      provides: "Nibble-encoded module configuration"
      exports: ["ModuleConfigField"]
  key_links:
    - from: "ModuleRegistry"
      to: "BlockTypeTags"
      via: "each module references its block type tags"
      pattern: "BlockTypeTags\\."
    - from: "ModuleManifestField"
      to: "ModuleRegistry"
      via: "manifest bits map to registered modules"
      pattern: "ModuleRegistry\\.GetModule"
---

<objective>
Implement the module system: 19 composable modules with a 32-bit ModuleManifest, nibble-encoded ModuleConfig (16 bytes for 32 modules at 16 levels each), and a module registry mapping each module to its regions, block type tags, and inode byte contributions.

Purpose: The module system is the core of VDE v2.0 composability. It determines which regions exist, which inode fields are present, and how the VDE is configured. Required by the inode layout (plan 05) and creation profiles (plan 06).
Output: Three source files defining module metadata, manifest bit operations, and configuration encoding.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v6.0-VDE-FORMAT-v2.0-SPEC.md
@.planning/phases/71-vde-format-v2/71-01-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Module definitions and registry</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs
  </files>
  <action>
**ModuleDefinitions.cs** — Contains `ModuleId` enum, `VdeModule` record, and `ModuleRegistry` static class.

`ModuleId : byte` enum — bit positions 0-18:
```
Security = 0, Compliance = 1, Intelligence = 2, Tags = 3,
Replication = 4, Raid = 5, Streaming = 6, Compute = 7,
Fabric = 8, Consensus = 9, Compression = 10, Integrity = 11,
Snapshot = 12, Query = 13, Privacy = 14, Sustainability = 15,
Transit = 16, Observability = 17, AuditLog = 18
```

`VdeModule` readonly record struct:
- `ModuleId Id`
- `string Name` (e.g., "Security")
- `string Abbreviation` (e.g., "SEC")
- `uint[] BlockTypeTags` (tags this module adds — from spec)
- `string[] RegionNames` (regions this module adds)
- `int InodeFieldBytes` (bytes this module contributes to inode: SEC=24, CMPL=12, INTL=12, TAGS=136, REPL=8, RAID=4, STRM=8, COMP=0, FABR=0, CNSS=0, CMPR=4, INTG=0, SNAP=0, QURY=4, PRIV=2, SUST=4, TRNS=1, OBSV=0, ALOG=0)
- `bool HasInodeFields => InodeFieldBytes > 0`
- `bool HasRegion => RegionNames.Length > 0`

`ModuleRegistry` static class:
- Private static readonly dictionary of all 19 modules
- `static VdeModule GetModule(ModuleId id)` — returns module definition
- `static IReadOnlyList<VdeModule> AllModules` — all 19 modules
- `static IReadOnlyList<VdeModule> GetActiveModules(uint manifest)` — returns modules where manifest bit is set
- `static int CalculateTotalInodeFieldBytes(uint manifest)` — sums InodeFieldBytes for all active modules
- `static IReadOnlyList<uint> GetRequiredBlockTypeTags(uint manifest)` — union of all block type tags for active modules
- `static IReadOnlyList<string> GetRequiredRegions(uint manifest)` — union of all region names for active modules
- `static bool IsModuleActive(uint manifest, ModuleId module)` — checks bit at module's position

Initialize all 19 modules matching the spec exactly:
- SEC: tags=[POLV, ENCR], regions=["PolicyVault", "EncryptionHeader"], inode=24
- CMPL: tags=[CMVT, ALOG], regions=["ComplianceVault", "AuditLog"], inode=12
- INTL: tags=[INTE], regions=["IntelligenceCache"], inode=12
- TAGS: tags=[TAGI], regions=["TagIndexRegion"], inode=136
- REPL: tags=[REPL], regions=["ReplicationState"], inode=8
- RAID: tags=[RAID], regions=["RAIDMetadata"], inode=4
- STRM: tags=[STRE, DWAL], regions=["StreamingAppend", "DataWAL"], inode=8
- COMP: tags=[CODE], regions=["ComputeCodeCache"], inode=0
- FABR: tags=[XREF], regions=["CrossVDEReferenceTable"], inode=0
- CNSS: tags=[CLOG], regions=["ConsensusLogRegion"], inode=0
- CMPR: tags=[DICT], regions=["DictionaryRegion"], inode=4
- INTG: tags=[MTRK], regions=["IntegrityTree"], inode=0
- SNAP: tags=[SNAP], regions=["SnapshotTable"], inode=0
- QURY: tags=[BTRE], regions=["BTreeIndexForest"], inode=4
- PRIV: tags=[ANON], regions=["AnonymizationTable"], inode=2
- SUST: tags=[], regions=[], inode=4
- TRNS: tags=[], regions=[], inode=1
- OBSV: tags=[MLOG], regions=["MetricsLogRegion"], inode=0
- ALOG: tags=[ALOG], regions=["AuditLogRegion"], inode=0

Use `[SdkCompatibility("6.0.0")]`. Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles. `ModuleRegistry.AllModules.Count == 19`. `ModuleRegistry.CalculateTotalInodeFieldBytes(0x0007FFFF) == 219` (sum of all module inode bytes from spec).
  </verify>
  <done>All 19 modules defined with correct metadata. Registry provides lookup, manifest queries, and inode byte calculation.</done>
</task>

<task type="auto">
  <name>Task 2: Module manifest and nibble-encoded config</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleManifest.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleConfig.cs
  </files>
  <action>
**ModuleManifest.cs** — `ModuleManifestField` readonly struct wrapping a uint32:

- `uint Value` (the raw 32-bit field)
- Constructor from uint
- `bool IsModuleActive(ModuleId module)` — checks bit at (int)module
- `ModuleManifestField WithModule(ModuleId module)` — returns new manifest with bit set
- `ModuleManifestField WithoutModule(ModuleId module)` — returns new manifest with bit cleared
- `int ActiveModuleCount` — popcount of value (use `BitOperations.PopCount`)
- `IReadOnlyList<ModuleId> GetActiveModuleIds()` — iterates bits, returns active IDs
- `static ModuleManifestField FromModules(params ModuleId[] modules)` — creates manifest from list
- `static ModuleManifestField AllModules` — 0x0007FFFF (all 19 bits set)
- `static ModuleManifestField None` — 0x00000000
- Implicit conversion from/to uint
- `static void Serialize(in ModuleManifestField manifest, Span<byte> buffer)` — 4 bytes LE
- `static ModuleManifestField Deserialize(ReadOnlySpan<byte> buffer)` — 4 bytes LE

**ModuleConfig.cs** — `ModuleConfigField` struct wrapping two ulong fields (16 bytes total):

- `ulong ConfigPrimary` (modules 0-15, 4 bits each)
- `ulong ConfigExtended` (modules 16-31, 4 bits each)

- `byte GetLevel(ModuleId module)` — extracts 4-bit nibble for module:
  - If (int)module < 16: extract from ConfigPrimary bits [(int)module*4 .. (int)module*4+3]
  - If (int)module >= 16: extract from ConfigExtended bits [((int)module-16)*4 .. ((int)module-16)*4+3]
- `ModuleConfigField WithLevel(ModuleId module, byte level)` — returns new config with nibble set (level must be 0-15)
- `bool IsDisabled(ModuleId module) => GetLevel(module) == 0`
- `Dictionary<ModuleId, byte> GetAllLevels()` — returns all non-zero levels
- `static ModuleConfigField AllMaximum` — all nibbles set to 0xF
- `static ModuleConfigField FromLevels(IReadOnlyDictionary<ModuleId, byte> levels)` — builds from dictionary
- `static void Serialize(in ModuleConfigField config, Span<byte> buffer)` — writes 16 bytes (8 + 8 LE)
- `static ModuleConfigField Deserialize(ReadOnlySpan<byte> buffer)` — reads 16 bytes

Round-trip guarantee: `Deserialize(Serialize(config)) == config` for any valid input.

Nibble extraction: `(byte)((field >> (moduleIndex * 4)) & 0xF)`
Nibble insertion: `field = (field & ~(0xFUL << (moduleIndex * 4))) | ((ulong)level << (moduleIndex * 4))`

Use `[SdkCompatibility("6.0.0")]`. Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles. ModuleManifestField.AllModules.Value == 0x0007FFFF. ModuleConfigField round-trips: setting SEC=0x3, TAGS=0xF, reading back yields same values.
  </verify>
  <done>ModuleManifest provides bit-level module activation. ModuleConfig provides nibble-level configuration for 32 modules across 16 bytes. Both serialize/deserialize cleanly.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — zero errors
2. 19 modules defined, matching spec bit positions and inode byte sizes
3. ModuleManifest bit operations: set/clear/query work correctly
4. ModuleConfig nibble encoding: 16 bytes encodes 32 modules at 16 levels each
5. Total inode field bytes for all 19 modules = 219 (per spec worked example)
</verification>

<success_criteria>
- Three source files compile cleanly
- Module registry matches spec exactly (19 modules, correct byte sizes)
- Manifest and config round-trip through serialize/deserialize
- Nibble encoding handles all 32 module slots
</success_criteria>

<output>
After completion, create `.planning/phases/71-vde-format-v2/71-04-SUMMARY.md`
</output>
