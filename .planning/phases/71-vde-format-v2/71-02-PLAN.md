---
phase: 71-vde-format-v2
plan: 02
type: execute
wave: 2
depends_on: ["71-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/RegionPointerTable.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/ExtendedMetadata.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/IntegrityAnchor.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockGroup.cs
autonomous: true

must_haves:
  truths:
    - "Primary superblock serializes to exactly one block with all 50+ fields intact"
    - "Region Pointer Table holds 127 slots x 32 bytes in one block"
    - "Extended Metadata stores namespace registration, DVV, sovereignty, RAID summary"
    - "Integrity Anchor stores Merkle root, policy vault hash, chain hash, format fingerprint"
    - "SuperblockGroup writes 4 blocks (primary + RPT + extended + integrity) and mirrors to blocks 4-7"
    - "Deserialized superblock group matches the originally serialized data exactly"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs"
      provides: "Primary superblock struct with all fields from spec"
      exports: ["SuperblockV2"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/RegionPointerTable.cs"
      provides: "127-slot region pointer table"
      exports: ["RegionPointerTable", "RegionPointer"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/ExtendedMetadata.cs"
      provides: "Block 2 extended metadata"
      exports: ["ExtendedMetadata", "NamespaceRegistration"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/IntegrityAnchor.cs"
      provides: "Block 3 integrity anchor"
      exports: ["IntegrityAnchor"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockGroup.cs"
      provides: "4-block group with mirror support"
      exports: ["SuperblockGroup"]
  key_links:
    - from: "SuperblockV2"
      to: "FormatConstants"
      via: "uses magic, version, block type tags"
      pattern: "FormatConstants\\."
    - from: "SuperblockGroup"
      to: "SuperblockV2, RegionPointerTable, ExtendedMetadata, IntegrityAnchor"
      via: "composes all 4 blocks into group, serializes/deserializes"
      pattern: "Serialize|Deserialize"
---

<objective>
Implement the 4-block Superblock Group (primary superblock, region pointer table, extended metadata, integrity anchor) with mirror layout at blocks 4-7.

Purpose: The superblock group is the entry point for opening any DWVD v2.0 file. It contains format identity, volume metadata, module manifest, region pointers, namespace identity, and integrity verification data.
Output: Five source files covering all four superblock blocks plus the group coordinator.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v6.0-VDE-FORMAT-v2.0-SPEC.md
@.planning/phases/71-vde-format-v2/71-01-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/MagicSignature.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/FeatureFlags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Primary Superblock and Region Pointer Table</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockV2.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/RegionPointerTable.cs
  </files>
  <action>
**SuperblockV2.cs** — Readonly struct for Block 0 (primary superblock, 4080 usable bytes after trailer):

Fields (matching spec section "Block 0 -- Primary Superblock"):
- `MagicSignature Magic` (16 bytes — embedded magic signature struct)
- `FormatVersionInfo VersionInfo` (16 bytes — feature flags + min versions)
- `uint ModuleManifest` (32-bit module bitfield at offset +0x40)
- `ulong ModuleConfig` (64-bit nibble-encoded config at +0x44)
- `ulong ModuleConfigExt` (64-bit extended config at +0x4C)
- `int BlockSize` (block size in bytes)
- `long TotalBlocks`, `long FreeBlocks`
- `long ExpectedFileSize` (file size sentinel at +0x60)
- `long TotalAllocatedBlocks` (at +0x68)
- `Guid VolumeUuid` (16 bytes, UUID v7)
- `Guid ClusterNodeId` (16 bytes)
- `byte DefaultCompressionAlgo`, `byte DefaultEncryptionAlgo`, `byte DefaultChecksumAlgo`
- `ushort InodeSize` (calculated from modules)
- `uint PolicyVersion`, `uint ReplicationEpoch`
- `long WormHighWaterMark`
- `ulong EncryptionKeyFingerprint`
- `ushort SovereigntyZoneId`
- Volume label: `VolumeLabel` — fixed 64-byte UTF-8 buffer (use a byte array field or unsafe fixed buffer; prefer a wrapper that stores as `byte[64]`)
- `long CreatedTimestampUtc`, `long ModifiedTimestampUtc`, `long LastScrubTimestamp`
- `long CheckpointSequence`, `long ErrorMapBlockCount`
- `Guid LastWriterSessionId`, `long LastWriterTimestamp`, `Guid LastWriterNodeId`
- `long PhysicalAllocatedBlocks` (for thin provisioning)
- Reserved area (zero-fill remaining bytes up to offset BlockSize-48)
- `byte[32] HeaderIntegritySeal` (HMAC-BLAKE3 seal, last 32 bytes before trailer)

Methods:
- `static void Serialize(in SuperblockV2 sb, Span<byte> buffer, int blockSize)` — writes to block-sized buffer (leaving last 16 bytes for Universal Block Trailer)
- `static SuperblockV2 Deserialize(ReadOnlySpan<byte> buffer, int blockSize)` — reads from block buffer
- `static SuperblockV2 CreateDefault(int blockSize, long totalBlocks, Guid volumeUuid)` — initializes with sensible defaults

Use `BinaryPrimitives` for all multi-byte fields. Use little-endian throughout (matching spec LE notation).

**RegionPointerTable.cs** — Block 1: 127 region pointer slots x 32 bytes = 4064 bytes.

`RegionPointer` readonly struct (32 bytes):
- `uint RegionTypeId` (block type tag identifying the region)
- `RegionFlags Flags` (uint: ACTIVE=1, ENCRYPTED=2, COMPRESSED=4, WORM=8)
- `long StartBlock` (first block of region)
- `long BlockCount` (total blocks in region)
- `long UsedBlocks` (blocks actually used)
- `static void Serialize(in RegionPointer rp, Span<byte> buffer)` — 32 bytes
- `static RegionPointer Deserialize(ReadOnlySpan<byte> buffer)` — 32 bytes

`RegionFlags` — [Flags] enum : uint with Active, Encrypted, Compressed, Worm, ReadOnly, Migrating.

`RegionPointerTable` readonly struct:
- Internal array of 127 `RegionPointer` entries (use `RegionPointer[]` with length validation)
- `RegionPointer GetSlot(int index)` — bounds-checked access
- `void SetSlot(int index, RegionPointer pointer)` — use mutable version or builder pattern
- `int FindRegion(uint regionTypeId)` — returns slot index or -1
- `int FindFreeSlot()` — returns first slot where Flags == 0
- `int ActiveRegionCount` — count of active slots
- `static void Serialize(in RegionPointerTable table, Span<byte> buffer, int blockSize)` — writes 127 slots + padding + trailer space
- `static RegionPointerTable Deserialize(ReadOnlySpan<byte> buffer, int blockSize)` — reads 127 slots

The RPT occupies all of Block 1. After 127 x 32 = 4064 bytes, the remaining 16 bytes before the block trailer are reserved (zero-filled). At 4096 block size: 4064 + 16 reserved + 16 trailer = 4096.

Use `[SdkCompatibility("6.0.0")]` on all types. Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. RegionPointerTable.MaxSlots == 127. RegionPointer serialized size == 32 bytes.
  </verify>
  <done>SuperblockV2 has all 50+ fields from spec. RegionPointerTable supports 127 slots with find/add/remove operations. Both serialize/deserialize to block-sized buffers.</done>
</task>

<task type="auto">
  <name>Task 2: Extended metadata, integrity anchor, and superblock group coordinator</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/ExtendedMetadata.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/IntegrityAnchor.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/SuperblockGroup.cs
  </files>
  <action>
**ExtendedMetadata.cs** — Block 2 struct (4080 usable bytes):

`NamespaceRegistration` readonly struct (176 bytes, per spec):
- `byte[32] NamespacePrefix` (UTF-8, null-padded)
- `Guid NamespaceUuid` (UUID v7, 16 bytes)
- `byte[64] NamespaceAuthority` (UTF-8, null-padded)
- `byte[64] NamespaceSignature` (Ed25519 sig)
- Serialize/Deserialize methods (176 bytes)

`ExtendedMetadata` readonly struct:
- `NamespaceRegistration Namespace` (176 bytes)
- `byte[256] DottedVersionVector` (DVV snapshot)
- `byte[128] SovereigntyZoneConfig`
- `byte[128] RaidLayoutSummary`
- `byte[128] StreamingConfig`
- `byte[256] FabricNamespaceRoot`
- `byte[128] TierPolicyDigest`
- `byte[128] AiMetadataSummary`
- `byte[128] BillingMeterSnapshot`
- Remaining bytes zero-filled
- `static void Serialize(in ExtendedMetadata em, Span<byte> buffer, int blockSize)`
- `static ExtendedMetadata Deserialize(ReadOnlySpan<byte> buffer, int blockSize)`

**IntegrityAnchor.cs** — Block 3 struct (4080 usable bytes):

`IntegrityAnchor` readonly struct:
- `byte[32] MerkleRootHash` (BLAKE3)
- `byte[32] PolicyVaultHash`
- `byte[32] InodeTableHash`
- `byte[32] TagIndexHash`
- `long HashChainCounter`
- `byte[64] HashChainHead` (512-bit)
- `byte[64] BlockchainAnchorTxId` (512-bit)
- `byte[32] SbomDigest`
- `byte[32] FormatFingerprint` (BLAKE3 of spec document)
- `byte[32] MetadataChainHash` (rolling chain)
- `long ChainGeneration`
- `long ChainTimestamp` (UTC nanoseconds)
- Remaining bytes zero-filled
- `static void Serialize(in IntegrityAnchor ia, Span<byte> buffer, int blockSize)`
- `static IntegrityAnchor Deserialize(ReadOnlySpan<byte> buffer, int blockSize)`

**SuperblockGroup.cs** — Coordinates all 4 blocks:

`SuperblockGroup` class:
- Properties: `SuperblockV2 PrimarySuperblock`, `RegionPointerTable RegionPointers`, `ExtendedMetadata Extended`, `IntegrityAnchor Integrity`
- `byte[] SerializeToBlocks(int blockSize)` — returns 4 * blockSize bytes. Each block gets its content serialized, then a Universal Block Trailer appended at last 16 bytes (BlockTypeTag=SUPB for block 0, RMAP for block 1, SUPB for blocks 2-3; GenerationNumber from checkpoint sequence; XxHash64 of bytes [0..blockSize-16]).
- `static SuperblockGroup DeserializeFromBlocks(ReadOnlySpan<byte> buffer, int blockSize)` — reads 4 blocks, validates each trailer
- `byte[] SerializeWithMirror(int blockSize)` — returns 8 * blockSize bytes (primary group + identical mirror copy at blocks 4-7)
- `static SuperblockGroup DeserializeWithMirror(ReadOnlySpan<byte> buffer, int blockSize)` — reads primary first; if any block trailer fails validation, falls back to mirror
- `bool ValidateTrailers(ReadOnlySpan<byte> blockData, int blockSize)` — checks all 4 block trailers
- `static SuperblockGroup CreateDefault(int blockSize, long totalBlocks, Guid volumeUuid, uint moduleManifest)` — creates a complete default group

The Universal Block Trailer writing logic (last 16 bytes of each block): `[BlockTypeTag:4][GenerationNumber:4][XxHash64:8]`. Use `System.IO.Hashing.XxHash64` to compute the checksum over bytes [0..blockSize-16].

Use `[SdkCompatibility("6.0.0")]` on all types.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. SuperblockGroup.SerializeWithMirror produces exactly 8 * blockSize bytes. All five files exist in Format/ directory.
  </verify>
  <done>Superblock Group serializes 4 blocks with trailers, mirrors to blocks 4-7, and supports fallback deserialization from mirror on corruption. All fields from spec Block 0-3 are present.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — zero errors
2. SuperblockV2 covers all spec fields including magic, module manifest, volume UUID, feature flags, file size sentinel, last writer identity
3. RegionPointerTable holds exactly 127 slots
4. ExtendedMetadata includes 176-byte NamespaceRegistration
5. IntegrityAnchor includes MerkleRootHash, MetadataChainHash, FormatFingerprint
6. SuperblockGroup writes Universal Block Trailer on each block
7. Mirror fallback logic exists in DeserializeWithMirror
</verification>

<success_criteria>
- Five new source files compile cleanly
- Superblock Group (8 blocks with mirror) round-trips serialize/deserialize
- Universal Block Trailer (16 bytes) written on every block
- All spec fields present in their respective structs
</success_criteria>

<output>
After completion, create `.planning/phases/71-vde-format-v2/71-02-SUMMARY.md`
</output>
