---
phase: 71-vde-format-v2
plan: 03
type: execute
wave: 3
depends_on: ["71-01", "71-02"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Format/RegionDirectory.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/BlockAddressing.cs
autonomous: true

must_haves:
  truths:
    - "Region Directory occupies 2 blocks at blocks 8-9 with 127 addressable slots"
    - "Adding or removing a region updates the directory without corrupting other slots"
    - "Universal Block Trailer (16 bytes) can be written and verified on any block"
    - "XxHash64 in trailer detects single-bit corruption"
    - "Block addressing calculates byte offsets correctly for any valid block size (512-64K)"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/RegionDirectory.cs"
      provides: "2-block region directory with atomic add/remove operations"
      exports: ["RegionDirectory"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs"
      provides: "16-byte block trailer struct with write/verify"
      exports: ["UniversalBlockTrailer"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/BlockAddressing.cs"
      provides: "Block-to-byte offset calculations"
      exports: ["BlockAddressing"]
  key_links:
    - from: "RegionDirectory"
      to: "RegionPointerTable"
      via: "wraps RPT from superblock group into standalone 2-block region"
      pattern: "RegionPointer"
    - from: "UniversalBlockTrailer"
      to: "BlockTypeTags"
      via: "uses block type tag constants"
      pattern: "BlockTypeTags\\."
---

<objective>
Implement the Region Directory (2 blocks at blocks 8-9 with 127 indirectable region pointer slots) and the Universal Block Trailer (16 bytes appended to every block for self-verification), plus block addressing utilities.

Purpose: The Region Directory enables dynamic region management (add/remove regions at runtime). The Universal Block Trailer makes every block self-verifiable for corruption detection and forensic recovery. Block addressing provides the math layer for all block-to-byte conversions.
Output: Three source files.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v6.0-VDE-FORMAT-v2.0-SPEC.md
@.planning/phases/71-vde-format-v2/71-01-SUMMARY.md
@.planning/phases/71-vde-format-v2/71-02-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/BlockTypeTags.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/RegionPointerTable.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Universal Block Trailer and block addressing</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/UniversalBlockTrailer.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/BlockAddressing.cs
  </files>
  <action>
**UniversalBlockTrailer.cs** — Readonly struct, exactly 16 bytes:

Fields:
- `uint BlockTypeTag` (4 bytes — from BlockTypeTags constants)
- `uint GenerationNumber` (4 bytes — monotonic, detects torn writes)
- `ulong XxHash64Checksum` (8 bytes — checksum of bytes [0..BlockSize-16])

Static methods:
- `static UniversalBlockTrailer Create(uint blockTypeTag, uint generation, ReadOnlySpan<byte> blockPayload)` — computes XxHash64 over blockPayload (which is bytes [0..blockSize-16]), returns populated trailer
- `static void Write(Span<byte> block, int blockSize, uint blockTypeTag, uint generation)` — computes checksum of block[0..blockSize-16], writes trailer into block[blockSize-16..blockSize]
- `static UniversalBlockTrailer Read(ReadOnlySpan<byte> block, int blockSize)` — reads last 16 bytes
- `static bool Verify(ReadOnlySpan<byte> block, int blockSize)` — reads trailer, recomputes XxHash64 of [0..blockSize-16], compares. Returns true if match.
- `static bool Verify(ReadOnlySpan<byte> block, int blockSize, out UniversalBlockTrailer trailer)` — same but outputs trailer on success
- `static int PayloadSize(int blockSize) => blockSize - 16` — usable bytes per block

Use `System.IO.Hashing.XxHash64.HashToUInt64(ReadOnlySpan<byte>)` for checksum computation.

**BlockAddressing.cs** — Static utility class:

Methods:
- `static long BlockToByteOffset(long blockNumber, int blockSize)` — returns blockNumber * blockSize
- `static long ByteOffsetToBlock(long byteOffset, int blockSize)` — returns byteOffset / blockSize
- `static int UsablePayloadSize(int blockSize)` — returns blockSize - FormatConstants.UniversalBlockTrailerSize
- `static long CalculateTotalFileSize(long totalBlocks, int blockSize)` — returns totalBlocks * blockSize
- `static long CalculateBlockCount(long fileSize, int blockSize)` — returns fileSize / blockSize
- `static bool IsValidBlockSize(int blockSize)` — checks power of 2, between MinBlockSize and MaxBlockSize
- `static int SuperblockGroupByteSize(int blockSize)` — 4 * blockSize
- `static long MirrorGroupStartOffset(int blockSize)` — 4 * blockSize (byte offset of mirror)
- `static long RegionDirectoryStartOffset(int blockSize)` — 8 * blockSize
- `static long RegionDirectoryByteSize(int blockSize)` — 2 * blockSize
- `static long FirstDataRegionMinBlock()` — returns 14 (after SB group x2 + region dir + policy vault header + encryption header)

All methods use checked arithmetic to detect overflow. Throw `ArgumentOutOfRangeException` for invalid inputs.

Use `[SdkCompatibility("6.0.0")]`. Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. UniversalBlockTrailer size is exactly 16 bytes (4+4+8). BlockAddressing.UsablePayloadSize(4096) == 4080.
  </verify>
  <done>Universal Block Trailer writes and verifies checksum on any block. Block addressing provides all offset calculations for block sizes 512-65536.</done>
</task>

<task type="auto">
  <name>Task 2: Region Directory (2-block standalone region)</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/RegionDirectory.cs
  </files>
  <action>
**RegionDirectory.cs** — Class that manages the 2-block Region Directory at blocks 8-9:

The Region Directory is a standalone copy of region pointers (separate from the RPT in Superblock Block 1). It occupies 2 blocks = 2 * blockSize bytes. With 4096 block size: 8160 usable bytes (2 * 4080). Stores 127 slots x 32 bytes = 4064 bytes in the first block, with the second block providing overflow, versioning, and future expansion.

`RegionDirectory` class:
- Private field: `RegionPointer[] _slots` (length 127)
- `int SlotCount => FormatConstants.MaxRegionSlots` (127)
- `RegionPointer GetSlot(int index)` — bounds-checked
- `int AddRegion(uint regionTypeId, RegionFlags flags, long startBlock, long blockCount)` — finds first free slot, populates it, returns slot index. Throws if no free slots.
- `bool RemoveRegion(uint regionTypeId)` — finds slot by type, zeros it out, returns success
- `bool RemoveRegionAt(int index)` — zeros slot at index
- `int FindRegion(uint regionTypeId)` — returns slot index or -1
- `IReadOnlyList<(int Index, RegionPointer Pointer)> GetActiveRegions()` — returns all non-zero slots
- `int ActiveRegionCount { get; }` — count of slots with ACTIVE flag
- `int FreeSlotCount => SlotCount - ActiveRegionCount`

Serialization — writes to 2-block buffer:
- `void Serialize(Span<byte> buffer, int blockSize)`:
  1. Write 127 x 32-byte slots to block 0 starting at offset 0
  2. Zero-fill remaining bytes in block 0 up to blockSize-16
  3. Write Universal Block Trailer for block 0 (tag=RMAP, generation from caller or stored generation)
  4. Block 1: write a directory header (version uint16, slot count uint16, active count uint16, checksum of block 0 data), zero-fill rest, write trailer (tag=RMAP)
- `static RegionDirectory Deserialize(ReadOnlySpan<byte> buffer, int blockSize)`:
  1. Verify block 0 trailer
  2. Read 127 slots from block 0
  3. Verify block 1 trailer
  4. Read directory header from block 1

- `uint Generation { get; set; }` — monotonic generation for trailers

The Region Directory MUST be kept in sync with the Region Pointer Table in Superblock Block 1. This class manages the standalone region only; sync is handled at a higher level.

Use `[SdkCompatibility("6.0.0")]`. Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero errors. RegionDirectory.SlotCount == 127. Serialize output is exactly 2 * blockSize bytes.
  </verify>
  <done>Region Directory manages 127 pointer slots across 2 blocks with add/remove/find operations. Each block has a Universal Block Trailer. Slot operations are bounds-checked.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — zero errors
2. UniversalBlockTrailer.Verify returns true for correctly written blocks
3. UniversalBlockTrailer.Verify returns false when any byte is modified
4. RegionDirectory occupies exactly 2 blocks
5. 127 slots x 32 bytes = 4064 bytes fits within one 4096-byte block (with 16 bytes remaining + 16-byte trailer)
6. BlockAddressing calculations are consistent across all supported block sizes
</verification>

<success_criteria>
- Three source files compile cleanly
- Every block gets a Universal Block Trailer with verifiable XxHash64
- Region Directory supports 127 region slots with add/remove
- Block addressing math correct for 512B through 64KB block sizes
</success_criteria>

<output>
After completion, create `.planning/phases/71-vde-format-v2/71-03-SUMMARY.md`
</output>
