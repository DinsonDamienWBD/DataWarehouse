---
phase: 71-vde-format-v2
plan: 05
type: execute
wave: 4
depends_on: ["71-03", "71-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/InodeLayoutDescriptor.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Format/InodeSizeCalculator.cs
autonomous: true

must_haves:
  truths:
    - "Inode size is calculated correctly: 320B minimal (no modules), 576B maximal (all 19 modules)"
    - "InodeLayoutDescriptor is self-describing: any VDE engine can parse inodes regardless of active modules"
    - "Extent-based addressing: 8 extents x 24 bytes covers terabytes of data"
    - "Inline tag area: 128 bytes for ~4 compact tags when Tags module active"
    - "Padding bytes are reserved for future module additions without inode migration"
    - "Inode size is always a multiple of 64 bytes"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs"
      provides: "Variable-size inode struct with core + module fields"
      exports: ["InodeV2", "InodeFlags"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/InodeLayoutDescriptor.cs"
      provides: "Self-describing inode layout with module field mappings"
      exports: ["InodeLayoutDescriptor", "ModuleFieldEntry"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs"
      provides: "24-byte extent entry with flags"
      exports: ["InodeExtent", "ExtentFlags"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Format/InodeSizeCalculator.cs"
      provides: "Inode size calculation from module selection"
      exports: ["InodeSizeCalculator", "InodeSizeResult"]
  key_links:
    - from: "InodeSizeCalculator"
      to: "ModuleRegistry"
      via: "uses module inode byte sizes to compute total"
      pattern: "ModuleRegistry\\.CalculateTotalInodeFieldBytes"
    - from: "InodeLayoutDescriptor"
      to: "ModuleManifestField"
      via: "descriptor reflects which modules are active"
      pattern: "ModuleManifest"
---

<objective>
Implement the v2.0 inode layout: variable-size InodeV2 (320-576 bytes), InodeLayoutDescriptor for self-describing field layout, extent-based addressing (8 extents x 24 bytes), inline tag area (128 bytes), and the inode size calculator that computes correct size from module selection.

Purpose: The inode is the metadata record for every object in the VDE. Its variable size based on selected modules is a key innovation of v2.0 composability. Every subsequent feature that reads/writes objects needs the inode layout.
Output: Four source files covering inode structure, layout descriptor, extents, and size calculation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v6.0-VDE-FORMAT-v2.0-SPEC.md
@.planning/phases/71-vde-format-v2/71-01-SUMMARY.md
@.planning/phases/71-vde-format-v2/71-04-SUMMARY.md
@DataWarehouse.SDK/VirtualDiskEngine/Format/FormatConstants.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleDefinitions.cs
@DataWarehouse.SDK/VirtualDiskEngine/Format/ModuleManifest.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extent structure and inode size calculator</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/InodeExtent.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/InodeSizeCalculator.cs
  </files>
  <action>
**InodeExtent.cs** — Readonly struct, exactly 24 bytes per extent:

`ExtentFlags : uint` [Flags] enum:
- `None = 0`
- `Compressed = 1 << 0`
- `Precompressed = 1 << 1` (skip re-compression for JPEG/MP4/etc.)
- `Encrypted = 1 << 2`
- `Hole = 1 << 3` (sparse — no data on disk)
- `SharedCow = 1 << 4` (shared via copy-on-write snapshot)

`InodeExtent` readonly struct (24 bytes):
- `long StartBlock` (8 bytes — physical block number)
- `int BlockCount` (4 bytes — number of contiguous blocks)
- `ExtentFlags Flags` (4 bytes — uint)
- `long LogicalOffset` (8 bytes — logical byte offset within file)
- `static void Serialize(in InodeExtent ext, Span<byte> buffer)` — 24 bytes LE
- `static InodeExtent Deserialize(ReadOnlySpan<byte> buffer)` — 24 bytes
- `long PhysicalSize(int blockSize) => (long)BlockCount * blockSize`
- `bool IsSparse => Flags.HasFlag(ExtentFlags.Hole)`
- `bool IsShared => Flags.HasFlag(ExtentFlags.SharedCow)`

**InodeSizeCalculator.cs** — Static class:

`InodeSizeResult` readonly record struct:
- `int InodeSize` (final aligned size)
- `int CoreBytes` (always 304)
- `int ModuleFieldBytes` (sum of active module inode contributions)
- `int PaddingBytes` (InodeSize - CoreBytes - ModuleFieldBytes)
- `IReadOnlyList<(ModuleId Module, int Offset, int Size)> ModuleFieldLayout` — offset within inode for each active module's fields

`InodeSizeCalculator` static class:
- `static InodeSizeResult Calculate(uint moduleManifest)`:
  1. Start with base = FormatConstants.InodeCoreSize (304)
  2. Iterate active modules from ModuleRegistry in ModuleId order
  3. For each active module with InodeFieldBytes > 0, record offset (base + running total) and size
  4. Sum module bytes
  5. raw = base + moduleFieldBytes
  6. inodeSize = ((raw + FormatConstants.InodeAlignmentMultiple - 1) / FormatConstants.InodeAlignmentMultiple) * FormatConstants.InodeAlignmentMultiple
  7. padding = inodeSize - raw
  8. Return result with all fields

- `static InodeSizeResult CalculateMinimal()` — Calculate(0x00000000) => 320 bytes
- `static InodeSizeResult CalculateMaximal()` — Calculate(0x0007FFFF) => 576 bytes
- `static bool CanAddModuleWithoutMigration(int currentPadding, ModuleId module)` — checks if module's inode bytes fit in current padding

Verify the spec worked examples produce correct results:
- No modules: 304 raw -> 320 aligned, 16 padding
- SEC+TAGS+REPL+INTL: 304+24+136+8+12=484 raw -> 512 aligned, 28 padding
- SEC+CMPL+RAID+CMPR+QURY: 304+24+12+4+4+4=352 raw -> 384 aligned, 32 padding
- All 19: 304+219=523 raw -> 576 aligned, 53 padding

Use `[SdkCompatibility("6.0.0")]`. Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles. InodeExtent serialized size is 24 bytes. InodeSizeCalculator.CalculateMinimal().InodeSize == 320. InodeSizeCalculator.CalculateMaximal().InodeSize == 576.
  </verify>
  <done>Extent struct handles 8 addressing entries with sparse/CoW/compression flags. Inode size calculator matches all 4 spec worked examples exactly.</done>
</task>

<task type="auto">
  <name>Task 2: InodeV2 structure and InodeLayoutDescriptor</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Format/InodeV2.cs
    DataWarehouse.SDK/VirtualDiskEngine/Format/InodeLayoutDescriptor.cs
  </files>
  <action>
**InodeLayoutDescriptor.cs** — Stored in Superblock Block 1 after the Region Pointer slots:

`ModuleFieldEntry` readonly struct (7 bytes each, per spec):
- `byte ModuleId` (module bit position)
- `ushort FieldOffset` (byte offset within inode)
- `ushort FieldSize` (bytes)
- `byte FieldVersion` (layout version for this module)
- `byte Flags` (bit 0: ACTIVE, bit 1: MIGRATING)
- `static void Serialize(in ModuleFieldEntry entry, Span<byte> buffer)` — 7 bytes
- `static ModuleFieldEntry Deserialize(ReadOnlySpan<byte> buffer)` — 7 bytes

`InodeLayoutDescriptor` readonly struct:
- `ushort InodeSize` (actual inode size in bytes)
- `ushort CoreFieldsEnd` (always 304 in v2.0)
- `byte ModuleFieldCount` (0-19)
- `byte PaddingBytes` (reserved bytes at end)
- `ushort Reserved` (zero)
- `ModuleFieldEntry[] ModuleFields` (array of ModuleFieldCount entries)

Methods:
- `static InodeLayoutDescriptor Create(uint moduleManifest)` — uses InodeSizeCalculator to build descriptor
- `int GetModuleFieldOffset(ModuleId module)` — returns offset or -1 if not present
- `int GetModuleFieldSize(ModuleId module)` — returns size or 0 if not present
- `bool HasModule(ModuleId module)` — checks if module has entry
- `int TotalSerializedSize => 8 + ModuleFieldCount * 7` (max 141 bytes)
- `static void Serialize(in InodeLayoutDescriptor desc, Span<byte> buffer)` — header(8) + entries(N*7)
- `static InodeLayoutDescriptor Deserialize(ReadOnlySpan<byte> buffer)` — reads header + entries

**InodeV2.cs** — The variable-size inode structure:

`InodeFlags : byte` [Flags] enum:
- `None = 0`, `Encrypted = 1`, `Compressed = 2`, `Worm = 4`, `InlineData = 8`

`InodeV2` class (not struct — variable size):
- Core fields (304 bytes total):
  - `long InodeNumber` (8)
  - `InodeType Type` (1) — reuse existing InodeType enum from Metadata/InodeStructure.cs
  - `InodeFlags Flags` (1)
  - `InodePermissions Permissions` (2) — reuse existing enum
  - `int LinkCount` (4)
  - `Guid OwnerId` (16)
  - `long Size`, `long AllocatedSize` (16)
  - `long CreatedUtc`, `long ModifiedUtc`, `long AccessedUtc`, `long ChangedUtc` (32)
  - `int ExtentCount` (4) — number of valid extents (0-8)
  - `InodeExtent[] Extents` (8 entries x 24 bytes = 192)
  - `long IndirectExtentBlock`, `long DoubleIndirectBlock`, `long ExtendedAttributeBlock` (24)

- Module fields (stored as byte[] blob, interpreted via InodeLayoutDescriptor):
  - `byte[] ModuleFieldData` — variable length, contains all module fields concatenated in order

- Well-known module field accessors (convenience, use descriptor offsets):
  - Security: `int EncryptionKeySlot`, `int AclPolicyId`, `byte[] ContentHash` (16 bytes)
  - Tags: `int InlineTagCount`, `int TagOverflowBlock`, `byte[] InlineTagArea` (128 bytes)
  - Replication: `int ReplicationGeneration`, `int DirtyFlag`
  - RAID: `short RaidShardId`, `short RaidGroupId`
  - Streaming: `long StreamSequenceNumber`
  - (Other modules accessed via generic GetModuleField<T> or raw byte access)

- `byte[] SymLinkTargetOrReserved` (16 bytes — last 16 bytes before total size)
- `byte[] PaddingBytes` — zero-filled padding

Methods:
- `static byte[] Serialize(InodeV2 inode, InodeLayoutDescriptor descriptor)` — returns descriptor.InodeSize bytes
- `static InodeV2 Deserialize(ReadOnlySpan<byte> buffer, InodeLayoutDescriptor descriptor)` — reads variable-size inode
- `ReadOnlySpan<byte> GetModuleFieldRaw(InodeLayoutDescriptor descriptor, ModuleId module)` — returns raw bytes for module's field area
- `void SetModuleFieldRaw(InodeLayoutDescriptor descriptor, ModuleId module, ReadOnlySpan<byte> data)` — writes raw bytes

The key design: InodeV2 + InodeLayoutDescriptor together are self-describing. An engine that doesn't know about a particular module can still parse the inode by skipping unknown module field entries.

Use `[SdkCompatibility("6.0.0")]`. Namespace: `DataWarehouse.SDK.VirtualDiskEngine.Format`.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles. InodeLayoutDescriptor.Create(0).InodeSize == 320. InodeLayoutDescriptor.Create(0x0007FFFF).InodeSize == 576. InodeV2 serialized size matches descriptor.InodeSize.
  </verify>
  <done>InodeV2 supports variable-size layout (320-576 bytes) with self-describing InodeLayoutDescriptor. Extent-based addressing with 8 extents x 24 bytes. Module fields accessible via descriptor offsets. Inline tag area (128 bytes) when Tags module active.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — zero errors
2. Inode size calculation matches all 4 spec examples (320, 512, 384, 576)
3. InodeLayoutDescriptor.Create() produces correct field offsets for any module combination
4. InodeExtent is exactly 24 bytes with sparse/CoW/compression flags
5. InodeV2 round-trips through serialize/deserialize for both minimal (320B) and maximal (576B) configurations
6. Padding bytes correctly calculated as InodeSize - CoreBytes - ModuleFieldBytes
</verification>

<success_criteria>
- Four source files compile cleanly
- Inode size: 320B minimal, 576B maximal (matches spec)
- InodeLayoutDescriptor is self-describing (any engine can parse unknown module fields)
- 8 extents x 24 bytes provide terabyte-scale addressing
- 128-byte inline tag area present when Tags module active
- Padding bytes reserved for future modules
</success_criteria>

<output>
After completion, create `.planning/phases/71-vde-format-v2/71-05-SUMMARY.md`
</output>
