---
phase: 24-plugin-hierarchy-storage-validation
plan: 05
type: execute
wave: 4
depends_on: ["24-03", "24-04"]
files_modified:
  - DataWarehouse.SDK/Storage/Services/ITierManager.cs
  - DataWarehouse.SDK/Storage/Services/ICacheManager.cs
  - DataWarehouse.SDK/Storage/Services/IStorageIndex.cs
  - DataWarehouse.SDK/Storage/Services/IConnectionRegistry.cs
  - DataWarehouse.SDK/Storage/Services/DefaultTierManager.cs
  - DataWarehouse.SDK/Storage/Services/DefaultCacheManager.cs
  - DataWarehouse.SDK/Storage/Services/DefaultStorageIndex.cs
  - DataWarehouse.SDK/Storage/Services/DefaultConnectionRegistry.cs
autonomous: true

must_haves:
  truths:
    - "ITierManager interface extracted from TieredStoragePluginBase logic"
    - "ICacheManager interface extracted from CacheableStoragePluginBase logic"
    - "IStorageIndex interface extracted from IndexableStoragePluginBase logic"
    - "IConnectionRegistry interface extracted from HybridStoragePluginBase logic"
    - "Default implementations exist for each service"
    - "Old specialized storage bases still compile unchanged"
    - "SDK compiles with zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/Services/ITierManager.cs"
      provides: "Composable tier management service"
      contains: "interface ITierManager"
    - path: "DataWarehouse.SDK/Storage/Services/ICacheManager.cs"
      provides: "Composable cache management service"
      contains: "interface ICacheManager"
    - path: "DataWarehouse.SDK/Storage/Services/IStorageIndex.cs"
      provides: "Composable storage indexing service"
      contains: "interface IStorageIndex"
    - path: "DataWarehouse.SDK/Storage/Services/IConnectionRegistry.cs"
      provides: "Composable connection registry service"
      contains: "interface IConnectionRegistry"
  key_links:
    - from: "StoragePluginBase (new)"
      to: "ITierManager, ICacheManager, IStorageIndex, IConnectionRegistry"
      via: "optional injectable services pattern"
      pattern: "protected ITierManager"
---

<objective>
Extract specialized storage base class logic into composable services per AD-03. Create interfaces (ITierManager, ICacheManager, IStorageIndex, IConnectionRegistry) and default implementations that encapsulate the logic currently locked in the TieredStoragePluginBase -> CacheableStoragePluginBase -> IndexableStoragePluginBase -> HybridStoragePluginBase inheritance chain.

Purpose: C# single inheritance means UltimateStoragePlugin can only inherit ONE base. By extracting capabilities into composable services, any storage plugin can use all capabilities simultaneously. The old bases remain for backward compat but are no longer the only way to access this logic.
Output: 4 service interfaces + 4 default implementations in DataWarehouse.SDK/Storage/Services/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ARCHITECTURE_DECISIONS.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-RESEARCH.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-03-SUMMARY.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-04-SUMMARY.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Storage/HybridStoragePluginBase.cs
@DataWarehouse.SDK/Database/HybridDatabasePluginBase.cs
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create composable service interfaces (4 interfaces)</name>
  <files>
    DataWarehouse.SDK/Storage/Services/ITierManager.cs
    DataWarehouse.SDK/Storage/Services/ICacheManager.cs
    DataWarehouse.SDK/Storage/Services/IStorageIndex.cs
    DataWarehouse.SDK/Storage/Services/IConnectionRegistry.cs
  </files>
  <action>
Create directory `DataWarehouse.SDK/Storage/Services/` and the following 4 interface files.

**CRITICAL: Read the existing specialized bases FIRST to extract their public contracts accurately.**

Read these files before writing:
1. `TieredStoragePluginBase` in PluginBase.cs (~line 1505) for tier logic
2. `CacheableStoragePluginBase` in PluginBase.cs (~line 1537) for cache logic
3. `IndexableStoragePluginBase` in PluginBase.cs (~line 1772) for index logic
4. `HybridStoragePluginBase` in Storage/HybridStoragePluginBase.cs for connection/instance logic
5. `DataWarehouse.SDK/Infrastructure/PerformanceOptimizations.cs` for TieredStorageManager (1,566 lines -- check if it already provides an ITierManager-like interface)

**1. ITierManager.cs** -- Extracted from TieredStoragePluginBase + TieredStorageManager
```csharp
namespace DataWarehouse.SDK.Storage.Services;

/// <summary>
/// Composable tier management service (AD-03).
/// Extracted from TieredStoragePluginBase to enable composition.
/// </summary>
public interface ITierManager
{
    /// <summary>Moves an object to the specified storage tier.</summary>
    Task<string> MoveToTierAsync(string key, StorageTier targetTier, CancellationToken ct = default);

    /// <summary>Gets the current tier of an object.</summary>
    Task<StorageTier> GetCurrentTierAsync(string key, CancellationToken ct = default);

    /// <summary>Gets tier statistics (object count, size per tier).</summary>
    Task<TierStatistics> GetTierStatisticsAsync(CancellationToken ct = default);

    /// <summary>Evaluates whether an object should be moved based on access patterns.</summary>
    Task<TierRecommendation?> EvaluateTierPlacementAsync(string key, CancellationToken ct = default);
}
```

Define `TierStatistics` and `TierRecommendation` as records in the same file:
```csharp
public record TierStatistics
{
    public IReadOnlyDictionary<StorageTier, long> ObjectCounts { get; init; } = new Dictionary<StorageTier, long>();
    public IReadOnlyDictionary<StorageTier, long> TotalSizeBytes { get; init; } = new Dictionary<StorageTier, long>();
}

public record TierRecommendation
{
    public string Key { get; init; } = string.Empty;
    public StorageTier CurrentTier { get; init; }
    public StorageTier RecommendedTier { get; init; }
    public string Reason { get; init; } = string.Empty;
}
```

**2. ICacheManager.cs** -- Extracted from CacheableStoragePluginBase
```csharp
namespace DataWarehouse.SDK.Storage.Services;

/// <summary>
/// Composable cache management service (AD-03).
/// Extracted from CacheableStoragePluginBase to enable composition.
/// </summary>
public interface ICacheManager
{
    /// <summary>Stores data with a TTL.</summary>
    Task StoreWithTtlAsync(string key, Stream data, TimeSpan ttl, CancellationToken ct = default);

    /// <summary>Gets remaining TTL for an entry.</summary>
    Task<TimeSpan?> GetTtlAsync(string key, CancellationToken ct = default);

    /// <summary>Sets or updates TTL for an existing entry.</summary>
    Task<bool> SetTtlAsync(string key, TimeSpan ttl, CancellationToken ct = default);

    /// <summary>Invalidates entries matching a glob pattern.</summary>
    Task<int> InvalidatePatternAsync(string pattern, CancellationToken ct = default);

    /// <summary>Gets cache statistics.</summary>
    Task<CacheStatistics> GetStatisticsAsync(CancellationToken ct = default);

    /// <summary>Removes all expired entries.</summary>
    Task<int> CleanupExpiredAsync(CancellationToken ct = default);
}
```

Use the existing `CacheStatistics`, `CacheEntryMetadata`, and `CacheOptions` types from PluginBase.cs. Check if they are already defined as public types; if they are nested or private, create equivalent public records.

**3. IStorageIndex.cs** -- Extracted from IndexableStoragePluginBase
```csharp
namespace DataWarehouse.SDK.Storage.Services;

/// <summary>
/// Composable storage indexing service (AD-03).
/// Extracted from IndexableStoragePluginBase to enable composition.
/// </summary>
public interface IStorageIndex
{
    /// <summary>Indexes metadata for a storage object.</summary>
    Task IndexAsync(string key, StorageObjectMetadata metadata, CancellationToken ct = default);

    /// <summary>Searches the index with a query string.</summary>
    Task<IReadOnlyList<StorageObjectMetadata>> SearchAsync(string query, int maxResults = 100, CancellationToken ct = default);

    /// <summary>Removes an entry from the index.</summary>
    Task RemoveAsync(string key, CancellationToken ct = default);

    /// <summary>Gets the total number of indexed entries.</summary>
    Task<long> GetIndexCountAsync(CancellationToken ct = default);

    /// <summary>Rebuilds the index from scratch.</summary>
    Task RebuildAsync(IAsyncEnumerable<StorageObjectMetadata> allObjects, CancellationToken ct = default);
}
```

**4. IConnectionRegistry.cs** -- Extracted from HybridStoragePluginBase / HybridDatabasePluginBase
```csharp
namespace DataWarehouse.SDK.Storage.Services;

/// <summary>
/// Composable connection registry service (AD-03).
/// Manages multiple storage backend connections, health monitoring, and instance lifecycle.
/// Extracted from HybridStoragePluginBase to enable composition.
/// </summary>
public interface IConnectionRegistry<TConfig> where TConfig : class
{
    /// <summary>Registers a new storage backend connection.</summary>
    Task<string> RegisterAsync(string name, TConfig config, CancellationToken ct = default);

    /// <summary>Unregisters and disconnects a storage backend.</summary>
    Task UnregisterAsync(string connectionId, CancellationToken ct = default);

    /// <summary>Gets the configuration for a registered connection.</summary>
    TConfig? GetConfig(string connectionId);

    /// <summary>Lists all registered connection IDs.</summary>
    IReadOnlyList<string> GetRegisteredIds();

    /// <summary>Gets health status for a specific connection.</summary>
    Task<ConnectionHealth> GetHealthAsync(string connectionId, CancellationToken ct = default);

    /// <summary>Gets health status for all connections.</summary>
    Task<IReadOnlyDictionary<string, ConnectionHealth>> GetAllHealthAsync(CancellationToken ct = default);
}

public record ConnectionHealth
{
    public string ConnectionId { get; init; } = string.Empty;
    public bool IsHealthy { get; init; }
    public TimeSpan Latency { get; init; }
    public string? ErrorMessage { get; init; }
    public DateTimeOffset LastChecked { get; init; }
}
```

For ALL interfaces, add the correct `using` statements for types like `StorageTier`, `StorageObjectMetadata`, `CacheStatistics`, etc. Check where they are defined and reference correctly.

Build the SDK after creating all interface files.
  </action>
  <verify>Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile. Verify all 4 interface files exist in `DataWarehouse.SDK/Storage/Services/`.</verify>
  <done>4 composable service interfaces created (ITierManager, ICacheManager, IStorageIndex, IConnectionRegistry) with supporting record types. SDK compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create default implementations for composable services</name>
  <files>
    DataWarehouse.SDK/Storage/Services/DefaultTierManager.cs
    DataWarehouse.SDK/Storage/Services/DefaultCacheManager.cs
    DataWarehouse.SDK/Storage/Services/DefaultStorageIndex.cs
    DataWarehouse.SDK/Storage/Services/DefaultConnectionRegistry.cs
  </files>
  <action>
Create default implementations for each interface. These are simple, in-memory implementations that provide the baseline behavior extracted from the old specialized bases. They will be used by the new StoragePluginBase from 24-03.

**CRITICAL: Read the EXISTING implementation code from the old bases and EXTRACT the logic.**

**1. DefaultTierManager.cs** -- Extract tier tracking logic.
- Use ConcurrentDictionary<string, StorageTier> to track object tiers
- `MoveToTierAsync` updates the tier tracking (actual data movement is delegated to the storage backend)
- `GetCurrentTierAsync` returns tracked tier or default (Hot)
- `EvaluateTierPlacementAsync` provides a simple time-based heuristic (objects not accessed in 30 days -> Cool, 90 days -> Cold, 365 days -> Archive)
- Check `DataWarehouse.SDK/Infrastructure/PerformanceOptimizations.cs` for `TieredStorageManager` -- if it has reusable logic, delegate to it rather than duplicating

**2. DefaultCacheManager.cs** -- Extract cache logic from CacheableStoragePluginBase.
- Use ConcurrentDictionary<string, CacheEntry> for cache tracking
- Include cleanup timer (configurable interval)
- `StoreWithTtlAsync` records metadata with expiry
- `CleanupExpiredAsync` removes expired entries
- `InvalidatePatternAsync` uses Regex with timeout (VALID-04) -- `TimeSpan.FromMilliseconds(100)`
- `GetStatisticsAsync` returns counts and sizes
- Implement IDisposable for cleanup timer disposal
- Reference: CacheableStoragePluginBase in PluginBase.cs (~line 1537-1680)

**3. DefaultStorageIndex.cs** -- Extract index logic from IndexableStoragePluginBase.
- Use ConcurrentDictionary<string, StorageObjectMetadata> as in-memory index
- `IndexAsync` adds/updates metadata
- `SearchAsync` does simple key/content-type matching (case-insensitive)
- `RemoveAsync` removes from index
- `RebuildAsync` clears and re-adds all objects
- Reference: IndexableStoragePluginBase in PluginBase.cs (~line 1772)

**4. DefaultConnectionRegistry.cs** -- Extract connection management from HybridStoragePluginBase.
- Generic `DefaultConnectionRegistry<TConfig>` implementation
- Use ConcurrentDictionary<string, TConfig> for registration
- `RegisterAsync` generates connection ID, stores config
- `UnregisterAsync` removes config
- Health tracking uses ConcurrentDictionary<string, ConnectionHealth>
- Reference: HybridStoragePluginBase.cs (~108+ lines) and HybridDatabasePluginBase.cs (~31+ lines)

**For ALL implementations:**
- Namespace: `DataWarehouse.SDK.Storage.Services`
- Thread-safe using ConcurrentDictionary
- CancellationToken respected on all async methods
- Full XML documentation
- `sealed` classes (not designed for inheritance -- the interface is the extension point)
- IDisposable where resources need cleanup (timers)

**Do NOT modify any existing specialized base classes.** They continue to work unchanged. The new services are alternatives, not replacements (Phase 28 handles cleanup).

Build the SDK after creating all implementation files.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile.
Verify all 4 implementation files exist in `DataWarehouse.SDK/Storage/Services/`.
Verify existing specialized bases (TieredStoragePluginBase, CacheableStoragePluginBase, etc.) still compile unchanged.
  </verify>
  <done>4 default service implementations created (DefaultTierManager, DefaultCacheManager, DefaultStorageIndex, DefaultConnectionRegistry). Logic extracted from specialized bases. Existing bases unchanged. SDK compiles.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors
2. 8 files in DataWarehouse.SDK/Storage/Services/ (4 interfaces + 4 implementations)
3. Existing specialized storage bases unchanged and still compile
4. DefaultCacheManager uses Regex with timeout (VALID-04 compliance)
5. All async methods accept CancellationToken
</verification>

<success_criteria>
- AD-03: Specialized base logic extracted into composable services
- ITierManager, ICacheManager, IStorageIndex, IConnectionRegistry interfaces defined
- Default implementations provide baseline behavior
- Existing inheritance chain untouched (backward compat)
- SDK compiles
</success_criteria>

<output>
After completion, create `.planning/phases/24-plugin-hierarchy-storage-validation/24-05-SUMMARY.md`
</output>
