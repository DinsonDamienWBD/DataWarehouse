---
phase: 24-plugin-hierarchy-storage-validation
plan: 04
type: execute
wave: 3
depends_on: ["24-02"]
files_modified:
  - DataWarehouse.SDK/Storage/PathStorageAdapter.cs
  - DataWarehouse.SDK/Storage/IObjectStorageCore.cs
autonomous: true

must_haves:
  truths:
    - "IObjectStorageCore interface defines the canonical key-based storage contract"
    - "PathStorageAdapter wraps IObjectStorageCore and exposes IStorageProvider (Uri-based) API"
    - "URI-to-key translation correctly maps scheme://host/path to key format"
    - "Key-to-URI reconstruction correctly maps keys back to URIs"
    - "StorageObjectMetadata already exists and is reused (not duplicated)"
    - "SDK compiles with zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Storage/PathStorageAdapter.cs"
      provides: "Translation layer from URI-based API to key-based object storage"
      contains: "class PathStorageAdapter"
    - path: "DataWarehouse.SDK/Storage/IObjectStorageCore.cs"
      provides: "Canonical object storage interface"
      contains: "interface IObjectStorageCore"
  key_links:
    - from: "PathStorageAdapter"
      to: "IObjectStorageCore"
      via: "wraps and translates URIs to keys"
      pattern: "class PathStorageAdapter.*IStorageProvider"
    - from: "IObjectStorageCore"
      to: "IStorageStrategy"
      via: "same key-based contract pattern"
      pattern: "interface IObjectStorageCore"
---

<objective>
Unify storage around the object/key-based model (AD-04) by formalizing IObjectStorageCore as the canonical storage interface and creating PathStorageAdapter as the URI translation layer.

Purpose: The SDK has two competing storage models (IStorageProvider with URIs vs IStorageStrategy with keys). AD-04 declares key-based as the universal core. PathStorageAdapter provides backward compatibility for all code that uses URI-based IStorageProvider.
Output: IObjectStorageCore interface and PathStorageAdapter class in DataWarehouse.SDK/Storage/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ARCHITECTURE_DECISIONS.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-RESEARCH.md
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
@DataWarehouse.SDK/Contracts/ProviderInterfaces.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IObjectStorageCore interface</name>
  <files>DataWarehouse.SDK/Storage/IObjectStorageCore.cs</files>
  <action>
Create `DataWarehouse.SDK/Storage/IObjectStorageCore.cs`. This interface is the canonical storage contract per AD-04. It mirrors `IStorageStrategy` but is positioned as the SDK-level contract (not strategy-level).

First, check if the `DataWarehouse.SDK/Storage/` directory already exists (it should -- HybridStoragePluginBase.cs is there). If not, create it.

```csharp
using DataWarehouse.SDK.Contracts.Storage;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace DataWarehouse.SDK.Storage;

/// <summary>
/// The canonical object/key-based storage contract (AD-04).
/// All storage operations in the SDK ultimately resolve to this interface.
/// URI-based access is provided via <see cref="PathStorageAdapter"/> which translates
/// URI paths to keys and delegates to this interface.
/// </summary>
/// <remarks>
/// <para>
/// This interface aligns with the <see cref="IStorageStrategy"/> contract used by
/// UltimateStoragePlugin's 130+ backend strategies. The key difference:
/// </para>
/// <list type="bullet">
///   <item><see cref="IObjectStorageCore"/> is the SDK-level contract for plugin bases and kernel</item>
///   <item><see cref="IStorageStrategy"/> is the strategy-level contract for individual backends</item>
/// </list>
/// <para>
/// Keys follow a hierarchical convention: "namespace/category/name" (e.g., "data/users/profile.json").
/// No leading slash. Forward slashes only. No path traversal sequences.
/// </para>
/// </remarks>
public interface IObjectStorageCore
{
    /// <summary>
    /// Stores data with the specified key and optional metadata.
    /// </summary>
    /// <param name="key">The unique key for the object. Must not be null, empty, or contain path traversal.</param>
    /// <param name="data">The data stream to store.</param>
    /// <param name="metadata">Optional metadata to associate with the object.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Metadata of the stored object including size, ETag, timestamps.</returns>
    Task<StorageObjectMetadata> StoreAsync(string key, Stream data, IDictionary<string, string>? metadata = null, CancellationToken ct = default);

    /// <summary>
    /// Retrieves data for the specified key.
    /// </summary>
    /// <param name="key">The unique key of the object.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>A readable stream of the object data.</returns>
    /// <exception cref="KeyNotFoundException">The key does not exist.</exception>
    Task<Stream> RetrieveAsync(string key, CancellationToken ct = default);

    /// <summary>
    /// Deletes the object with the specified key.
    /// </summary>
    /// <param name="key">The unique key of the object.</param>
    /// <param name="ct">Cancellation token.</param>
    Task DeleteAsync(string key, CancellationToken ct = default);

    /// <summary>
    /// Checks if an object with the specified key exists.
    /// </summary>
    /// <param name="key">The unique key to check.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>True if the object exists.</returns>
    Task<bool> ExistsAsync(string key, CancellationToken ct = default);

    /// <summary>
    /// Lists objects matching an optional key prefix.
    /// </summary>
    /// <param name="prefix">Optional prefix to filter results (e.g., "data/users/").</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>An async enumerable of object metadata.</returns>
    IAsyncEnumerable<StorageObjectMetadata> ListAsync(string? prefix = null, CancellationToken ct = default);

    /// <summary>
    /// Gets metadata for a specific object without retrieving its data.
    /// </summary>
    /// <param name="key">The unique key of the object.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Object metadata including size, timestamps, ETag, content type.</returns>
    Task<StorageObjectMetadata> GetMetadataAsync(string key, CancellationToken ct = default);

    /// <summary>
    /// Gets the health status of the underlying storage backend.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Health information including status, latency, and capacity.</returns>
    Task<StorageHealthInfo> GetHealthAsync(CancellationToken ct = default);

    /// <summary>
    /// Gets available storage capacity in bytes.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Available capacity in bytes, or null if unknown.</returns>
    Task<long?> GetAvailableCapacityAsync(CancellationToken ct = default);
}
```

Verify that `StorageObjectMetadata` and `StorageHealthInfo` are accessible from this namespace. They are defined in `DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs`. Check the exact namespace and add the correct `using`.
  </action>
  <verify>Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile. Verify file exists at `DataWarehouse.SDK/Storage/IObjectStorageCore.cs`.</verify>
  <done>IObjectStorageCore interface defined with Store, Retrieve, Delete, Exists, List, GetMetadata, GetHealth, GetAvailableCapacity methods. SDK compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create PathStorageAdapter translation layer</name>
  <files>DataWarehouse.SDK/Storage/PathStorageAdapter.cs</files>
  <action>
Create `DataWarehouse.SDK/Storage/PathStorageAdapter.cs`. This class wraps an `IObjectStorageCore` implementation and exposes the `IStorageProvider` (Uri-based) API for backward compatibility.

```csharp
using DataWarehouse.SDK.Contracts;
using DataWarehouse.SDK.Contracts.Storage;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace DataWarehouse.SDK.Storage;

/// <summary>
/// Translates URI-based storage operations (<see cref="IStorageProvider"/>) to
/// key-based object operations (<see cref="IObjectStorageCore"/>) per AD-04.
/// </summary>
/// <remarks>
/// <para>
/// This adapter enables backward compatibility: any code that uses the old URI-based
/// <see cref="IStorageProvider"/> interface (kernel, legacy plugins) can continue
/// working while the underlying storage is entirely key-based.
/// </para>
/// <para>
/// URI to key translation rules:
/// </para>
/// <list type="bullet">
///   <item><c>scheme://host/path/to/file.ext</c> becomes <c>path/to/file.ext</c></item>
///   <item><c>file:///C:/data/file.ext</c> becomes <c>data/file.ext</c> (drive letter stripped)</item>
///   <item><c>/simple/path</c> becomes <c>simple/path</c> (leading slash stripped)</item>
///   <item>Backslashes are normalized to forward slashes</item>
///   <item>Path traversal sequences (../, ..\) are rejected</item>
/// </list>
/// </remarks>
public sealed class PathStorageAdapter : IStorageProvider, IListableStorage
{
    private readonly IObjectStorageCore _core;
    private readonly string _scheme;

    /// <summary>
    /// Creates a new PathStorageAdapter wrapping the given object storage core.
    /// </summary>
    /// <param name="core">The key-based storage implementation to wrap.</param>
    /// <param name="scheme">The URI scheme this adapter handles (e.g., "file", "dw", "s3").</param>
    /// <exception cref="ArgumentNullException">Thrown if core or scheme is null.</exception>
    public PathStorageAdapter(IObjectStorageCore core, string scheme)
    {
        _core = core ?? throw new ArgumentNullException(nameof(core));
        _scheme = scheme ?? throw new ArgumentNullException(nameof(scheme));
    }

    /// <inheritdoc/>
    public string Scheme => _scheme;

    /// <inheritdoc/>
    public async Task SaveAsync(Uri uri, Stream data)
    {
        ArgumentNullException.ThrowIfNull(uri);
        ArgumentNullException.ThrowIfNull(data);

        var key = UriToKey(uri);
        await _core.StoreAsync(key, data);
    }

    /// <inheritdoc/>
    public async Task<Stream> LoadAsync(Uri uri)
    {
        ArgumentNullException.ThrowIfNull(uri);

        var key = UriToKey(uri);
        return await _core.RetrieveAsync(key);
    }

    /// <inheritdoc/>
    public async Task DeleteAsync(Uri uri)
    {
        ArgumentNullException.ThrowIfNull(uri);

        var key = UriToKey(uri);
        await _core.DeleteAsync(key);
    }

    /// <inheritdoc/>
    public async Task<bool> ExistsAsync(Uri uri)
    {
        ArgumentNullException.ThrowIfNull(uri);

        var key = UriToKey(uri);
        return await _core.ExistsAsync(key);
    }

    /// <summary>
    /// Lists all storage items matching a prefix URI.
    /// </summary>
    public async IAsyncEnumerable<StorageListItem> ListFilesAsync(
        string prefix = "",
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        var keyPrefix = string.IsNullOrEmpty(prefix) ? null : NormalizePath(prefix);

        await foreach (var metadata in _core.ListAsync(keyPrefix, ct))
        {
            yield return new StorageListItem
            {
                Path = metadata.Key,
                Size = metadata.Size,
                LastModified = metadata.Modified
            };
        }
    }

    #region URI/Key Translation

    /// <summary>
    /// Converts a URI to a storage key by stripping scheme, host, and normalizing the path.
    /// </summary>
    /// <param name="uri">The URI to convert.</param>
    /// <returns>A normalized storage key.</returns>
    /// <exception cref="ArgumentException">If the URI contains path traversal sequences.</exception>
    internal static string UriToKey(Uri uri)
    {
        string path;

        if (uri.IsAbsoluteUri)
        {
            // For file:///C:/path or scheme://host/path
            path = uri.IsFile ? uri.LocalPath : uri.AbsolutePath;
        }
        else
        {
            path = uri.OriginalString;
        }

        return NormalizePath(path);
    }

    /// <summary>
    /// Converts a storage key back to a URI with the adapter's scheme.
    /// </summary>
    /// <param name="key">The storage key.</param>
    /// <returns>A URI representation of the key.</returns>
    public Uri KeyToUri(string key)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(key);
        return new Uri($"{_scheme}://storage/{key}");
    }

    /// <summary>
    /// Normalizes a path string into a valid storage key.
    /// Strips leading slashes, drive letters, normalizes separators, rejects traversal.
    /// </summary>
    internal static string NormalizePath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
            return string.Empty;

        // Normalize separators
        var normalized = path.Replace('\\', '/');

        // Reject path traversal (VALID-02)
        if (normalized.Contains("../") || normalized.Contains("/..") || normalized == "..")
        {
            throw new ArgumentException(
                $"Path traversal detected in storage path: '{path}'",
                nameof(path));
        }

        // Strip leading slash
        normalized = normalized.TrimStart('/');

        // Strip Windows drive letter (e.g., "C:/path" -> "path")
        if (normalized.Length >= 2 && char.IsLetter(normalized[0]) && normalized[1] == ':')
        {
            normalized = normalized.Substring(2).TrimStart('/');
        }

        // Strip leading "./" if present
        if (normalized.StartsWith("./"))
        {
            normalized = normalized.Substring(2);
        }

        return normalized;
    }

    #endregion
}
```

**IMPORTANT:** Check whether `IStorageProvider` and `IListableStorage` interfaces exist. They should be defined in `DataWarehouse.SDK/Contracts/ProviderInterfaces.cs` or similar. Verify the exact method signatures and ensure PathStorageAdapter implements them correctly. Also check if `StorageListItem` is a known type or if it needs to be found/referenced.

If `IStorageProvider` has different method signatures than what is shown above, adjust PathStorageAdapter to match. Read the interface definition before writing.

If `IListableStorage` does not exist as a standalone interface, check if listing is part of `IStorageProvider` or `IListableStorage` in `PluginBase.cs` (around the `ListableStoragePluginBase` class).
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile.
Verify PathStorageAdapter.cs exists with correct implementations of all IStorageProvider methods.
Verify UriToKey handles: "file:///C:/data/file.ext" -> "data/file.ext", "dw://host/path/file" -> "path/file", "../traversal" throws ArgumentException.
  </verify>
  <done>PathStorageAdapter created wrapping IObjectStorageCore with IStorageProvider API. URI-to-key translation handles file/scheme URIs. Path traversal protection enforced (VALID-02). SDK compiles.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors
2. IObjectStorageCore interface aligns with IStorageStrategy contract
3. PathStorageAdapter correctly wraps IObjectStorageCore with IStorageProvider API
4. URI-to-key translation is well-defined and handles edge cases
5. Path traversal detection in NormalizePath
</verification>

<success_criteria>
- AD-04: Object/key-based storage is the canonical model (IObjectStorageCore)
- AD-04: PathStorageAdapter provides URI translation layer for backward compatibility
- VALID-02: Path traversal protection in NormalizePath
- StorageObjectMetadata reused (not duplicated)
- SDK compiles
</success_criteria>

<output>
After completion, create `.planning/phases/24-plugin-hierarchy-storage-validation/24-04-SUMMARY.md`
</output>
