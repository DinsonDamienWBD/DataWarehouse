---
phase: 24-plugin-hierarchy-storage-validation
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
  - DataWarehouse.SDK/Contracts/PluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/DataPipelinePluginBase.cs
  - DataWarehouse.SDK/Contracts/Hierarchy/NewFeaturePluginBase.cs
autonomous: true

must_haves:
  truths:
    - "IntelligenceAwarePluginBase inherits from PluginBase directly (not FeaturePluginBase)"
    - "DataPipelinePluginBase and FeaturePluginBase are sibling branches under IntelligenceAwarePluginBase"
    - "Old FeaturePluginBase in PluginBase.cs is renamed to LegacyFeaturePluginBase with [Obsolete]"
    - "New FeaturePluginBase under IntelligenceAwarePluginBase provides StartAsync/StopAsync"
    - "All 40+ plugins that inherit from IntelligenceAwarePluginBase still compile"
    - "UltimateIntelligencePlugin inherits PluginBase directly (HIER-07)"
    - "Solution builds with zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs"
      provides: "IntelligenceAwarePluginBase inheriting PluginBase"
      contains: "class IntelligenceAwarePluginBase : PluginBase"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/DataPipelinePluginBase.cs"
      provides: "DataPipelinePluginBase branch for data-flow plugins"
      contains: "class DataPipelinePluginBase : IntelligenceAwarePluginBase"
    - path: "DataWarehouse.SDK/Contracts/Hierarchy/NewFeaturePluginBase.cs"
      provides: "New FeaturePluginBase branch for service plugins"
      contains: "class FeaturePluginBase : IntelligenceAwarePluginBase"
  key_links:
    - from: "IntelligenceAwarePluginBase"
      to: "PluginBase"
      via: "direct inheritance"
      pattern: "class IntelligenceAwarePluginBase : PluginBase"
    - from: "DataPipelinePluginBase"
      to: "IntelligenceAwarePluginBase"
      via: "inheritance"
      pattern: "class DataPipelinePluginBase : IntelligenceAwarePluginBase"
    - from: "FeaturePluginBase (new)"
      to: "IntelligenceAwarePluginBase"
      via: "inheritance"
      pattern: "class FeaturePluginBase : IntelligenceAwarePluginBase"
---

<objective>
Restructure the plugin hierarchy into the target two-branch design (AD-01). Move IntelligenceAwarePluginBase from FeaturePluginBase to PluginBase (HIER-05), create DataPipelinePluginBase + FeaturePluginBase siblings (HIER-06 foundation), rename old FeaturePluginBase to LegacyFeaturePluginBase, and fix UltimateIntelligencePlugin (HIER-07).

Purpose: This is the MOST CRITICAL change in Phase 24 -- it restructures the inheritance hierarchy that all 60 plugins depend on. The two-branch design (DataPipeline + Feature) is the architectural cornerstone of AD-01.
Output: New hierarchy with IntelligenceAwarePluginBase -> {DataPipelinePluginBase, FeaturePluginBase} as siblings under PluginBase.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/ARCHITECTURE_DECISIONS.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-RESEARCH.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reparent IntelligenceAwarePluginBase and rename old FeaturePluginBase</name>
  <files>
    DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs
    DataWarehouse.SDK/Contracts/PluginBase.cs
  </files>
  <action>
**Step 1: Reparent IntelligenceAwarePluginBase (HIER-05)**

In `DataWarehouse.SDK/Contracts/IntelligenceAware/IntelligenceAwarePluginBase.cs`, line ~56:

Change:
```csharp
public abstract class IntelligenceAwarePluginBase : FeaturePluginBase, IIntelligenceAware, IIntelligenceAwareNotifiable
```
To:
```csharp
public abstract class IntelligenceAwarePluginBase : PluginBase, IIntelligenceAware, IIntelligenceAwareNotifiable
```

Add the necessary using if not present: `using DataWarehouse.SDK.Contracts;`

**CRITICAL:** IntelligenceAwarePluginBase currently inherits `StartAsync(CancellationToken)` and `StopAsync()` from FeaturePluginBase. It overrides both (line ~251 and ~275). After reparenting to PluginBase, these methods will no longer be overrides -- they become NEW virtual methods on IntelligenceAwarePluginBase.

Change these method signatures:
- `public override async Task StartAsync(CancellationToken ct)` -> `public virtual async Task StartAsync(CancellationToken ct)`
- `public override async Task StopAsync()` -> `public virtual async Task StopAsync()`

Also override the new `ExecuteAsync` from PluginBase to call `StartAsync`:
```csharp
/// <summary>
/// Executes the plugin by starting Intelligence discovery and initialization.
/// </summary>
public override async Task ExecuteAsync(CancellationToken ct = default)
{
    await StartAsync(ct);
}

/// <summary>
/// Shuts down the plugin, cleaning up Intelligence subscriptions first.
/// </summary>
public override async Task ShutdownAsync(CancellationToken ct = default)
{
    await StopAsync();
    await base.ShutdownAsync(ct);
}
```

Add `IFeaturePlugin` interface implementation directly to IntelligenceAwarePluginBase so that all downstream code expecting IFeaturePlugin still works:
```csharp
public abstract class IntelligenceAwarePluginBase : PluginBase, IIntelligenceAware, IIntelligenceAwareNotifiable, IFeaturePlugin
```

**Step 2: Rename old FeaturePluginBase in PluginBase.cs (backward compat)**

In `DataWarehouse.SDK/Contracts/PluginBase.cs`, find `FeaturePluginBase` (line ~1293):

Change:
```csharp
public abstract class FeaturePluginBase : PluginBase, IFeaturePlugin
```
To:
```csharp
[Obsolete("Use the new FeaturePluginBase from DataWarehouse.SDK.Contracts.Hierarchy namespace. This legacy base exists for backward compatibility during Phase 27 plugin migration.")]
public abstract class LegacyFeaturePluginBase : PluginBase, IFeaturePlugin
```

Update the XML doc to note it is legacy.

**Step 3: Add a type alias for backward compatibility**

Add to PluginBase.cs, right after the `LegacyFeaturePluginBase` class closing brace, a comment block:
```csharp
// NOTE: Classes that previously inherited FeaturePluginBase : PluginBase now need to either:
// 1. Inherit LegacyFeaturePluginBase (temporary, until Phase 27 migration)
// 2. Inherit the new FeaturePluginBase from DataWarehouse.SDK.Contracts.Hierarchy
// See AD-01 in ARCHITECTURE_DECISIONS.md
```

**Step 4: Update all DIRECT references to old FeaturePluginBase in PluginBase.cs**

Search PluginBase.cs for all classes that directly inherit `FeaturePluginBase`:
- `InterfacePluginBase : FeaturePluginBase` (line ~1410) -> change to `: LegacyFeaturePluginBase`
- `ConsensusPluginBase : FeaturePluginBase` (line ~2019) -> change to `: LegacyFeaturePluginBase`
- `RealTimePluginBase : FeaturePluginBase` (line ~2081) -> change to `: LegacyFeaturePluginBase`
- `ReplicationPluginBase : FeaturePluginBase` (line ~2204) -> change to `: LegacyFeaturePluginBase`
- `ContainerManagerPluginBase : FeaturePluginBase` (line ~3777) -> change to `: LegacyFeaturePluginBase`

Also search other files for direct FeaturePluginBase inheritance:
- `StoragePoolBase : FeaturePluginBase` in `StorageOrchestratorBase.cs` -> change to `: LegacyFeaturePluginBase`
- `WasmFunctionPluginBase : FeaturePluginBase` in `ActiveStoragePluginBases.cs` -> change to `: LegacyFeaturePluginBase`
- `DataVirtualizationPluginBase : FeaturePluginBase` in `ActiveStoragePluginBases.cs` -> change to `: LegacyFeaturePluginBase`
- `MediaTranscodingPluginBase : FeaturePluginBase` in `ActiveStoragePluginBases.cs` -> change to `: LegacyFeaturePluginBase`
- All AEDS plugin bases in `AedsPluginBases.cs` that inherit `FeaturePluginBase` -> change to `: LegacyFeaturePluginBase`

Use `grep -rn ": FeaturePluginBase" DataWarehouse.SDK/` to find ALL occurrences. Every one must be updated to `: LegacyFeaturePluginBase`.

**Do NOT update plugins (files in Plugins/ directory) -- that is Phase 27.**

**Step 5: Fix UltimateIntelligencePlugin base class (HIER-07)**

Find UltimateIntelligencePlugin in the Plugins directory. Change its base class from `PipelinePluginBase` to `PluginBase` directly. UltimateIntelligencePlugin IS the intelligence provider -- it must NOT inherit IntelligenceAwarePluginBase (which would create a circular dependency).

Search: `grep -rn "class UltimateIntelligencePlugin" Plugins/`

Change: `class UltimateIntelligencePlugin : PipelinePluginBase` -> `class UltimateIntelligencePlugin : PluginBase`

When removing PipelinePluginBase inheritance, UltimateIntelligencePlugin loses:
- `SubCategory` property (from DataTransformationPluginBase) -- add as a simple property: `public string SubCategory => "Intelligence";`
- `QualityLevel` property -- add: `public int QualityLevel => 100;`
- `DefaultOrder` property (from PipelinePluginBase) -- add if the plugin uses it: `public int DefaultOrder => 0;`
- `Category` override -- must override from PluginBase: `public override PluginCategory Category => PluginCategory.OrchestrationProvider;`
- `OnWrite`/`OnRead`/`OnWriteAsync`/`OnReadAsync` -- check if UltimateIntelligencePlugin actually overrides these. If it does, they need to be preserved as standalone methods. If it does NOT override them (likely), nothing to do.

**Read the UltimateIntelligencePlugin file FIRST** to understand what it actually uses from PipelinePluginBase before making changes. Preserve ALL existing functionality per AD-08.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile.
Then run `dotnet build` for the full solution -- check if plugin projects still compile. Some may fail because they inherit from IntelligenceAwarePluginBase which no longer provides FeaturePluginBase's StartAsync as an override. These should be captured but are expected to be addressed by the LegacyFeaturePluginBase rename.
  </verify>
  <done>IntelligenceAwarePluginBase inherits PluginBase directly. Old FeaturePluginBase renamed to LegacyFeaturePluginBase. All SDK-internal references updated. UltimateIntelligencePlugin inherits PluginBase directly.</done>
</task>

<task type="auto">
  <name>Task 2: Create DataPipelinePluginBase and new FeaturePluginBase</name>
  <files>
    DataWarehouse.SDK/Contracts/Hierarchy/DataPipelinePluginBase.cs
    DataWarehouse.SDK/Contracts/Hierarchy/NewFeaturePluginBase.cs
  </files>
  <action>
Create the `DataWarehouse.SDK/Contracts/Hierarchy/` directory if it does not exist.

**File 1: DataWarehouse.SDK/Contracts/Hierarchy/DataPipelinePluginBase.cs**

```csharp
using DataWarehouse.SDK.Contracts.IntelligenceAware;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace DataWarehouse.SDK.Contracts.Hierarchy;

/// <summary>
/// Abstract base class for plugins that data flows THROUGH (AD-01 DataPipeline branch).
/// Provides pipeline semantics: stage ordering, back-pressure signals, throughput tracking.
/// Examples: Encryption, Compression, Storage, Replication, Transit, Integrity.
/// </summary>
/// <remarks>
/// <para>
/// DataPipeline plugins are fundamentally different from Feature plugins:
/// </para>
/// <list type="bullet">
///   <item>Data enters, gets transformed/stored/moved, and exits</item>
///   <item>They participate in pipeline ordering (earlier stages run first)</item>
///   <item>They track throughput and can signal back-pressure</item>
///   <item>They may mutate data (encryption, compression) or persist it (storage)</item>
/// </list>
/// </remarks>
public abstract class DataPipelinePluginBase : IntelligenceAwarePluginBase
{
    /// <summary>
    /// Default execution order in the pipeline (lower = earlier).
    /// Can be overridden at runtime by the kernel.
    /// </summary>
    public virtual int DefaultPipelineOrder => 100;

    /// <summary>
    /// Whether this pipeline stage can be bypassed based on content analysis.
    /// </summary>
    public virtual bool AllowBypass => false;

    /// <summary>
    /// Stage dependencies -- other stages that must run before this one.
    /// Empty means no dependencies.
    /// </summary>
    public virtual IReadOnlyList<string> RequiredPrecedingStages => Array.Empty<string>();

    /// <summary>
    /// Stage conflicts -- stages that cannot run in the same pipeline.
    /// </summary>
    public virtual IReadOnlyList<string> IncompatibleStages => Array.Empty<string>();

    /// <summary>
    /// Whether this pipeline stage mutates data (true for encryption/compression)
    /// or persists/moves it (false for storage/replication).
    /// </summary>
    public virtual bool MutatesData => false;

    /// <summary>
    /// Gets pipeline-specific metadata for registration and AI-driven optimization.
    /// </summary>
    protected override Dictionary<string, object> GetMetadata()
    {
        var metadata = base.GetMetadata();
        metadata["PipelineBranch"] = "DataPipeline";
        metadata["DefaultPipelineOrder"] = DefaultPipelineOrder;
        metadata["AllowBypass"] = AllowBypass;
        metadata["MutatesData"] = MutatesData;
        metadata["RequiredPrecedingStages"] = RequiredPrecedingStages;
        metadata["IncompatibleStages"] = IncompatibleStages;
        return metadata;
    }
}
```

**File 2: DataWarehouse.SDK/Contracts/Hierarchy/NewFeaturePluginBase.cs**

NOTE: The file is named "NewFeaturePluginBase.cs" but the CLASS is named `FeaturePluginBase`. This avoids file name collision with the old definition in PluginBase.cs. The class name is what matters for inheritance.

```csharp
using DataWarehouse.SDK.Contracts.IntelligenceAware;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace DataWarehouse.SDK.Contracts.Hierarchy;

/// <summary>
/// Abstract base class for plugins that provide SERVICES (AD-01 Feature branch).
/// Provides service lifecycle semantics: start, stop, health reporting.
/// Examples: Security, Interface, DataManagement, Compute, Observability, Streaming.
/// </summary>
/// <remarks>
/// <para>
/// Feature plugins are fundamentally different from DataPipeline plugins:
/// </para>
/// <list type="bullet">
///   <item>They provide services/capabilities to the system (not data transformation)</item>
///   <item>They observe, enforce, or serve data (not mutate or persist it)</item>
///   <item>They have their own lifecycle (start/stop) independent of pipeline ordering</item>
///   <item>They may expose external interfaces (REST, gRPC) or enforce policies (compliance)</item>
/// </list>
/// <para>
/// This is the NEW FeaturePluginBase under IntelligenceAwarePluginBase (AD-01).
/// The old FeaturePluginBase : PluginBase has been renamed to LegacyFeaturePluginBase.
/// Plugins will be migrated from LegacyFeaturePluginBase to this class in Phase 27.
/// </para>
/// </remarks>
public abstract class FeaturePluginBase : IntelligenceAwarePluginBase
{
    /// <summary>
    /// Whether this feature supports hot-reload (reconfiguration without restart).
    /// </summary>
    public virtual bool SupportsHotReload => false;

    /// <summary>
    /// Feature category for grouping in capability registry.
    /// Override to specify (e.g., "Security", "Interface", "Compute").
    /// </summary>
    public virtual string FeatureCategory => "Generic";

    /// <summary>
    /// Gets feature-specific metadata for registration and AI-driven discovery.
    /// </summary>
    protected override Dictionary<string, object> GetMetadata()
    {
        var metadata = base.GetMetadata();
        metadata["PipelineBranch"] = "Feature";
        metadata["FeatureCategory"] = FeatureCategory;
        metadata["SupportsHotReload"] = SupportsHotReload;
        metadata["RequiresLifecycleManagement"] = true;
        return metadata;
    }
}
```

**IMPORTANT naming note:** Both new base classes are in the `DataWarehouse.SDK.Contracts.Hierarchy` namespace. The new `FeaturePluginBase` and the old `LegacyFeaturePluginBase` (in `DataWarehouse.SDK.Contracts` namespace) coexist. Code using `using DataWarehouse.SDK.Contracts.Hierarchy;` gets the NEW FeaturePluginBase. Code using `using DataWarehouse.SDK.Contracts;` gets `LegacyFeaturePluginBase`. No conflicts because the old class was renamed.

Build the SDK to verify these new files compile.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile with zero new errors.
Confirm both files exist: `DataWarehouse.SDK/Contracts/Hierarchy/DataPipelinePluginBase.cs` and `DataWarehouse.SDK/Contracts/Hierarchy/NewFeaturePluginBase.cs`.
Grep for `class DataPipelinePluginBase : IntelligenceAwarePluginBase` and `class FeaturePluginBase : IntelligenceAwarePluginBase` in the Hierarchy directory.
  </verify>
  <done>DataPipelinePluginBase and new FeaturePluginBase exist as sibling branches under IntelligenceAwarePluginBase. SDK compiles. Old FeaturePluginBase renamed to LegacyFeaturePluginBase for backward compatibility.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors
2. `dotnet build` (full solution) -- capture results, document any plugin compile errors (expected: some plugins may need Phase 27 migration)
3. IntelligenceAwarePluginBase inherits PluginBase (not FeaturePluginBase)
4. DataPipelinePluginBase : IntelligenceAwarePluginBase exists
5. New FeaturePluginBase : IntelligenceAwarePluginBase exists
6. Old FeaturePluginBase renamed to LegacyFeaturePluginBase with [Obsolete]
7. UltimateIntelligencePlugin : PluginBase (not PipelinePluginBase)
8. All SDK-internal FeaturePluginBase references updated to LegacyFeaturePluginBase
</verification>

<success_criteria>
- HIER-05: IntelligenceAwarePluginBase extends PluginBase directly
- HIER-07: UltimateIntelligencePlugin inherits PluginBase directly
- AD-01: Two-branch hierarchy (DataPipelinePluginBase + FeaturePluginBase) under IntelligenceAwarePluginBase
- All SDK .cs files compile
- Zero functionality lost from existing code (AD-08)
</success_criteria>

<output>
After completion, create `.planning/phases/24-plugin-hierarchy-storage-validation/24-02-SUMMARY.md`
</output>
