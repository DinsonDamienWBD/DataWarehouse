---
phase: 24-plugin-hierarchy-storage-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/PluginBase.cs
autonomous: true

must_haves:
  truths:
    - "PluginBase has InitializeAsync(CancellationToken), ExecuteAsync(CancellationToken), ShutdownAsync(CancellationToken) virtual methods"
    - "Existing OnHandshakeAsync and OnMessageAsync still work unchanged"
    - "Capability registry register/query/deregister all functional"
    - "Knowledge registry register/query/cache all functional"
    - "IDisposable and IAsyncDisposable implementations exist with proper Dispose(bool) pattern"
    - "Solution builds with zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "PluginBase with complete lifecycle, dispose, capability registry, knowledge registry"
      contains: "InitializeAsync"
  key_links:
    - from: "PluginBase.InitializeAsync"
      to: "PluginBase.OnHandshakeAsync"
      via: "lifecycle method wraps existing handshake plumbing"
      pattern: "virtual.*Task.*InitializeAsync.*CancellationToken"
---

<objective>
Verify and complete PluginBase foundation: add explicit lifecycle methods (HIER-02), verify capability registry (HIER-03), knowledge registry (HIER-04), and IDisposable/IAsyncDisposable (HIER-01 from Phase 23).

Purpose: PluginBase is the root of the entire plugin hierarchy. It must have a complete, well-defined lifecycle before any hierarchy restructuring begins. HIER-02 is the only net-new work; HIER-01/03/04 are verification.
Output: PluginBase.cs with InitializeAsync/ExecuteAsync/ShutdownAsync lifecycle methods added.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/ARCHITECTURE_DECISIONS.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-RESEARCH.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
@DataWarehouse.SDK/Contracts/IPlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify Phase 23 deliverables and audit existing PluginBase registries</name>
  <files>DataWarehouse.SDK/Contracts/PluginBase.cs</files>
  <action>
Verify that PluginBase already has all of the following (from Phase 23 and existing v1.0 code):

1. **HIER-01 (IDisposable/IAsyncDisposable):** Confirm PluginBase declares `: IPlugin, IDisposable, IAsyncDisposable` (line ~21), has `Dispose(bool disposing)` (line ~973), `Dispose()` with `GC.SuppressFinalize` (line ~998), `DisposeAsyncCore()` (line ~1008), and `DisposeAsync()` with `GC.SuppressFinalize` (line ~1025). If ANY of these are missing, Phase 23 did not complete -- STOP and report.

2. **HIER-03 (Capability Registry):** Confirm these members exist:
   - `CapabilityRegistry` property (IPluginCapabilityRegistry?)
   - `SetCapabilityRegistry()` method
   - `RegisterCapabilitiesAsync()` method
   - `GetCapabilityRegistrations()` method
   - `DeclaredCapabilities` property
   - `GetCapabilities()` method
   - `_registeredCapabilityIds` list for cleanup tracking
   If `UnregisterCapabilityAsync(string capabilityId)` does not exist as a public method, note it but do NOT add it yet (Phase 27 may need it).

3. **HIER-04 (Knowledge Registry):** Confirm these members exist:
   - `_knowledgeCache` (ConcurrentDictionary)
   - `RegisterKnowledgeAsync()` method
   - `HandleKnowledgeQueryAsync()` method
   - `SubscribeToKnowledgeRequests()` method
   - `GetRegistrationKnowledge()` / `GetStaticKnowledge()` methods
   - `HandleDynamicKnowledgeQueryAsync()` method
   - `CacheKnowledge()` / `GetCachedKnowledge()` / `ClearKnowledgeCache()` methods
   - `KnowledgeLake` property

Do NOT modify the file in this task. This is pure verification. Record findings.
  </action>
  <verify>Read PluginBase.cs and grep for each member listed above. All must exist. Report which are present and any that are missing.</verify>
  <done>All HIER-01, HIER-03, HIER-04 members confirmed present in PluginBase.cs, or gaps clearly documented for Task 2.</done>
</task>

<task type="auto">
  <name>Task 2: Add explicit lifecycle methods to PluginBase (HIER-02)</name>
  <files>DataWarehouse.SDK/Contracts/PluginBase.cs</files>
  <action>
Add three explicit lifecycle methods to PluginBase. Insert them in the region after `OnMessageAsync` (around line ~207) and before `DeclaredCapabilities`. These methods provide the explicit lifecycle contract required by HIER-02.

**Add these methods:**

```csharp
#region Explicit Lifecycle Methods (HIER-02)

/// <summary>
/// Initializes the plugin with the provided cancellation token.
/// Default implementation calls <see cref="OnHandshakeAsync"/> with a default request.
/// Override to add custom initialization logic. Always call base.InitializeAsync(ct).
/// </summary>
/// <param name="ct">Cancellation token for the initialization operation.</param>
/// <returns>A task representing the initialization operation.</returns>
public virtual async Task InitializeAsync(CancellationToken ct = default)
{
    ct.ThrowIfCancellationRequested();

    // Trigger the existing handshake flow which registers capabilities and knowledge
    await OnHandshakeAsync(new HandshakeRequest
    {
        RequestId = Guid.NewGuid().ToString("N"),
        Timestamp = DateTimeOffset.UtcNow
    });
}

/// <summary>
/// Executes the plugin's main processing logic.
/// Default implementation is a no-op. Override to implement plugin-specific processing.
/// For FeaturePluginBase derivatives, this maps to StartAsync.
/// For DataPipelinePluginBase derivatives, this sets up the pipeline stage.
/// </summary>
/// <param name="ct">Cancellation token for the execution operation.</param>
/// <returns>A task representing the execution operation.</returns>
public virtual Task ExecuteAsync(CancellationToken ct = default)
{
    ct.ThrowIfCancellationRequested();
    return Task.CompletedTask;
}

/// <summary>
/// Shuts down the plugin gracefully, releasing resources in preparation for disposal.
/// Default implementation unregisters from system registries. Always call base.ShutdownAsync(ct).
/// </summary>
/// <param name="ct">Cancellation token for the shutdown operation.</param>
/// <returns>A task representing the shutdown operation.</returns>
public virtual async Task ShutdownAsync(CancellationToken ct = default)
{
    try
    {
        await UnregisterFromSystemAsync();
    }
    catch (OperationCanceledException) when (ct.IsCancellationRequested)
    {
        throw;
    }
    catch
    {
        // Best effort during shutdown
    }
}

#endregion
```

**CRITICAL rules:**
- Do NOT modify any existing methods (OnHandshakeAsync, OnMessageAsync, etc.)
- Do NOT change any existing member signatures
- Do NOT remove or rename any existing code
- The new methods are `virtual` (not `abstract`) so all 60 existing plugins compile unchanged
- `InitializeAsync` wraps the existing `OnHandshakeAsync` so existing initialization plumbing is reused
- `ShutdownAsync` wraps the existing `UnregisterFromSystemAsync` for cleanup
- `ExecuteAsync` is a no-op by default -- derived bases (FeaturePluginBase, DataPipelinePluginBase) will override it

Verify `HandshakeRequest` has a parameterless constructor or adjust the initialization accordingly. If `HandshakeRequest` requires specific fields, check its definition and provide sensible defaults.
  </action>
  <verify>Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile with zero new errors/warnings. Grep PluginBase.cs for `InitializeAsync`, `ExecuteAsync`, `ShutdownAsync` to confirm all three exist.</verify>
  <done>PluginBase has InitializeAsync(CancellationToken), ExecuteAsync(CancellationToken), ShutdownAsync(CancellationToken) as virtual methods. Existing code unchanged. SDK builds.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
2. PluginBase.cs contains `InitializeAsync`, `ExecuteAsync`, `ShutdownAsync` methods
3. All existing members (OnHandshakeAsync, OnMessageAsync, CapabilityRegistry, KnowledgeLake, Dispose, DisposeAsync) unchanged
4. No `abstract` lifecycle methods -- all are `virtual` with default implementations
</verification>

<success_criteria>
- HIER-01: IDisposable/IAsyncDisposable confirmed present (Phase 23 deliverable verified)
- HIER-02: InitializeAsync, ExecuteAsync, ShutdownAsync added as virtual methods with CancellationToken
- HIER-03: Capability registry confirmed complete (register, query, deregister via cleanup)
- HIER-04: Knowledge registry confirmed complete (register, query, cache, subscribe)
- SDK compiles with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-plugin-hierarchy-storage-validation/24-01-SUMMARY.md`
</output>
