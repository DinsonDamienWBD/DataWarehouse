---
phase: 24-plugin-hierarchy-storage-validation
plan: 06
type: execute
wave: 3
depends_on: ["24-01"]
files_modified:
  - DataWarehouse.SDK/Validation/Guards.cs
  - DataWarehouse.SDK/Validation/SizeLimitOptions.cs
  - DataWarehouse.SDK/Security/PluginIdentity.cs
  - DataWarehouse.SDK/AI/SemanticAnalyzerBase.cs
  - DataWarehouse.SDK/Validation/SqlSecurity.cs
  - DataWarehouse.SDK/Validation/ValidationMiddleware.cs
  - DataWarehouse.SDK/Services/SmartFolderService.cs
  - DataWarehouse.SDK/Services/IntelligenceInterfaceService.cs
  - DataWarehouse.SDK/Security/SecretManager.cs
  - DataWarehouse.SDK/Infrastructure/ErrorHandling.cs
autonomous: true

must_haves:
  truths:
    - "Guards static class provides ArgumentNullException.ThrowIfNull, range, format, path traversal validation"
    - "All Regex instances in SDK have explicit timeout (TimeSpan.FromMilliseconds(100))"
    - "All Regex static method calls replaced with pre-compiled Regex instances with timeout"
    - "SizeLimitOptions configures maximum sizes for messages, knowledge objects, capability payloads"
    - "PluginIdentity provides cryptographic key pair for plugin identity verification"
    - "SDK compiles with zero new errors"
  artifacts:
    - path: "DataWarehouse.SDK/Validation/Guards.cs"
      provides: "Centralized guard clause methods for input validation"
      contains: "static class Guards"
    - path: "DataWarehouse.SDK/Validation/SizeLimitOptions.cs"
      provides: "Configurable size limits for incoming data"
      contains: "class SizeLimitOptions"
    - path: "DataWarehouse.SDK/Security/PluginIdentity.cs"
      provides: "Plugin cryptographic identity verification"
      contains: "class PluginIdentity"
  key_links:
    - from: "Guards"
      to: "All public SDK methods"
      via: "guard clause calls at method entry"
      pattern: "Guards\\."
    - from: "Regex"
      to: "TimeSpan"
      via: "timeout parameter on every Regex constructor"
      pattern: "new Regex\\(.*TimeSpan"
---

<objective>
Implement the input validation framework: centralized guard clauses (VALID-01), path traversal protection verification (VALID-02), configurable size limits (VALID-03), Regex timeout audit (VALID-04), and plugin identity verification (VALID-05).

Purpose: Harden all SDK boundaries against invalid/malicious input. Every public method should validate before processing. This is the security hardening layer that makes the SDK suitable for military-grade deployment.
Output: Guards.cs, SizeLimitOptions.cs, PluginIdentity.cs, and all Regex instances fixed with timeouts.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ARCHITECTURE_DECISIONS.md
@.planning/phases/24-plugin-hierarchy-storage-validation/24-RESEARCH.md
@DataWarehouse.SDK/Validation/InputValidation.cs
@DataWarehouse.SDK/Validation/SqlSecurity.cs
@DataWarehouse.SDK/Validation/ValidationMiddleware.cs
@DataWarehouse.SDK/AI/SemanticAnalyzerBase.cs
@DataWarehouse.SDK/Infrastructure/ErrorHandling.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Guards class, SizeLimitOptions, and fix ALL Regex timeouts</name>
  <files>
    DataWarehouse.SDK/Validation/Guards.cs
    DataWarehouse.SDK/Validation/SizeLimitOptions.cs
    DataWarehouse.SDK/AI/SemanticAnalyzerBase.cs
    DataWarehouse.SDK/Validation/SqlSecurity.cs
    DataWarehouse.SDK/Validation/ValidationMiddleware.cs
    DataWarehouse.SDK/Services/SmartFolderService.cs
    DataWarehouse.SDK/Services/IntelligenceInterfaceService.cs
    DataWarehouse.SDK/Security/SecretManager.cs
    DataWarehouse.SDK/Infrastructure/ErrorHandling.cs
  </files>
  <action>
**Part A: Create DataWarehouse.SDK/Validation/Guards.cs (VALID-01)**

```csharp
using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace DataWarehouse.SDK.Validation;

/// <summary>
/// Centralized guard clauses for all public SDK methods (VALID-01).
/// Use these at the entry point of every public method to validate inputs
/// before processing. Throws <see cref="ArgumentException"/> variants on failure.
/// </summary>
public static class Guards
{
    /// <summary>Default regex timeout for all pattern matching (100ms).</summary>
    public static readonly TimeSpan DefaultRegexTimeout = TimeSpan.FromMilliseconds(100);

    /// <summary>
    /// Validates that a string is not null, empty, or whitespace.
    /// </summary>
    public static string NotNullOrWhiteSpace(
        string? value,
        [CallerArgumentExpression(nameof(value))] string? paramName = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(value, paramName);
        return value;
    }

    /// <summary>
    /// Validates that an object is not null.
    /// </summary>
    public static T NotNull<T>(
        T? value,
        [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : class
    {
        ArgumentNullException.ThrowIfNull(value, paramName);
        return value;
    }

    /// <summary>
    /// Validates that a value is within a range (inclusive).
    /// </summary>
    public static T InRange<T>(
        T value,
        T min,
        T max,
        [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable<T>
    {
        if (value.CompareTo(min) < 0 || value.CompareTo(max) > 0)
        {
            throw new ArgumentOutOfRangeException(
                paramName,
                value,
                $"Value must be between {min} and {max}.");
        }
        return value;
    }

    /// <summary>
    /// Validates that a value is positive (> 0).
    /// </summary>
    public static T Positive<T>(
        T value,
        [CallerArgumentExpression(nameof(value))] string? paramName = null) where T : IComparable<T>
    {
        if (value.CompareTo(default!) <= 0)
        {
            throw new ArgumentOutOfRangeException(
                paramName,
                value,
                "Value must be positive.");
        }
        return value;
    }

    /// <summary>
    /// Validates that a string matches a regex pattern (with timeout, VALID-04).
    /// </summary>
    public static string MatchesPattern(
        string value,
        Regex pattern,
        string? errorMessage = null,
        [CallerArgumentExpression(nameof(value))] string? paramName = null)
    {
        ArgumentNullException.ThrowIfNull(value, paramName);
        try
        {
            if (!pattern.IsMatch(value))
            {
                throw new ArgumentException(
                    errorMessage ?? $"Value does not match required pattern: {pattern}",
                    paramName);
            }
        }
        catch (RegexMatchTimeoutException)
        {
            throw new ArgumentException(
                "Input validation timed out (possible ReDoS). Value rejected.",
                paramName);
        }
        return value;
    }

    /// <summary>
    /// Validates that a path does not contain traversal sequences (VALID-02).
    /// </summary>
    public static string SafePath(
        string path,
        [CallerArgumentExpression(nameof(path))] string? paramName = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path, paramName);

        // Check for path traversal patterns
        if (path.Contains("..") || path.Contains("%2e%2e", StringComparison.OrdinalIgnoreCase) ||
            path.Contains("%252e", StringComparison.OrdinalIgnoreCase))
        {
            throw new ArgumentException(
                "Path traversal detected. Path must not contain '..' or encoded equivalents.",
                paramName);
        }

        // Normalize and verify
        try
        {
            var fullPath = Path.GetFullPath(path);
            // Verify normalized path doesn't escape a reference directory
            // (caller should also verify against their root)
        }
        catch (Exception ex) when (ex is ArgumentException or PathTooLongException or NotSupportedException)
        {
            throw new ArgumentException($"Invalid path format: {ex.Message}", paramName, ex);
        }

        return path;
    }

    /// <summary>
    /// Validates that a string does not exceed the maximum length (VALID-03).
    /// </summary>
    public static string MaxLength(
        string? value,
        int maxLength,
        [CallerArgumentExpression(nameof(value))] string? paramName = null)
    {
        if (value != null && value.Length > maxLength)
        {
            throw new ArgumentException(
                $"Value length ({value.Length}) exceeds maximum allowed ({maxLength}).",
                paramName);
        }
        return value!;
    }

    /// <summary>
    /// Validates that a stream does not exceed the maximum size (VALID-03).
    /// </summary>
    public static Stream MaxSize(
        Stream stream,
        long maxSizeBytes,
        [CallerArgumentExpression(nameof(stream))] string? paramName = null)
    {
        ArgumentNullException.ThrowIfNull(stream, paramName);
        if (stream.CanSeek && stream.Length > maxSizeBytes)
        {
            throw new ArgumentException(
                $"Stream size ({stream.Length} bytes) exceeds maximum allowed ({maxSizeBytes} bytes).",
                paramName);
        }
        return stream;
    }

    /// <summary>
    /// Validates that a collection does not exceed the maximum count (VALID-03).
    /// </summary>
    public static IReadOnlyCollection<T> MaxCount<T>(
        IReadOnlyCollection<T> collection,
        int maxCount,
        [CallerArgumentExpression(nameof(collection))] string? paramName = null)
    {
        ArgumentNullException.ThrowIfNull(collection, paramName);
        if (collection.Count > maxCount)
        {
            throw new ArgumentException(
                $"Collection count ({collection.Count}) exceeds maximum allowed ({maxCount}).",
                paramName);
        }
        return collection;
    }
}
```

**Part B: Create DataWarehouse.SDK/Validation/SizeLimitOptions.cs (VALID-03)**

```csharp
namespace DataWarehouse.SDK.Validation;

/// <summary>
/// Configurable size limits for all incoming data at SDK boundaries (VALID-03).
/// </summary>
public sealed class SizeLimitOptions
{
    /// <summary>Maximum size of a single message payload in bytes. Default: 10MB.</summary>
    public long MaxMessageSizeBytes { get; set; } = 10 * 1024 * 1024;

    /// <summary>Maximum size of a knowledge object in bytes. Default: 1MB.</summary>
    public long MaxKnowledgeObjectSizeBytes { get; set; } = 1 * 1024 * 1024;

    /// <summary>Maximum size of a capability registration payload in bytes. Default: 256KB.</summary>
    public long MaxCapabilityPayloadSizeBytes { get; set; } = 256 * 1024;

    /// <summary>Maximum string length for general text inputs. Default: 10,000 chars.</summary>
    public int MaxStringLength { get; set; } = 10_000;

    /// <summary>Maximum number of items in a single collection input. Default: 10,000.</summary>
    public int MaxCollectionCount { get; set; } = 10_000;

    /// <summary>Maximum storage key length. Default: 1,024 chars.</summary>
    public int MaxStorageKeyLength { get; set; } = 1_024;

    /// <summary>Maximum metadata entries per storage object. Default: 100.</summary>
    public int MaxMetadataEntries { get; set; } = 100;

    /// <summary>Maximum size of a single storage object in bytes. Default: 5GB.</summary>
    public long MaxStorageObjectSizeBytes { get; set; } = 5L * 1024 * 1024 * 1024;

    /// <summary>Default singleton instance with standard limits.</summary>
    public static SizeLimitOptions Default { get; } = new();
}
```

**Part C: Fix ALL Regex timeouts in SDK (VALID-04)**

This is the most critical part. Search EVERY .cs file in DataWarehouse.SDK/ for:
1. `new Regex(` without a TimeSpan parameter
2. `Regex.IsMatch(`, `Regex.Match(`, `Regex.Replace(`, `Regex.Split(` static calls

**Known gaps from research:**

1. **ValidationMiddleware.cs** -- PathTraversalFilter:
   Find: `new Regex(..., RegexOptions.Compiled)` without timeout
   Fix: Add `TimeSpan.FromMilliseconds(100)` as the last parameter

2. **SemanticAnalyzerBase.cs** -- ~16+ Regex instances without timeout:
   Find ALL `new Regex(` calls. Add `TimeSpan.FromMilliseconds(100)` timeout to each.
   Find ALL `Regex.IsMatch(`, `Regex.Match(`, `Regex.Split(` static calls. Replace with pre-compiled `Regex` instance fields with timeout, OR use the overloads that accept TimeSpan:
   - `Regex.IsMatch(input, pattern)` -> `Regex.IsMatch(input, pattern, RegexOptions.None, TimeSpan.FromMilliseconds(100))`
   - `Regex.Match(input, pattern)` -> `Regex.Match(input, pattern, RegexOptions.None, TimeSpan.FromMilliseconds(100))`

3. **SqlSecurity.cs** -- 7 `Regex.IsMatch()` static calls:
   Fix each by adding timeout parameter:
   - `Regex.IsMatch(input, pattern, options)` -> `Regex.IsMatch(input, pattern, options, TimeSpan.FromMilliseconds(100))`

4. **SmartFolderService.cs** -- 1 `Regex.IsMatch()`:
   Same fix as SqlSecurity.

5. **IntelligenceInterfaceService.cs** -- 2 `Regex.Match()`:
   Same fix.

6. **SecretManager.cs** -- 1 `Regex.Match()`:
   Same fix.

7. **ErrorHandling.cs** -- Verify existing Regex uses. Research says some have timeouts, some may not. Check and fix any that lack timeout.

**Process for each file:**
1. Read the file
2. Find every `new Regex(` call -- verify it has a TimeSpan parameter; if not, add one
3. Find every `Regex.IsMatch/Match/Replace/Split(` static call -- add TimeSpan.FromMilliseconds(100) parameter
4. Wrap any Regex operations in try/catch for `RegexMatchTimeoutException` if not already handled
5. Write the fixed file

**Do NOT change the regex patterns themselves.** Only add timeouts. Preserve all existing behavior.

Build the SDK after all fixes.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile with zero new errors.
Run: `grep -rn "new Regex(" DataWarehouse.SDK/ | grep -v "TimeSpan"` -- must return ZERO results (all Regex instances have timeout).
Run: `grep -rn "Regex\.\(IsMatch\|Match\|Replace\|Split\)" DataWarehouse.SDK/ | grep -v "TimeSpan"` -- must return ZERO or only false positives (all static Regex calls have timeout).
Verify Guards.cs and SizeLimitOptions.cs exist.
  </verify>
  <done>Guards class created with NotNull, NotNullOrWhiteSpace, InRange, SafePath, MaxLength, MaxSize, MaxCount, MatchesPattern. SizeLimitOptions created with configurable limits. ALL Regex in SDK have explicit timeouts. SDK compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create plugin identity verification (VALID-05)</name>
  <files>
    DataWarehouse.SDK/Security/PluginIdentity.cs
  </files>
  <action>
Create `DataWarehouse.SDK/Security/PluginIdentity.cs` for cryptographic plugin identity verification.

```csharp
using System;
using System.Security.Cryptography;
using System.Text;

namespace DataWarehouse.SDK.Security;

/// <summary>
/// Provides cryptographic identity for plugins in distributed environments (VALID-05).
/// Each plugin instance generates an asymmetric key pair on initialization.
/// The public key is registered with the kernel for message authentication.
/// Other nodes can verify a plugin's messages using its registered public key.
/// </summary>
public sealed class PluginIdentity : IDisposable
{
    private readonly RSA _keyPair;
    private bool _disposed;

    /// <summary>
    /// Gets the plugin ID this identity belongs to.
    /// </summary>
    public string PluginId { get; }

    /// <summary>
    /// Gets the public key bytes (DER-encoded SubjectPublicKeyInfo).
    /// This is shared with other nodes for verification.
    /// </summary>
    public byte[] PublicKey { get; }

    /// <summary>
    /// Gets the public key as a Base64 string for serialization.
    /// </summary>
    public string PublicKeyBase64 => Convert.ToBase64String(PublicKey);

    /// <summary>
    /// Gets when this identity was created.
    /// </summary>
    public DateTimeOffset CreatedAt { get; }

    /// <summary>
    /// Creates a new plugin identity with a fresh RSA-2048 key pair.
    /// </summary>
    /// <param name="pluginId">The plugin ID this identity belongs to.</param>
    /// <exception cref="ArgumentException">If pluginId is null or whitespace.</exception>
    public PluginIdentity(string pluginId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(pluginId);

        PluginId = pluginId;
        _keyPair = RSA.Create(2048);
        PublicKey = _keyPair.ExportSubjectPublicKeyInfo();
        CreatedAt = DateTimeOffset.UtcNow;
    }

    /// <summary>
    /// Creates a plugin identity from an existing key pair (for persistence/restoration).
    /// </summary>
    /// <param name="pluginId">The plugin ID.</param>
    /// <param name="pkcs8PrivateKey">The PKCS#8-encoded private key bytes.</param>
    public PluginIdentity(string pluginId, byte[] pkcs8PrivateKey)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(pluginId);
        ArgumentNullException.ThrowIfNull(pkcs8PrivateKey);

        PluginId = pluginId;
        _keyPair = RSA.Create();
        _keyPair.ImportPkcs8PrivateKey(pkcs8PrivateKey, out _);
        PublicKey = _keyPair.ExportSubjectPublicKeyInfo();
        CreatedAt = DateTimeOffset.UtcNow;
    }

    /// <summary>
    /// Signs a message payload, producing a digital signature.
    /// </summary>
    /// <param name="data">The data to sign.</param>
    /// <returns>The RSA-SHA256 signature bytes.</returns>
    public byte[] Sign(byte[] data)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        ArgumentNullException.ThrowIfNull(data);

        return _keyPair.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
    }

    /// <summary>
    /// Signs a string message, producing a Base64-encoded signature.
    /// </summary>
    /// <param name="message">The message to sign.</param>
    /// <returns>Base64-encoded RSA-SHA256 signature.</returns>
    public string SignMessage(string message)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        ArgumentNullException.ThrowIfNull(message);

        var data = Encoding.UTF8.GetBytes(message);
        var signature = Sign(data);
        return Convert.ToBase64String(signature);
    }

    /// <summary>
    /// Verifies a signature against a public key.
    /// Use this on the receiving end to authenticate a plugin's message.
    /// </summary>
    /// <param name="data">The original data that was signed.</param>
    /// <param name="signature">The signature to verify.</param>
    /// <param name="publicKey">The signer's public key (DER-encoded SubjectPublicKeyInfo).</param>
    /// <returns>True if the signature is valid.</returns>
    public static bool VerifySignature(byte[] data, byte[] signature, byte[] publicKey)
    {
        ArgumentNullException.ThrowIfNull(data);
        ArgumentNullException.ThrowIfNull(signature);
        ArgumentNullException.ThrowIfNull(publicKey);

        using var rsa = RSA.Create();
        rsa.ImportSubjectPublicKeyInfo(publicKey, out _);
        return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
    }

    /// <summary>
    /// Verifies a Base64-encoded signature on a string message.
    /// </summary>
    /// <param name="message">The original message.</param>
    /// <param name="signatureBase64">Base64-encoded signature.</param>
    /// <param name="publicKeyBase64">Base64-encoded public key.</param>
    /// <returns>True if the signature is valid.</returns>
    public static bool VerifyMessage(string message, string signatureBase64, string publicKeyBase64)
    {
        ArgumentNullException.ThrowIfNull(message);
        ArgumentNullException.ThrowIfNull(signatureBase64);
        ArgumentNullException.ThrowIfNull(publicKeyBase64);

        var data = Encoding.UTF8.GetBytes(message);
        var signature = Convert.FromBase64String(signatureBase64);
        var publicKey = Convert.FromBase64String(publicKeyBase64);
        return VerifySignature(data, signature, publicKey);
    }

    /// <summary>
    /// Exports the private key for secure storage (PKCS#8 format).
    /// SECURITY: Handle with extreme care. Wipe from memory after use.
    /// </summary>
    /// <returns>PKCS#8-encoded private key bytes.</returns>
    public byte[] ExportPrivateKey()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        return _keyPair.ExportPkcs8PrivateKey();
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (_disposed) return;
        _keyPair.Dispose();
        _disposed = true;
    }
}
```

**Verify** that `DataWarehouse.SDK/Security/` directory exists. It should (SecretManager.cs is there).

This design uses RSA-2048 with SHA-256 which is FIPS 140-3 compliant (CRYPTO-05 from Phase 23). All crypto uses .NET BCL implementations -- no custom crypto.

Build the SDK after creating the file.
  </action>
  <verify>
Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- must compile.
Verify PluginIdentity.cs exists with Sign, VerifySignature, VerifyMessage, ExportPrivateKey methods.
Verify it implements IDisposable for RSA key cleanup.
  </verify>
  <done>PluginIdentity class created with RSA-2048 key pair generation, Sign/Verify methods, PKCS#8 key export/import, IDisposable for secure cleanup. FIPS-compliant (uses .NET BCL RSA). SDK compiles.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors
2. Guards.cs exists with all guard methods
3. SizeLimitOptions.cs exists with configurable limits
4. PluginIdentity.cs exists with crypto identity
5. ALL Regex in SDK have explicit timeouts (grep verification)
6. No existing functionality modified (only timeouts added to Regex)
</verification>

<success_criteria>
- VALID-01: Guards class provides centralized input validation for all public SDK methods
- VALID-02: Guards.SafePath provides path traversal protection (complementing existing SecurityRules)
- VALID-03: SizeLimitOptions provides configurable size limits for messages, knowledge, capabilities
- VALID-04: ALL Regex instances in SDK have bounded timeouts (zero remaining without timeout)
- VALID-05: PluginIdentity provides RSA-2048 key pair for cryptographic plugin identity verification
- SDK compiles with zero new errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-plugin-hierarchy-storage-validation/24-06-SUMMARY.md`
</output>
