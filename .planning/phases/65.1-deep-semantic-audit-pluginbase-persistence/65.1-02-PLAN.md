---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Utilities/BoundedDictionary.cs
  - DataWarehouse.SDK/Utilities/BoundedList.cs
  - DataWarehouse.SDK/Utilities/BoundedQueue.cs
autonomous: true

must_haves:
  truths:
    - "BoundedDictionary is a drop-in replacement for ConcurrentDictionary with LRU eviction"
    - "BoundedList provides thread-safe bounded list with configurable max size"
    - "BoundedQueue provides thread-safe bounded queue with configurable max size"
    - "All bounded collections support optional auto-persistence via IPluginStateStore"
    - "All bounded collections are thread-safe"
  artifacts:
    - path: "DataWarehouse.SDK/Utilities/BoundedDictionary.cs"
      provides: "Drop-in ConcurrentDictionary replacement with LRU eviction + persistence"
      exports: ["BoundedDictionary<TKey,TValue>"]
    - path: "DataWarehouse.SDK/Utilities/BoundedList.cs"
      provides: "Bounded thread-safe list with persistence"
      exports: ["BoundedList<T>"]
    - path: "DataWarehouse.SDK/Utilities/BoundedQueue.cs"
      provides: "Bounded thread-safe queue with persistence"
      exports: ["BoundedQueue<T>"]
  key_links:
    - from: "BoundedDictionary"
      to: "IPluginStateStore"
      via: "optional auto-persistence on modification"
      pattern: "_stateStore\\.SaveAsync"
---

<objective>
Create bounded, thread-safe, optionally-persistent collection types to replace all unbounded ConcurrentDictionary usage.

Purpose: Every plugin currently uses unbounded ConcurrentDictionary with no eviction and no persistence. These bounded collections enforce memory limits via LRU eviction and optionally persist state via IPluginStateStore.
Output: 3 new files in DataWarehouse.SDK/Utilities/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/Persistence/IPluginStateStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BoundedDictionary with LRU eviction and persistence</name>
  <files>DataWarehouse.SDK/Utilities/BoundedDictionary.cs</files>
  <action>
Create `BoundedDictionary<TKey, TValue>` in namespace `DataWarehouse.SDK.Utilities` where TKey : notnull.

**Drop-in replacement API** — must match ConcurrentDictionary surface:
- `TValue this[TKey key] { get; set; }`
- `bool TryGetValue(TKey key, out TValue value)`
- `bool TryAdd(TKey key, TValue value)`
- `bool TryRemove(TKey key, out TValue value)`
- `TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory)`
- `TValue AddOrUpdate(TKey key, TValue addValue, Func<TKey, TValue, TValue> updateValueFactory)`
- `bool ContainsKey(TKey key)`
- `int Count { get; }`
- `void Clear()`
- `IEnumerable<TKey> Keys { get; }`
- `IEnumerable<TValue> Values { get; }`
- `IEnumerable<KeyValuePair<TKey, TValue>> ToArray()`
- Implement `IEnumerable<KeyValuePair<TKey, TValue>>`

**Internal implementation:**
- Use `ReaderWriterLockSlim` for thread safety (better read perf than lock)
- Backing store: `Dictionary<TKey, LinkedListNode<(TKey Key, TValue Value)>>` for O(1) lookup
- LRU tracking: `LinkedList<(TKey Key, TValue Value)>` — move to front on access, evict from tail
- `int MaxCapacity` set in constructor (required param, no default)
- When at capacity and adding: evict LRU entry (tail of linked list), fire `OnEvicted` event

**Persistence integration:**
- Constructor overload: `BoundedDictionary(int maxCapacity, IPluginStateStore? stateStore = null, string? pluginId = null, string? stateKey = null)`
- If stateStore + pluginId + stateKey provided, auto-persist on modification (debounced: persist at most once per 5 seconds via timer)
- `Task PersistAsync(CancellationToken ct = default)` — manual persistence trigger
- `Task LoadPersistedAsync(CancellationToken ct = default)` — load from store
- Serialization: System.Text.Json, serialize as `Dictionary<string, string>` where keys/values are JSON-serialized

**Events:**
- `event Action<TKey, TValue>? OnEvicted` — fired when LRU eviction happens

Implement `IDisposable` to clean up the `ReaderWriterLockSlim` and debounce timer.

Full XML doc comments. Namespace: `DataWarehouse.SDK.Utilities`.
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — 0 errors. File exists at DataWarehouse.SDK/Utilities/BoundedDictionary.cs.</verify>
  <done>BoundedDictionary exists with full ConcurrentDictionary-compatible API, LRU eviction, optional persistence, thread safety.</done>
</task>

<task type="auto">
  <name>Task 2: Create BoundedList and BoundedQueue</name>
  <files>
    DataWarehouse.SDK/Utilities/BoundedList.cs
    DataWarehouse.SDK/Utilities/BoundedQueue.cs
  </files>
  <action>
**BoundedList&lt;T&gt;** in namespace `DataWarehouse.SDK.Utilities`:
- Thread-safe via `ReaderWriterLockSlim`
- Constructor: `BoundedList(int maxCapacity, IPluginStateStore? stateStore = null, string? pluginId = null, string? stateKey = null)`
- When at capacity: Remove oldest (index 0) on Add
- API: `void Add(T item)`, `bool Remove(T item)`, `T this[int index]`, `int Count`, `void Clear()`, `bool Contains(T item)`, `IReadOnlyList<T> ToList()`, `IEnumerator<T> GetEnumerator()`
- Same persistence pattern as BoundedDictionary (debounced auto-persist, manual PersistAsync/LoadPersistedAsync)
- Implement `IEnumerable<T>`, `IDisposable`

**BoundedQueue&lt;T&gt;** in namespace `DataWarehouse.SDK.Utilities`:
- Thread-safe via `lock` (simpler since queues are always sequential access)
- Constructor: `BoundedQueue(int maxCapacity, IPluginStateStore? stateStore = null, string? pluginId = null, string? stateKey = null)`
- When at capacity: Dequeue oldest on Enqueue (drop-oldest policy)
- API: `void Enqueue(T item)`, `bool TryDequeue(out T item)`, `bool TryPeek(out T item)`, `int Count`, `void Clear()`, `T[] ToArray()`
- Same persistence pattern
- `event Action<T>? OnDropped` — fired when oldest item dropped due to capacity
- Implement `IEnumerable<T>`, `IDisposable`

Full XML doc comments on all public members. Both files in DataWarehouse.SDK/Utilities/.
  </action>
  <verify>`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — 0 errors. Both files exist.</verify>
  <done>BoundedList and BoundedQueue exist with thread safety, bounded capacity, drop-oldest policy, optional persistence.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — 0 errors
- All 3 files in DataWarehouse.SDK/Utilities/
- BoundedDictionary has ConcurrentDictionary-compatible API
</verification>

<success_criteria>
Three bounded collection types compile and provide drop-in replacements for unbounded collections. All are thread-safe with configurable max capacity and optional auto-persistence.
</success_criteria>

<output>
After completion, create `.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-02-SUMMARY.md`
</output>
