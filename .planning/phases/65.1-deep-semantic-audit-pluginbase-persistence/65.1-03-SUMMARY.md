---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: "03"
subsystem: PluginBase / State Persistence
tags: [pluginbase, persistence, bounded-collections, state-store, lru, lifecycle]

dependency_graph:
  requires:
    - 65.1-01  # IPluginStateStore + DefaultPluginStateStore
    - 65.1-02  # BoundedDictionary + BoundedList + BoundedQueue
  provides:
    - PluginBase.StateStore property (IPluginStateStore)
    - PluginBase.CreateBoundedDictionary/List/Queue factory methods
    - PluginBase.SaveStateAsync / LoadStateAsync / DeleteStateAsync / ListStateKeysAsync
    - PluginBase.CreateCustomStateStore() override point
    - PluginBase.OnBeforeStatePersistAsync() / OnAfterStatePersistAsync() hooks
  affects:
    - All 60+ plugins that inherit PluginBase (zero code changes required in plugins)

tech_stack:
  added: []
  patterns:
    - LRU-bounded knowledge cache (replaces unbounded ConcurrentDictionary)
    - Auto-persist via BoundedDictionary debounce timer (5s after last write)
    - Tracked IDisposable collections for deterministic cleanup
    - Virtual factory pattern (CreateCustomStateStore) for backend substitution

key_files:
  modified:
    - DataWarehouse.SDK/Contracts/PluginBase.cs

decisions:
  - "_knowledgeCache uses BoundedDictionary initialized lazily in InitializeAsync so StateStore is available for auto-persist wiring"
  - "CreateCustomStateStore is virtual, not abstract — default impl uses DefaultPluginStateStore via message bus, plugins opt out by returning null"
  - "All bounded collections tracked in _trackedCollections so Dispose(bool) handles deterministic cleanup without requiring plugin overrides"
  - "Factory methods (CreateBoundedDictionary/List/Queue) auto-register with _trackedCollections — plugins cannot forget to dispose"
  - "Pre-InitializeAsync null guard added to GetCachedKnowledge / CacheKnowledge / ClearKnowledgeCache for safety"

metrics:
  duration_seconds: 127
  completed_date: "2026-02-21"
  tasks_completed: 1
  tasks_total: 1
  files_modified: 1
  lines_added: 180
  lines_removed: 18
---

# Phase 65.1 Plan 03: PluginBase Persistence Integration Summary

**One-liner:** BoundedDictionary LRU knowledge cache + IPluginStateStore lifecycle wiring + CreateBoundedDictionary/List/Queue factory methods give all 60+ plugins automatic state persistence with zero additional code.

## Objective

Integrate the persistence infrastructure built in Plans 01 and 02 (IPluginStateStore, DefaultPluginStateStore, BoundedDictionary/List/Queue) into PluginBase so every plugin inheriting from it gets state persistence, bounded collections, and lifecycle management for free.

## What Was Done

### Task 1: Add state store and bounded collection support to PluginBase

**Changes to `DataWarehouse.SDK/Contracts/PluginBase.cs`:**

1. **Using directives** — Added `using DataWarehouse.SDK.Contracts.Persistence;`, removed `using System.Collections.Concurrent;` (no longer needed).

2. **`_knowledgeCache` field** — Changed from:
   ```csharp
   private readonly ConcurrentDictionary<string, KnowledgeObject> _knowledgeCache = new();
   ```
   To:
   ```csharp
   private BoundedDictionary<string, KnowledgeObject>? _knowledgeCache;
   ```
   Now initialized lazily in `InitializeAsync` so that `StateStore` is available at construction time for auto-persist wiring.

3. **New fields and properties** added after `MessageBus`:
   - `protected IPluginStateStore? StateStore { get; private set; }` — state store initialized in `InitializeAsync`
   - `private readonly List<IDisposable> _trackedCollections = new()` — all bounded collections registered here

4. **`InitializeAsync` updated** — Before calling `OnHandshakeAsync`:
   - Calls `CreateCustomStateStore()` to initialize `StateStore`
   - Creates `BoundedDictionary<string, KnowledgeObject>` for `_knowledgeCache` with `MaxKnowledgeCacheSize` capacity, wired to `StateStore`
   - Registers the cache in `_trackedCollections`

5. **Null-safe guards** added to all pre-existing `_knowledgeCache` usages:
   - `GetCachedKnowledge`: returns `null` if cache is null
   - `CacheKnowledge`: skips assignment if cache is null; removed manual eviction logic (BoundedDictionary does LRU automatically)
   - `ClearKnowledgeCache`: uses `?.Clear()`
   - `RegisterKnowledgeAsync`: uses `if (_knowledgeCache != null)` guard

6. **`#region State Persistence` added** (after Knowledge and Capability Integration):

   | Member | Type | Purpose |
   |--------|------|---------|
   | `CreateCustomStateStore()` | `protected virtual` | Override to substitute a custom backend; default creates `DefaultPluginStateStore` via message bus |
   | `OnBeforeStatePersistAsync()` | `protected virtual` | Hook called before every `SaveStateAsync` — override for validation/encryption |
   | `OnAfterStatePersistAsync()` | `protected virtual` | Hook called after every `SaveStateAsync` — override for metrics/logging |
   | `SaveStateAsync(key, data, ct)` | `protected async` | Persists binary state; calls before/after hooks |
   | `LoadStateAsync(key, ct)` | `protected async` | Loads binary state; null-safe |
   | `DeleteStateAsync(key, ct)` | `protected async` | Removes a state entry |
   | `ListStateKeysAsync(ct)` | `protected async` | Lists all keys in plugin namespace |
   | `CreateBoundedDictionary<K,V>(name, capacity)` | `protected` | Creates tracked BoundedDictionary with auto-persist |
   | `CreateBoundedList<T>(name, capacity)` | `protected` | Creates tracked BoundedList with auto-persist |
   | `CreateBoundedQueue<T>(name, capacity)` | `protected` | Creates tracked BoundedQueue with auto-persist |

7. **`Dispose(bool)` updated** — Added loop to dispose all `_trackedCollections` entries, replacing the old `_knowledgeCache.Clear()` call (BoundedDictionary.Dispose flushes pending persistence and disposes its timer).

## Verification Results

```
dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj
Build succeeded.
    0 Warning(s)
    0 Error(s)
```

- `IPluginStateStore` matches in PluginBase.cs: lines 83, 1145, 1146
- `BoundedDictionary` matches in PluginBase.cs: lines 29, 249, 1056, 1228, 1229, 1232
- `ConcurrentDictionary` matches in PluginBase.cs: **0** (fully removed)
- `CreateCustomStateStore` match: line 1146
- `OnBeforeStatePersistAsync` / `OnAfterStatePersistAsync`: lines 1154, 1162
- `CreateBoundedDictionary` / `CreateBoundedList` / `CreateBoundedQueue`: lines 1229, 1247, 1263

## Deviations from Plan

### Auto-fixed Issues

**1. [Rule 2 - Missing Functionality] Added DeleteStateAsync and ListStateKeysAsync**
- **Found during:** Task 1 — IPluginStateStore has `DeleteAsync` and `ListKeysAsync` but the plan only specified `SaveStateAsync`/`LoadStateAsync` convenience wrappers
- **Fix:** Added `DeleteStateAsync` and `ListStateKeysAsync` as protected convenience methods to expose the full IPluginStateStore surface consistently
- **Files modified:** DataWarehouse.SDK/Contracts/PluginBase.cs
- **Commit:** 81c01be4

**2. [Rule 1 - Bug] Replaced manual eviction in CacheKnowledge with BoundedDictionary native eviction**
- **Found during:** Task 1 — old `CacheKnowledge` manually evicted the "first key" (approximate LRU) from ConcurrentDictionary; BoundedDictionary handles proper LRU automatically
- **Fix:** Removed the 6-line manual eviction block; kept only the null-guard and the assignment
- **Files modified:** DataWarehouse.SDK/Contracts/PluginBase.cs
- **Commit:** 81c01be4

## Commits

| Hash | Message |
|------|---------|
| 81c01be4 | feat(65.1-03): integrate persistence infrastructure into PluginBase |

## Self-Check: PASSED

- [x] `DataWarehouse.SDK/Contracts/PluginBase.cs` exists and was modified
- [x] Commit `81c01be4` exists
- [x] Build: 0 errors, 0 warnings
- [x] IPluginStateStore property present in PluginBase
- [x] BoundedDictionary used for _knowledgeCache
- [x] ConcurrentDictionary fully removed
- [x] All override points (CreateCustomStateStore, OnBefore/AfterStatePersistAsync) present
- [x] All factory methods (CreateBoundedDictionary/List/Queue) present
