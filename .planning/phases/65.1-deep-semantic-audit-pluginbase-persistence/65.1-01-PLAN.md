---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/Persistence/IPluginStateStore.cs
  - DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs
  - DataWarehouse.SDK/Contracts/Persistence/DefaultPluginStateStore.cs
  - DataWarehouse.SDK/Contracts/Persistence/PluginStateEntry.cs
autonomous: true

must_haves:
  truths:
    - "IPluginStateStore defines Save/Load/Delete/ListKeys for plugin state"
    - "IPersistentBackingStore defines the backend contract for state storage"
    - "DefaultPluginStateStore routes state operations through message bus to storage provider"
    - "State paths follow convention dw://internal/plugin-state/{PluginId}/{key}"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/Persistence/IPluginStateStore.cs"
      provides: "Plugin state store interface"
      exports: ["IPluginStateStore"]
    - path: "DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs"
      provides: "Backend contract for persistent state storage"
      exports: ["IPersistentBackingStore"]
    - path: "DataWarehouse.SDK/Contracts/Persistence/DefaultPluginStateStore.cs"
      provides: "Default implementation using message bus"
      exports: ["DefaultPluginStateStore"]
    - path: "DataWarehouse.SDK/Contracts/Persistence/PluginStateEntry.cs"
      provides: "Serializable state entry model"
      exports: ["PluginStateEntry"]
  key_links:
    - from: "DefaultPluginStateStore"
      to: "IMessageBus"
      via: "PublishAndWaitAsync for storage operations"
      pattern: "PublishAndWaitAsync.*plugin-state"
---

<objective>
Create the plugin state persistence interfaces and default implementation in the SDK.

Purpose: Foundation for all plugin persistence — IPluginStateStore is the contract plugins use, IPersistentBackingStore is the backend contract, DefaultPluginStateStore routes through message bus to whatever storage provider is configured.
Output: 4 new files in DataWarehouse.SDK/Contracts/Persistence/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Contracts/PluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state persistence contracts and default implementation</name>
  <files>
    DataWarehouse.SDK/Contracts/Persistence/IPluginStateStore.cs
    DataWarehouse.SDK/Contracts/Persistence/IPersistentBackingStore.cs
    DataWarehouse.SDK/Contracts/Persistence/DefaultPluginStateStore.cs
    DataWarehouse.SDK/Contracts/Persistence/PluginStateEntry.cs
  </files>
  <action>
Create directory `DataWarehouse.SDK/Contracts/Persistence/`.

**PluginStateEntry.cs**: Serializable model for state entries. Fields: `string Key`, `byte[] Data`, `string ContentType` (default "application/json"), `DateTime LastModified`, `Dictionary<string,string> Metadata`. Use `System.Text.Json` serialization attributes.

**IPluginStateStore.cs**: Interface in namespace `DataWarehouse.SDK.Contracts.Persistence`.
Methods (all async with CancellationToken):
- `Task SaveAsync(string pluginId, string key, byte[] data, CancellationToken ct)`
- `Task<byte[]?> LoadAsync(string pluginId, string key, CancellationToken ct)`
- `Task DeleteAsync(string pluginId, string key, CancellationToken ct)`
- `Task<IReadOnlyList<string>> ListKeysAsync(string pluginId, CancellationToken ct)`
- `Task<bool> ExistsAsync(string pluginId, string key, CancellationToken ct)`

Path convention helper: `static string BuildPath(string pluginId, string key) => $"dw://internal/plugin-state/{pluginId}/{key}";`

**IPersistentBackingStore.cs**: Backend contract for state store implementations.
Methods:
- `Task WriteAsync(string path, byte[] data, CancellationToken ct)`
- `Task<byte[]?> ReadAsync(string path, CancellationToken ct)`
- `Task DeleteAsync(string path, CancellationToken ct)`
- `Task<IReadOnlyList<string>> ListAsync(string prefix, CancellationToken ct)`
- `Task<bool> ExistsAsync(string path, CancellationToken ct)`

**DefaultPluginStateStore.cs**: Implements `IPluginStateStore`. Constructor takes `IMessageBus messageBus`.
- Uses message bus to publish storage operations to topic `dw.internal.plugin-state.write` / `.read` / `.delete` / `.list` / `.exists`
- Message payload contains the `dw://internal/plugin-state/{pluginId}/{key}` path
- Save: publishes PluginMessage with Data containing serialized PluginStateEntry to write topic
- Load: publishes request to read topic, awaits response via PublishAndWaitAsync
- Also accepts an optional `IPersistentBackingStore` for direct backend access (fallback when message bus not available)
- All methods validate inputs (null checks, empty string checks) and throw ArgumentException

Follow existing SDK patterns: XML doc comments on all public members, namespace `DataWarehouse.SDK.Contracts.Persistence`, no external dependencies.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` completes with 0 errors. All 4 files exist. `IPluginStateStore` has 5 methods. `DefaultPluginStateStore` implements all 5.
  </verify>
  <done>State persistence contracts and default implementation exist in SDK, build succeeds, path convention enforced.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — 0 errors
- All 4 files in DataWarehouse.SDK/Contracts/Persistence/
- DefaultPluginStateStore references IMessageBus (not direct storage)
</verification>

<success_criteria>
IPluginStateStore, IPersistentBackingStore, DefaultPluginStateStore, and PluginStateEntry exist and compile. DefaultPluginStateStore routes through message bus with dw://internal/plugin-state/{PluginId}/{key} path convention.
</success_criteria>

<output>
After completion, create `.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-01-SUMMARY.md`
</output>
