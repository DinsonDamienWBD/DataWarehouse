---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: 04
type: execute
wave: 3
depends_on: ["65.1-03"]
files_modified:
  - Metadata/deep-audit-analyzer.py
  - Metadata/deep-audit-report.json
autonomous: true

must_haves:
  truths:
    - "Audit script scans ALL .cs files in the solution"
    - "Detects: Task.CompletedTask stubs, yield break stubs, delegate passthrough, NotImplementedException, empty catch, hardcoded limits, ConcurrentDictionary, sync-over-async, thread safety issues, empty return values"
    - "Generates structured JSON report with file, line, category, severity, code snippet"
    - "Report categorizes findings by severity: critical, high, medium, low"
  artifacts:
    - path: "Metadata/deep-audit-analyzer.py"
      provides: "Python script for deep semantic code audit"
    - path: "Metadata/deep-audit-report.json"
      provides: "Structured audit findings"
  key_links:
    - from: "deep-audit-analyzer.py"
      to: "all .cs files"
      via: "recursive file scanning"
      pattern: "glob.*\\.cs"
---

<objective>
Create and run a comprehensive deep audit script that finds ALL silent stubs, anti-patterns, and production-readiness issues across the entire codebase.

Purpose: Part B of the phase — automated discovery of every issue that grep-based searches miss. The audit findings drive Wave 4 fix plans.
Output: Python audit script + JSON report with every finding categorized and located
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deep semantic audit analyzer</name>
  <files>Metadata/deep-audit-analyzer.py</files>
  <action>
Create a Python script that scans all .cs files and detects the following categories:

**Category 1: Silent Stubs (severity: critical)**
- `Task.CompletedTask` returns in methods that have meaningful names (not default lifecycle methods like OnMessageAsync, ActivateAsync, ExecuteAsync in PluginBase itself). Detect: method body is ONLY `=> Task.CompletedTask;` or `return Task.CompletedTask;` AND method name suggests it should do work (Publish, Subscribe, Execute, Process, Handle, Send, Write, Save, Apply).
- `yield break` in IAsyncEnumerable methods that should produce items (method name contains: Get, List, Enumerate, Subscribe, Stream, Query, Find, Search).
- Methods returning `default(T)`, `null`, empty array/list/dictionary as the ONLY action (not as a fallback).

**Category 2: No-Op Patterns (severity: high)**
- Delegate passthrough: method receives a strategy/policy/handler parameter but never uses it — calls the inner function directly. Detect: parameter named `strategy`, `policy`, `handler`, `processor`, `filter` that never appears in the method body after the parameter declaration.
- `NotSupportedException` / `NotImplementedException` thrown in non-abstract, non-interface methods.
- Empty catch blocks: `catch` with empty body or only a comment.

**Category 3: Unbounded Collections (severity: high)**
- `ConcurrentDictionary<` usage anywhere in Plugins/ or DataWarehouse.SDK/ (should be BoundedDictionary after migration)
- `new Dictionary<` or `new List<` assigned to class fields without bounds

**Category 4: Sync-over-Async (severity: high)**
- `.GetAwaiter().GetResult()` anywhere
- `.Result` property access on Task (but NOT `Task.FromResult`, `TaskCompletionSource`, or property declarations named `Result`)
- `.Wait()` on Task objects

**Category 5: Obsolete Code (severity: medium)**
- `[Obsolete` attribute on any member
- Files containing `#pragma warning disable CS0618` (obsolete warning suppression)

**Category 6: Hardcoded Limits (severity: low)**
- Magic numbers in collection capacity: `new Dictionary<.*>(1000)`, array allocations with literals > 100
- Hardcoded timeouts: `TimeSpan.FromSeconds(30)`, `TimeSpan.FromMinutes(5)` etc. that aren't in configuration classes

**Implementation:**
- Use Python regex-based scanning (no Roslyn dependency needed — patterns are clear enough for regex)
- Scan ALL .cs files under the repo root, excluding bin/, obj/, .planning/
- For each finding: record `file` (relative path), `line` (number), `category`, `severity`, `pattern` (which rule matched), `snippet` (the matching line + 2 lines context)
- Output: Write `Metadata/deep-audit-report.json` as a JSON array of findings
- Also print summary to stdout: count by category and severity
- EXCLUDE known-safe patterns: PluginBase.cs lifecycle methods (ActivateAsync, ExecuteAsync, CheckHealthAsync, OnMessageAsync), test files, benchmark files

The script must be robust — handle encoding errors gracefully (use `errors='replace'`), large files, and binary files mixed in.
  </action>
  <verify>Run `python Metadata/deep-audit-analyzer.py` and confirm it completes without errors. Check `Metadata/deep-audit-report.json` exists and contains findings. Verify known issues appear: UltimateStreamingData PublishAsync, UltimateResilience ExecuteWithResilienceAsync, ChaosVaccination .GetAwaiter().GetResult().</verify>
  <done>Audit script runs against full codebase, produces structured JSON report with all findings categorized. Known issues (UltimateStreamingData stubs, UltimateResilience no-op, sync-over-async in ChaosVaccination) appear in report.</done>
</task>

</tasks>

<verification>
- `python Metadata/deep-audit-analyzer.py` exits 0
- `Metadata/deep-audit-report.json` is valid JSON
- Report contains findings in categories 1-6
- Known issues are detected (spot-check 3+ known findings)
</verification>

<success_criteria>
Comprehensive audit report exists with categorized findings covering all .cs files. All known issues from phase scope are detected. Report structure supports automated processing by Wave 4 fix plans.
</success_criteria>

<output>
After completion, create `.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-04-SUMMARY.md`
</output>
