---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: 07
type: execute
wave: 4
depends_on: ["65.1-03", "65.1-04"]
files_modified:
  - Plugins/**/*.cs
  - DataWarehouse.SDK/**/*.cs
  - DataWarehouse.Kernel/**/*.cs
  - DataWarehouse.Shared/**/*.cs
autonomous: true

must_haves:
  truths:
    - "Zero unbounded ConcurrentDictionary remains in any plugin"
    - "All ConcurrentDictionary replaced with BoundedDictionary with appropriate capacity"
    - "Zero [Obsolete] attributes remain in codebase — obsolete code deleted"
    - "All audit findings from Part B addressed"
  artifacts:
    - path: "Plugins/"
      provides: "All 60+ plugins migrated to BoundedDictionary"
    - path: "DataWarehouse.SDK/"
      provides: "SDK code migrated to BoundedDictionary"
  key_links:
    - from: "every plugin"
      to: "BoundedDictionary"
      via: "direct construction or PluginBase.CreateBoundedDictionary"
      pattern: "BoundedDictionary|CreateBoundedDictionary"
---

<objective>
Migrate ALL ConcurrentDictionary instances to BoundedDictionary, delete ALL [Obsolete] code, and fix remaining audit findings.

Purpose: ConcurrentDictionary is unbounded (memory leak risk) and non-persistent. Migration to BoundedDictionary enforces memory limits and enables auto-persistence. Obsolete code must be completely deleted since DW hasn't shipped (no backward compat needed).
Output: Zero ConcurrentDictionary in plugins, zero [Obsolete] attributes, all audit findings resolved
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-02-SUMMARY.md
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-03-SUMMARY.md
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-04-SUMMARY.md
@Metadata/deep-audit-report.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate all ConcurrentDictionary to BoundedDictionary in plugins</name>
  <files>Plugins/**/*.cs</files>
  <action>
This is a large mechanical migration across ~50 files with ~142 ConcurrentDictionary occurrences in plugins.

**Step 1:** Read audit report for all "unbounded_collection" findings in Plugins/.

**Step 2:** For each file containing ConcurrentDictionary:

**In plugin main classes (classes extending PluginBase):**
- If the ConcurrentDictionary is a class field initialized in constructor: replace with a call to `CreateBoundedDictionary<K,V>("descriptive-name", capacity)` in InitializeAsync or a lazy init pattern.
- Choose capacity based on the dictionary's purpose:
  - Caches: 10,000 (default)
  - Session/connection tracking: 1,000
  - Configuration/settings: 500
  - Metrics/counters: 5,000
  - Strategy registries: 200
  - Small lookup tables: 100

**In non-plugin classes (helpers, strategy classes, etc.):**
- Replace `ConcurrentDictionary<K,V>` with `BoundedDictionary<K,V>` directly
- Add capacity parameter to constructor
- No persistence needed for internal helper classes (just pass null for stateStore)

**Migration pattern:**
```csharp
// BEFORE
private readonly ConcurrentDictionary<string, SomeType> _cache = new();

// AFTER (in plugin class)
private BoundedDictionary<string, SomeType>? _cache;
// In InitializeAsync:
_cache = CreateBoundedDictionary<string, SomeType>("cache", 10_000);

// AFTER (in non-plugin class)
private readonly BoundedDictionary<string, SomeType> _cache;
// In constructor:
_cache = new BoundedDictionary<string, SomeType>(10_000);
```

**API changes needed:**
- `ConcurrentDictionary.TryAdd` -> `BoundedDictionary.TryAdd` (same API)
- `ConcurrentDictionary.TryGetValue` -> `BoundedDictionary.TryGetValue` (same API)
- `ConcurrentDictionary.TryRemove` -> `BoundedDictionary.TryRemove` (same API)
- `ConcurrentDictionary.GetOrAdd` -> `BoundedDictionary.GetOrAdd` (same API)
- `ConcurrentDictionary.AddOrUpdate` -> `BoundedDictionary.AddOrUpdate` (same API)
- `ConcurrentDictionary[key]` -> `BoundedDictionary[key]` (same API)
- `ConcurrentDictionary.Keys` -> `BoundedDictionary.Keys` (same API)
- `ConcurrentDictionary.Values` -> `BoundedDictionary.Values` (same API)
- `ConcurrentDictionary.Count` -> `BoundedDictionary.Count` (same API)

Add `using DataWarehouse.SDK.Utilities;` where needed. Remove `using System.Collections.Concurrent;` if no longer needed.

**Work through ALL 50 files systematically.** Process in batches by plugin to keep builds green. Build after each batch.

DO NOT skip any file. The goal is ZERO ConcurrentDictionary in plugins.
  </action>
  <verify>
Grep for `ConcurrentDictionary` in Plugins/ — 0 matches (excluding comments). `dotnet build DataWarehouse.sln` — 0 errors.
  </verify>
  <done>All ~142 ConcurrentDictionary occurrences in plugins replaced with BoundedDictionary. Every collection has an explicit capacity limit.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate ConcurrentDictionary in SDK/Kernel/Shared and delete obsolete code</name>
  <files>
    DataWarehouse.SDK/**/*.cs
    DataWarehouse.Kernel/**/*.cs
    DataWarehouse.Shared/**/*.cs
  </files>
  <action>
**Part A: Migrate remaining ConcurrentDictionary (SDK, Kernel, Shared)**

Using the audit report, find all ConcurrentDictionary in:
- DataWarehouse.SDK/ (~30 occurrences across ~15 files based on earlier grep)
- DataWarehouse.Kernel/ (~30 occurrences across ~10 files)
- DataWarehouse.Shared/ (~15 occurrences across ~5 files)

Apply same migration pattern as Task 1. For SDK infrastructure classes (MessageBus, PluginRegistry, etc.), choose higher capacities:
- MessageBus subscriber tracking: 10,000
- Plugin registry: 500
- Kernel storage: 10,000
- Validation caches: 5,000

**Part B: Delete ALL [Obsolete] code**

From the audit report, 17 [Obsolete] occurrences across 16 files. For each:
1. Read the obsolete attribute message to find what replaces it
2. Verify the replacement exists and is functional
3. Check if anything still references the obsolete member
4. If referenced: update references to use the replacement
5. COMPLETELY DELETE the obsolete member/file (do NOT keep for compat — DW hasn't shipped)
6. Remove any `#pragma warning disable CS0618` suppressions

Files with [Obsolete] include:
- DataWarehouse.Kernel/Storage/ContainerManager.cs
- DataWarehouse.Kernel/PluginRegistry.cs
- Plugins/DataWarehouse.Plugins.AirGapBridge/Security/SecurityManager.cs
- DataWarehouse.Shared/Services/PortableMediaDetector.cs
- DataWarehouse.Shared/CommandRegistry.cs
- DataWarehouse.SDK/Security/IKeyStore.cs
- DataWarehouse.SDK/Replication/IMultiMasterReplication.cs
- Several plugin files

**Part C: Fix remaining audit findings**

Read the complete audit report and fix any remaining critical/high findings not addressed by Plans 05 and 06:
- Empty catch blocks: add proper logging or re-throw
- NotImplementedException in non-abstract methods: implement or remove
- Additional silent stubs found by the analyzer

Build after each batch of changes.
  </action>
  <verify>
Grep for `ConcurrentDictionary` across entire solution (excluding bin/obj/Tests/Benchmarks) — 0 matches. Grep for `[Obsolete` across entire solution — 0 matches. Grep for `CS0618` pragma — 0 matches. `dotnet build DataWarehouse.sln` — 0 errors.
  </verify>
  <done>Zero ConcurrentDictionary in production code. Zero [Obsolete] attributes. All critical/high audit findings resolved. Full solution builds clean.</done>
</task>

</tasks>

<verification>
- `grep -r "ConcurrentDictionary" --include="*.cs" --exclude-dir=bin --exclude-dir=obj --exclude-dir=Tests --exclude-dir=Benchmarks` — 0 matches
- `grep -r "\[Obsolete" --include="*.cs" --exclude-dir=bin --exclude-dir=obj` — 0 matches
- `dotnet build DataWarehouse.sln` — 0 errors
</verification>

<success_criteria>
Zero unbounded ConcurrentDictionary anywhere in production code. Zero [Obsolete] code. All audit findings addressed. Full solution builds clean.
</success_criteria>

<output>
After completion, create `.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-07-SUMMARY.md`
</output>
