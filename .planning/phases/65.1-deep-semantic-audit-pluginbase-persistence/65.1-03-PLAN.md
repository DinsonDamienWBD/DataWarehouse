---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: 03
type: execute
wave: 2
depends_on: ["65.1-01", "65.1-02"]
files_modified:
  - DataWarehouse.SDK/Contracts/PluginBase.cs
autonomous: true

must_haves:
  truths:
    - "PluginBase provides automatic state persistence to all 60+ plugins without additional code"
    - "Plugins can override CreateCustomStateStore() for custom backends"
    - "Plugins can override OnBeforeStatePersistAsync() and OnAfterStatePersistAsync() for hooks"
    - "PluginBase._knowledgeCache uses BoundedDictionary instead of ConcurrentDictionary"
    - "PluginBase exposes CreateBoundedDictionary/CreateBoundedList/CreateBoundedQueue helper methods"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/PluginBase.cs"
      provides: "Updated base class with persistence integration"
      contains: "IPluginStateStore"
  key_links:
    - from: "PluginBase"
      to: "IPluginStateStore"
      via: "StateStore property initialized in InitializeAsync"
      pattern: "StateStore.*IPluginStateStore"
    - from: "PluginBase"
      to: "BoundedDictionary"
      via: "_knowledgeCache field type"
      pattern: "BoundedDictionary.*_knowledgeCache"
---

<objective>
Integrate persistence infrastructure into PluginBase so all 60+ plugins get automatic state persistence for free.

Purpose: Every plugin currently uses unbounded ConcurrentDictionary with no persistence. After this plan, PluginBase provides state store access, bounded collection factory methods, and automatic lifecycle management. Zero additional code needed in plugins for basic state persistence.
Output: Updated PluginBase.cs with full persistence integration
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@DataWarehouse.SDK/Contracts/PluginBase.cs
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-01-SUMMARY.md
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state store and bounded collection support to PluginBase</name>
  <files>DataWarehouse.SDK/Contracts/PluginBase.cs</files>
  <action>
Read the full PluginBase.cs (1205 lines). Make these targeted additions — do NOT rewrite the file, only add/modify specific sections:

**1. Add using directives** (top of file):
- `using DataWarehouse.SDK.Contracts.Persistence;`
- `using DataWarehouse.SDK.Utilities;`

**2. Replace _knowledgeCache field** (line 27):
Change: `private readonly ConcurrentDictionary<string, KnowledgeObject> _knowledgeCache = new();`
To: `private BoundedDictionary<string, KnowledgeObject>? _knowledgeCache;`
Initialize it lazily in InitializeAsync (after StateStore is available) with `MaxKnowledgeCacheSize` capacity and auto-persistence.

**3. Add state store properties and fields** (after the MessageBus property, around line 74):
```csharp
/// <summary>
/// State store for persisting plugin state. Initialized during InitializeAsync.
/// Plugins get this for free — no additional code needed for basic state persistence.
/// </summary>
protected IPluginStateStore? StateStore { get; private set; }

/// <summary>
/// Tracked bounded collections for automatic disposal.
/// </summary>
private readonly List<IDisposable> _trackedCollections = new();
```

**4. Add virtual override points** (new region after Knowledge and Capability Integration):
```csharp
#region State Persistence

/// <summary>
/// Override to provide a custom state store implementation.
/// Default uses DefaultPluginStateStore via message bus.
/// </summary>
protected virtual IPluginStateStore? CreateCustomStateStore()
    => MessageBus != null ? new DefaultPluginStateStore(MessageBus) : null;

/// <summary>
/// Called before state is persisted. Override for validation or transformation.
/// </summary>
protected virtual Task OnBeforeStatePersistAsync(CancellationToken ct = default)
    => Task.CompletedTask;

/// <summary>
/// Called after state is successfully persisted. Override for logging or notifications.
/// </summary>
protected virtual Task OnAfterStatePersistAsync(CancellationToken ct = default)
    => Task.CompletedTask;

/// <summary>
/// Saves arbitrary state for this plugin. Uses the state store.
/// </summary>
protected async Task SaveStateAsync(string key, byte[] data, CancellationToken ct = default)
{
    if (StateStore == null) return;
    await OnBeforeStatePersistAsync(ct);
    await StateStore.SaveAsync(Id, key, data, ct);
    await OnAfterStatePersistAsync(ct);
}

/// <summary>
/// Loads previously saved state for this plugin.
/// </summary>
protected async Task<byte[]?> LoadStateAsync(string key, CancellationToken ct = default)
    => StateStore != null ? await StateStore.LoadAsync(Id, key, ct) : null;

#endregion
```

**5. Add bounded collection factory methods** (in the State Persistence region):
```csharp
/// <summary>
/// Creates a bounded dictionary tracked by this plugin's lifecycle.
/// Auto-persists if state store is available.
/// </summary>
protected BoundedDictionary<TKey, TValue> CreateBoundedDictionary<TKey, TValue>(
    string collectionName, int maxCapacity) where TKey : notnull
{
    var dict = new BoundedDictionary<TKey, TValue>(
        maxCapacity, StateStore, Id, $"collection.{collectionName}");
    _trackedCollections.Add(dict);
    return dict;
}

/// <summary>
/// Creates a bounded list tracked by this plugin's lifecycle.
/// </summary>
protected BoundedList<T> CreateBoundedList<T>(string collectionName, int maxCapacity)
{
    var list = new BoundedList<T>(maxCapacity, StateStore, Id, $"collection.{collectionName}");
    _trackedCollections.Add(list);
    return list;
}

/// <summary>
/// Creates a bounded queue tracked by this plugin's lifecycle.
/// </summary>
protected BoundedQueue<T> CreateBoundedQueue<T>(string collectionName, int maxCapacity)
{
    var queue = new BoundedQueue<T>(maxCapacity, StateStore, Id, $"collection.{collectionName}");
    _trackedCollections.Add(queue);
    return queue;
}
```

**6. Modify InitializeAsync** (around line 225):
Add after the handshake call:
```csharp
// Initialize state persistence
StateStore = CreateCustomStateStore();

// Initialize knowledge cache with bounded dictionary (now that StateStore is available)
_knowledgeCache = new BoundedDictionary<string, KnowledgeObject>(
    MaxKnowledgeCacheSize, StateStore, Id, "knowledge-cache");
_trackedCollections.Add(_knowledgeCache);
```

**7. Update all _knowledgeCache usages** throughout PluginBase to handle the nullable type. The cache is only used after InitializeAsync, so add null checks (`_knowledgeCache?.TryGetValue(...)` etc.) or use a local variable pattern.

**8. Update Dispose/DisposeAsync** to dispose all tracked collections:
In the existing Dispose(bool disposing) method, add:
```csharp
foreach (var collection in _trackedCollections)
{
    collection.Dispose();
}
_trackedCollections.Clear();
```

**IMPORTANT:** Preserve ALL existing functionality. This is additive — do not remove or restructure existing methods. The existing 1205 lines of PluginBase logic must remain intact.
  </action>
  <verify>
`dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — 0 errors. Grep for `IPluginStateStore` in PluginBase.cs returns matches. Grep for `BoundedDictionary` in PluginBase.cs returns matches. Grep for `ConcurrentDictionary` in PluginBase.cs returns 0 matches. Grep for `CreateCustomStateStore` confirms override point exists.
  </verify>
  <done>PluginBase has state persistence built in. All plugins inherit StateStore, CreateBoundedDictionary/List/Queue, SaveStateAsync/LoadStateAsync. _knowledgeCache uses BoundedDictionary. Override points exist for custom backends and persistence hooks.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` — 0 errors
- PluginBase.cs contains IPluginStateStore, BoundedDictionary, no ConcurrentDictionary
- Override points: CreateCustomStateStore, OnBeforeStatePersistAsync, OnAfterStatePersistAsync
- Factory methods: CreateBoundedDictionary, CreateBoundedList, CreateBoundedQueue
</verification>

<success_criteria>
PluginBase provides automatic state persistence. All 60+ plugins inherit persistence capability with zero code changes. Knowledge cache is bounded. Override points exist for customization.
</success_criteria>

<output>
After completion, create `.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-03-SUMMARY.md`
</output>
