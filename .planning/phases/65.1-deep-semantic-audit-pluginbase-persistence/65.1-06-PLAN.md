---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: 06
type: execute
wave: 4
depends_on: ["65.1-04"]
files_modified:
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/**/*.cs
  - Plugins/DataWarehouse.Plugins.Virtualization.SqlOverObject/**/*.cs
  - Plugins/DataWarehouse.Plugins.UltimateSustainability/**/*.cs
  - Plugins/DataWarehouse.Plugins.UltimateSDKPorts/**/*.cs
  - DataWarehouse.SDK/**/*.cs
  - DataWarehouse.Kernel/**/*.cs
  - DataWarehouse.Shared/**/*.cs
autonomous: true

must_haves:
  truths:
    - "Zero .GetAwaiter().GetResult() calls remain in any plugin"
    - "Zero .Result property access on Task in any plugin (excluding TaskCompletionSource and Task.FromResult)"
    - "All sync-over-async patterns replaced with proper async/await"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/"
      provides: "ChaosVaccination with all 8 sync-over-async fixed"
    - path: "Plugins/DataWarehouse.Plugins.Virtualization.SqlOverObject/"
      provides: "SqlOverObject with all 3 sync-over-async fixed"
    - path: "Plugins/DataWarehouse.Plugins.UltimateSustainability/"
      provides: "UltimateSustainability with sync-over-async fixed"
    - path: "Plugins/DataWarehouse.Plugins.UltimateSDKPorts/"
      provides: "UltimateSDKPorts with sync-over-async fixed"
    - path: "DataWarehouse.SDK/"
      provides: "SDK code with any .Result calls fixed"
    - path: "DataWarehouse.Kernel/"
      provides: "Kernel code with any .Result calls fixed"
  key_links: []
---

<objective>
Eliminate ALL sync-over-async patterns (.GetAwaiter().GetResult() and .Result) across all plugins.

Purpose: Sync-over-async causes thread pool starvation and deadlocks in production. Known locations: ChaosVaccination (8), SqlOverObject (3), Sustainability (1), CrossLanguageSdkPorts/UltimateSDKPorts (1). Also fix any additional findings from the audit report.
Output: Zero sync-over-async patterns in any plugin
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-04-SUMMARY.md
@Metadata/deep-audit-report.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix sync-over-async in ChaosVaccination and SqlOverObject</name>
  <files>
    Plugins/DataWarehouse.Plugins.ChaosVaccination/**/*.cs
    Plugins/DataWarehouse.Plugins.Virtualization.SqlOverObject/**/*.cs
  </files>
  <action>
**Step 1:** Read the audit report `Metadata/deep-audit-report.json` and filter for category "sync-over-async" to get the complete list of affected files and lines.

**Step 2:** For each `.GetAwaiter().GetResult()` and `.Result` on Task:

The fix pattern depends on the calling context:

**A. Method can be made async:**
Change the method signature to `async Task<T>` (or `async Task`) and replace `.GetAwaiter().GetResult()` with `await`. This is the PREFERRED fix. Most cases fall here.

Example:
```csharp
// BEFORE
public void DoWork()
{
    var result = SomeAsync().GetAwaiter().GetResult();
}

// AFTER
public async Task DoWorkAsync()
{
    var result = await SomeAsync();
}
```

When making a method async, update ALL callers of that method to await it too. Follow the async chain up until you reach a method that's already async.

**B. Constructor or static initializer (can't be async):**
Use `Task.Run(() => SomeAsync()).GetAwaiter().GetResult()` as a last resort with a comment explaining why (constructor). But PREFER moving the async work to an Initialize method if possible.

**C. IDisposable.Dispose (synchronous requirement):**
Use `Task.Run(() => SomeAsync()).ConfigureAwait(false).GetAwaiter().GetResult()` with a comment. Or better, ensure cleanup is done in DisposeAsync and Dispose just sets a flag.

**Step 3: ChaosVaccination specifics (8 occurrences):**
- Search all .cs files under `Plugins/DataWarehouse.Plugins.ChaosVaccination/` for `.GetAwaiter().GetResult()` and `.Result`
- Fix each one using pattern A (make method async) where possible
- The plugin already has async infrastructure — most sync-over-async is likely in event handlers or initialization code

**Step 4: SqlOverObject specifics (3 occurrences):**
- Search `Plugins/DataWarehouse.Plugins.Virtualization.SqlOverObject/SqlOverObjectPlugin.cs`
- Fix each one using pattern A

**CRITICAL:** When changing method signatures to async, you MUST update the return type AND all callers. If a caller is also synchronous, make it async too (cascade). If you hit an interface method, check if the interface already has an async version — use that instead.

Do NOT introduce `async void` — use `async Task` always.
  </action>
  <verify>
Grep for `.GetAwaiter().GetResult()` in ChaosVaccination — 0 matches. Grep for `.GetAwaiter().GetResult()` in SqlOverObject — 0 matches. `dotnet build Plugins/DataWarehouse.Plugins.ChaosVaccination/DataWarehouse.Plugins.ChaosVaccination.csproj` — 0 errors. `dotnet build Plugins/DataWarehouse.Plugins.Virtualization.SqlOverObject/DataWarehouse.Plugins.Virtualization.SqlOverObject.csproj` — 0 errors.
  </verify>
  <done>Zero sync-over-async patterns in ChaosVaccination and SqlOverObject. All converted to proper async/await.</done>
</task>

<task type="auto">
  <name>Task 2: Fix sync-over-async in remaining plugins and SDK</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateSustainability/**/*.cs
    Plugins/DataWarehouse.Plugins.UltimateSDKPorts/**/*.cs
    DataWarehouse.SDK/**/*.cs
    DataWarehouse.Kernel/**/*.cs
    DataWarehouse.Shared/**/*.cs
    Plugins/**/*.cs
  </files>
  <action>
**Step 1:** Read audit report for ALL remaining sync-over-async findings outside ChaosVaccination and SqlOverObject.

**Step 2:** Fix UltimateSustainability (1 known occurrence) and UltimateSDKPorts/CrossLanguageSdkPorts (1 known occurrence) using same patterns from Task 1.

**Step 3:** Check the audit report for ANY additional `.GetAwaiter().GetResult()` or `.Result` findings in:
- Other plugin directories
- DataWarehouse.SDK/ (non-test code)
- DataWarehouse.Kernel/
- DataWarehouse.Shared/

Fix each using the async pattern. Exclude:
- Test files (DataWarehouse.Tests/)
- Benchmark files (DataWarehouse.Benchmarks/)
- `Task.FromResult` (this is fine — it's creating a completed task, not blocking on one)
- `TaskCompletionSource.SetResult` (this is fine)
- Properties named `Result` that aren't Task.Result

**Step 4:** Do a final comprehensive grep across the entire solution (excluding bin/, obj/, tests, benchmarks) to verify zero remaining sync-over-async.
  </action>
  <verify>
Full-solution grep for `.GetAwaiter().GetResult()` in .cs files (excluding Tests/, Benchmarks/, bin/, obj/) — 0 matches. Build all affected projects — 0 errors.
  </verify>
  <done>Zero sync-over-async patterns remain anywhere in production code. Every .GetAwaiter().GetResult() and blocking .Result replaced with proper async/await.</done>
</task>

</tasks>

<verification>
- `grep -r "GetAwaiter().GetResult()" --include="*.cs" --exclude-dir=bin --exclude-dir=obj --exclude-dir=Tests --exclude-dir=Benchmarks` — 0 matches
- All affected plugin projects build with 0 errors
- Full solution build: `dotnet build DataWarehouse.sln` — 0 errors
</verification>

<success_criteria>
Zero sync-over-async patterns in any production code. All blocking Task access converted to proper async/await chains.
</success_criteria>

<output>
After completion, create `.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-06-SUMMARY.md`
</output>
