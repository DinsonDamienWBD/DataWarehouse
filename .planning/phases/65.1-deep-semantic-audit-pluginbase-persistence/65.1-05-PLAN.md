---
phase: 65.1-deep-semantic-audit-pluginbase-persistence
plan: 05
type: execute
wave: 4
depends_on: ["65.1-03", "65.1-04"]
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateStreamingData/UltimateStreamingDataPlugin.cs
  - Plugins/DataWarehouse.Plugins.UltimateResilience/UltimateResiliencePlugin.cs
autonomous: true

must_haves:
  truths:
    - "UltimateStreamingData.PublishAsync actually publishes data to streaming infrastructure via message bus"
    - "UltimateStreamingData.SubscribeAsync actually yields real streaming data from message bus"
    - "UltimateResilience.ExecuteWithResilienceAsync actually uses the strategy parameter to apply resilience policies"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateStreamingData/UltimateStreamingDataPlugin.cs"
      provides: "Real streaming publish/subscribe implementation"
      contains: "PublishAsync.*MessageBus"
    - path: "Plugins/DataWarehouse.Plugins.UltimateResilience/UltimateResiliencePlugin.cs"
      provides: "Real resilience execution with strategy application"
      contains: "strategy"
  key_links:
    - from: "UltimateStreamingData.PublishAsync"
      to: "MessageBus"
      via: "message bus publish for streaming"
      pattern: "MessageBus.*PublishAsync"
    - from: "UltimateResilience.ExecuteWithResilienceAsync"
      to: "strategy"
      via: "strategy lookup and application"
      pattern: "strategy.*Execute|RetryCount|CircuitBreaker"
---

<objective>
Fix the three critical known stubs: UltimateStreamingData PublishAsync/SubscribeAsync and UltimateResilience ExecuteWithResilienceAsync.

Purpose: These are the highest-severity findings — methods that appear functional but do nothing. PublishAsync returns Task.CompletedTask (data silently lost), SubscribeAsync does yield break (consumers get nothing), ExecuteWithResilienceAsync ignores the strategy (no actual resilience).
Output: Real implementations that use message bus and strategy patterns
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@Plugins/DataWarehouse.Plugins.UltimateStreamingData/UltimateStreamingDataPlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateResilience/UltimateResiliencePlugin.cs
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Contracts/Resilience/
@.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement real PublishAsync and SubscribeAsync in UltimateStreamingData</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateStreamingData/UltimateStreamingDataPlugin.cs</files>
  <action>
Read the full UltimateStreamingDataPlugin.cs. Find the stub implementations at lines ~233-237.

**Fix PublishAsync** (currently `=> Task.CompletedTask`):
Replace with real implementation that:
1. Serializes the Stream data to a byte array
2. Creates a PluginMessage with the topic and data payload
3. Publishes to the message bus topic `dw.streaming.{topic}` using `MessageBus.PublishAsync()`
4. Logs the publish operation (use existing plugin logging patterns)
5. If MessageBus is null, throw InvalidOperationException("MessageBus not initialized — call InitializeAsync first")

```csharp
public override async Task PublishAsync(string topic, Stream data, CancellationToken ct = default)
{
    ct.ThrowIfCancellationRequested();
    if (MessageBus == null)
        throw new InvalidOperationException("MessageBus not initialized. Ensure InitializeAsync has been called.");

    using var ms = new MemoryStream();
    await data.CopyToAsync(ms, ct);
    var payload = ms.ToArray();

    var message = new PluginMessage
    {
        SourcePluginId = Id,
        Topic = $"dw.streaming.{topic}",
        Timestamp = DateTime.UtcNow,
        Data = new Dictionary<string, object>
        {
            ["streamTopic"] = topic,
            ["payload"] = Convert.ToBase64String(payload),
            ["payloadLength"] = payload.Length
        }
    };

    await MessageBus.PublishAsync($"dw.streaming.{topic}", message, ct);
}
```

**Fix SubscribeAsync** (currently `yield break`):
Replace with real implementation that subscribes to the message bus and yields streaming data:

```csharp
public override async IAsyncEnumerable<Dictionary<string, object>> SubscribeAsync(
    string topic,
    [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct = default)
{
    if (MessageBus == null)
        throw new InvalidOperationException("MessageBus not initialized. Ensure InitializeAsync has been called.");

    var channel = System.Threading.Channels.Channel.CreateBounded<Dictionary<string, object>>(
        new System.Threading.Channels.BoundedChannelOptions(1000)
        {
            FullMode = System.Threading.Channels.BoundedChannelFullMode.DropOldest
        });

    var subscription = await MessageBus.SubscribeAsync($"dw.streaming.{topic}", async (msg, msgCt) =>
    {
        if (msg.Data != null)
        {
            await channel.Writer.WriteAsync(msg.Data, msgCt);
        }
    }, ct);

    try
    {
        await foreach (var item in channel.Reader.ReadAllAsync(ct))
        {
            yield return item;
        }
    }
    finally
    {
        subscription?.Dispose();
        channel.Writer.TryComplete();
    }
}
```

Adapt the code to match the exact MessageBus.SubscribeAsync signature — check IMessageBus for the Subscribe return type and callback signature. The pattern above is the intent; adjust types to compile.

Add `using System.Threading.Channels;` at the top of the file.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateStreamingData/DataWarehouse.Plugins.UltimateStreamingData.csproj` — 0 errors. Grep for `Task.CompletedTask` in the file — should NOT match the PublishAsync method. Grep for `yield break` — should NOT be present as the sole body of SubscribeAsync.</verify>
  <done>PublishAsync publishes real data to message bus. SubscribeAsync creates real subscription and yields streaming data via Channel.</done>
</task>

<task type="auto">
  <name>Task 2: Implement real resilience strategy application in UltimateResilience</name>
  <files>Plugins/DataWarehouse.Plugins.UltimateResilience/UltimateResiliencePlugin.cs</files>
  <action>
Read UltimateResiliencePlugin.cs, focusing on ExecuteWithResilienceAsync at lines ~643-670.

The current code gets a strategy at line ~650 but never uses it, just calls `action(ct)` directly at line ~661.

**Fix ExecuteWithResilienceAsync** to actually apply the resilience strategy:
1. Look up the strategy by policyName (existing line ~650 does this)
2. Extract resilience parameters from the strategy: RetryCount, RetryDelay, CircuitBreakerThreshold, Timeout
3. Apply the strategy: wrap `action(ct)` with retry logic, circuit breaker, and timeout based on strategy config
4. Implementation pattern:

```csharp
public override async Task<T> ExecuteWithResilienceAsync<T>(
    Func<CancellationToken, Task<T>> action,
    string policyName,
    CancellationToken ct)
{
    ct.ThrowIfCancellationRequested();

    // Look up the resilience strategy (existing code does this)
    var strategy = GetResilienceStrategy(policyName);

    if (strategy == null)
    {
        // No strategy found — execute without resilience (log warning)
        return await action(ct);
    }

    var maxRetries = strategy.RetryCount > 0 ? strategy.RetryCount : 3;
    var retryDelay = strategy.RetryDelay > TimeSpan.Zero ? strategy.RetryDelay : TimeSpan.FromMilliseconds(200);
    var timeout = strategy.Timeout > TimeSpan.Zero ? strategy.Timeout : TimeSpan.FromSeconds(30);

    Exception? lastException = null;

    for (int attempt = 0; attempt <= maxRetries; attempt++)
    {
        ct.ThrowIfCancellationRequested();

        try
        {
            using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            timeoutCts.CancelAfter(timeout);

            var result = await action(timeoutCts.Token);
            return result;
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            throw; // Real cancellation, don't retry
        }
        catch (Exception ex)
        {
            lastException = ex;

            if (attempt < maxRetries)
            {
                // Exponential backoff with jitter
                var delay = TimeSpan.FromMilliseconds(
                    retryDelay.TotalMilliseconds * Math.Pow(2, attempt) *
                    (0.5 + Random.Shared.NextDouble() * 0.5));
                await Task.Delay(delay, ct);
            }
        }
    }

    throw new AggregateException(
        $"ExecuteWithResilienceAsync failed after {maxRetries + 1} attempts using policy '{policyName}'",
        lastException!);
}
```

**Adapt to actual types:** Read the strategy type to find the actual property names for retry count, delay, timeout, etc. The code above uses `RetryCount`, `RetryDelay`, `Timeout` — adjust to match the actual strategy class properties. Check `DataWarehouse.SDK/Contracts/Resilience/` for the strategy base class.

Also check if there's a `GetResilienceStrategy` method already or if the lookup is done differently. Preserve the existing lookup mechanism, just USE the result.
  </action>
  <verify>`dotnet build Plugins/DataWarehouse.Plugins.UltimateResilience/DataWarehouse.Plugins.UltimateResilience.csproj` — 0 errors. Grep for `strategy` usage in ExecuteWithResilienceAsync confirms it is actually used in retry/timeout logic, not just looked up and ignored.</verify>
  <done>ExecuteWithResilienceAsync applies the looked-up resilience strategy with retry, exponential backoff, timeout. No more no-op passthrough.</done>
</task>

</tasks>

<verification>
- Both plugins build with 0 errors
- UltimateStreamingData: PublishAsync publishes to message bus, SubscribeAsync yields real data
- UltimateResilience: ExecuteWithResilienceAsync uses strategy for retry + timeout
- No silent stubs remain in these two files
</verification>

<success_criteria>
The three highest-severity stubs are eliminated. PublishAsync sends real data, SubscribeAsync receives real data, ExecuteWithResilienceAsync applies real resilience policies. All three methods do actual work.
</success_criteria>

<output>
After completion, create `.planning/phases/65.1-deep-semantic-audit-pluginbase-persistence/65.1-05-SUMMARY.md`
</output>
