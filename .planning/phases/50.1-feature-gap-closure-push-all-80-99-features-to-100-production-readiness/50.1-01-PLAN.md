---
phase: 50.1-feature-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzoStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/Lz77Strategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/Lz78Strategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzfseStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzhStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzxStrategy.cs
autonomous: true
must_haves:
  truths:
    - "All 6 LZ-family strategies have InitializeAsyncCore with configuration validation"
    - "All 6 LZ-family strategies have GetCachedHealthAsync with 60-second cache"
    - "All 6 LZ-family strategies have ShutdownAsyncCore for resource cleanup"
    - "All 6 LZ-family strategies have IncrementCounter calls for compress/decompress operations"
    - "All 6 LZ-family strategies have input guards for null/empty/oversized data"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzoStrategy.cs"
      provides: "LZO compression with production infrastructure"
      contains: "InitializeAsyncCore"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/Lz77Strategy.cs"
      provides: "LZ77 compression with production infrastructure"
      contains: "InitializeAsyncCore"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/Lz78Strategy.cs"
      provides: "LZ78 compression with production infrastructure"
      contains: "InitializeAsyncCore"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzfseStrategy.cs"
      provides: "LZFSE compression with production infrastructure"
      contains: "InitializeAsyncCore"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzhStrategy.cs"
      provides: "LZH compression with production infrastructure"
      contains: "InitializeAsyncCore"
    - path: "Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzxStrategy.cs"
      provides: "LZX compression with production infrastructure"
      contains: "InitializeAsyncCore"
  key_links:
    - from: "LzFamily strategies"
      to: "StrategyBase"
      via: "InitializeAsyncCore, ShutdownAsyncCore, IncrementCounter, GetCachedHealthAsync"
      pattern: "IncrementCounter|GetCachedHealthAsync|InitializeAsyncCore|ShutdownAsyncCore"
---

<objective>
Add production readiness infrastructure to 6 LZ-family compression strategies (Lzo, Lz77, Lz78, Lzfse, Lzh, Lzx) in UltimateCompression plugin.

Purpose: These strategies have real, working compression algorithms but lack the 7-point production readiness checklist items: configuration validation, health checks, metrics, graceful shutdown, error boundaries, edge case handling. Push from 90% to 100%.

Output: 6 strategy files updated with full production infrastructure using existing StrategyBase patterns.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/50.1-feature-gap-closure-push-all-80-99-features-to-100-production-readiness/50.1-RESEARCH.md

Key patterns from StrategyBase (DataWarehouse.SDK/Contracts/StrategyBase.cs):
- `IncrementCounter(string name)` - thread-safe counter increment
- `GetCachedHealthAsync(Func<CancellationToken, Task<StrategyHealthCheckResult>>, TimeSpan?, CancellationToken)` - cached health with lock
- `InitializeAsyncCore(CancellationToken)` - override for init logic
- `ShutdownAsyncCore(CancellationToken)` - override for shutdown logic
- `DisposeAsyncCore()` - override for async disposal

CompressionStrategyBase (DataWarehouse.SDK/Contracts/Compression/CompressionStrategy.cs) already wraps Compress/Decompress with Stopwatch timing, UpdateCompressionStats, IncrementCompressionFailures, and CompressionException wrapping. So metrics/error-boundaries at the Compress/Decompress level are ALREADY handled by the base class.

What each strategy STILL NEEDS:
1. Override `InitializeAsyncCore` to validate any configurable parameters
2. Override `GetCachedHealthAsync` pattern via a public health method or override if base exposes it
3. Override `ShutdownAsyncCore` to clean up any resources (SemaphoreSlim, etc.)
4. Override `DisposeAsyncCore` to dispose resources
5. Add input edge case guards in CompressCore/DecompressCore for boundary conditions (max size, min size)
6. Add `IncrementCounter("lzo.compress")` / `IncrementCounter("lzo.decompress")` in CompressCore/DecompressCore for strategy-specific counters (base tracks aggregate stats, these track per-strategy)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Production-harden LZ-family strategies (Lzo, Lz77, Lz78)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzoStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/Lz77Strategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/Lz78Strategy.cs
  </files>
  <action>
For each of the 3 strategies (LzoStrategy, Lz77Strategy, Lz78Strategy), add the following production infrastructure while preserving ALL existing compression algorithm code:

1. **InitializeAsyncCore override**: Load configurable parameters from SystemConfiguration. For LZO: validate hash table size (must be power of 2, 256-16384), max match length (3-264). For LZ77: validate window size (1024-65536, power of 2), max chain length (1-4096). For LZ78: validate dictionary size (256-65536). Throw ArgumentException for invalid values.

2. **Health check method**: Add a `public async Task<StrategyHealthCheckResult> CheckHealthAsync(CancellationToken ct)` method that uses `GetCachedHealthAsync()` from StrategyBase. The health check should perform a small round-trip (compress + decompress 16 bytes of test data) and verify the output matches input. Cache for 60 seconds.

3. **ShutdownAsyncCore override**: Dispose any SemaphoreSlim or resources. Call base.

4. **DisposeAsyncCore override**: Same disposal pattern, call base.

5. **Strategy-specific counters**: At the start of CompressCore, add `IncrementCounter("{algo}.compress")`. At the start of DecompressCore, add `IncrementCounter("{algo}.decompress")`. Where {algo} is "lzo", "lz77", "lz78" respectively.

6. **Edge case guards**: Ensure CompressCore/DecompressCore have guards for:
   - Input length > 100MB: throw ArgumentException("Input exceeds maximum size of 100MB")
   - DecompressCore: validate header/magic bytes before processing (strategy-specific)

DO NOT modify any compression/decompression algorithm logic. Only ADD infrastructure around existing code.
  </action>
  <verify>
Run `dotnet build DataWarehouse.slnx --no-restore 2>&1 | tail -5` and confirm 0 errors 0 warnings.
Grep each file for "InitializeAsyncCore", "GetCachedHealthAsync", "ShutdownAsyncCore", "IncrementCounter" to confirm all 4 patterns present.
  </verify>
  <done>LzoStrategy, Lz77Strategy, Lz78Strategy all have InitializeAsyncCore with config validation, health checks with 60s cache, shutdown/dispose, strategy-specific counters, and edge case guards. Build passes with 0 errors.</done>
</task>

<task type="auto">
  <name>Task 2: Production-harden LZ-family strategies (Lzfse, Lzh, Lzx)</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzfseStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzhStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateCompression/Strategies/LzFamily/LzxStrategy.cs
  </files>
  <action>
Apply the SAME production infrastructure pattern from Task 1 to Lzfse, Lzh, and Lzx strategies:

1. **InitializeAsyncCore override**: For LZFSE: validate block size (4096-1048576). For LZH: validate window size (4096-32768), match length (3-256). For LZX: validate window bits (15-21), validate position slots. Throw ArgumentException for invalid values.

2. **Health check method**: Same pattern as Task 1 â€” `CheckHealthAsync` using `GetCachedHealthAsync()`, round-trip test, 60-second cache.

3. **ShutdownAsyncCore override**: Dispose resources, call base.

4. **DisposeAsyncCore override**: Disposal pattern, call base.

5. **Strategy-specific counters**: `IncrementCounter("lzfse.compress")` etc.

6. **Edge case guards**: Max 100MB input guard, decompression header validation.

DO NOT modify any compression/decompression algorithm logic.
  </action>
  <verify>
Run `dotnet build DataWarehouse.slnx --no-restore 2>&1 | tail -5` and confirm 0 errors 0 warnings.
Grep each file for "InitializeAsyncCore", "GetCachedHealthAsync", "ShutdownAsyncCore", "IncrementCounter".
  </verify>
  <done>LzfseStrategy, LzhStrategy, LzxStrategy all have full production infrastructure. Build passes with 0 errors.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.slnx --no-restore` passes with 0 errors, 0 warnings
2. All 6 LZ-family strategy files contain: InitializeAsyncCore, GetCachedHealthAsync, ShutdownAsyncCore, IncrementCounter
3. No existing compression algorithm logic was modified (only additions)
</verification>

<success_criteria>
All 6 LZ-family compression strategies (Lzo, Lz77, Lz78, Lzfse, Lzh, Lzx) upgraded from 90% to 100% with configuration validation, cached health checks, graceful shutdown, metrics counters, and edge case handling. Zero build errors.
</success_criteria>

<output>
After completion, create `.planning/phases/50.1-feature-gap-closure-push-all-80-99-features-to-100-production-readiness/50.1-01-SUMMARY.md`
</output>
