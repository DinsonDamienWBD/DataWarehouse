---
phase: 50.1-feature-gap-closure
plan: 06
type: execute
wave: 2  # Waves are execution scheduling groups (max 2-3 concurrent), not dependency markers
depends_on: []
files_modified:
  - Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Aes/AesGcmStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hsm/Pkcs11HsmStrategy.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hsm/Pkcs11HsmStrategyBase.cs
  - Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hardware/TpmStrategy.cs
autonomous: true
must_haves:
  truths:
    - "AES-192-GCM and AES-128-GCM modes in AesGcmStrategy have config validation"
    - "HSM strategies have config validation for PKCS#11 library path, slot, PIN"
    - "TPM strategy has config validation for device path, PCR selection"
    - "All security strategies have cached health checks"
    - "All security strategies have proper error boundaries with domain-specific exceptions"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Aes/AesGcmStrategy.cs"
      provides: "AES-GCM encryption with production infrastructure for all key sizes"
      contains: "InitializeAsyncCore"
    - path: "Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hardware/TpmStrategy.cs"
      provides: "TPM 2.0 key management with production infrastructure"
      contains: "InitializeAsyncCore"
  key_links:
    - from: "Encryption/KeyManagement strategies"
      to: "StrategyBase"
      via: "InitializeAsyncCore, GetCachedHealthAsync, IncrementCounter"
      pattern: "InitializeAsyncCore|GetCachedHealthAsync"
---

<objective>
Add production readiness infrastructure to encryption and key management strategies: AES-GCM (covering 128/192 bit modes), HSM (PKCS#11), and TPM 2.0.

Purpose: Push Domain 03 encryption/key-management features from 90% to 100%. AES-GCM strategy likely handles multiple key sizes — ensure all modes (128, 192, 256) have proper validation. HSM and TPM are hardware security modules that need careful init/health/shutdown.

Output: 4 files updated with production infrastructure.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/50.1-feature-gap-closure-push-all-80-99-features-to-100-production-readiness/50.1-RESEARCH.md

The 90-94 features list includes AES-192-GCM and AES-128-GCM. The AesGcmStrategy.cs likely handles all AES-GCM key sizes. Check if there are separate strategy classes per key size or one class with a key size parameter.

For HSM: There are multiple HSM strategies (AWS CloudHSM, Azure Dedicated HSM, GCP Cloud HSM, PKCS#11). The "HSM" feature likely refers to the generic PKCS#11 HSM strategy. Check Pkcs11HsmStrategy.cs and Pkcs11HsmStrategyBase.cs.

Check encryption base class for domain-specific methods:
```bash
grep -n "class.*EncryptionStrategyBase" DataWarehouse.SDK/Contracts/Encryption/*.cs
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Production-harden AES-GCM encryption strategy for all key sizes</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateEncryption/Strategies/Aes/AesGcmStrategy.cs
  </files>
  <action>
FIRST: Read AesGcmStrategy.cs to understand how it handles different key sizes (128, 192, 256 bit).

Add production infrastructure:

1. **InitializeAsyncCore override**: Validate key size (must be 128, 192, or 256 bits), nonce size (must be 12 bytes for GCM), tag size (must be 16 bytes for GCM), validate that the configured key source is available. Throw ArgumentException for invalid crypto parameters.

2. **Health check**: `CheckHealthAsync` using `GetCachedHealthAsync()`. Test encrypt+decrypt round-trip with a test key and known plaintext. 60-second cache. If System.Security.Cryptography.AesGcm is not available on the platform, report degraded.

3. **ShutdownAsyncCore**: Securely clear any cached key material (Array.Clear or CryptographicOperations.ZeroMemory if available). Dispose crypto resources.

4. **DisposeAsyncCore**: Same secure cleanup.

5. **Strategy-specific counters**: `IncrementCounter("aesgcm.encrypt")`, `IncrementCounter("aesgcm.decrypt")`.

6. **Error boundaries**: Catch `CryptographicException`, wrap with context (key size, operation). Catch `PlatformNotSupportedException` for environments without hardware AES.

DO NOT modify any cryptographic algorithm logic.
  </action>
  <verify>
`dotnet build DataWarehouse.slnx --no-restore 2>&1 | tail -5` — 0 errors 0 warnings.
  </verify>
  <done>AES-GCM strategy handles all key sizes (128/192/256) with config validation, health checks, secure shutdown, counters. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Production-harden HSM and TPM key management strategies</name>
  <files>
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hsm/Pkcs11HsmStrategy.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hsm/Pkcs11HsmStrategyBase.cs
    Plugins/DataWarehouse.Plugins.UltimateKeyManagement/Strategies/Hardware/TpmStrategy.cs
  </files>
  <action>
FIRST: Read all 3 files to understand class hierarchy and which methods already exist.

For PKCS#11 HSM strategies (Pkcs11HsmStrategyBase and Pkcs11HsmStrategy):

1. **InitializeAsyncCore override** (in base if not present, or concrete): Validate PKCS#11 library path (file exists or is loadable), slot index (>=0), PIN (non-empty when required), token label. For cloud HSM variants: validate endpoint, credentials. Throw InvalidOperationException for missing required config.

2. **Health check**: Check session state with HSM, validate token accessibility. 60-second cache.

3. **ShutdownAsyncCore**: Close PKCS#11 session, log out of token, unload library. 10-second timeout.

4. **Counters**: `IncrementCounter("hsm.keygen")`, `IncrementCounter("hsm.sign")`, `IncrementCounter("hsm.encrypt")`.

5. **Error boundaries**: Catch PKCS#11-specific errors (CKR_* return codes), wrap with context.

For TPM 2.0 strategy (TpmStrategy):

1. **InitializeAsyncCore**: Validate device path (/dev/tpmrm0 on Linux, Windows TPM via TBS), PCR bank selection (SHA-1, SHA-256), authorization policy. Throw InvalidOperationException for missing config.

2. **Health check**: Check TPM device accessibility, read PCR values. 60-second cache.

3. **ShutdownAsyncCore**: Close TPM context, flush transient objects.

4. **Counters**: `IncrementCounter("tpm.seal")`, `IncrementCounter("tpm.unseal")`, `IncrementCounter("tpm.sign")`.

5. **Error boundaries**: Catch TPM-specific errors, wrap with TpmException or similar domain exception.

DO NOT modify any cryptographic or hardware interaction logic.
  </action>
  <verify>
`dotnet build DataWarehouse.slnx --no-restore 2>&1 | tail -5` — 0 errors 0 warnings.
  </verify>
  <done>HSM (PKCS#11) and TPM 2.0 strategies have full production infrastructure. Build passes.</done>
</task>

</tasks>

<verification>
1. `dotnet build DataWarehouse.slnx --no-restore` passes with 0 errors, 0 warnings
2. AES-GCM, HSM, and TPM strategies all have production infrastructure
</verification>

<success_criteria>
AES-192-GCM, AES-128-GCM, HSM, and TPM 2.0 features pushed to 100%. Zero build errors.
</success_criteria>

<output>
After completion, create `.planning/phases/50.1-feature-gap-closure-push-all-80-99-features-to-100-production-readiness/50.1-06-SUMMARY.md`
</output>
