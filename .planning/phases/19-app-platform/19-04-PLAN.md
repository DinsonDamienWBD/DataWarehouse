---
phase: 19-app-platform
plan: 04
type: execute
wave: 3
depends_on: ["19-02", "19-03"]
files_modified:
  - Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppObservabilityConfig.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Models/ServiceEndpoint.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppObservabilityStrategy.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Services/PlatformServiceFacade.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/AppPlatformPlugin.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Models/PlatformTopics.cs
autonomous: true
must_haves:
  truths:
    - "Each app's metrics, traces, and logs are tagged with app_id for isolation"
    - "Per-app observability configuration controls retention, alert thresholds, and enabled telemetry types"
    - "Observability data from one app cannot leak into another app's view"
    - "PlatformServiceFacade exposes a unified service discovery API listing all consumable services"
    - "Service endpoints describe each available service with its topic, required scopes, and capabilities"
    - "The full platform API is discoverable via a single 'platform.services.list' message"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppObservabilityConfig.cs"
      provides: "Per-app observability configuration records"
      contains: "sealed record AppObservabilityConfig"
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Models/ServiceEndpoint.cs"
      provides: "Service endpoint descriptors for service discovery"
      contains: "sealed record ServiceEndpoint"
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppObservabilityStrategy.cs"
      provides: "Strategy for per-app observability tag injection and telemetry isolation"
      contains: "sealed class AppObservabilityStrategy"
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Services/PlatformServiceFacade.cs"
      provides: "Unified service discovery and consumption facade"
      contains: "sealed class PlatformServiceFacade"
  key_links:
    - from: "AppObservabilityStrategy.cs"
      to: "observability.metrics.emit"
      via: "message bus with app_id tag injection"
      pattern: "SendAsync.*observability\\.metrics"
    - from: "AppObservabilityStrategy.cs"
      to: "observability.query"
      via: "message bus with app_id filter for isolated queries"
      pattern: "SendAsync.*observability\\.query"
    - from: "PlatformServiceFacade.cs"
      to: "platform.services.list"
      via: "returns all ServiceEndpoint descriptors"
      pattern: "ServiceEndpoint"
    - from: "AppPlatformPlugin.cs"
      to: "PlatformServiceFacade"
      via: "private field and topic handler delegation"
      pattern: "_serviceFacade"
---

<objective>
Implement per-app observability isolation and the unified service consumption API (PlatformServiceFacade).

Purpose: Each app's telemetry (metrics, traces, logs) must be isolated via app_id tagging so apps see only their own data. The PlatformServiceFacade provides a discovery endpoint where apps can learn about all available DW services and their access requirements, completing the platform surface.

Output: AppObservabilityStrategy for tag-based isolation, PlatformServiceFacade for service discovery, ServiceEndpoint descriptors, all wired into AppPlatformPlugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-app-platform/19-RESEARCH.md
@.planning/phases/19-app-platform/19-01-SUMMARY.md
@.planning/phases/19-app-platform/19-02-SUMMARY.md
@.planning/phases/19-app-platform/19-03-SUMMARY.md
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Utilities/PluginDetails.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppObservabilityConfig, ServiceEndpoint models, and AppObservabilityStrategy</name>
  <files>
    Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppObservabilityConfig.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/Models/ServiceEndpoint.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppObservabilityStrategy.cs
  </files>
  <action>
1. Create `Models/AppObservabilityConfig.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Models`:
   - `sealed record AppObservabilityConfig` with XML docs:
     * `required string AppId`
     * `bool MetricsEnabled` (default true)
     * `bool TracingEnabled` (default true)
     * `bool LoggingEnabled` (default true)
     * `bool AlertingEnabled` (default false)
     * `int MetricsRetentionDays` (default 30)
     * `int TracingRetentionDays` (default 7)
     * `int LogRetentionDays` (default 14)
     * `ObservabilityLevel LogLevel` (default Info)
     * `double? AlertThresholdErrorRate` -- percentage; null means no alerting
     * `double? AlertThresholdLatencyMs` -- P95 latency threshold; null means no alerting
     * `int? AlertThresholdRequestsPerMinute` -- rate limit alerting; null means no alerting
     * `string[] AlertNotificationChannels` (default []) -- e.g., "email:admin@app.com", "webhook:https://..."
     * `DateTime CreatedAt`
     * `DateTime? UpdatedAt`
   - `enum ObservabilityLevel` with: Trace, Debug, Info, Warning, Error, Critical
   - All with XML docs.

2. Create `Models/ServiceEndpoint.cs` in same namespace:
   - `sealed record ServiceEndpoint` with XML docs:
     * `required string ServiceName` -- e.g., "storage", "intelligence", "accesscontrol"
     * `required string DisplayName` -- e.g., "Storage Service"
     * `required string Description` -- what the service provides
     * `required string RequestTopic` -- message bus topic to use (e.g., "platform.service.storage")
     * `required string[] RequiredScopes` -- scopes the service token must have
     * `required string[] SupportedOperations` -- operations this service supports
     * `bool RequiresAiWorkflow` (default false) -- whether AI workflow config is required
     * `ServiceStatus Status` (default Available)
   - `enum ServiceStatus` with: Available, Degraded, Unavailable, Maintenance
   - `sealed record PlatformServiceCatalog` with:
     * `required ServiceEndpoint[] Services`
     * `required string PlatformVersion` -- "1.0.0"
     * `required DateTime GeneratedAt`
   - All with XML docs.

3. Create `Strategies/AppObservabilityStrategy.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Strategies`:
   - `internal sealed class AppObservabilityStrategy` with XML docs.
   - Constructor takes `IMessageBus messageBus, string pluginId`.
   - `ConcurrentDictionary<string, AppObservabilityConfig> _configs` for per-app config.
   - `ConfigureObservabilityAsync(AppObservabilityConfig config)`:
     * Store in `_configs`.
     * Send config to UniversalObservability via message bus:
       `_messageBus.SendAsync("observability.app.configure", new PluginMessage { Type = "observability.app.configure", SourcePluginId = _pluginId, Payload = { ["AppId"] = config.AppId, ["MetricsEnabled"] = config.MetricsEnabled, ["TracingEnabled"] = config.TracingEnabled, ["LoggingEnabled"] = config.LoggingEnabled, ["MetricsRetentionDays"] = config.MetricsRetentionDays, ["LogLevel"] = config.LogLevel.ToString() } })`.
     * Return MessageResponse.
   - `RemoveObservabilityAsync(string appId)`:
     * Remove from `_configs`. Send removal: `"observability.app.remove"`.
   - `GetObservabilityConfigAsync(string appId)` -- lookup from `_configs`.
   - `UpdateObservabilityAsync(AppObservabilityConfig updatedConfig)` -- update and re-send.
   - `EmitMetricAsync(string appId, string metricName, double value, Dictionary<string, string>? tags)`:
     * Get config for app. If metrics disabled, return silently.
     * Inject `app_id` tag: add `["app_id"] = appId` to the tags dictionary.
     * Also add `["source"] = "platform"` tag to distinguish platform-routed metrics.
     * Forward via `_messageBus.SendAsync("observability.metrics.emit", new PluginMessage { ..., Payload = { ["MetricName"] = metricName, ["Value"] = value, ["Tags"] = enrichedTags, ["AppId"] = appId } })`.
   - `EmitTraceAsync(string appId, string spanName, string traceId, Dictionary<string, string>? attributes)`:
     * Get config. If tracing disabled, return silently.
     * Inject `app_id` attribute.
     * Forward: `"observability.traces.emit"`.
   - `EmitLogAsync(string appId, ObservabilityLevel level, string message, Dictionary<string, string>? properties)`:
     * Get config. If logging disabled or level below configured LogLevel, return silently.
     * Inject `app_id` property.
     * Forward: `"observability.logs.emit"`.
   - `QueryMetricsAsync(string appId, string metricName, DateTime from, DateTime to)`:
     * Enforces isolation: ALWAYS includes `app_id` filter in query.
     * Send: `_messageBus.SendAsync("observability.query", new PluginMessage { ..., Payload = { ["QueryType"] = "metrics", ["MetricName"] = metricName, ["From"] = from, ["To"] = to, ["Filter_AppId"] = appId } })`.
     * Return query results.
   - `QueryTracesAsync(string appId, string traceId)`:
     * Enforces isolation with app_id filter.
     * Send: `"observability.query"` with QueryType = "traces".
   - `QueryLogsAsync(string appId, ObservabilityLevel? minLevel, DateTime from, DateTime to)`:
     * Enforces isolation with app_id filter.
     * Send: `"observability.query"` with QueryType = "logs".
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` -- zero errors. Verify: (1) every emit method injects app_id tag, (2) every query method includes app_id filter for isolation, (3) log level filtering respects configured minimum, (4) ServiceEndpoint has all required fields, (5) no direct plugin references.
  </verify>
  <done>
Per-app observability isolation implemented via app_id tag injection on all emitted metrics, traces, and logs. Queries always filtered by app_id to prevent cross-app data leakage. Config controls enabled telemetry types, retention, log level, and alerting thresholds. ServiceEndpoint and PlatformServiceCatalog models define the service discovery contract.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement PlatformServiceFacade and wire everything into AppPlatformPlugin</name>
  <files>
    Plugins/DataWarehouse.Plugins.AppPlatform/Services/PlatformServiceFacade.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/AppPlatformPlugin.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/Models/PlatformTopics.cs
  </files>
  <action>
1. Create `Services/PlatformServiceFacade.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Services`:
   - `internal sealed class PlatformServiceFacade` with XML docs.
   - Constructor takes `IMessageBus messageBus, string pluginId`.
   - Private static method `BuildServiceCatalog()` that creates the canonical list of `ServiceEndpoint` objects:
     * Storage: ServiceName "storage", DisplayName "Storage Service", Description "Persistent storage with provider selection, tiering, and quotas", RequestTopic PlatformTopics.ServiceStorage, RequiredScopes ["storage"], SupportedOperations ["read", "write", "delete", "list", "metadata"]
     * AccessControl: ServiceName "accesscontrol", DisplayName "Access Control Service", Description "RBAC/ABAC/MAC/DAC policy evaluation and management", RequestTopic PlatformTopics.ServiceAccessControl, RequiredScopes ["accesscontrol"], SupportedOperations ["evaluate", "grant", "revoke", "audit"]
     * Intelligence: ServiceName "intelligence", DisplayName "AI Intelligence Service", Description "AI-powered analysis, embeddings, chat, and knowledge operations", RequestTopic PlatformTopics.ServiceIntelligence, RequiredScopes ["intelligence"], SupportedOperations ["chat", "embeddings", "analysis", "knowledge"], RequiresAiWorkflow true
     * Observability: ServiceName "observability", DisplayName "Observability Service", Description "Metrics, tracing, logging, and alerting with per-app isolation", RequestTopic PlatformTopics.ServiceObservability, RequiredScopes ["observability"], SupportedOperations ["emit_metric", "emit_trace", "emit_log", "query_metrics", "query_traces", "query_logs"]
     * Replication: ServiceName "replication", DisplayName "Replication Service", Description "Geo-dispersed data replication with WORM and sharding", RequestTopic PlatformTopics.ServiceReplication, RequiredScopes ["replication"], SupportedOperations ["replicate", "status", "configure", "failover"]
     * Compliance: ServiceName "compliance", DisplayName "Compliance Service", Description "Regulatory compliance evaluation (GDPR, HIPAA, SOC2, FedRAMP) and reporting", RequestTopic PlatformTopics.ServiceCompliance, RequiredScopes ["compliance"], SupportedOperations ["evaluate", "report", "audit", "certify"]
   - `GetServiceCatalogAsync()` -- returns `PlatformServiceCatalog` with all endpoints, PlatformVersion "1.0.0", GeneratedAt = DateTime.UtcNow.
   - `GetServiceEndpointAsync(string serviceName)` -- lookup by name, return ServiceEndpoint or null.
   - `GetServicesForAppAsync(string appId, string[] tokenScopes)`:
     * Filter catalog to only services whose RequiredScopes intersect with tokenScopes.
     * Returns filtered list showing what this specific app/token can access.
   - `CheckServiceHealthAsync(string serviceName)`:
     * Send health ping via message bus to the service's topic.
     * Return ServiceStatus based on response (Available if success, Unavailable if timeout/error).

2. Update `Models/PlatformTopics.cs` -- add observability and service discovery topics:
   - `ObservabilityConfigure = $"{Prefix}.observability.configure"`
   - `ObservabilityRemove = $"{Prefix}.observability.remove"`
   - `ObservabilityGet = $"{Prefix}.observability.get"`
   - `ObservabilityUpdate = $"{Prefix}.observability.update"`
   - `ObservabilityEmitMetric = $"{Prefix}.observability.emit.metric"`
   - `ObservabilityEmitTrace = $"{Prefix}.observability.emit.trace"`
   - `ObservabilityEmitLog = $"{Prefix}.observability.emit.log"`
   - `ObservabilityQueryMetrics = $"{Prefix}.observability.query.metrics"`
   - `ObservabilityQueryTraces = $"{Prefix}.observability.query.traces"`
   - `ObservabilityQueryLogs = $"{Prefix}.observability.query.logs"`
   - `ServicesList = $"{Prefix}.services.list"` -- list all available services
   - `ServicesGet = $"{Prefix}.services.get"` -- get specific service endpoint
   - `ServicesForApp = $"{Prefix}.services.forapp"` -- get services available to an app
   - `ServicesHealth = $"{Prefix}.services.health"` -- check service health
   - XML docs on each.

3. Update `AppPlatformPlugin.cs`:
   - Add private fields: `AppObservabilityStrategy? _observabilityStrategy`, `PlatformServiceFacade? _serviceFacade`.
   - Update `InitializeServices()`:
     * `_observabilityStrategy = new AppObservabilityStrategy(MessageBus!, Id)`
     * `_serviceFacade = new PlatformServiceFacade(MessageBus!, Id)`
   - Add observability topic subscriptions (use response-capable overload):
     * `PlatformTopics.ObservabilityConfigure` -> `HandleObservabilityConfigureAsync`: extract config fields, create AppObservabilityConfig, call strategy.ConfigureObservabilityAsync.
     * `PlatformTopics.ObservabilityRemove` -> `HandleObservabilityRemoveAsync`
     * `PlatformTopics.ObservabilityGet` -> `HandleObservabilityGetAsync`
     * `PlatformTopics.ObservabilityUpdate` -> `HandleObservabilityUpdateAsync`
     * `PlatformTopics.ObservabilityEmitMetric` -> `HandleObservabilityEmitMetricAsync`: extract AppId, MetricName, Value, Tags. Call strategy.EmitMetricAsync.
     * `PlatformTopics.ObservabilityEmitTrace` -> `HandleObservabilityEmitTraceAsync`
     * `PlatformTopics.ObservabilityEmitLog` -> `HandleObservabilityEmitLogAsync`
     * `PlatformTopics.ObservabilityQueryMetrics` -> `HandleObservabilityQueryMetricsAsync`: extract AppId, MetricName, From, To. Call strategy.QueryMetricsAsync with app_id isolation.
     * `PlatformTopics.ObservabilityQueryTraces` -> `HandleObservabilityQueryTracesAsync`
     * `PlatformTopics.ObservabilityQueryLogs` -> `HandleObservabilityQueryLogsAsync`
   - Add service discovery topic subscriptions:
     * `PlatformTopics.ServicesList` -> `HandleServicesListAsync`: call `_serviceFacade!.GetServiceCatalogAsync()`, return MessageResponse.Ok with catalog.
     * `PlatformTopics.ServicesGet` -> `HandleServicesGetAsync`: extract ServiceName, return endpoint or error.
     * `PlatformTopics.ServicesForApp` -> `HandleServicesForAppAsync`: extract AppId and Scopes, return filtered services.
     * `PlatformTopics.ServicesHealth` -> `HandleServicesHealthAsync`: extract ServiceName, return health status.
   - Update `Dispose()` to clean up all new fields.
   - All handlers have XML docs and error handling with MessageResponse.Error.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` -- zero errors. Verify: (1) PlatformServiceFacade lists 6 services with correct topics and scopes, (2) observability handlers inject app_id tags, (3) query handlers include app_id filter, (4) ServicesList handler returns full catalog, (5) all topics defined in PlatformTopics, (6) no direct plugin references, (7) all new fields cleaned up in Dispose.
  </verify>
  <done>
Per-app observability fully wired with 10 topic handlers covering config management, telemetry emission, and isolated querying. PlatformServiceFacade provides 6 service endpoints via 4 discovery topic handlers. Complete platform API discoverable via single ServicesList call. All observability data isolated by app_id. Plugin cleanup handles all subscriptions and resources.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` compiles cleanly
2. Every observability emit method injects app_id tag
3. Every observability query method filters by app_id (no cross-app data leakage)
4. PlatformServiceFacade.GetServiceCatalogAsync returns all 6 services
5. ServiceEndpoint records include RequiredScopes for token scope validation
6. All 14 new topic handlers registered in AppPlatformPlugin (10 observability + 4 service discovery)
7. No direct plugin references -- all via message bus
8. Plugin Dispose cleans up all subscriptions and resources
</verification>

<success_criteria>
- Per-app observability: metrics, traces, and logs tagged with app_id for complete isolation
- Observability config controls retention, log level, and alerting per app
- Queries enforced with app_id filter -- impossible to query another app's data
- Service catalog lists 6 consumable services (Storage, AccessControl, Intelligence, Observability, Replication, Compliance)
- Each service endpoint defines topic, scopes, and supported operations
- Full platform surface discoverable via platform.services.list
</success_criteria>

<output>
After completion, create `.planning/phases/19-app-platform/19-04-SUMMARY.md`
</output>
