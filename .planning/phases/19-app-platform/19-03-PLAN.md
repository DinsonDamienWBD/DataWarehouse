---
phase: 19-app-platform
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppAiWorkflowConfig.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppAiWorkflowStrategy.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/AppPlatformPlugin.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Models/PlatformTopics.cs
autonomous: true
must_haves:
  truths:
    - "Each registered app has its own AI workflow configuration (auto/manual/budget/approval)"
    - "Per-app AI configuration controls mode, budget limits, model preferences, and concurrency"
    - "AI workflow configuration is sent to UltimateIntelligence via message bus on bind"
    - "Apps can update their AI workflow configuration without code changes"
    - "Budget enforcement prevents requests exceeding per-month or per-request limits"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppAiWorkflowConfig.cs"
      provides: "Per-app AI workflow configuration records and enums"
      contains: "sealed record AppAiWorkflowConfig"
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppAiWorkflowStrategy.cs"
      provides: "Strategy that manages per-app AI workflow configs and routes to Intelligence"
      contains: "sealed class AppAiWorkflowStrategy"
  key_links:
    - from: "AppAiWorkflowStrategy.cs"
      to: "intelligence.workflow.configure"
      via: "message bus SendAsync to configure per-app AI scope"
      pattern: "SendAsync.*intelligence\\.workflow"
    - from: "AppAiWorkflowStrategy.cs"
      to: "intelligence.request"
      via: "message bus forwarding with budget and mode enforcement"
      pattern: "SendAsync.*intelligence\\.request"
    - from: "AppPlatformPlugin.cs"
      to: "AppAiWorkflowStrategy"
      via: "private field and topic handler delegation"
      pattern: "_aiWorkflowStrategy"
---

<objective>
Implement per-app AI workflow configuration and routing to UltimateIntelligence.

Purpose: Each registered app configures how UltimateIntelligence handles its requests -- auto mode (Intelligence chooses), manual mode (app specifies provider/model), budget mode (cost-optimized), or approval mode (human gate for expensive operations). This enables apps to control AI costs and behavior independently.

Output: AppAiWorkflowConfig model, AppAiWorkflowStrategy for configuration management and budget enforcement, wired into AppPlatformPlugin.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-app-platform/19-RESEARCH.md
@.planning/phases/19-app-platform/19-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Utilities/PluginDetails.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppAiWorkflowConfig model and AppAiWorkflowStrategy</name>
  <files>
    Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppAiWorkflowConfig.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppAiWorkflowStrategy.cs
  </files>
  <action>
1. Create `Models/AppAiWorkflowConfig.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Models`:
   - `sealed record AppAiWorkflowConfig` with XML docs:
     * `required string AppId`
     * `AiWorkflowMode Mode` (default Auto)
     * `decimal? BudgetLimitPerMonth` -- null means unlimited
     * `decimal? BudgetLimitPerRequest` -- null means unlimited
     * `string? PreferredProvider` -- e.g., "openai", "claude", "ollama"; null for auto-select
     * `string? PreferredModel` -- e.g., "gpt-4", "claude-3"; null for auto-select
     * `bool RequireApproval` (default false) -- if true, requests above budget threshold require human approval
     * `int MaxConcurrentRequests` (default 10)
     * `string[] AllowedOperations` (default ["chat", "embeddings", "analysis"])
     * `DateTime CreatedAt`
     * `DateTime? UpdatedAt`
   - `enum AiWorkflowMode` with XML docs:
     * `Auto` -- Intelligence chooses optimal provider and model
     * `Manual` -- app specifies provider and model per request
     * `Budget` -- Intelligence optimizes for cost within budget constraints
     * `Approval` -- requests above cost threshold require human approval
   - `sealed record AiUsageTracking` with XML docs:
     * `required string AppId`
     * `decimal TotalSpentThisMonth` (default 0)
     * `int RequestCountThisMonth` (default 0)
     * `int ActiveConcurrentRequests` (default 0)
     * `DateTime PeriodStart`
     * `DateTime? LastRequestTime`

2. Create `Strategies/AppAiWorkflowStrategy.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Strategies`:
   - `internal sealed class AppAiWorkflowStrategy` with XML docs.
   - Constructor takes `IMessageBus messageBus, string pluginId`.
   - `ConcurrentDictionary<string, AppAiWorkflowConfig> _configs` for per-app AI config.
   - `ConcurrentDictionary<string, AiUsageTracking> _usageTracking` for budget enforcement.
   - `ConfigureWorkflowAsync(AppAiWorkflowConfig config)`:
     * Store in `_configs`.
     * Initialize usage tracking if not exists.
     * Send config to Intelligence via message bus:
       `_messageBus.SendAsync("intelligence.workflow.configure", new PluginMessage { Type = "intelligence.workflow.configure", SourcePluginId = _pluginId, Payload = { ["AppId"] = config.AppId, ["Mode"] = config.Mode.ToString(), ["PreferredProvider"] = config.PreferredProvider, ["PreferredModel"] = config.PreferredModel, ["MaxConcurrentRequests"] = config.MaxConcurrentRequests, ["AllowedOperations"] = config.AllowedOperations } })`.
     * Return MessageResponse from Intelligence.
   - `RemoveWorkflowAsync(string appId)`:
     * Remove from `_configs` and `_usageTracking`.
     * Send removal to Intelligence: `"intelligence.workflow.remove"`.
   - `GetWorkflowAsync(string appId)` -- lookup from `_configs`.
   - `UpdateWorkflowAsync(AppAiWorkflowConfig updatedConfig)`:
     * Update in `_configs`, set UpdatedAt = DateTime.UtcNow.
     * Re-send to Intelligence.
   - `ProcessAiRequestAsync(string appId, PluginMessage originalRequest)`:
     * Get config for app. If no config, return error "No AI workflow configured for app".
     * **Budget enforcement:**
       - Get usage tracking for app.
       - If `BudgetLimitPerMonth` set and `TotalSpentThisMonth >= BudgetLimitPerMonth`, return error "Monthly AI budget exceeded".
       - If `BudgetLimitPerRequest` set, include limit in forwarded message.
     * **Concurrency enforcement:**
       - If `ActiveConcurrentRequests >= MaxConcurrentRequests`, return error "Max concurrent AI requests reached".
       - Increment `ActiveConcurrentRequests` using `Interlocked.Increment`.
     * **Operation enforcement:**
       - Extract operation type from originalRequest.Payload["Operation"].
       - If not in `AllowedOperations`, return error "Operation not allowed for this app".
     * **Approval enforcement:**
       - If `RequireApproval` and estimated cost > threshold, return response with `NeedsApproval = true`.
     * **Forward to Intelligence:**
       - Create enriched message with `Payload["AiMode"] = config.Mode.ToString()`, `Payload["PreferredProvider"]`, `Payload["PreferredModel"]`, `Payload["AppId"]`.
       - Send via `_messageBus.SendAsync("intelligence.request", enrichedMessage)`.
       - On response, update usage: `TotalSpentThisMonth += cost`, `RequestCountThisMonth++`, decrement `ActiveConcurrentRequests`.
       - Return Intelligence response.
   - `ResetMonthlyUsageAsync(string appId)` -- resets TotalSpentThisMonth and RequestCountThisMonth.
   - `GetUsageAsync(string appId)` -- returns current AiUsageTracking.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` -- zero errors. Verify: (1) AiWorkflowMode has all 4 modes, (2) budget enforcement checks monthly and per-request limits, (3) concurrency uses Interlocked, (4) all communication via message bus topics, (5) no direct plugin references.
  </verify>
  <done>
AppAiWorkflowConfig supports 4 modes (Auto/Manual/Budget/Approval) with budget limits, model preferences, operation restrictions, and concurrency caps. AppAiWorkflowStrategy enforces all constraints before forwarding to Intelligence via message bus. Usage tracking maintains per-app monthly spend and request counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AI workflow into AppPlatformPlugin with topic handlers</name>
  <files>
    Plugins/DataWarehouse.Plugins.AppPlatform/AppPlatformPlugin.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/Models/PlatformTopics.cs
  </files>
  <action>
1. Update `Models/PlatformTopics.cs` -- add AI workflow topic constants:
   - `AiWorkflowConfigure = $"{Prefix}.ai.configure"`
   - `AiWorkflowRemove = $"{Prefix}.ai.remove"`
   - `AiWorkflowGet = $"{Prefix}.ai.get"`
   - `AiWorkflowUpdate = $"{Prefix}.ai.update"`
   - `AiRequest = $"{Prefix}.ai.request"` -- app-scoped AI request
   - `AiUsageGet = $"{Prefix}.ai.usage"` -- get usage tracking
   - `AiUsageReset = $"{Prefix}.ai.usage.reset"` -- reset monthly usage
   - XML docs on each.

2. Update `AppPlatformPlugin.cs`:
   - Add private field `AppAiWorkflowStrategy? _aiWorkflowStrategy`.
   - Update `InitializeServices()` to create: `_aiWorkflowStrategy = new AppAiWorkflowStrategy(MessageBus!, Id)`.
   - Add subscriptions in `SubscribeToPlatformTopics()`:
     * `PlatformTopics.AiWorkflowConfigure` -> `HandleAiWorkflowConfigureAsync`:
       - Extract AppId, Mode, BudgetLimitPerMonth, BudgetLimitPerRequest, PreferredProvider, PreferredModel, RequireApproval, MaxConcurrentRequests, AllowedOperations from Payload.
       - Parse Mode string to `AiWorkflowMode` enum.
       - Create `AppAiWorkflowConfig` record.
       - Call `_aiWorkflowStrategy!.ConfigureWorkflowAsync(config)`.
       - Return MessageResponse.
     * `PlatformTopics.AiWorkflowRemove` -> `HandleAiWorkflowRemoveAsync`:
       - Extract AppId. Call `_aiWorkflowStrategy!.RemoveWorkflowAsync(appId)`. Return result.
     * `PlatformTopics.AiWorkflowGet` -> `HandleAiWorkflowGetAsync`:
       - Extract AppId. Call `_aiWorkflowStrategy!.GetWorkflowAsync(appId)`. Return config or error.
     * `PlatformTopics.AiWorkflowUpdate` -> `HandleAiWorkflowUpdateAsync`:
       - Extract fields, build updated config, call `UpdateWorkflowAsync`. Return result.
     * `PlatformTopics.AiRequest` -> `HandleAiRequestAsync`:
       - Extract AppId and RawKey from Payload.
       - Validate token via `_tokenService!.ValidateTokenAsync(rawKey)`.
       - If invalid, return auth error.
       - Check "intelligence" is in AllowedScopes.
       - Call `_aiWorkflowStrategy!.ProcessAiRequestAsync(appId, message)`.
       - Return Intelligence result.
     * `PlatformTopics.AiUsageGet` -> `HandleAiUsageGetAsync`:
       - Extract AppId. Return usage tracking.
     * `PlatformTopics.AiUsageReset` -> `HandleAiUsageResetAsync`:
       - Extract AppId. Reset monthly usage. Return success.
   - All handlers have XML docs and use try-catch with MessageResponse.Error for failures.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` -- zero errors. Verify: (1) 7 new AI workflow topic handlers wired, (2) AiRequest handler validates token and checks "intelligence" scope before delegating, (3) all topic strings in PlatformTopics class, (4) AiWorkflowMode enum parsing handles all 4 values.
  </verify>
  <done>
AI workflow fully wired into AppPlatformPlugin with 7 topic handlers. Apps configure their AI workflow mode (auto/manual/budget/approval), set budget limits, and submit AI requests. Token validation and scope checking enforced on AI requests. Usage tracking provides monthly spend and request counts.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` compiles cleanly
2. AppAiWorkflowConfig has all 4 modes with budget, provider, and operation controls
3. Budget enforcement rejects requests exceeding monthly or per-request limits
4. Concurrency enforcement uses Interlocked for thread-safe tracking
5. AI requests validate token and check "intelligence" scope before processing
6. All 7 AI workflow topic handlers registered in plugin
7. No direct plugin references -- Intelligence reached via message bus only
</verification>

<success_criteria>
- Per-app AI workflows configurable with 4 modes (Auto/Manual/Budget/Approval)
- Budget enforcement blocks over-budget requests with clear error messages
- Concurrency limiting prevents request storms
- Operation restrictions filter to allowed AI operations only
- Usage tracking maintains per-app monthly costs and request counts
- All communication to Intelligence via message bus
</success_criteria>

<output>
After completion, create `.planning/phases/19-app-platform/19-03-SUMMARY.md`
</output>
