---
phase: 19-app-platform
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppAccessPolicy.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppAccessPolicyStrategy.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Services/AppContextRouter.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppRequestContext.cs
  - Plugins/DataWarehouse.Plugins.AppPlatform/AppPlatformPlugin.cs
autonomous: true
must_haves:
  truths:
    - "Each registered app has its own RBAC/ABAC policy rules within UltimateAccessControl"
    - "Per-app access policies are configured via message bus, not direct plugin reference"
    - "Incoming service requests are enriched with AppRequestContext (AppId, ServiceTokenId, scopes) before forwarding"
    - "The AppContextRouter validates the service token before forwarding any request"
    - "Downstream plugins receive app context metadata in every forwarded message payload"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppAccessPolicy.cs"
      provides: "Per-app access control policy configuration records"
      contains: "sealed record AppAccessPolicy"
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppRequestContext.cs"
      provides: "Standard context record included in all platform-routed messages"
      contains: "sealed record AppRequestContext"
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppAccessPolicyStrategy.cs"
      provides: "Strategy that binds per-app RBAC/ABAC rules into access control via message bus"
      contains: "sealed class AppAccessPolicyStrategy"
    - path: "Plugins/DataWarehouse.Plugins.AppPlatform/Services/AppContextRouter.cs"
      provides: "Request router that validates tokens, resolves app context, forwards to service plugins"
      contains: "sealed class AppContextRouter"
  key_links:
    - from: "AppAccessPolicyStrategy.cs"
      to: "accesscontrol.policy.bind"
      via: "message bus SendAsync to bind per-app policies"
      pattern: "SendAsync.*accesscontrol\\.policy"
    - from: "AppContextRouter.cs"
      to: "ServiceTokenService"
      via: "token validation before forwarding"
      pattern: "ValidateTokenAsync"
    - from: "AppContextRouter.cs"
      to: "platform.service.*"
      via: "SubscribePattern for all service requests"
      pattern: "SubscribePattern.*platform\\.service"
    - from: "AppContextRouter.cs"
      to: "downstream plugin topics"
      via: "SendAsync with enriched AppRequestContext in payload"
      pattern: "Payload\\[.*AppContext"
---

<objective>
Implement per-app access control policy isolation and the service request routing layer.

Purpose: Each registered app needs its own RBAC/ABAC rules enforced by UltimateAccessControl, and all incoming service requests must be authenticated (via service token) and enriched with app context before being forwarded to downstream plugins.

Output: AppAccessPolicyStrategy for policy binding, AppContextRouter for request routing with token validation, and AppRequestContext model for standardized context propagation.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-app-platform/19-RESEARCH.md
@.planning/phases/19-app-platform/19-01-SUMMARY.md
@DataWarehouse.SDK/Contracts/IMessageBus.cs
@DataWarehouse.SDK/Utilities/PluginDetails.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppAccessPolicy model, AppRequestContext, and AppAccessPolicyStrategy</name>
  <files>
    Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppAccessPolicy.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/Models/AppRequestContext.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/AppAccessPolicyStrategy.cs
  </files>
  <action>
1. Create `Models/AppAccessPolicy.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Models`:
   - `sealed record AppAccessPolicy` with:
     * `required string AppId`
     * `required string PolicyId` (generated on creation)
     * `AccessControlModel Model` enum (RBAC, ABAC, MAC, DAC, PBAC)
     * `required AppRole[] Roles` (for RBAC model)
     * `required AppAttribute[] Attributes` (for ABAC model)
     * `bool EnforceTenantIsolation` (default true)
     * `bool AllowCrossTenantAccess` (default false)
     * `string[] AllowedCrossTenantApps` (default [])
     * `DateTime CreatedAt`
     * `DateTime? UpdatedAt`
   - `enum AccessControlModel` with: RBAC, ABAC, MAC, DAC, PBAC
   - `sealed record AppRole` with: `required string RoleName`, `required string[] Permissions`, `string? Description`
   - `sealed record AppAttribute` with: `required string AttributeName`, `required string AttributeValue`, `AttributeOperator Operator` (default Equals)
   - `enum AttributeOperator` with: Equals, NotEquals, Contains, GreaterThan, LessThan, In, NotIn
   - All with XML docs.

2. Create `Models/AppRequestContext.cs` in same namespace:
   - `sealed record AppRequestContext` with:
     * `required string AppId` -- identifies the app
     * `required string TokenId` -- which token was used
     * `required string[] AllowedScopes` -- scopes from validated token
     * `required DateTime RequestTimestamp` -- when the request arrived
     * `string? RequestId` -- optional correlation ID (default Guid.NewGuid().ToString("N"))
     * `Dictionary<string, object> AdditionalContext` (default new())
   - Include a `ToDictionary()` method that returns `Dictionary<string, object>` containing all fields serialized for embedding in PluginMessage.Payload.
   - Static `FromPayload(Dictionary<string, object> payload)` method to reconstruct from a message payload.
   - XML docs on every member.

3. Create directory `Plugins/DataWarehouse.Plugins.AppPlatform/Strategies/`.

4. Create `Strategies/AppAccessPolicyStrategy.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Strategies`:
   - `internal sealed class AppAccessPolicyStrategy` with XML docs.
   - Constructor takes `IMessageBus messageBus, string pluginId`.
   - `ConcurrentDictionary<string, AppAccessPolicy> _policies` for per-app policies.
   - `BindPolicyAsync(AppAccessPolicy policy)`:
     * Store in `_policies`.
     * Send policy binding to UltimateAccessControl via message bus:
       `_messageBus.SendAsync("accesscontrol.policy.bind", new PluginMessage { Type = "accesscontrol.policy.bind", SourcePluginId = _pluginId, Payload = { ["AppId"] = policy.AppId, ["PolicyId"] = policy.PolicyId, ["Model"] = policy.Model.ToString(), ["Roles"] = policy.Roles, ["Attributes"] = policy.Attributes, ["EnforceTenantIsolation"] = policy.EnforceTenantIsolation, ["AllowCrossTenantAccess"] = policy.AllowCrossTenantAccess } })`.
     * Return MessageResponse from access control.
   - `UnbindPolicyAsync(string appId)`:
     * Remove from `_policies`.
     * Send unbind via message bus: `_messageBus.SendAsync("accesscontrol.policy.unbind", ...)`.
   - `GetPolicyAsync(string appId)` -- lookup from `_policies`.
   - `UpdatePolicyAsync(AppAccessPolicy updatedPolicy)` -- update in dict and rebind via message bus.
   - `EvaluateAccessAsync(string appId, string userId, string resource, string action)`:
     * Send evaluation request via message bus: `_messageBus.SendAsync("accesscontrol.evaluate", new PluginMessage { ..., Payload = { ["TenantId"] = appId, ["UserId"] = userId, ["Resource"] = resource, ["Action"] = action } })`.
     * Return MessageResponse with allow/deny decision.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` -- zero errors. Verify: AppAccessPolicy has RBAC and ABAC support, AppRequestContext has ToDictionary/FromPayload, all message bus calls use string topics (no direct plugin references).
  </verify>
  <done>
Per-app access policy model supports RBAC/ABAC/MAC/DAC/PBAC modes. Policy binding communicates with UltimateAccessControl via message bus. AppRequestContext provides standardized context propagation format for all platform-routed messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement AppContextRouter and wire into AppPlatformPlugin</name>
  <files>
    Plugins/DataWarehouse.Plugins.AppPlatform/Services/AppContextRouter.cs
    Plugins/DataWarehouse.Plugins.AppPlatform/AppPlatformPlugin.cs
  </files>
  <action>
1. Create `Services/AppContextRouter.cs` in namespace `DataWarehouse.Plugins.AppPlatform.Services`:
   - `internal sealed class AppContextRouter` with XML docs.
   - Constructor takes `IMessageBus messageBus, string pluginId, ServiceTokenService tokenService, AppRegistrationService registrationService`.
   - Core method `RouteServiceRequestAsync(PluginMessage message, string targetServiceTopic)`:
     * Extract `RawKey` from message.Payload (service token for authentication).
     * Call `_tokenService.ValidateTokenAsync(rawKey)`.
     * If invalid: return `MessageResponse.Error("Invalid or expired service token", "AUTH_FAILED")`.
     * Check scope: verify the target service (e.g., "storage", "intelligence") is in `AllowedScopes`.
     * If scope denied: return `MessageResponse.Error("Token does not have scope for this service", "SCOPE_DENIED")`.
     * Verify app exists and is Active via `_registrationService.GetAppAsync(appId)`.
     * If app not active: return `MessageResponse.Error("Application is not active", "APP_INACTIVE")`.
     * Create `AppRequestContext` with AppId, TokenId, AllowedScopes, RequestTimestamp.
     * Enrich the forwarded message: create new PluginMessage with original Payload PLUS `["AppId"] = appId`, `["AppContext"] = context.ToDictionary()`, `["ServiceTokenId"] = tokenId`. Set SourcePluginId to this plugin's ID.
     * Forward via `_messageBus.SendAsync(targetServiceTopic, enrichedMessage)`.
     * Return the downstream response.
   - Service-specific route methods (thin wrappers calling RouteServiceRequestAsync with correct topic):
     * `RouteStorageRequestAsync(PluginMessage msg)` -- routes to `"storage.request"`, validates "storage" scope
     * `RouteAccessControlRequestAsync(PluginMessage msg)` -- routes to `"accesscontrol.request"`, validates "accesscontrol" scope
     * `RouteIntelligenceRequestAsync(PluginMessage msg)` -- routes to `"intelligence.request"`, validates "intelligence" scope
     * `RouteObservabilityRequestAsync(PluginMessage msg)` -- routes to `"observability.request"`, validates "observability" scope
     * `RouteReplicationRequestAsync(PluginMessage msg)` -- routes to `"replication.request"`, validates "replication" scope
     * `RouteComplianceRequestAsync(PluginMessage msg)` -- routes to `"compliance.request"`, validates "compliance" scope
   - All methods are async with CancellationToken support.

2. Update `AppPlatformPlugin.cs`:
   - Add private field `AppAccessPolicyStrategy? _accessPolicyStrategy`.
   - Add private field `AppContextRouter? _contextRouter`.
   - Update `InitializeServices()` to also create:
     * `_accessPolicyStrategy = new AppAccessPolicyStrategy(MessageBus!, Id)`
     * `_contextRouter = new AppContextRouter(MessageBus!, Id, _tokenService!, _registrationService!)`
   - Add new message bus subscriptions in `SubscribeToPlatformTopics()`:
     * `PlatformTopics.ServiceStorage` -> handler calls `_contextRouter!.RouteStorageRequestAsync(msg)` and returns MessageResponse
     * `PlatformTopics.ServiceAccessControl` -> handler calls `_contextRouter!.RouteAccessControlRequestAsync(msg)`
     * `PlatformTopics.ServiceIntelligence` -> handler calls `_contextRouter!.RouteIntelligenceRequestAsync(msg)`
     * `PlatformTopics.ServiceObservability` -> handler calls `_contextRouter!.RouteObservabilityRequestAsync(msg)`
     * `PlatformTopics.ServiceReplication` -> handler calls `_contextRouter!.RouteReplicationRequestAsync(msg)`
     * `PlatformTopics.ServiceCompliance` -> handler calls `_contextRouter!.RouteComplianceRequestAsync(msg)`
   - Add policy management handlers:
     * New topic const or inline string "platform.policy.bind" -> `HandlePolicyBindAsync` which calls `_accessPolicyStrategy!.BindPolicyAsync(...)`
     * "platform.policy.unbind" -> `HandlePolicyUnbindAsync`
     * "platform.policy.get" -> `HandlePolicyGetAsync`
     * "platform.policy.evaluate" -> `HandlePolicyEvaluateAsync`
   - Add the new policy topics to `PlatformTopics.cs`: PolicyBind, PolicyUnbind, PolicyGet, PolicyEvaluate.
   - All new handlers have XML docs.
  </action>
  <verify>
Run `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` -- zero errors. Verify: (1) AppContextRouter validates token before any forwarding, (2) scope checking enforced per service, (3) enriched messages include AppId, AppContext, and ServiceTokenId in Payload, (4) policy management wired through message bus, (5) no direct plugin references.
  </verify>
  <done>
AppContextRouter authenticates every incoming service request via token validation, checks scope authorization, verifies app status, enriches messages with AppRequestContext, and forwards to downstream plugins. Per-app access policies can be bound, unbound, queried, and evaluated via message bus. All 6 service routes (storage, accesscontrol, intelligence, observability, replication, compliance) are wired.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Plugins/DataWarehouse.Plugins.AppPlatform/DataWarehouse.Plugins.AppPlatform.csproj` compiles cleanly
2. AppContextRouter.RouteServiceRequestAsync validates token, checks scope, verifies app status, enriches message
3. AppAccessPolicyStrategy sends policy operations to `accesscontrol.policy.*` topics
4. All 6 service routing handlers registered in AppPlatformPlugin
5. All 4 policy management handlers registered in AppPlatformPlugin
6. No direct plugin references -- all via message bus
7. AppRequestContext.ToDictionary/FromPayload provide round-trip serialization
</verification>

<success_criteria>
- Per-app RBAC/ABAC policies configurable and bound to UltimateAccessControl via message bus
- Service requests authenticated via token, scope-checked, and enriched with app context
- Downstream plugins receive AppId, ServiceTokenId, and full AppRequestContext in every forwarded message
- Invalid tokens, insufficient scopes, and inactive apps all produce appropriate error responses
</success_criteria>

<output>
After completion, create `.planning/phases/19-app-platform/19-02-SUMMARY.md`
</output>
