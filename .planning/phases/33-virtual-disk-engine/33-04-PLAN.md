---
phase: 33-virtual-disk-engine
plan: 04
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Integrity/IBlockChecksummer.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Integrity/BlockChecksummer.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Integrity/ChecksumTable.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Integrity/CorruptionDetector.cs
autonomous: true

must_haves:
  truths:
    - "Every data block has a corresponding XxHash3 checksum stored in a dedicated checksum table"
    - "Every block read verifies its checksum before returning data"
    - "Flipping a single bit in stored data is detected on the next read"
    - "Checksum verification adds less than 5% overhead to sequential reads"
    - "Corruption is reported via a structured CorruptionEvent"
    - "Recently verified blocks are cached to avoid re-verification on repeated reads"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Integrity/IBlockChecksummer.cs"
      provides: "Interface for computing and verifying per-block checksums"
      exports: ["IBlockChecksummer"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Integrity/BlockChecksummer.cs"
      provides: "XxHash3-based block checksum computation and verification"
      exports: ["BlockChecksummer"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Integrity/ChecksumTable.cs"
      provides: "On-disk checksum storage: maps block number to checksum value"
      exports: ["ChecksumTable"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Integrity/CorruptionDetector.cs"
      provides: "Corruption detection, reporting, and batch integrity scanning"
      exports: ["CorruptionDetector", "CorruptionEvent"]
  key_links:
    - from: "BlockChecksummer"
      to: "System.IO.Hashing.XxHash3"
      via: "Computes 64-bit XxHash3 checksums for block data"
      pattern: "XxHash3\\.HashToUInt64"
    - from: "ChecksumTable"
      to: "IBlockDevice"
      via: "Reads/writes checksum table blocks to disk"
      pattern: "IBlockDevice.*ReadBlockAsync|WriteBlockAsync"
    - from: "CorruptionDetector"
      to: "ChecksumTable"
      via: "Batch verifies all blocks against their stored checksums"
      pattern: "ChecksumTable.*GetChecksum|Verify"
---

<objective>
Build the block-level checksumming subsystem for the Virtual Disk Engine using XxHash3 from System.IO.Hashing.

Purpose: Detects silent data corruption (bit rot, media errors, firmware bugs) by computing and verifying a checksum for every data block. This is the integrity backbone of the VDE -- every read is verified, every corruption is detected and reported.

Output: IBlockChecksummer interface, BlockChecksummer with XxHash3, ChecksumTable for on-disk storage, and CorruptionDetector for batch verification and reporting.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-virtual-disk-engine/33-RESEARCH.md
@.planning/phases/33-virtual-disk-engine/33-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: IBlockChecksummer, BlockChecksummer, and ChecksumTable</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Integrity/IBlockChecksummer.cs
    DataWarehouse.SDK/VirtualDiskEngine/Integrity/BlockChecksummer.cs
    DataWarehouse.SDK/VirtualDiskEngine/Integrity/ChecksumTable.cs
  </files>
  <action>
    Create the checksumming subsystem in DataWarehouse.SDK/VirtualDiskEngine/Integrity/:

    **IBlockChecksummer.cs**: Interface:
    - `ulong ComputeChecksum(ReadOnlySpan<byte> blockData)` -- compute XxHash3 checksum for a block
    - `bool VerifyChecksum(ReadOnlySpan<byte> blockData, ulong expectedChecksum)` -- compute and compare
    - `Task StoreChecksumAsync(long blockNumber, ulong checksum, CancellationToken ct = default)` -- persist to checksum table
    - `Task<ulong> GetStoredChecksumAsync(long blockNumber, CancellationToken ct = default)` -- retrieve from table
    - `Task<bool> VerifyBlockAsync(long blockNumber, ReadOnlyMemory<byte> blockData, CancellationToken ct = default)` -- compute, compare with stored, return true/false
    - `Task FlushAsync(CancellationToken ct = default)` -- persist dirty checksum entries

    **BlockChecksummer.cs**: XxHash3-based implementation:
    - Uses `System.IO.Hashing.XxHash3.HashToUInt64(ReadOnlySpan<byte>)` -- already available in SDK via System.IO.Hashing 10.0.3
    - `ComputeChecksum()`: Direct call to XxHash3.HashToUInt64. Zero allocation, span-based.
    - `VerifyChecksum()`: Compute and compare with constant-time comparison (not timing-sensitive for non-crypto checksums, but good practice). Use simple `==` comparison since this is not security-critical.
    - Delegates storage operations to ChecksumTable
    - **Verified block cache**: `ConcurrentDictionary<long, bool>` tracking recently verified blocks. Max 10,000 entries with oldest-first eviction. If a block is in the cache as verified, skip re-verification on read. Invalidate cache entry on any write to that block.
    - `InvalidateCacheEntry(long blockNumber)` -- called by VDE engine after any block write
    - Constructor takes `ChecksumTable table`

    **ChecksumTable.cs**: On-disk checksum storage:
    - Layout: Each checksum is 8 bytes (ulong). With 4096-byte blocks, each checksum table block holds 512 checksums. Block N's checksum is at checksumTable[N / 512], offset (N % 512) * 8.
    - Constructor takes `IBlockDevice device, long checksumTableStartBlock, long checksumTableBlockCount, long totalDataBlocks`
    - In-memory dirty tracking: `HashSet<long>` of dirty checksum table blocks (blocks that have been modified but not flushed to disk)
    - `GetChecksumAsync(long blockNumber)`: Compute which checksum table block contains this entry, read it (or use cached), extract 8 bytes at correct offset, return ulong.
    - `SetChecksumAsync(long blockNumber, ulong checksum)`: Compute position, update in-memory, mark checksum table block as dirty.
    - `FlushAsync()`: Write all dirty checksum table blocks to disk. Clear dirty set.
    - **Checksum table block cache**: `ConcurrentDictionary<long, byte[]>` caching recently-read checksum table blocks. Bounded to 256 entries (covers 131,072 data blocks). Evict oldest on overflow.
    - `static long ComputeRequiredBlocks(long totalDataBlocks, int blockSize)` -- helper for ContainerFormat layout calculation. Returns ceiling(totalDataBlocks * 8 / blockSize).
    - All reads/writes use ArrayPool for temporary block buffers.

    All public APIs have XML docs. Namespace: DataWarehouse.SDK.VirtualDiskEngine.Integrity.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify `using System.IO.Hashing;` is used and XxHash3.HashToUInt64 is called.
  </verify>
  <done>
    BlockChecksummer computes XxHash3 checksums with zero allocation. ChecksumTable stores 8-byte checksums per block in dedicated disk blocks with in-memory dirty tracking and block cache. Verified block cache avoids re-verification overhead on repeated reads.
  </done>
</task>

<task type="auto">
  <name>Task 2: CorruptionDetector for batch verification and reporting</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Integrity/CorruptionDetector.cs
  </files>
  <action>
    Create the corruption detection and reporting layer:

    **CorruptionDetector.cs**: Batch verification and reporting:
    - `CorruptionEvent` record: `long BlockNumber`, `ulong ExpectedChecksum`, `ulong ActualChecksum`, `DateTimeOffset DetectedAtUtc`, `string Description`
    - `CorruptionScanResult` record: `long TotalBlocksScanned`, `long CorruptedBlocks`, `long VerifiedBlocks`, `TimeSpan Duration`, `IReadOnlyList<CorruptionEvent> Events`
    - Constructor takes `IBlockChecksummer checksummer, IBlockDevice device, long dataStartBlock, long dataBlockCount`
    - `Task<bool> VerifyBlockOnReadAsync(long blockNumber, ReadOnlyMemory<byte> blockData, CancellationToken ct)`:
      - Called on every data block read by the VDE engine
      - Delegates to BlockChecksummer.VerifyBlockAsync
      - If verification fails, creates CorruptionEvent, adds to event list, raises OnCorruptionDetected event
      - Returns false if corrupted
    - `Task<CorruptionScanResult> ScanAllBlocksAsync(IProgress<double>? progress = null, CancellationToken ct = default)`:
      - Full integrity scan of all allocated data blocks
      - Reads each block, verifies checksum
      - Reports progress (0.0 to 1.0)
      - Returns CorruptionScanResult with all corruption events
      - Uses ArrayPool for block buffers
    - `Task<CorruptionScanResult> ScanBlockRangeAsync(long startBlock, long blockCount, CancellationToken ct = default)`:
      - Partial scan of a specific block range
    - `event Action<CorruptionEvent>? OnCorruptionDetected` -- event for real-time notification
    - `IReadOnlyList<CorruptionEvent> RecentCorruptionEvents { get; }` -- bounded list (last 1000 events)
    - `long TotalCorruptionCount { get; }` -- lifetime counter
    - `HealthStatus GetHealthStatus()`:
      - Returns Healthy if TotalCorruptionCount == 0
      - Returns Degraded if corruption detected but data is recoverable (via redundancy)
      - Returns Critical if unrecoverable corruption detected
    - `HealthStatus` enum: Healthy, Degraded, Critical

    Thread safety: ConcurrentBag for events, Interlocked for counters.
    All public APIs have XML docs.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify CorruptionDetector uses IBlockChecksummer.
  </verify>
  <done>
    CorruptionDetector verifies blocks on read and provides batch integrity scanning. Corruption events are structured with block number, expected/actual checksum, and timestamp. Real-time notification via event. Health status reporting (Healthy/Degraded/Critical). Full scan with progress reporting.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
- All files exist under DataWarehouse.SDK/VirtualDiskEngine/Integrity/
- XxHash3.HashToUInt64 used for checksum computation (not SHA256 or CRC32)
- ChecksumTable layout: 8 bytes per data block, packed into checksum table blocks
- BlockChecksummer has verified-block cache (bounded, invalidated on write)
- CorruptionDetector reports structured CorruptionEvent on verification failure
- Batch scan provides progress reporting
</verification>

<success_criteria>
- Per-block XxHash3 checksum computed and stored for every data block
- Every read verifies checksum before returning data
- Single-bit corruption detected on next read
- Verified-block cache avoids redundant re-verification (bounded to 10K entries)
- Batch integrity scan covers all allocated blocks with progress reporting
- Corruption events are structured with block number, checksums, timestamp
- Health status reflects corruption state (Healthy/Degraded/Critical)
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-virtual-disk-engine/33-04-SUMMARY.md`
</output>
