---
phase: 33-virtual-disk-engine
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Metadata/InodeStructure.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Metadata/IInodeTable.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Metadata/InodeTable.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Metadata/DirectoryEntry.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Metadata/NamespaceTree.cs
autonomous: true

must_haves:
  truths:
    - "An inode stores file metadata: permissions, timestamps, size, owner, block pointers, and extended attributes"
    - "Directory entries map names to inode numbers in a hierarchical namespace"
    - "Hard links create multiple directory entries pointing to the same inode (reference counted)"
    - "Soft links store a target path as inode data"
    - "Extended attributes store arbitrary key-value metadata on any inode"
    - "Inode numbers are stable across renames (only directory entry changes)"
    - "A directory tree 5 levels deep with 1000 files can be created and traversed"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Metadata/InodeStructure.cs"
      provides: "On-disk inode data structure with permissions, timestamps, block pointers, xattrs"
      exports: ["Inode", "InodeType", "InodePermissions"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Metadata/IInodeTable.cs"
      provides: "Interface for inode CRUD operations"
      exports: ["IInodeTable"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Metadata/InodeTable.cs"
      provides: "On-disk inode table stored in allocated blocks"
      exports: ["InodeTable"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Metadata/DirectoryEntry.cs"
      provides: "Directory entry structure mapping name to inode number"
      exports: ["DirectoryEntry"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Metadata/NamespaceTree.cs"
      provides: "Hierarchical namespace with path resolution, mkdir, link, unlink"
      exports: ["NamespaceTree"]
  key_links:
    - from: "InodeTable"
      to: "IBlockAllocator"
      via: "Allocates blocks for new inodes and inode data"
      pattern: "IBlockAllocator.*Allocate"
    - from: "InodeTable"
      to: "IBlockDevice"
      via: "Reads/writes inode blocks to disk"
      pattern: "IBlockDevice.*ReadBlockAsync|WriteBlockAsync"
    - from: "NamespaceTree"
      to: "InodeTable"
      via: "Resolves paths by walking directory inodes"
      pattern: "InodeTable.*Get|Create"
    - from: "DirectoryEntry"
      to: "InodeStructure"
      via: "Each entry references an inode by number"
      pattern: "InodeNumber"
---

<objective>
Build the inode table and metadata management subsystem for the Virtual Disk Engine.

Purpose: The inode system provides the namespace and metadata layer that maps human-readable paths to block-level storage. It enables directory hierarchies, file metadata (permissions, timestamps), hard/soft links, and extended attributes -- the essential abstraction between "named files" and "raw blocks."

Output: InodeStructure, InodeTable, DirectoryEntry, and NamespaceTree classes providing a complete POSIX-like metadata layer.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-virtual-disk-engine/33-RESEARCH.md
@.planning/phases/33-virtual-disk-engine/33-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: InodeStructure, DirectoryEntry, and IInodeTable interface</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Metadata/InodeStructure.cs
    DataWarehouse.SDK/VirtualDiskEngine/Metadata/DirectoryEntry.cs
    DataWarehouse.SDK/VirtualDiskEngine/Metadata/IInodeTable.cs
  </files>
  <action>
    Create the metadata data structures in DataWarehouse.SDK/VirtualDiskEngine/Metadata/:

    **InodeStructure.cs**: On-disk inode structure:
    - `InodeType` enum: File, Directory, SymLink, HardLinkTarget
    - `InodePermissions` flags enum: OwnerRead, OwnerWrite, OwnerExecute, GroupRead, GroupWrite, GroupExecute, OtherRead, OtherWrite, OtherExecute (standard rwxrwxrwx)
    - `Inode` class with:
      - `long InodeNumber` (unique, stable across renames)
      - `InodeType Type`
      - `InodePermissions Permissions`
      - `int LinkCount` (hard link reference count)
      - `long OwnerId`, `long GroupId`
      - `long Size` (bytes for files, entry count for directories)
      - `long CreatedUtc`, `long ModifiedUtc`, `long AccessedUtc` (Unix ticks)
      - `long[] DirectBlockPointers` (12 direct block pointers for small files -- block numbers)
      - `long IndirectBlockPointer` (single indirect: block number pointing to block of block numbers)
      - `long DoubleIndirectPointer` (double indirect for large files)
      - `Dictionary<string, byte[]> ExtendedAttributes` (xattrs -- key-value, persisted in overflow blocks)
      - `string? SymLinkTarget` (for symlinks only)
    - `Serialize(Span<byte> buffer)` and `static Deserialize(ReadOnlySpan<byte> buffer)` using BinaryPrimitives for little-endian
    - Fixed inode size: 256 bytes on disk (excluding xattr overflow). 16 inodes per 4096-byte block.
    - Inode block layout: pack inodes sequentially, inode N is at block (inodeTableStart + N/16), offset (N%16)*256

    **DirectoryEntry.cs**: Directory entry structure:
    - `long InodeNumber`
    - `byte NameLength` (max 255)
    - `string Name` (UTF-8 encoded, max 255 bytes)
    - `InodeType Type` (cached from inode for readdir optimization)
    - Variable size: 8 + 1 + 1 + NameLength bytes (inode# + type + nameLen + name)
    - `Serialize(Span<byte> buffer)` and `static Deserialize(ReadOnlySpan<byte> buffer)` using BinaryPrimitives
    - Directory entries are packed into data blocks of the directory inode. Multiple entries per block. Entry count stored at block start (2 bytes).

    **IInodeTable.cs**: Interface:
    - `Task<Inode> AllocateInodeAsync(InodeType type, CancellationToken ct = default)`
    - `Task<Inode?> GetInodeAsync(long inodeNumber, CancellationToken ct = default)`
    - `Task UpdateInodeAsync(Inode inode, CancellationToken ct = default)`
    - `Task FreeInodeAsync(long inodeNumber, CancellationToken ct = default)`
    - `Task<IReadOnlyList<DirectoryEntry>> ReadDirectoryAsync(long directoryInodeNumber, CancellationToken ct = default)`
    - `Task AddDirectoryEntryAsync(long directoryInodeNumber, DirectoryEntry entry, CancellationToken ct = default)`
    - `Task RemoveDirectoryEntryAsync(long directoryInodeNumber, string name, CancellationToken ct = default)`
    - `Task SetExtendedAttributeAsync(long inodeNumber, string key, byte[] value, CancellationToken ct = default)`
    - `Task<byte[]?> GetExtendedAttributeAsync(long inodeNumber, string key, CancellationToken ct = default)`
    - `Task<IReadOnlyDictionary<string, byte[]>> ListExtendedAttributesAsync(long inodeNumber, CancellationToken ct = default)`
    - `long AllocatedInodeCount { get; }`
    - `Inode RootInode { get; }` (inode 0 or 1 is always the root directory)

    All public APIs have XML documentation. Use DataWarehouse.SDK.VirtualDiskEngine.Metadata namespace.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify InodeStructure serializes to exactly 256 bytes fixed size.
  </verify>
  <done>
    Inode structure defined with type, permissions, timestamps, block pointers (direct + indirect + double-indirect), xattrs. DirectoryEntry maps names to inodes with variable-length encoding. IInodeTable interface covers all inode CRUD, directory operations, and xattr management.
  </done>
</task>

<task type="auto">
  <name>Task 2: InodeTable implementation and NamespaceTree</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Metadata/InodeTable.cs
    DataWarehouse.SDK/VirtualDiskEngine/Metadata/NamespaceTree.cs
  </files>
  <action>
    Implement the full metadata management layer:

    **InodeTable.cs**: IInodeTable implementation:
    - Constructor takes `IBlockDevice device, IBlockAllocator allocator, long inodeTableStartBlock, long inodeTableBlockCount`
    - Maintains in-memory inode cache (`ConcurrentDictionary<long, Inode>`) with bounded size (max 10,000 cached inodes)
    - `_nextInodeNumber` counter (persisted in superblock extension or first inode block header)
    - `AllocateInodeAsync()`: Increment counter, create Inode with defaults, write to disk, return
    - `GetInodeAsync()`: Check cache, read from disk if miss, cache result
    - `UpdateInodeAsync()`: Update cache, write to disk
    - `FreeInodeAsync()`: Clear inode on disk (zero bytes), remove from cache, do NOT decrement counter (inode numbers never reused)
    - Directory operations: ReadDirectoryAsync reads all data blocks of a directory inode, deserializes DirectoryEntry list. AddDirectoryEntryAsync appends entry to last directory data block (allocates new block if full). RemoveDirectoryEntryAsync compacts entries.
    - Block pointer resolution: For file inodes, resolve block number from logical offset using direct/indirect/double-indirect pointers. `ResolveBlockAsync(Inode inode, long logicalBlockIndex)` returns physical block number.
    - `AllocateDataBlockAsync(Inode inode)`: Adds a new data block to the inode's block pointer list (fills direct first, then indirect, then double-indirect). Uses IBlockAllocator.
    - Extended attributes: Stored as serialized key-value pairs in dedicated overflow blocks referenced by the inode. Simple scheme: serialize all xattrs to byte array, store in blocks.
    - Initialization: On container create, allocate root directory inode (inode 1) with type Directory, full permissions.
    - Thread safety: `SemaphoreSlim` per-inode for write operations, concurrent reads via cache.
    - Use ArrayPool for all block-sized temporary buffers.

    **NamespaceTree.cs**: Hierarchical path resolution:
    - Constructor takes `IInodeTable inodeTable`
    - `ResolvePath(string path)` -> `Task<Inode?>`: Walk path components from root inode, reading directory entries at each level. Returns null if any component not found.
    - `CreateFileAsync(string path, InodePermissions perms)` -> `Task<Inode>`: Resolve parent directory, allocate file inode, add directory entry. Throw if parent doesn't exist or name already exists.
    - `CreateDirectoryAsync(string path, InodePermissions perms)` -> `Task<Inode>`: Same as file but type=Directory. Add "." and ".." entries.
    - `DeleteAsync(string path)` -> `Task`: Resolve path, decrement link count. If link count reaches 0, free inode and all data blocks. For directories, must be empty (except . and ..).
    - `HardLinkAsync(string existingPath, string newPath)` -> `Task`: Resolve existing inode, add new directory entry in target directory, increment link count. Cannot hard-link directories.
    - `SymLinkAsync(string targetPath, string linkPath)` -> `Task<Inode>`: Create new inode with type SymLink, store targetPath as symlink data.
    - `RenameAsync(string oldPath, string newPath)` -> `Task`: Remove directory entry from old parent, add to new parent. Inode number unchanged (stable across renames).
    - `StatAsync(string path)` -> `Task<Inode?>`: Resolve path and return inode metadata.
    - `ListDirectoryAsync(string path)` -> `Task<IReadOnlyList<DirectoryEntry>>`: Resolve directory inode, read entries.
    - Path validation: No null/empty, no path traversal (..), forward slashes only, max 255 bytes per component, max 4096 bytes total path.
    - All public APIs have XML documentation.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `class InodeTable : IInodeTable` to confirm implementation.
  </verify>
  <done>
    InodeTable persists inodes to disk blocks with bounded cache, supports direct/indirect/double-indirect block pointers for files of any size. NamespaceTree provides full path resolution, file/directory creation, deletion, hard links, soft links, rename (inode-stable), and directory listing. Root inode created on container initialization.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
- All files exist under DataWarehouse.SDK/VirtualDiskEngine/Metadata/
- Inode structure serializes to 256 bytes fixed size
- InodeTable uses IBlockAllocator for data block allocation
- NamespaceTree resolves hierarchical paths by walking directory inodes
- Hard links increment link count, soft links store target path
- Extended attributes stored as serialized key-value pairs in overflow blocks
</verification>

<success_criteria>
- Inodes store complete metadata: type, permissions (rwx), timestamps (create/modify/access), size, owner/group, block pointers, xattrs
- Directory entries map names (UTF-8, max 255 bytes) to inode numbers
- Hierarchical namespace: create file, create directory, delete, rename, hard link, soft link
- Inode numbers are stable across renames
- Root directory inode created on container initialization
- Direct + indirect + double-indirect block pointers support files of any size
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-virtual-disk-engine/33-02-SUMMARY.md`
</output>
