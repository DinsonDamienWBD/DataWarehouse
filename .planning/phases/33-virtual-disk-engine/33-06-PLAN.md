---
phase: 33-virtual-disk-engine
plan: 06
type: execute
wave: 4
depends_on: ["33-01", "33-02", "33-03", "33-04", "33-05"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/ICowEngine.cs
  - DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/CowBlockManager.cs
  - DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/SnapshotManager.cs
  - DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/SpaceReclaimer.cs
autonomous: true

must_haves:
  truths:
    - "Snapshot creation is O(1): clones root inode and increments block reference counts"
    - "Modifying the original after snapshot does not affect the snapshot (copy-on-write)"
    - "Snapshots are read-only point-in-time views"
    - "Cloning creates a writable copy sharing all unchanged blocks with the original"
    - "Deleting a snapshot only frees blocks whose reference count drops to zero"
    - "Block reference counts are tracked in a B-Tree and persisted to disk"
    - "Space reclamation correctly handles cascading deref across multiple snapshots"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/ICowEngine.cs"
      provides: "Interface for CoW write path, snapshot creation, clone, and reference management"
      exports: ["ICowEngine"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/CowBlockManager.cs"
      provides: "Copy-on-write block modification: read-copy-modify with reference tracking"
      exports: ["CowBlockManager"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/SnapshotManager.cs"
      provides: "Snapshot creation, listing, deletion, and clone operations"
      exports: ["SnapshotManager", "Snapshot"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/SpaceReclaimer.cs"
      provides: "Reference-counted space reclamation when snapshots are deleted"
      exports: ["SpaceReclaimer"]
  key_links:
    - from: "CowBlockManager"
      to: "IBTreeIndex"
      via: "Block reference counts stored in a dedicated B-Tree"
      pattern: "IBTreeIndex.*Lookup|Insert|Update"
    - from: "CowBlockManager"
      to: "IBlockAllocator"
      via: "Allocates new blocks for CoW copies"
      pattern: "IBlockAllocator.*AllocateBlock"
    - from: "CowBlockManager"
      to: "IWriteAheadLog"
      via: "WAL-protects all CoW operations (ref count changes + block copies)"
      pattern: "IWriteAheadLog.*BeginTransaction"
    - from: "SnapshotManager"
      to: "IInodeTable"
      via: "Clones root inode to create snapshot"
      pattern: "IInodeTable.*AllocateInode|GetInode"
    - from: "SpaceReclaimer"
      to: "CowBlockManager"
      via: "Decrements reference counts and frees blocks at zero"
      pattern: "CowBlockManager.*DecrementRef|GetRefCount"
---

<objective>
Build the Copy-on-Write (CoW) engine with snapshot support for the Virtual Disk Engine.

Purpose: CoW enables zero-cost snapshots (point-in-time copies) and efficient clones without data duplication. When a block is modified, the original is preserved for snapshots and a new block is written. This is the mechanism that makes VDE a versioned storage engine, not just a block store.

Output: ICowEngine interface, CowBlockManager for reference tracking and CoW writes, SnapshotManager for snapshot lifecycle, and SpaceReclaimer for garbage collection.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-virtual-disk-engine/33-RESEARCH.md
@.planning/phases/33-virtual-disk-engine/33-01-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-02-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-03-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ICowEngine, CowBlockManager with reference counting</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/ICowEngine.cs
    DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/CowBlockManager.cs
  </files>
  <action>
    Create the CoW core in DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/:

    **ICowEngine.cs**: Interface:
    - `Task<long> WriteBlockCowAsync(long originalBlockNumber, ReadOnlyMemory<byte> newData, CancellationToken ct = default)` -- CoW write: if ref count > 1, allocate new block, write new data there, decrement ref on original. If ref count == 1, write in place. Returns the block number where data was written.
    - `Task IncrementRefAsync(long blockNumber, CancellationToken ct = default)` -- increment reference count (called during snapshot)
    - `Task DecrementRefAsync(long blockNumber, CancellationToken ct = default)` -- decrement reference count (called during delete/snapshot removal). If reaches 0, free block.
    - `Task<int> GetRefCountAsync(long blockNumber, CancellationToken ct = default)` -- get current reference count
    - `Task IncrementRefBatchAsync(IEnumerable<long> blockNumbers, CancellationToken ct = default)` -- batch increment for snapshot creation
    - `Task DecrementRefBatchAsync(IEnumerable<long> blockNumbers, CancellationToken ct = default)` -- batch decrement for snapshot deletion

    **CowBlockManager.cs**: CoW block management with reference tracking:
    - Constructor takes `IBlockDevice device, IBlockAllocator allocator, IBTreeIndex refCountTree, IWriteAheadLog wal, IBlockChecksummer checksummer`
    - **Reference count storage**: Uses a dedicated B-Tree (refCountTree) where key = block number (8 bytes, big-endian for correct B-Tree ordering), value = reference count encoded as long.
    - Default reference count for newly allocated blocks = 1 (not tracked in B-Tree until it changes from 1 to save space). Only blocks with refCount != 1 are stored in the B-Tree.
    - `WriteBlockCowAsync()`:
      1. Begin WAL transaction
      2. Get ref count for originalBlockNumber (default 1 if not in B-Tree)
      3. If refCount == 1: write newData to originalBlockNumber in place (no copy needed). Update checksum.
      4. If refCount > 1: allocate new block, write newData to new block, decrement refCount on original, update checksum for new block. Return new block number.
      5. Commit WAL transaction
    - `IncrementRefAsync()`:
      1. Get current refCount (default 1)
      2. If refCount == 1: insert into B-Tree with value 2
      3. If refCount > 1: update B-Tree entry to refCount + 1
    - `DecrementRefAsync()`:
      1. Get current refCount (default 1)
      2. If refCount == 1: free block via allocator, remove from B-Tree if present
      3. If refCount == 2: delete from B-Tree (back to default 1)
      4. If refCount > 2: update B-Tree entry to refCount - 1
    - `IncrementRefBatchAsync()`: Begin single WAL transaction, increment all refs, commit. Optimized for snapshot creation where many blocks need ref increment.
    - `DecrementRefBatchAsync()`: Begin single WAL transaction, decrement all refs, free blocks at zero, commit.
    - Thread safety: All operations go through WAL transactions which are serialized. No additional locking needed beyond WAL serialization.
    - Use ArrayPool for temporary buffers.

    All public APIs have XML docs. Namespace: DataWarehouse.SDK.VirtualDiskEngine.CopyOnWrite.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors.
  </verify>
  <done>
    CowBlockManager provides CoW write path (allocate-on-modify when refCount > 1, in-place when refCount == 1). Reference counts stored in B-Tree with space optimization (only non-default counts stored). Batch operations for efficient snapshot creation/deletion. All operations WAL-protected.
  </done>
</task>

<task type="auto">
  <name>Task 2: SnapshotManager and SpaceReclaimer</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/SnapshotManager.cs
    DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/SpaceReclaimer.cs
  </files>
  <action>
    Implement snapshot lifecycle and space reclamation:

    **SnapshotManager.cs**: Snapshot lifecycle management:
    - `Snapshot` record: `long SnapshotId`, `string Name`, `long RootInodeNumber` (snapshot's root directory inode), `DateTimeOffset CreatedUtc`, `bool IsReadOnly` (true for snapshots, false for clones), `long BlockCount` (number of blocks at creation time)
    - `SnapshotTable` stored as metadata in a dedicated inode (snapshot metadata inode). Serialized as list of Snapshot records.
    - Constructor takes `IInodeTable inodeTable, ICowEngine cowEngine, IBlockAllocator allocator, IWriteAheadLog wal`
    - `CreateSnapshotAsync(string name, CancellationToken ct)`:
      1. Begin WAL transaction
      2. Get current root directory inode
      3. Collect ALL block numbers referenced by root inode and all descendants (recursive walk of directory tree, collecting all data block pointers from all inodes)
      4. Batch increment ref counts for all collected blocks via CowEngine.IncrementRefBatchAsync()
      5. Allocate new snapshot metadata inode, clone the root inode to create snapshot root
      6. Create Snapshot record with new root inode number
      7. Persist snapshot table
      8. Commit WAL transaction
      9. Return Snapshot
    - `ListSnapshotsAsync(CancellationToken ct)` -> `Task<IReadOnlyList<Snapshot>>`
    - `GetSnapshotAsync(string name, CancellationToken ct)` -> `Task<Snapshot?>`
    - `DeleteSnapshotAsync(string name, CancellationToken ct)`:
      1. Begin WAL transaction
      2. Find snapshot by name
      3. Collect all block numbers referenced by snapshot's root inode tree
      4. Batch decrement ref counts via SpaceReclaimer
      5. Free the snapshot root inode
      6. Remove from snapshot table, persist
      7. Commit WAL transaction
    - `CloneAsync(string snapshotName, string cloneName, CancellationToken ct)`:
      1. Same as CreateSnapshotAsync but with IsReadOnly = false
      2. The clone gets its own root inode that allows modifications
      3. Modifications to clone use CoW (new blocks allocated, original shared blocks preserved)
    - Read operations on snapshots: Access via snapshot's root inode number. All reads work because blocks are shared. Writes rejected for read-only snapshots.

    **SpaceReclaimer.cs**: Reference-counted garbage collection:
    - Constructor takes `ICowEngine cowEngine, IBlockAllocator allocator`
    - `ReclaimBlocksAsync(IEnumerable<long> blockNumbers, CancellationToken ct)`:
      1. For each block number, decrement reference count
      2. If ref count reaches 0: free block via allocator
      3. Track freed blocks count
      4. Return ReclaimResult with (blocksProcessed, blocksFreed, blocksShared)
    - `ReclaimResult` record: `long BlocksProcessed`, `long BlocksFreed`, `long BlocksStillShared`
    - `CollectBlockNumbersAsync(long rootInodeNumber, IInodeTable inodeTable, CancellationToken ct)`:
      1. Recursive walk from root inode
      2. For each inode: collect all direct block pointers, indirect block pointers (and the indirect pointer blocks themselves), double-indirect blocks
      3. For directory inodes: recurse into child inodes
      4. Returns `IReadOnlyList<long>` of all block numbers
      - Uses bounded stack-based traversal (not recursion) to avoid stack overflow on deep trees
    - `EstimateReclaimableSpaceAsync(string snapshotName, SnapshotManager snapshots, IInodeTable inodeTable, CancellationToken ct)`:
      1. Collect all block numbers for snapshot
      2. Check ref counts: blocks with refCount == 1 will be freed
      3. Return estimated bytes reclaimable
    - Thread safety: All operations delegated to CowBlockManager which is WAL-serialized.

    All public APIs have XML docs.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors.
  </verify>
  <done>
    SnapshotManager creates snapshots by cloning root inode and incrementing block ref counts (O(n) in blocks, but O(1) in wall-clock if blocks are counted during normal operation). Clone creates writable copies sharing blocks. SpaceReclaimer handles cascading deref: blocks freed only when last reference removed. All snapshot operations WAL-protected.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
- All files exist under DataWarehouse.SDK/VirtualDiskEngine/CopyOnWrite/
- Reference counts stored in B-Tree (only non-default counts to save space)
- CoW write: in-place if refCount == 1, allocate-new-block if refCount > 1
- Snapshot creation: clone root inode + batch increment all block refs
- Snapshot deletion: batch decrement refs + free blocks at zero
- Clone: like snapshot but writable
- All operations WAL-protected
</verification>

<success_criteria>
- Snapshot creation is O(1) in concept (clone root + increment refs -- actual time proportional to block count but not data copy)
- Modifying original after snapshot: CoW allocates new block, snapshot retains original
- Snapshots are read-only, clones are writable
- Deleting a snapshot frees blocks only when refCount drops to zero
- Reference counts correctly handle multiple snapshots of same data
- SpaceReclaimer collects all block numbers via bounded (non-recursive) tree walk
- Batch ref operations wrapped in single WAL transaction for atomicity
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-virtual-disk-engine/33-06-SUMMARY.md`
</output>
