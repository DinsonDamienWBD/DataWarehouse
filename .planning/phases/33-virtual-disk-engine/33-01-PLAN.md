---
phase: 33-virtual-disk-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
  - DataWarehouse.SDK/VirtualDiskEngine/FileBlockDevice.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Container/Superblock.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Container/ContainerFormat.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Container/ContainerFile.cs
  - DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/IBlockAllocator.cs
  - DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs
  - DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/ExtentTree.cs
  - DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/FreeSpaceManager.cs
  - DataWarehouse.SDK/VirtualDiskEngine/VdeConstants.cs
autonomous: true

must_haves:
  truths:
    - "A DWVD container file can be created with configurable block size and block count"
    - "Opening a container validates magic bytes (DWVD = 0x44575644) and superblock checksum"
    - "Dual superblock mirroring survives corruption of one superblock"
    - "Blocks can be allocated (single and multi-block extents) and deallocated without space leaks"
    - "Free space bitmap accurately tracks all allocated and free blocks"
    - "Extent tree merges adjacent free regions for efficient large allocation"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs"
      provides: "Block device abstraction (read/write/flush by block number)"
      exports: ["IBlockDevice"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/FileBlockDevice.cs"
      provides: "File-backed block device using RandomAccess API"
      exports: ["FileBlockDevice"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Container/Superblock.cs"
      provides: "On-disk superblock structure with DWVD magic, versioning, block layout offsets"
      exports: ["Superblock"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Container/ContainerFile.cs"
      provides: "Create/open/validate/close container files with dual superblock"
      exports: ["ContainerFile"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs"
      provides: "Bitmap-based free space tracking with O(1) single-block allocation"
      exports: ["BitmapAllocator"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/ExtentTree.cs"
      provides: "Extent-based allocation for contiguous multi-block regions"
      exports: ["ExtentTree"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/FreeSpaceManager.cs"
      provides: "Coordinates bitmap + extent tree for unified allocation"
      exports: ["FreeSpaceManager"]
  key_links:
    - from: "ContainerFile"
      to: "FileBlockDevice"
      via: "Container creates and owns the block device"
      pattern: "new FileBlockDevice"
    - from: "ContainerFile"
      to: "Superblock"
      via: "Container reads/writes dual superblocks on open/checkpoint"
      pattern: "Superblock\\.Serialize|Superblock\\.Deserialize"
    - from: "FreeSpaceManager"
      to: "BitmapAllocator"
      via: "Manager delegates single-block allocation to bitmap"
      pattern: "BitmapAllocator\\.Allocate"
    - from: "FreeSpaceManager"
      to: "ExtentTree"
      via: "Manager delegates multi-block allocation to extent tree"
      pattern: "ExtentTree\\.AllocateExtent"
---

<objective>
Build the foundational layer of the Virtual Disk Engine: the container file format with dual superblock and the bitmap block allocator with extent trees.

Purpose: This is Wave 1 -- every other VDE subsystem (inodes, WAL, B-Tree, CoW, checksums) depends on the block device abstraction and block allocator. The container format defines the physical layout of a DWVD file, and the allocator manages free space within it.

Output: IBlockDevice abstraction, FileBlockDevice implementation, Superblock structure, ContainerFile manager, BitmapAllocator, ExtentTree, and FreeSpaceManager -- all in DataWarehouse.SDK/VirtualDiskEngine/.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-virtual-disk-engine/33-RESEARCH.md
@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: IBlockDevice, FileBlockDevice, Superblock, ContainerFile, VdeConstants</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/IBlockDevice.cs
    DataWarehouse.SDK/VirtualDiskEngine/FileBlockDevice.cs
    DataWarehouse.SDK/VirtualDiskEngine/Container/Superblock.cs
    DataWarehouse.SDK/VirtualDiskEngine/Container/ContainerFormat.cs
    DataWarehouse.SDK/VirtualDiskEngine/Container/ContainerFile.cs
    DataWarehouse.SDK/VirtualDiskEngine/VdeConstants.cs
  </files>
  <action>
    Create the foundational VDE types in DataWarehouse.SDK/VirtualDiskEngine/ namespace:

    **VdeConstants.cs**: Constants class with:
    - `MagicBytes` = 0x44575644u ("DWVD" in little-endian)
    - `FormatVersion` = 1
    - `DefaultBlockSize` = 4096
    - `MinBlockSize` = 512
    - `MaxBlockSize` = 65536
    - `SuperblockMirrorOffset` -- block 1 (adjacent to primary at block 0)

    **IBlockDevice.cs**: Interface with:
    - `int BlockSize { get; }`
    - `long BlockCount { get; }`
    - `Task ReadBlockAsync(long blockNumber, Memory<byte> buffer, CancellationToken ct = default)`
    - `Task WriteBlockAsync(long blockNumber, ReadOnlyMemory<byte> data, CancellationToken ct = default)`
    - `Task FlushAsync(CancellationToken ct = default)`
    - Extends IAsyncDisposable

    **FileBlockDevice.cs**: File-backed IBlockDevice implementation:
    - Constructor takes `string path, int blockSize, long blockCount, bool createNew`
    - Use `RandomAccess.ReadAsync`/`WriteAsync` with `SafeFileHandle` for thread-safe I/O (not FileStream.Seek)
    - Pre-allocate file to full size on creation (`RandomAccess.SetLength`)
    - `SemaphoreSlim` for write serialization
    - `FileOptions.Asynchronous | FileOptions.RandomAccess` on the handle
    - Proper IAsyncDisposable with handle cleanup

    **Superblock.cs**: Superblock structure:
    - Fields: Magic (uint), FormatVersion (ushort), Flags (ushort), BlockSize (int), TotalBlocks (long), FreeBlocks (long), InodeTableBlock (long), BitmapStartBlock (long), BitmapBlockCount (long), BTreeRootBlock (long), WalStartBlock (long), WalBlockCount (long), ChecksumTableBlock (long), CreatedTimestampUtc (long, Unix ticks), ModifiedTimestampUtc (long), CheckpointSequence (long), Checksum (ulong -- XxHash64 of all preceding fields)
    - Static `Serialize(Superblock sb, Span<byte> buffer)` using BinaryPrimitives for little-endian
    - Static `Deserialize(ReadOnlySpan<byte> buffer, out Superblock sb)` with magic and checksum validation
    - `ComputeChecksum(ReadOnlySpan<byte> buffer)` using System.IO.Hashing.XxHash64 -- hash all bytes except the last 8 (checksum field)
    - `IsValid()` method checking magic + checksum

    **ContainerFormat.cs**: Static helper with:
    - `ComputeLayout(int blockSize, long totalBlocks)` returns a layout record describing where each region starts (superblock at 0, mirror at 1, bitmap start, inode table start, WAL start, data start, B-Tree root, checksum table)
    - Layout reserves: 2 blocks for superblocks, N blocks for bitmap (1 bit per data block, rounded up), fixed initial inode table region, fixed WAL region (1% of total, min 256 blocks), checksum table region (8 bytes per data block, packed into blocks), remainder = data blocks
    - Layout is a C# record with init-only properties

    **ContainerFile.cs**: Container lifecycle manager:
    - `static async Task<ContainerFile> CreateAsync(string path, int blockSize, long totalBlocks, CancellationToken ct)` -- creates FileBlockDevice, writes initial superblock + mirror, initializes bitmap (all data blocks free), returns ContainerFile
    - `static async Task<ContainerFile> OpenAsync(string path, CancellationToken ct)` -- reads block 0, validates superblock; if primary corrupt, reads mirror from block 1; throws if both corrupt
    - Exposes `IBlockDevice BlockDevice`, `Superblock CurrentSuperblock`, `ContainerLayout Layout`
    - `WriteCheckpointAsync()` -- writes mirror first, then primary superblock (safe ordering)
    - IAsyncDisposable (disposes block device)
    - All on-disk binary formats use little-endian via BinaryPrimitives

    Use `System.IO.Hashing` (already in SDK) for XxHash64. Use ArrayPool for temporary buffers. All public APIs have XML documentation. Namespace: `DataWarehouse.SDK.VirtualDiskEngine` and sub-namespaces.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify files exist in DataWarehouse.SDK/VirtualDiskEngine/ with correct namespace declarations.
  </verify>
  <done>
    IBlockDevice interface defined. FileBlockDevice reads/writes blocks via RandomAccess API. Superblock serializes/deserializes with DWVD magic, XxHash64 checksum, and dual-superblock support. ContainerFile creates/opens/validates containers. ContainerFormat computes block layout.
  </done>
</task>

<task type="auto">
  <name>Task 2: BitmapAllocator, ExtentTree, FreeSpaceManager</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/IBlockAllocator.cs
    DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/BitmapAllocator.cs
    DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/ExtentTree.cs
    DataWarehouse.SDK/VirtualDiskEngine/BlockAllocation/FreeSpaceManager.cs
  </files>
  <action>
    Create the block allocation subsystem:

    **IBlockAllocator.cs**: Interface with:
    - `long AllocateBlock(CancellationToken ct = default)` -- allocate single block, returns block number
    - `long[] AllocateExtent(int blockCount, CancellationToken ct = default)` -- allocate contiguous blocks
    - `void FreeBlock(long blockNumber)` -- free single block
    - `void FreeExtent(long startBlock, int blockCount)` -- free contiguous range
    - `long FreeBlockCount { get; }`
    - `long TotalBlockCount { get; }`
    - `double FragmentationRatio { get; }` -- hint for defragmentation
    - `Task PersistAsync(IBlockDevice device, long bitmapStartBlock, CancellationToken ct = default)` -- write bitmap to disk
    - `static Task<IBlockAllocator> LoadAsync(IBlockDevice device, long bitmapStartBlock, long bitmapBlockCount, long totalDataBlocks, CancellationToken ct = default)` -- read bitmap from disk

    **BitmapAllocator.cs**: Bitmap-based free space tracker:
    - Internal storage: `byte[]` where each bit represents one block (0=free, 1=allocated)
    - `AllocateBlock()`: Scan for first zero bit using hardware-accelerated bit operations (`BitOperations.TrailingZeroCount`). Track a `_nextFreeHint` for O(1) amortized allocation by remembering where last free block was found.
    - `AllocateExtent(int count)`: Scan bitmap for `count` consecutive zero bits. Use the extent tree to find free extents efficiently. Fall back to bitmap scan if extent tree has no match.
    - `FreeBlock(long)`: Clear bit, update extent tree (merge with adjacent free extents).
    - `FreeExtent(long start, int count)`: Clear range of bits, merge into extent tree.
    - `PersistAsync()`: Write bitmap bytes to consecutive blocks starting at bitmapStartBlock. Use ArrayPool for block-aligned buffers.
    - `LoadAsync()`: Read bitmap from disk blocks, reconstruct extent tree from bitmap.
    - Thread safety: `ReaderWriterLockSlim` -- readers for queries, writer for allocate/free.

    **ExtentTree.cs**: In-memory sorted structure tracking free extents:
    - Stores `SortedSet<FreeExtent>` ordered by (startBlock) where `FreeExtent` is a record with `StartBlock` and `BlockCount`
    - Secondary index: `SortedDictionary<int, SortedSet<FreeExtent>>` by extent size for best-fit allocation
    - `FindExtent(int minBlocks)` -- find smallest extent >= minBlocks (best-fit)
    - `AddFreeExtent(long start, int count)` -- add extent, merge with adjacent extents
    - `RemoveExtent(FreeExtent extent)` -- remove after allocation
    - `SplitExtent(FreeExtent extent, int allocatedBlocks)` -- split extent, return remainder to tree
    - Built from bitmap during load (scan for consecutive zero-bit runs)

    **FreeSpaceManager.cs**: Coordinates bitmap + extent tree:
    - Constructor takes `BitmapAllocator bitmap, ExtentTree extents`
    - `AllocateBlock()`: Delegates to bitmap for single-block O(1) allocation
    - `AllocateExtent(int count)`: First tries extent tree (O(log n) best-fit). If no suitable extent, falls back to bitmap scan.
    - `Free*()`: Updates both bitmap and extent tree atomically
    - `PersistAsync()`: Delegates to bitmap (extent tree is derived from bitmap on load, not persisted separately)
    - Implements IBlockAllocator

    Namespace: `DataWarehouse.SDK.VirtualDiskEngine.BlockAllocation`. All public APIs have XML docs. Use `System.Numerics.BitOperations` for hardware-accelerated bit scanning. Use ArrayPool for all temporary buffers.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Grep for `namespace DataWarehouse.SDK.VirtualDiskEngine.BlockAllocation` to confirm correct namespace.
  </verify>
  <done>
    BitmapAllocator tracks free space with O(1) single-block allocation via bit scanning. ExtentTree provides best-fit contiguous allocation with automatic merge of adjacent free regions. FreeSpaceManager coordinates both into a unified IBlockAllocator. Bitmap persists to disk blocks and reconstructs extent tree on load.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
- All files exist under DataWarehouse.SDK/VirtualDiskEngine/
- Superblock uses DWVD magic (0x44575644) and XxHash64 checksum
- Dual superblock: mirror at block 1, primary at block 0
- BitmapAllocator tracks free/allocated bits with proper bit operations
- ExtentTree merges adjacent free regions
- ContainerFile validates on open and falls back to mirror superblock
</verification>

<success_criteria>
- Container file can be created with specified block size and block count
- Superblock serializes/deserializes correctly with magic validation and checksum verification
- Dual superblock mirroring -- if primary is corrupted, mirror is used
- Single-block allocation is O(1) amortized via next-free hint
- Multi-block extent allocation uses best-fit from extent tree
- Deallocation merges adjacent free regions in extent tree
- Bitmap persists to disk and loads correctly
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-virtual-disk-engine/33-01-SUMMARY.md`
</output>
