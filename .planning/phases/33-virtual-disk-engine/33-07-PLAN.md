---
phase: 33-virtual-disk-engine
plan: 07
type: execute
wave: 5
depends_on: ["33-01", "33-02", "33-03", "33-04", "33-05", "33-06"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/VirtualDiskEngine.cs
  - DataWarehouse.SDK/VirtualDiskEngine/VdeStorageStrategy.cs
  - DataWarehouse.SDK/VirtualDiskEngine/VdeOptions.cs
  - DataWarehouse.SDK/VirtualDiskEngine/VdeHealthReport.cs
autonomous: true

must_haves:
  truths:
    - "VDE registers as an UltimateStorage backend strategy with strategyId 'vde-container'"
    - "Standard storage operations (store, retrieve, delete, list, exists, getMetadata) work through VDE"
    - "Key-to-inode mapping translates storage keys to VDE namespace paths"
    - "Container lifecycle managed automatically: create on first use, open on subsequent"
    - "Health reporting exposes free space, checksum errors, WAL utilization, and snapshot count"
    - "VDE integrates all subsystems: container, allocator, inodes, WAL, B-Tree, CoW, checksums"
    - "The SDK builds with zero new errors after adding all VDE files"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/VirtualDiskEngine.cs"
      provides: "Engine facade coordinating all VDE subsystems"
      exports: ["VirtualDiskEngine"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/VdeStorageStrategy.cs"
      provides: "IStorageStrategy implementation registering VDE as UltimateStorage backend"
      exports: ["VdeStorageStrategy"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/VdeOptions.cs"
      provides: "Configuration options for VDE (block size, container path, WAL size, etc.)"
      exports: ["VdeOptions"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/VdeHealthReport.cs"
      provides: "Health reporting with free space, corruption count, WAL utilization"
      exports: ["VdeHealthReport"]
  key_links:
    - from: "VirtualDiskEngine"
      to: "ContainerFile"
      via: "Engine creates/opens container on initialization"
      pattern: "ContainerFile\\.CreateAsync|OpenAsync"
    - from: "VirtualDiskEngine"
      to: "FreeSpaceManager"
      via: "Engine uses allocator for all block allocation"
      pattern: "FreeSpaceManager|IBlockAllocator"
    - from: "VirtualDiskEngine"
      to: "WriteAheadLog"
      via: "Engine routes all writes through WAL"
      pattern: "WriteAheadLog|IWriteAheadLog"
    - from: "VirtualDiskEngine"
      to: "BTree"
      via: "Engine uses B-Tree for key-to-block index"
      pattern: "BTree|IBTreeIndex"
    - from: "VdeStorageStrategy"
      to: "VirtualDiskEngine"
      via: "Strategy delegates all operations to the engine"
      pattern: "VirtualDiskEngine\\."
    - from: "VdeStorageStrategy"
      to: "StorageStrategyBase"
      via: "Inherits SDK storage strategy base for auto-discovery"
      pattern: "class VdeStorageStrategy : StorageStrategyBase"
---

<objective>
Build the VDE engine facade and storage strategy integration, wiring all subsystems together and registering VDE as an UltimateStorage backend.

Purpose: This is the final integration plan that makes the VDE usable as a real storage backend. The engine facade coordinates container, allocator, WAL, inodes, B-Tree, CoW, and checksums into a coherent API. The storage strategy adapts the engine to the existing IStorageStrategy interface so it can be used through UltimateStorage like any other backend.

Output: VirtualDiskEngine facade, VdeStorageStrategy (inherits StorageStrategyBase), VdeOptions for configuration, VdeHealthReport for monitoring.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-virtual-disk-engine/33-RESEARCH.md
@.planning/phases/33-virtual-disk-engine/33-01-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-02-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-03-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-04-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-05-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-06-SUMMARY.md
@DataWarehouse.SDK/Contracts/Storage/StorageStrategy.cs
@DataWarehouse.SDK/Storage/IObjectStorageCore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: VdeOptions, VdeHealthReport, and VirtualDiskEngine facade</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/VdeOptions.cs
    DataWarehouse.SDK/VirtualDiskEngine/VdeHealthReport.cs
    DataWarehouse.SDK/VirtualDiskEngine/VirtualDiskEngine.cs
  </files>
  <action>
    Create the engine facade and supporting types:

    **VdeOptions.cs**: Configuration record:
    - `string ContainerPath` (required -- path to .dwvd file)
    - `int BlockSize` init-only, default 4096
    - `long TotalBlocks` init-only, default 1_048_576 (4GB with 4K blocks)
    - `int WalSizePercent` init-only, default 1 (percent of total blocks for WAL, min 256 blocks)
    - `int MaxCachedInodes` init-only, default 10_000
    - `int MaxCachedBTreeNodes` init-only, default 1_000
    - `int MaxCachedChecksumBlocks` init-only, default 256
    - `int CheckpointWalUtilizationPercent` init-only, default 75
    - `bool EnableChecksumVerification` init-only, default true
    - `bool AutoCreateContainer` init-only, default true (create container if it doesn't exist)
    - Validate(): Throw ArgumentException for invalid values (BlockSize not power of 2, BlockSize < 512, etc.)

    **VdeHealthReport.cs**: Health status reporting:
    - `VdeHealthReport` record with:
      - `long TotalBlocks`, `long FreeBlocks`, `long UsedBlocks`
      - `double UsagePercent`
      - `long TotalInodes`, `long AllocatedInodes`
      - `double WalUtilizationPercent`
      - `long ChecksumErrorCount`
      - `int SnapshotCount`
      - `string HealthStatus` ("Healthy", "Degraded", "Critical")
      - `DateTimeOffset GeneratedAtUtc`
    - `ToStorageHealthInfo()` method that converts to existing SDK `StorageHealthInfo` type for compatibility

    **VirtualDiskEngine.cs**: Main engine facade:
    - Constructor takes `VdeOptions options`
    - `InitializeAsync(CancellationToken ct)`:
      1. If container exists: OpenAsync, validate superblock, check if WAL needs recovery
      2. If container doesn't exist and AutoCreateContainer: CreateAsync with layout from options
      3. If container doesn't exist and !AutoCreateContainer: throw
      4. Initialize subsystems in order:
        a. ContainerFile (owns IBlockDevice)
        b. FreeSpaceManager (BitmapAllocator + ExtentTree) -- loaded from bitmap blocks
        c. WriteAheadLog -- from WAL blocks; run recovery if NeedsRecovery
        d. BlockChecksummer + ChecksumTable -- from checksum table blocks
        e. CorruptionDetector
        f. InodeTable -- from inode table blocks
        g. NamespaceTree -- wraps InodeTable
        h. BTree (key index) -- from B-Tree root block
        i. CowBlockManager (ref count B-Tree) -- separate B-Tree instance
        j. SnapshotManager + SpaceReclaimer
    - **Data Operations** (the primary API):
      - `StoreAsync(string key, Stream data, IDictionary<string, string>? metadata, CancellationToken ct)`:
        1. Map key to VDE path (key = path in namespace tree)
        2. Begin WAL transaction
        3. Create file inode via NamespaceTree.CreateFileAsync (or get existing)
        4. Read data stream in block-sized chunks
        5. For each chunk: allocate block via FreeSpaceManager, write data via CoW engine, compute and store checksum, add block pointer to inode
        6. Store metadata as extended attributes on the inode
        7. Index key in B-Tree (key bytes -> inode number)
        8. Update inode size and timestamps
        9. Commit WAL transaction
        10. Auto-checkpoint if needed
        11. Return StorageObjectMetadata
      - `RetrieveAsync(string key, CancellationToken ct)`:
        1. Lookup key in B-Tree -> inode number
        2. Get inode, resolve all block pointers
        3. For each block: read from device, verify checksum, append to result stream
        4. Return stream
      - `DeleteAsync(string key, CancellationToken ct)`:
        1. Lookup key in B-Tree
        2. Begin WAL transaction
        3. Delete from namespace tree (decrements link count)
        4. If inode freed: decrement ref counts on all data blocks via SpaceReclaimer
        5. Remove from B-Tree
        6. Commit WAL transaction
      - `ExistsAsync(string key, CancellationToken ct)`: B-Tree lookup, return true if found
      - `ListAsync(string? prefix, CancellationToken ct)`: B-Tree range query with prefix
      - `GetMetadataAsync(string key, CancellationToken ct)`: B-Tree lookup -> inode -> StorageObjectMetadata
    - **Snapshot Operations**:
      - `CreateSnapshotAsync(string name, CancellationToken ct)` -> delegate to SnapshotManager
      - `ListSnapshotsAsync(CancellationToken ct)` -> delegate to SnapshotManager
      - `DeleteSnapshotAsync(string name, CancellationToken ct)` -> delegate to SnapshotManager
    - **Health**:
      - `GetHealthReportAsync(CancellationToken ct)` -> builds VdeHealthReport from all subsystems
      - `ScanIntegrityAsync(IProgress<double>? progress, CancellationToken ct)` -> delegates to CorruptionDetector
    - **Lifecycle**:
      - `CheckpointAsync(CancellationToken ct)` -> flush all, checkpoint WAL, write superblock
      - Implements IAsyncDisposable: checkpoint, flush, dispose all subsystems in reverse order
    - Thread safety: Write operations serialized via WAL. Read operations concurrent.
    - Use ArrayPool for all stream-to-block conversion buffers.

    All public APIs have XML documentation.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify VirtualDiskEngine class exists with StoreAsync, RetrieveAsync, DeleteAsync methods.
  </verify>
  <done>
    VirtualDiskEngine facade coordinates all subsystems (container, allocator, WAL, inodes, namespace, B-Tree, CoW, checksums) into a coherent API. Full data lifecycle: store (stream -> blocks with WAL + checksum + B-Tree index), retrieve (B-Tree -> inode -> blocks -> stream with checksum verification), delete (WAL + CoW deref + B-Tree remove). Snapshot operations. Health reporting. Proper initialization order and shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: VdeStorageStrategy registration and full build verification</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/VdeStorageStrategy.cs
  </files>
  <action>
    Create the storage strategy integration and verify the complete build:

    **VdeStorageStrategy.cs**: IStorageStrategy implementation:
    - Inherits from `StorageStrategyBase` (DataWarehouse.SDK.Contracts.Storage)
    - Properties:
      - `override string StrategyId => "vde-container"`
      - `override string Name => "Virtual Disk Engine"`
      - `override string Description => "Block-level storage engine with WAL, CoW snapshots, B-Tree indexing, and checksumming"`
      - `override StorageTier Tier => StorageTier.Hot`
      - `override StorageCapabilities Capabilities => new() { SupportsVersioning = true, SupportsMetadata = true, SupportsLocking = true, SupportsTiering = false, SupportsEncryption = false, SupportsCompression = false, SupportsStreaming = true, SupportsMultipart = false, ConsistencyModel = ConsistencyModel.Strong }`
    - Private field: `VirtualDiskEngine? _engine`
    - `override async Task InitializeAsync(CancellationToken ct)`:
      1. Call base.InitializeAsync(ct)
      2. Read VdeOptions from strategy configuration (or use defaults with container path from working directory)
      3. Create VirtualDiskEngine with options
      4. Call _engine.InitializeAsync(ct)
    - `override async Task<StorageObjectMetadata> StoreAsyncCore(string key, Stream data, IDictionary<string, string>? metadata, CancellationToken ct)`:
      - Delegate to _engine.StoreAsync(key, data, metadata, ct)
    - `override async Task<Stream> RetrieveAsyncCore(string key, CancellationToken ct)`:
      - Delegate to _engine.RetrieveAsync(key, ct)
    - `override async Task DeleteAsyncCore(string key, CancellationToken ct)`:
      - Delegate to _engine.DeleteAsync(key, ct)
    - `override async Task<bool> ExistsAsyncCore(string key, CancellationToken ct)`:
      - Delegate to _engine.ExistsAsync(key, ct)
    - `override async IAsyncEnumerable<StorageObjectMetadata> ListAsyncCore(string? prefix, [EnumeratorCancellation] CancellationToken ct)`:
      - Delegate to _engine.ListAsync(prefix, ct)
    - `override async Task<StorageObjectMetadata> GetMetadataAsyncCore(string key, CancellationToken ct)`:
      - Delegate to _engine.GetMetadataAsync(key, ct)
    - `override async Task<StorageHealthInfo> GetHealthAsyncCore(CancellationToken ct)`:
      - Get VdeHealthReport from engine, convert to StorageHealthInfo
    - `override async Task<long?> GetAvailableCapacityAsyncCore(CancellationToken ct)`:
      - Return engine free blocks * block size
    - Dispose: calls _engine?.DisposeAsync()

    **Build verification**:
    - After creating VdeStorageStrategy, run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj`
    - Verify zero new errors from all VDE files
    - Check that all VDE namespace files are correctly structured
    - Verify VdeStorageStrategy inherits StorageStrategyBase (will be auto-discovered by StorageStrategyRegistry)

    NOTE: Check StorageStrategyBase for exact method signatures. The base class may use `StoreAsyncCore` (protected virtual) or `StoreAsync` (public sealed calling core). Match the existing pattern. If the base doesn't have `*Core` methods, override the public methods directly. Read StorageStrategy.cs to confirm the exact pattern before implementing.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors from VDE code. Grep for `class VdeStorageStrategy` to confirm it inherits StorageStrategyBase. Verify all ~25 VDE files compile correctly.
  </verify>
  <done>
    VdeStorageStrategy registers as "vde-container" backend with StorageCapabilities (versioning, metadata, locking, strong consistency). Delegates all operations to VirtualDiskEngine. Auto-discovered by StorageStrategyRegistry. Full SDK builds with zero new errors. All VDE subsystems compile and integrate.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
- VdeStorageStrategy inherits StorageStrategyBase
- All ~25 VDE files compile in DataWarehouse.SDK/VirtualDiskEngine/
- VirtualDiskEngine.InitializeAsync creates/opens container and initializes all subsystems
- Store/Retrieve/Delete work through WAL + B-Tree + inodes + checksums
- Snapshot operations accessible via engine facade
- Health report aggregates data from all subsystems
- No existing files modified (all additive in new VirtualDiskEngine/ directory)
</verification>

<success_criteria>
- VDE is a fully functional storage backend accessible via strategyId "vde-container"
- Store: stream -> block allocation -> WAL-protected writes -> checksum -> B-Tree index -> inode metadata
- Retrieve: B-Tree lookup -> inode -> block reads -> checksum verification -> stream
- Delete: WAL-protected removal from B-Tree, namespace, and CoW-aware block deallocation
- Container auto-created on first use if configured
- Health reporting: free space, WAL utilization, checksum errors, snapshot count
- All ~25 VDE source files compile as part of DataWarehouse.SDK
- Zero regression: no existing files modified
</success_criteria>

<output>
After completion, create `.planning/phases/33-virtual-disk-engine/33-07-SUMMARY.md`
</output>
