---
phase: 33-virtual-disk-engine
plan: 05
type: execute
wave: 3
depends_on: ["33-01", "33-03", "33-04"]
files_modified:
  - DataWarehouse.SDK/VirtualDiskEngine/Index/IBTreeIndex.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Index/BTree.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Index/BTreeNode.cs
  - DataWarehouse.SDK/VirtualDiskEngine/Index/BulkLoader.cs
autonomous: true

must_haves:
  truths:
    - "B-Tree provides O(log n) lookup, insert, and delete for key-value pairs"
    - "B-Tree nodes fit in a single disk block with configurable order based on block size"
    - "Node split and merge operations maintain B-Tree invariants"
    - "Range queries traverse leaf nodes via next-leaf pointers in sorted order"
    - "Bulk loading builds a B-Tree bottom-up faster than sequential inserts"
    - "All structural modifications (split, merge) are WAL-protected for crash safety"
    - "Concurrent readers allowed with single writer"
  artifacts:
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Index/IBTreeIndex.cs"
      provides: "B-Tree interface for key-value lookup, insert, delete, range queries"
      exports: ["IBTreeIndex"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Index/BTree.cs"
      provides: "On-disk B-Tree implementation with WAL-protected modifications"
      exports: ["BTree"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Index/BTreeNode.cs"
      provides: "B-Tree node structure fitting in one block"
      exports: ["BTreeNode", "BTreeNodeHeader"]
    - path: "DataWarehouse.SDK/VirtualDiskEngine/Index/BulkLoader.cs"
      provides: "Bottom-up B-Tree construction for initial population"
      exports: ["BulkLoader"]
  key_links:
    - from: "BTree"
      to: "IBlockDevice"
      via: "Reads/writes B-Tree node blocks"
      pattern: "IBlockDevice.*ReadBlockAsync|WriteBlockAsync"
    - from: "BTree"
      to: "IBlockAllocator"
      via: "Allocates new blocks for node splits"
      pattern: "IBlockAllocator.*AllocateBlock"
    - from: "BTree"
      to: "IWriteAheadLog"
      via: "WAL-protects all structural modifications"
      pattern: "IWriteAheadLog.*BeginTransaction|AppendEntry"
    - from: "BTreeNode"
      to: "BinaryPrimitives"
      via: "Serializes node to/from block-sized byte buffer"
      pattern: "BinaryPrimitives\\.Write|Read"
---

<objective>
Build the B-Tree on-disk index for the Virtual Disk Engine providing O(log n) key-value operations.

Purpose: The B-Tree is the primary indexing structure for the VDE. It maps storage object keys to block numbers, enabling efficient lookup, insertion, deletion, and range queries. It is also used by the CoW engine (Plan 33-06) for reference counting. All B-Tree structural modifications are WAL-protected for crash safety.

Output: IBTreeIndex interface, BTree implementation, BTreeNode on-disk structure, and BulkLoader for efficient initial population.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-virtual-disk-engine/33-RESEARCH.md
@.planning/phases/33-virtual-disk-engine/33-01-SUMMARY.md
@.planning/phases/33-virtual-disk-engine/33-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: BTreeNode on-disk structure and IBTreeIndex interface</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Index/BTreeNode.cs
    DataWarehouse.SDK/VirtualDiskEngine/Index/IBTreeIndex.cs
  </files>
  <action>
    Create the B-Tree data structures in DataWarehouse.SDK/VirtualDiskEngine/Index/:

    **BTreeNode.cs**: On-disk B-Tree node structure:
    - `BTreeNodeHeader` struct:
      - `ushort KeyCount` (number of keys currently in this node)
      - `ushort Flags` (Leaf=0x01, Root=0x02, Internal=0x00)
      - `long ParentBlock` (-1 for root)
      - `long NextLeafBlock` (-1 if not leaf or last leaf -- for range queries)
      - `long PrevLeafBlock` (-1 if not leaf or first leaf)
      - Total: 2 + 2 + 8 + 8 + 8 = 28 bytes
    - `BTreeNode` class:
      - `long BlockNumber` (which block this node occupies)
      - `BTreeNodeHeader Header`
      - `byte[][] Keys` (variable-length keys, max 256 bytes each)
      - `long[] Values` (for leaf nodes: the mapped value, e.g., block number. For internal nodes: child block pointers)
      - `long[] ChildPointers` (for internal nodes: N+1 child pointers for N keys)
      - `bool IsLeaf => (Header.Flags & 0x01) != 0`
      - `bool IsRoot => (Header.Flags & 0x02) != 0`
      - `bool IsFull` -- true when KeyCount equals MaxKeys
      - `bool IsUnderflow` -- true when KeyCount < MinKeys (MinKeys = MaxKeys / 2)
    - **Node layout in a block**: [Header:28][KeyLengths:2*N][Keys:var][Values/ChildPtrs:8*(N+1)][Padding]
      - For 4096-byte block with max 256-byte keys: compute MaxKeys dynamically based on actual key sizes
      - Conservative static MaxKeys: For 64-byte average keys, MaxKeys = (4096 - 28 - overhead) / (64 + 2 + 8) ~= 54 keys per node
      - Store key lengths as ushort array for variable-length support
    - `Serialize(Span<byte> buffer, int blockSize)` using BinaryPrimitives, little-endian
    - `static Deserialize(ReadOnlySpan<byte> buffer, int blockSize, out BTreeNode node)`
    - `static int ComputeMaxKeys(int blockSize, int avgKeySize)` -- helper for order calculation
    - `int CompareKeys(byte[] a, byte[] b)` -- lexicographic byte comparison for key ordering

    **IBTreeIndex.cs**: Interface:
    - `Task<long?> LookupAsync(byte[] key, CancellationToken ct = default)` -- find value for exact key match. Returns null if not found.
    - `Task InsertAsync(byte[] key, long value, CancellationToken ct = default)` -- insert key-value. Throws if duplicate key.
    - `Task<bool> UpdateAsync(byte[] key, long newValue, CancellationToken ct = default)` -- update value for existing key. Returns false if not found.
    - `Task<bool> DeleteAsync(byte[] key, CancellationToken ct = default)` -- delete key. Returns false if not found.
    - `IAsyncEnumerable<(byte[] Key, long Value)> RangeQueryAsync(byte[]? startKey, byte[]? endKey, CancellationToken ct = default)` -- returns all key-value pairs in [startKey, endKey) sorted order. null startKey = from beginning, null endKey = to end.
    - `Task<long> CountAsync(CancellationToken ct = default)` -- total number of key-value pairs
    - `long RootBlockNumber { get; }` -- block number of root node (stored in superblock)

    All public APIs have XML docs. Namespace: DataWarehouse.SDK.VirtualDiskEngine.Index.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors.
  </verify>
  <done>
    BTreeNode structure with variable-length keys, values/child pointers, and leaf-to-leaf linking for range queries. Serializes to/from a single block with BinaryPrimitives. IBTreeIndex interface covers lookup, insert, update, delete, range query, and count.
  </done>
</task>

<task type="auto">
  <name>Task 2: BTree implementation and BulkLoader</name>
  <files>
    DataWarehouse.SDK/VirtualDiskEngine/Index/BTree.cs
    DataWarehouse.SDK/VirtualDiskEngine/Index/BulkLoader.cs
  </files>
  <action>
    Implement the full B-Tree engine:

    **BTree.cs**: On-disk B-Tree with WAL-protected modifications:
    - Constructor takes `IBlockDevice device, IBlockAllocator allocator, IWriteAheadLog wal, long rootBlockNumber, int blockSize`
    - **Node cache**: `ConcurrentDictionary<long, BTreeNode>` caching recently accessed nodes. Bounded to 1,000 nodes. LRU-like eviction (track access time, evict oldest when full).
    - **Lookup (search)**:
      1. Start at root node
      2. Binary search keys in current node for target key
      3. If leaf and key found: return value
      4. If leaf and key not found: return null
      5. If internal: follow child pointer to next level, repeat
      - All reads from cache or disk via ReadNodeAsync()
    - **Insert**:
      1. Begin WAL transaction
      2. Search for leaf node where key belongs
      3. If leaf has space: insert key-value in sorted position, WAL-log the node write, commit
      4. If leaf is full: SPLIT
        a. Allocate new node block
        b. Split keys: left half stays, right half moves to new node
        c. Middle key promoted to parent
        d. Update parent's child pointers
        e. If parent is full: recursively split parent (up to root)
        f. If root splits: allocate new root, new root has one key and two children
        g. WAL-log ALL modified nodes (old leaf, new leaf, parent(s), possibly new root)
        h. Update leaf next/prev pointers
        i. Commit WAL transaction
      - Update superblock if root changed
    - **Delete**:
      1. Begin WAL transaction
      2. Find leaf containing key
      3. Remove key-value from leaf
      4. If leaf underflows (< MinKeys):
        a. Try to borrow from left or right sibling
        b. If sibling can't lend: merge with sibling, remove separator from parent
        c. If parent underflows: propagate up
        d. If root has zero keys: child becomes new root
      5. WAL-log all modified nodes, commit
    - **Update**: Lookup + modify value in place + WAL-log node write
    - **Range query**: Find start leaf via search, then traverse next-leaf pointers, yielding key-value pairs. Stop when endKey reached or no more leaves.
    - **Count**: Traverse all leaf nodes, sum key counts.
    - **ReadNodeAsync(long blockNumber)**: Check cache, read from disk if miss, deserialize, cache, return.
    - **WriteNodeAsync(BTreeNode node)**: Serialize to block, write via device, update cache.
    - Thread safety: `ReaderWriterLockSlim` -- multiple concurrent readers, single writer for modifications.
    - Use ArrayPool for all temporary block buffers.

    **BulkLoader.cs**: Efficient bottom-up B-Tree construction:
    - `static async Task<long> BulkLoadAsync(IEnumerable<(byte[] Key, long Value)> sortedEntries, IBlockDevice device, IBlockAllocator allocator, int blockSize, CancellationToken ct)`:
      1. Entries MUST be pre-sorted by key (caller responsibility)
      2. Fill leaf nodes sequentially (no splits needed)
      3. When a leaf is full, allocate next leaf, link prev/next pointers
      4. After all leaves created, build internal nodes bottom-up:
        a. For each pair of adjacent leaves, promote the first key of the right leaf to the parent
        b. Continue building parent levels until a single root node is created
      5. Return root block number
    - `static async Task<long> BulkLoadAsync(IAsyncEnumerable<(byte[] Key, long Value)> sortedEntries, ...)` -- streaming variant for large datasets
    - Bulk load is ~5-10x faster than sequential inserts for large datasets because:
      - No splits during construction
      - Sequential writes (good for disk I/O)
      - Minimal tree traversal

    All public APIs have XML docs.
  </action>
  <verify>
    Run `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero new errors. Verify BTree implements IBTreeIndex.
  </verify>
  <done>
    BTree provides O(log n) lookup, insert, delete with WAL-protected structural modifications. Node split propagates up to root. Delete with merge/borrow maintains B-Tree invariants. Range queries traverse linked leaf nodes. BulkLoader builds B-Tree bottom-up from sorted data for efficient initial population. Node cache reduces disk reads.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with zero new errors
- All files exist under DataWarehouse.SDK/VirtualDiskEngine/Index/
- BTreeNode fits in a single block (configurable max keys based on block size)
- B-Tree operations are O(log n): lookup, insert, delete
- Node splits and merges are WAL-protected (begin transaction, log all modified nodes, commit)
- Leaf nodes linked via next/prev pointers for range queries
- BulkLoader builds bottom-up from sorted data without splits
</verification>

<success_criteria>
- O(log n) lookup: binary search within nodes, follow child pointers between levels
- Insert with node splitting propagates correctly to root
- Delete with merge/borrow maintains minimum key count invariant
- Range queries traverse leaf chain in sorted order via next-leaf pointers
- All structural modifications (split, merge) use WAL transactions for crash safety
- Bulk loading builds B-Tree bottom-up faster than sequential insert
- Node cache bounded to 1,000 entries with eviction
- Concurrent readers with single writer via ReaderWriterLockSlim
- Zero new build errors
</success_criteria>

<output>
After completion, create `.planning/phases/33-virtual-disk-engine/33-05-SUMMARY.md`
</output>
