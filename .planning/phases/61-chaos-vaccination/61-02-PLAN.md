---
phase: 61-chaos-vaccination
plan: 02
type: execute
wave: 2
depends_on: ["61-01"]
files_modified:
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.csproj
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/ChaosInjectionEngine.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/NetworkPartitionInjector.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/DiskFailureInjector.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/NodeCrashInjector.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/LatencySpikeInjector.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/MemoryPressureInjector.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/IFaultInjector.cs
autonomous: true
must_haves:
  truths:
    - "Chaos injection engine can execute fault experiments with safety checks"
    - "Each fault type has a dedicated injector implementing the strategy pattern"
    - "Experiments are validated for safety before execution"
    - "Running experiments can be aborted mid-flight"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs"
      provides: "Plugin entry point inheriting ResiliencePluginBase"
      contains: "class ChaosVaccinationPlugin"
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/ChaosInjectionEngine.cs"
      provides: "Core engine implementing IChaosInjectionEngine"
      contains: "class ChaosInjectionEngine"
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/IFaultInjector.cs"
      provides: "Strategy interface for fault injectors"
      exports: ["IFaultInjector"]
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs"
      to: "DataWarehouse.SDK/Contracts/Hierarchy/Feature/ResiliencePluginBase.cs"
      via: "inheritance"
      pattern: "ResiliencePluginBase"
    - from: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/ChaosInjectionEngine.cs"
      to: "DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosInjectionEngine.cs"
      via: "implements interface"
      pattern: "IChaosInjectionEngine"
---

<objective>
Build the Chaos Injection Engine -- the core component that executes fault injection experiments.

Purpose: Provide automated fault injection capability with safety-first design. Each fault type (network partition, disk failure, node crash, latency spike, memory pressure) gets a dedicated injector following the strategy pattern. The engine orchestrates experiment lifecycle: validate safety -> create isolation zone -> inject fault -> observe -> collect results -> cleanup.

Output: New ChaosVaccination plugin with injection engine and 5 fault injectors.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@.planning/phases/61-chaos-vaccination/61-01-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateResilience/UltimateResiliencePlugin.cs
@Plugins/DataWarehouse.Plugins.UltimateResilience/Strategies/ChaosEngineering/ChaosEngineeringStrategies.cs
@DataWarehouse.SDK/Contracts/Hierarchy/Feature/ResiliencePluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Plugin scaffold and fault injector interface</name>
  <files>
    Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.csproj
    Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/IFaultInjector.cs
  </files>
  <action>
1. Create csproj referencing ONLY DataWarehouse.SDK (following existing plugin pattern from UltimateResilience). Target net9.0. No external NuGet packages needed.

2. Create ChaosVaccinationPlugin inheriting ResiliencePluginBase:
   - Id: "com.datawarehouse.chaos.vaccination"
   - Name: "Chaos Vaccination"
   - Version: "1.0.0"
   - Category: PluginCategory.InfrastructureProvider
   - Override GetCapabilities() with: chaos.execute-experiment, chaos.abort-experiment, chaos.list-running, chaos.get-immune-memory, chaos.get-schedule, chaos.get-results
   - Override DeclaredCapabilities with proper RegisteredCapability entries
   - Override OnHandshakeAsync to register knowledge
   - Override OnMessageAsync to route: chaos.execute, chaos.abort, chaos.schedule, chaos.results, chaos.immune-memory
   - Override OnStartCoreAsync / OnStartWithIntelligenceAsync to initialize engine + subscribe to bus topics
   - Override ExecuteWithResilienceAsync to delegate to engine
   - Override GetResilienceHealthAsync to report experiment status
   - Holds references to ChaosInjectionEngine, BlastRadiusEnforcer, ImmuneResponseSystem (created in later plans), VaccinationScheduler, ChaosResultsDatabase
   - Fields initialized to null, populated when sub-components are created in later plans -- use conditional null checks

3. Create IFaultInjector strategy interface:
   - FaultType SupportedFaultType { get; }
   - string Name { get; }
   - Task&lt;FaultInjectionResult&gt; InjectAsync(ChaosExperiment experiment, CancellationToken ct)
   - Task CleanupAsync(string experimentId, CancellationToken ct) -- undo injected fault
   - Task&lt;bool&gt; CanInjectAsync(ChaosExperiment experiment, CancellationToken ct) -- pre-check
   - Record FaultInjectionResult with Success (bool), FaultSignature (FaultSignature?), AffectedComponents (string[]), Metrics (Dictionary&lt;string, double&gt;), CleanupRequired (bool)
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.ChaosVaccination/DataWarehouse.Plugins.ChaosVaccination.csproj -- zero errors</verify>
  <done>Plugin compiles, inherits ResiliencePluginBase correctly, IFaultInjector interface defined.</done>
</task>

<task type="auto">
  <name>Task 2: Chaos injection engine and 5 fault injectors</name>
  <files>
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/ChaosInjectionEngine.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/NetworkPartitionInjector.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/DiskFailureInjector.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/NodeCrashInjector.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/LatencySpikeInjector.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/FaultInjectors/MemoryPressureInjector.cs
  </files>
  <action>
**ChaosInjectionEngine.cs** -- implements IChaosInjectionEngine:
- Constructor takes IMessageBus? and ChaosVaccinationOptions
- Maintains ConcurrentDictionary&lt;string, RunningExperiment&gt; for active experiments
- RunningExperiment record: Experiment, CancellationTokenSource, StartedAt, IFaultInjector
- Auto-discovers fault injectors via reflection (like ResilienceStrategyRegistry pattern)
- ExecuteExperimentAsync flow:
  1. Validate safety checks (call each SafetyCheck.CheckAction)
  2. Select appropriate IFaultInjector based on experiment.FaultType
  3. Check CanInjectAsync
  4. Fire OnExperimentEvent(Started)
  5. Call injector.InjectAsync
  6. Wait for experiment.DurationLimit (or until aborted)
  7. Call injector.CleanupAsync
  8. Build ChaosExperimentResult with metrics
  9. Fire OnExperimentEvent(Completed)
- AbortExperimentAsync: Cancel CTS, cleanup injector, fire OnExperimentEvent(Aborted)
- ValidateExperimentSafetyAsync: Run all safety checks, check blast radius against global limit
- Respects ChaosVaccinationOptions.MaxConcurrentExperiments
- Thread-safe using SemaphoreSlim for concurrent experiment limiting

**5 Fault Injectors** (each implements IFaultInjector):

1. **NetworkPartitionInjector** -- SupportedFaultType = NetworkPartition
   - InjectAsync: Publishes "chaos.fault.network-partition" to message bus with target nodes/plugins
   - Simulates partition by publishing "network.partition.start" event with affected endpoint list
   - CleanupAsync: Publishes "network.partition.end" to lift the partition
   - Tracks partition state (partitioned endpoints, start time)
   - Metrics: partitionDurationMs, affectedEndpoints count

2. **DiskFailureInjector** -- SupportedFaultType = DiskFailure
   - InjectAsync: Publishes "chaos.fault.disk-failure" specifying target storage paths
   - Simulates I/O errors by publishing "storage.fault.inject" with error type (readonly, corrupt, slow, full)
   - CleanupAsync: Publishes "storage.fault.clear"
   - Metrics: affectedPaths count, ioErrorsGenerated

3. **NodeCrashInjector** -- SupportedFaultType = NodeCrash
   - InjectAsync: Publishes "chaos.fault.node-crash" for target node IDs
   - Simulates crash by sending "cluster.node.simulate-crash" to specified nodes via bus
   - Does NOT actually kill processes -- signals the node to enter crash-simulation mode (stop responding to heartbeats, reject new requests)
   - CleanupAsync: Sends "cluster.node.simulate-recover"
   - Metrics: crashDurationMs, missedHeartbeats

4. **LatencySpikeInjector** -- SupportedFaultType = LatencySpike
   - InjectAsync: Publishes "chaos.fault.latency-spike" with min/max latency from experiment.Parameters
   - Reads parameters: "minLatencyMs" (default 100), "maxLatencyMs" (default 5000), "affectedOperations" (default "*")
   - CleanupAsync: Publishes "chaos.fault.latency-clear"
   - Metrics: averageInjectedLatencyMs, maxInjectedLatencyMs, operationsAffected

5. **MemoryPressureInjector** -- SupportedFaultType = MemoryPressure
   - InjectAsync: Publishes "chaos.fault.memory-pressure" with target allocation size
   - Reads parameters: "pressureMB" (default 100), "allocationPattern" ("gradual"|"spike")
   - Allocates controlled byte arrays in a list to simulate pressure, respects CancellationToken
   - CleanupAsync: Releases allocated memory, forces GC.Collect
   - Metrics: allocatedMB, peakWorkingSetMB, gcCollections

All injectors: use IMessageBus for coordination (constructor-injected, nullable for single-node mode), log via PluginMessage events, never throw -- return FaultInjectionResult with Success=false on errors.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.ChaosVaccination/DataWarehouse.Plugins.ChaosVaccination.csproj -- zero errors. Verify 6 .cs files created in Engine/ directory.</verify>
  <done>ChaosInjectionEngine orchestrates experiment lifecycle with 5 fault injectors. Safety checks run before injection. Concurrent experiment limit enforced. Abort works mid-flight.</done>
</task>

</tasks>

<verification>
- Plugin builds with zero errors
- Plugin references only DataWarehouse.SDK
- ChaosInjectionEngine implements IChaosInjectionEngine
- All 5 injectors implement IFaultInjector
- No use of Task.Delay for simulating work (production-ready injectors)
</verification>

<success_criteria>
- ChaosVaccinationPlugin compiles and registers with the plugin system
- Engine can execute experiments with safety validation
- 5 fault injectors cover: network partition, disk failure, node crash, latency spike, memory pressure
- All communication via message bus -- no direct plugin references
</success_criteria>

<output>
After completion, create `.planning/phases/61-chaos-vaccination/61-02-SUMMARY.md`
</output>
