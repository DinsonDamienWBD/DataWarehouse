---
phase: 61-chaos-vaccination
plan: 04
type: execute
wave: 3
depends_on: ["61-01", "61-02"]
files_modified:
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/ImmuneResponseSystem.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/FaultSignatureAnalyzer.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/RemediationExecutor.cs
autonomous: true
must_haves:
  truths:
    - "Previously-seen faults trigger automatic remediation from immune memory"
    - "New fault patterns are learned and stored for future auto-remediation"
    - "Fault signatures are matched by pattern, not exact equality"
    - "Remediation actions execute in priority order with timeouts"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/ImmuneResponseSystem.cs"
      provides: "Immune memory + auto-remediation implementing IImmuneResponseSystem"
      contains: "class ImmuneResponseSystem"
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/FaultSignatureAnalyzer.cs"
      provides: "Fault pattern matching and signature generation"
      contains: "class FaultSignatureAnalyzer"
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/RemediationExecutor.cs"
      provides: "Executes remediation actions via message bus"
      contains: "class RemediationExecutor"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/ImmuneResponseSystem.cs"
      to: "DataWarehouse.SDK/Contracts/ChaosVaccination/IImmuneResponseSystem.cs"
      via: "implements interface"
      pattern: "IImmuneResponseSystem"
    - from: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/RemediationExecutor.cs"
      to: "DataWarehouse.SDK/Contracts/IMessageBus.cs"
      via: "publishes remediation commands"
      pattern: "IMessageBus.*PublishAsync"
---

<objective>
Build the Immune Response System that provides memory of previously-seen faults and automatic remediation.

Purpose: Like a biological immune system, the first encounter with a fault requires manual or slow recovery. Subsequent encounters of the same fault pattern trigger instant, learned remediation. This dramatically reduces mean-time-to-recovery (MTTR) for known failure modes. The system learns from chaos experiments AND from production incidents.

Output: 3 files implementing immune memory, fault signature analysis, and remediation execution.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/61-chaos-vaccination/61-01-SUMMARY.md
@.planning/phases/61-chaos-vaccination/61-02-SUMMARY.md
@DataWarehouse.SDK/Contracts/ChaosVaccination/IImmuneResponseSystem.cs
@DataWarehouse.SDK/Contracts/ChaosVaccination/ChaosVaccinationTypes.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fault signature analyzer</name>
  <files>
    Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/FaultSignatureAnalyzer.cs
  </files>
  <action>
**FaultSignatureAnalyzer.cs:**
- Generates FaultSignature from ChaosExperimentResult or from raw failure events
- GenerateSignature(ChaosExperimentResult result) -> FaultSignature:
  - Hash = SHA256 of (FaultType + sorted AffectedComponents + Pattern)
  - FaultType from result
  - Pattern = string describing the failure pattern (e.g., "network-partition:storage-plugins:3-nodes")
  - AffectedComponents from result.AffectedPlugins + result.AffectedNodes
  - Severity from result.ActualBlastRadius mapped to FaultSeverity
  - FirstObserved = result.StartedAt
  - ObservationCount = 1 (incremented when matched)

- GenerateSignatureFromEvent(string pluginId, string nodeId, FaultType type, string errorPattern) -> FaultSignature:
  - For production incidents (not chaos experiments)
  - Hash based on type + pluginId category + errorPattern

- MatchSignature(FaultSignature candidate, IReadOnlyList&lt;ImmuneMemoryEntry&gt; memory) -> ImmuneMemoryEntry?:
  - First try exact hash match
  - If no exact match, try fuzzy matching:
    a. Same FaultType + 60%+ overlap in AffectedComponents -> match
    b. Same FaultType + same Pattern prefix (before the last segment) -> match
  - Return the entry with highest SuccessRate among matches
  - Return null if no match found

- Uses System.Security.Cryptography.SHA256 for hashing (following project crypto conventions)
- No external dependencies
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.ChaosVaccination/DataWarehouse.Plugins.ChaosVaccination.csproj -- zero errors</verify>
  <done>FaultSignatureAnalyzer generates deterministic signatures from experiment results and matches against immune memory with exact + fuzzy matching.</done>
</task>

<task type="auto">
  <name>Task 2: Remediation executor and immune response system</name>
  <files>
    Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/RemediationExecutor.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/ImmuneResponse/ImmuneResponseSystem.cs
  </files>
  <action>
**RemediationExecutor.cs:**
- Executes RemediationAction[] in priority order (lowest Priority number = highest priority)
- Constructor takes IMessageBus?
- ExecuteAsync(RemediationAction[] actions, CancellationToken ct) -> RemediationResult:
  - RemediationResult record: TotalActions (int), SuccessfulActions (int), FailedActions (int), TotalDurationMs (long), ActionResults (ActionResult[])
  - ActionResult record: Action (RemediationAction), Success (bool), DurationMs (long), Error (string?)
- For each action, maps ActionType to message bus topic:
  - RestartPlugin -> "plugin.lifecycle.restart" with TargetId
  - TripCircuitBreaker -> "resilience.circuit-breaker.trip" with TargetId
  - DrainConnections -> "connectivity.drain" with TargetId
  - ScaleDown -> "cluster.autoscale.down" with TargetId
  - IsolateNode -> "cluster.node.isolate" with TargetId
  - RerouteTraffic -> "loadbalancer.reroute" with TargetId
  - RestoreFromCheckpoint -> "disaster-recovery.restore-checkpoint" with TargetId
  - NotifyOperator -> "observability.alert.operator" with TargetId
  - Custom -> "chaos.remediation.custom" with TargetId + Parameters
- Each action wrapped in try/catch with timeout (action.TimeoutMs, default 30000ms) using CancellationTokenSource.CreateLinkedTokenSource + CancelAfter
- Returns aggregate result

**ImmuneResponseSystem.cs** -- implements IImmuneResponseSystem:
- Constructor takes IMessageBus?, FaultSignatureAnalyzer
- Stores immune memory in ConcurrentDictionary&lt;string, ImmuneMemoryEntry&gt; keyed by signature hash
- RecognizeFaultAsync: Uses FaultSignatureAnalyzer.MatchSignature to find matching memory entry
- ApplyRemediationAsync: Uses RemediationExecutor to execute entry's remediation actions, updates entry.TimesApplied and entry.AverageRecoveryMs, fires OnImmuneResponse event
- LearnFromExperimentAsync:
  1. Generate FaultSignature from experiment result using FaultSignatureAnalyzer
  2. If signature already in memory: update entry (increment ObservationCount, merge remediation actions, update SuccessRate using exponential moving average)
  3. If new signature: create new ImmuneMemoryEntry with provided successful actions
  4. Fire OnImmuneResponse event with ActionTaken = "learned"
- GetImmuneMemoryAsync: Return all entries as list
- ForgetAsync: Remove entry by hash, useful for clearing stale remediation strategies
- Persistence: On every learn/forget, publishes "chaos.immune-memory.changed" to bus with serialized memory (other nodes can subscribe to sync)
- Memory decay: Entries not applied in 90 days have their SuccessRate halved (checked in RecognizeFaultAsync)
- Max memory entries: 10000 (configurable), LRU eviction by LastApplied when full
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.ChaosVaccination/DataWarehouse.Plugins.ChaosVaccination.csproj -- zero errors</verify>
  <done>ImmuneResponseSystem recognizes previously-seen faults via signature matching, applies learned remediation actions, and learns from new experiments. RemediationExecutor translates action types to message bus commands.</done>
</task>

</tasks>

<verification>
- Plugin builds with zero errors
- ImmuneResponseSystem implements IImmuneResponseSystem
- FaultSignatureAnalyzer produces deterministic hashes
- RemediationExecutor maps all ActionType values to bus topics
- No hardcoded remediation -- all actions dispatched via message bus
</verification>

<success_criteria>
- Fault signatures are generated from experiment results
- Exact + fuzzy matching finds relevant immune memory entries
- Remediation actions execute in priority order with timeouts
- New experiments teach the immune system for future auto-recovery
- Memory decay prevents stale remediation from being applied
</success_criteria>

<output>
After completion, create `.planning/phases/61-chaos-vaccination/61-04-SUMMARY.md`
</output>
