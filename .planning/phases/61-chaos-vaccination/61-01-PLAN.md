---
phase: 61-chaos-vaccination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosInjectionEngine.cs
  - DataWarehouse.SDK/Contracts/ChaosVaccination/IBlastRadiusEnforcer.cs
  - DataWarehouse.SDK/Contracts/ChaosVaccination/IImmuneResponseSystem.cs
  - DataWarehouse.SDK/Contracts/ChaosVaccination/IVaccinationScheduler.cs
  - DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosResultsDatabase.cs
  - DataWarehouse.SDK/Contracts/ChaosVaccination/ChaosVaccinationTypes.cs
autonomous: true
must_haves:
  truths:
    - "SDK defines all chaos vaccination contracts before any plugin implementation begins"
    - "Any plugin can reference chaos vaccination types without depending on the chaos plugin"
    - "Blast radius limits are expressible as SDK-level configuration"
    - "Immune memory entries are strongly typed records, not Dictionary<string,object>"
  artifacts:
    - path: "DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosInjectionEngine.cs"
      provides: "Core engine contract for fault injection"
      exports: ["IChaosInjectionEngine", "ChaosExperiment", "ChaosExperimentResult", "FaultType"]
    - path: "DataWarehouse.SDK/Contracts/ChaosVaccination/IBlastRadiusEnforcer.cs"
      provides: "Blast radius enforcement contract"
      exports: ["IBlastRadiusEnforcer", "BlastRadiusPolicy", "IsolationZone", "FailureContainmentResult"]
    - path: "DataWarehouse.SDK/Contracts/ChaosVaccination/IImmuneResponseSystem.cs"
      provides: "Immune memory and auto-remediation contract"
      exports: ["IImmuneResponseSystem", "ImmuneMemoryEntry", "RemediationAction", "FaultSignature"]
    - path: "DataWarehouse.SDK/Contracts/ChaosVaccination/IVaccinationScheduler.cs"
      provides: "Vaccination schedule contract"
      exports: ["IVaccinationScheduler", "VaccinationSchedule", "ScheduledExperiment"]
    - path: "DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosResultsDatabase.cs"
      provides: "Results storage contract"
      exports: ["IChaosResultsDatabase", "ExperimentRecord", "ExperimentQuery"]
    - path: "DataWarehouse.SDK/Contracts/ChaosVaccination/ChaosVaccinationTypes.cs"
      provides: "Shared enums, records, and configuration types"
      exports: ["FaultType", "FaultSeverity", "BlastRadiusLevel", "ChaosVaccinationOptions"]
  key_links:
    - from: "DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosInjectionEngine.cs"
      to: "DataWarehouse.SDK/Contracts/ChaosVaccination/ChaosVaccinationTypes.cs"
      via: "FaultType, ChaosExperiment references"
      pattern: "FaultType|ChaosExperiment"
    - from: "DataWarehouse.SDK/Contracts/ChaosVaccination/IImmuneResponseSystem.cs"
      to: "DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosInjectionEngine.cs"
      via: "FaultSignature derived from ChaosExperimentResult"
      pattern: "FaultSignature|ChaosExperimentResult"
---

<objective>
Define all SDK-level contracts for the Chaos Vaccination & Blast Radius system.

Purpose: Establish strongly-typed interfaces, records, and enums in the SDK so that the chaos vaccination plugin (and any other plugin) can reference these types without cross-plugin dependencies. This follows the project's architecture: plugins reference ONLY SDK.

Output: 6 contract files in DataWarehouse.SDK/Contracts/ChaosVaccination/
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/PLUGIN-CATALOG.md
@DataWarehouse.SDK/Contracts/Resilience/ICircuitBreaker.cs
@DataWarehouse.SDK/Contracts/Resilience/IBulkheadIsolation.cs
@DataWarehouse.SDK/Contracts/Resilience/IDeadLetterQueue.cs
@DataWarehouse.SDK/Contracts/Hierarchy/Feature/ResiliencePluginBase.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core chaos vaccination types and enums</name>
  <files>DataWarehouse.SDK/Contracts/ChaosVaccination/ChaosVaccinationTypes.cs</files>
  <action>
Create the shared types file in DataWarehouse.SDK/Contracts/ChaosVaccination/ namespace.

Define these types (all as records with init-only setters, following SDK conventions from ICircuitBreaker.cs):

1. `enum FaultType` — NetworkPartition, DiskFailure, NodeCrash, LatencySpike, MemoryPressure, CpuSaturation, ConnectionPoolExhaustion, DnsFailure, CertificateExpiry, MessageBusPartition, PluginCrash, KernelDegradation, StorageCorruption, ReplicationLag, Custom

2. `enum FaultSeverity` — Low, Medium, High, Critical, Catastrophic

3. `enum BlastRadiusLevel` — SingleStrategy, SinglePlugin, PluginCategory, SingleNode, NodeGroup, Cluster

4. `enum ExperimentStatus` — Pending, Running, Completed, Failed, Aborted, Quarantined

5. `record ChaosExperiment` — Id (string), Name (string), Description (string), FaultType (FaultType), Severity (FaultSeverity), MaxBlastRadius (BlastRadiusLevel), TargetPluginIds (string[]?), TargetNodeIds (string[]?), DurationLimit (TimeSpan), Parameters (IReadOnlyDictionary&lt;string, object&gt;), Tags (string[]), SafetyChecks (SafetyCheck[])

6. `record ChaosExperimentResult` — ExperimentId (string), Status (ExperimentStatus), StartedAt (DateTimeOffset), CompletedAt (DateTimeOffset?), ActualBlastRadius (BlastRadiusLevel), AffectedPlugins (string[]), AffectedNodes (string[]), FaultSignature (FaultSignature?), RecoveryTimeMs (long?), Metrics (IReadOnlyDictionary&lt;string, double&gt;), Observations (string[])

7. `record FaultSignature` — Hash (string), FaultType (FaultType), Pattern (string), AffectedComponents (string[]), Severity (FaultSeverity), FirstObserved (DateTimeOffset), ObservationCount (int)

8. `record SafetyCheck` — Name (string), Description (string), CheckAction (Func&lt;CancellationToken, Task&lt;bool&gt;&gt;), IsRequired (bool)

9. `record ChaosVaccinationOptions` — Enabled (bool, default false), MaxConcurrentExperiments (int, default 1), GlobalBlastRadiusLimit (BlastRadiusLevel, default SinglePlugin), SafeMode (bool, default true), RequireApprovalForCritical (bool, default true), QuarantineOnFailure (bool, default true)

Add [SdkCompatibility("5.0.0", Notes = "Phase 61: Chaos Vaccination contracts")] to all public types.
  </action>
  <verify>Build DataWarehouse.SDK with `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors.</verify>
  <done>All shared chaos vaccination types compile and are accessible from any project referencing the SDK.</done>
</task>

<task type="auto">
  <name>Task 2: Core contracts -- injection engine, blast radius, immune response, scheduler, results DB</name>
  <files>
    DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosInjectionEngine.cs
    DataWarehouse.SDK/Contracts/ChaosVaccination/IBlastRadiusEnforcer.cs
    DataWarehouse.SDK/Contracts/ChaosVaccination/IImmuneResponseSystem.cs
    DataWarehouse.SDK/Contracts/ChaosVaccination/IVaccinationScheduler.cs
    DataWarehouse.SDK/Contracts/ChaosVaccination/IChaosResultsDatabase.cs
  </files>
  <action>
Create 5 interface files, following the pattern established by ICircuitBreaker.cs and IBulkheadIsolation.cs (XML docs, SdkCompatibility attribute, CancellationToken on all async methods).

**IChaosInjectionEngine.cs:**
- `Task&lt;ChaosExperimentResult&gt; ExecuteExperimentAsync(ChaosExperiment experiment, CancellationToken ct)`
- `Task AbortExperimentAsync(string experimentId, string reason, CancellationToken ct)`
- `Task&lt;IReadOnlyList&lt;ChaosExperimentResult&gt;&gt; GetRunningExperimentsAsync(CancellationToken ct)`
- `Task&lt;bool&gt; ValidateExperimentSafetyAsync(ChaosExperiment experiment, CancellationToken ct)` -- runs safety checks before execution
- `event Action&lt;ChaosExperimentEvent&gt;? OnExperimentEvent` -- lifecycle events
- Record `ChaosExperimentEvent` with ExperimentId, EventType (enum: Started, FaultInjected, SafetyCheckFailed, BlastRadiusExceeded, Completed, Aborted), Timestamp, Detail

**IBlastRadiusEnforcer.cs:**
- `record BlastRadiusPolicy` — MaxLevel (BlastRadiusLevel), MaxAffectedPlugins (int), MaxAffectedNodes (int), MaxDurationMs (long), AutoAbortOnBreach (bool, default true), IsolationStrategy (IsolationStrategy enum: Bulkhead, CircuitBreaker, ProcessIsolation, NetworkPartition)
- `record IsolationZone` — ZoneId (string), ContainedPlugins (string[]), ContainedNodes (string[]), Policy (BlastRadiusPolicy), IsActive (bool)
- `record FailureContainmentResult` — Contained (bool), ActualRadius (BlastRadiusLevel), BreachedPlugins (string[]), BreachedNodes (string[]), ContainmentActions (string[])
- `Task&lt;IsolationZone&gt; CreateIsolationZoneAsync(BlastRadiusPolicy policy, string[] targetPlugins, CancellationToken ct)`
- `Task&lt;FailureContainmentResult&gt; EnforceAsync(string zoneId, CancellationToken ct)` -- monitors and enforces during experiment
- `Task ReleaseZoneAsync(string zoneId, CancellationToken ct)`
- `Task&lt;IReadOnlyList&lt;IsolationZone&gt;&gt; GetActiveZonesAsync(CancellationToken ct)`
- `event Action&lt;BlastRadiusBreachEvent&gt;? OnBreachDetected`
- Record `BlastRadiusBreachEvent` with ZoneId, Policy, ActualRadius, Timestamp

**IImmuneResponseSystem.cs:**
- `record ImmuneMemoryEntry` — Signature (FaultSignature), RemediationActions (RemediationAction[]), SuccessRate (double), LastApplied (DateTimeOffset?), TimesApplied (int), AverageRecoveryMs (double)
- `record RemediationAction` — ActionType (enum: RestartPlugin, TripCircuitBreaker, DrainConnections, ScaleDown, IsolateNode, RerouteTraffic, RestoreFromCheckpoint, NotifyOperator, Custom), TargetId (string), Parameters (IReadOnlyDictionary&lt;string, object&gt;), Priority (int), TimeoutMs (long)
- `Task&lt;ImmuneMemoryEntry?&gt; RecognizeFaultAsync(FaultSignature signature, CancellationToken ct)` -- lookup immune memory
- `Task&lt;bool&gt; ApplyRemediationAsync(ImmuneMemoryEntry entry, CancellationToken ct)` -- auto-remediate
- `Task LearnFromExperimentAsync(ChaosExperimentResult result, RemediationAction[] successfulActions, CancellationToken ct)` -- record new immune memory
- `Task&lt;IReadOnlyList&lt;ImmuneMemoryEntry&gt;&gt; GetImmuneMemoryAsync(CancellationToken ct)`
- `Task ForgetAsync(string signatureHash, CancellationToken ct)` -- remove stale immune memory
- `event Action&lt;ImmuneResponseEvent&gt;? OnImmuneResponse`
- Record `ImmuneResponseEvent` with SignatureHash, ActionTaken, Success, RecoveryTimeMs, Timestamp

**IVaccinationScheduler.cs:**
- `record VaccinationSchedule` — Id (string), Name (string), CronExpression (string?), IntervalMs (long?), Experiments (ScheduledExperiment[]), Enabled (bool), MaxConcurrent (int), TimeWindows (TimeWindow[]?)
- `record ScheduledExperiment` — Experiment (ChaosExperiment), Weight (double, default 1.0), RequiredImmunity (bool) -- if true, experiment MUST pass for system to be considered "vaccinated"
- `record TimeWindow` — DayOfWeek (DayOfWeek?), StartHour (int), EndHour (int), TimeZone (string)
- `Task AddScheduleAsync(VaccinationSchedule schedule, CancellationToken ct)`
- `Task RemoveScheduleAsync(string scheduleId, CancellationToken ct)`
- `Task&lt;IReadOnlyList&lt;VaccinationSchedule&gt;&gt; GetSchedulesAsync(CancellationToken ct)`
- `Task&lt;VaccinationSchedule?&gt; GetScheduleAsync(string scheduleId, CancellationToken ct)`
- `Task EnableScheduleAsync(string scheduleId, bool enabled, CancellationToken ct)`
- `Task&lt;DateTimeOffset?&gt; GetNextRunTimeAsync(string scheduleId, CancellationToken ct)`

**IChaosResultsDatabase.cs:**
- `record ExperimentRecord` — Result (ChaosExperimentResult), Schedule (string?), TriggeredBy (string), CreatedAt (DateTimeOffset)
- `record ExperimentQuery` — FaultTypes (FaultType[]?), Statuses (ExperimentStatus[]?), Since (DateTimeOffset?), Until (DateTimeOffset?), PluginIds (string[]?), MaxResults (int, default 100), OrderByDescending (bool, default true)
- `record ExperimentSummary` — TotalExperiments (int), SuccessRate (double), AverageRecoveryMs (double), MostCommonFaults (Dictionary&lt;FaultType, int&gt;), BlastRadiusDistribution (Dictionary&lt;BlastRadiusLevel, int&gt;)
- `Task StoreAsync(ExperimentRecord record, CancellationToken ct)`
- `Task&lt;IReadOnlyList&lt;ExperimentRecord&gt;&gt; QueryAsync(ExperimentQuery query, CancellationToken ct)`
- `Task&lt;ExperimentRecord?&gt; GetByIdAsync(string experimentId, CancellationToken ct)`
- `Task&lt;ExperimentSummary&gt; GetSummaryAsync(ExperimentQuery? filter, CancellationToken ct)`
- `Task PurgeAsync(DateTimeOffset olderThan, CancellationToken ct)`

All interfaces marked with `[SdkCompatibility("5.0.0", Notes = "Phase 61: Chaos Vaccination contracts")]`.
  </action>
  <verify>Build DataWarehouse.SDK with `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` -- zero errors. Verify all 5 interface files exist with correct namespace.</verify>
  <done>All 5 contracts compile, use strongly-typed records (not Dictionary&lt;string,object&gt; for core data), and follow existing SDK resilience contract patterns.</done>
</task>

</tasks>

<verification>
- `dotnet build DataWarehouse.SDK/DataWarehouse.SDK.csproj` compiles with 0 errors
- All 6 files exist in DataWarehouse.SDK/Contracts/ChaosVaccination/
- All public types have [SdkCompatibility] attribute
- No references to plugin assemblies from SDK
</verification>

<success_criteria>
- 6 SDK contract files defining the complete chaos vaccination type system
- Zero build errors in SDK project
- Types follow immutable record patterns established in ICircuitBreaker.cs
</success_criteria>

<output>
After completion, create `.planning/phases/61-chaos-vaccination/61-01-SUMMARY.md`
</output>
