---
phase: 61-chaos-vaccination
plan: 06
type: execute
wave: 4
depends_on: ["61-02", "61-03", "61-04", "61-05"]
files_modified:
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ExistingResilienceIntegration.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ChaosVaccinationMessageHandler.cs
  - Plugins/DataWarehouse.Plugins.ChaosVaccination/Strategies/ChaosVaccinationStrategies.cs
autonomous: true
must_haves:
  truths:
    - "All sub-components (engine, enforcer, immune system, scheduler, results DB) are wired together in the plugin"
    - "Message bus topics for chaos vaccination are registered and routed"
    - "Existing UltimateResilience strategies are leveraged for blast radius enforcement"
    - "Plugin registers capabilities and knowledge for AI discovery"
  artifacts:
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs"
      provides: "Fully wired plugin with all sub-components"
      contains: "ChaosInjectionEngine|BlastRadiusEnforcer|ImmuneResponseSystem|VaccinationScheduler|InMemoryChaosResultsDatabase"
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ExistingResilienceIntegration.cs"
      provides: "Bridge to UltimateResilience circuit breakers and bulkheads"
      contains: "class ExistingResilienceIntegration"
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ChaosVaccinationMessageHandler.cs"
      provides: "Message bus topic routing for all chaos vaccination operations"
      contains: "class ChaosVaccinationMessageHandler"
    - path: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Strategies/ChaosVaccinationStrategies.cs"
      provides: "Resilience strategies for the chaos vaccination system itself"
      contains: "class VaccinationStrategy"
  key_links:
    - from: "Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs"
      to: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Engine/ChaosInjectionEngine.cs"
      via: "composition (creates and owns engine)"
      pattern: "new ChaosInjectionEngine"
    - from: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ExistingResilienceIntegration.cs"
      to: "DataWarehouse.SDK/Contracts/Resilience/ICircuitBreaker.cs"
      via: "requests circuit breakers via message bus"
      pattern: "resilience\\.circuit-breaker"
    - from: "Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ChaosVaccinationMessageHandler.cs"
      to: "DataWarehouse.SDK/Contracts/IMessageBus.cs"
      via: "subscribes to chaos.* topics"
      pattern: "Subscribe.*chaos\\."
---

<objective>
Wire all chaos vaccination sub-components together and integrate with the existing resilience infrastructure.

Purpose: Connect the injection engine, blast radius enforcer, immune response system, vaccination scheduler, and results database into a cohesive plugin. Bridge to the existing UltimateResilience plugin's circuit breakers and bulkheads via message bus. Register all message bus topics, capabilities, and knowledge entries.

Output: Fully wired plugin, resilience integration bridge, message handler, and vaccination strategies.
</objective>

<execution_context>
@C:/Users/ddamien/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ddamien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/61-chaos-vaccination/61-02-SUMMARY.md
@.planning/phases/61-chaos-vaccination/61-03-SUMMARY.md
@.planning/phases/61-chaos-vaccination/61-04-SUMMARY.md
@.planning/phases/61-chaos-vaccination/61-05-SUMMARY.md
@Plugins/DataWarehouse.Plugins.UltimateResilience/UltimateResiliencePlugin.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integration bridge and message handler</name>
  <files>
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ExistingResilienceIntegration.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Integration/ChaosVaccinationMessageHandler.cs
    Plugins/DataWarehouse.Plugins.ChaosVaccination/Strategies/ChaosVaccinationStrategies.cs
  </files>
  <action>
**ExistingResilienceIntegration.cs:**
- Bridge between chaos vaccination and existing resilience infrastructure
- Constructor takes IMessageBus
- RequestCircuitBreakerTrip(string pluginId): Publishes to "resilience.circuit-breaker.trip" with plugin ID
- RequestCircuitBreakerReset(string pluginId): Publishes to "resilience.circuit-breaker.reset"
- RequestBulkheadIsolation(string pluginId, int maxConcurrency): Publishes to "resilience.bulkhead.create" with config
- RequestBulkheadRelease(string pluginId): Publishes to "resilience.bulkhead.release"
- GetCircuitBreakerStatus(string pluginId) -> publishes to "resilience.circuit-status" and awaits response
- GetHealthCheckResults() -> publishes to "resilience.health-check" and awaits response
- All operations via message bus -- NO direct reference to UltimateResilience plugin assembly
- Request/response pattern: publish request, subscribe to response topic with correlation ID, timeout after 5s

**ChaosVaccinationMessageHandler.cs:**
- Central message routing for all chaos vaccination topics
- Constructor takes ChaosInjectionEngine, BlastRadiusEnforcer, ImmuneResponseSystem, VaccinationScheduler, InMemoryChaosResultsDatabase
- RegisterSubscriptions(IMessageBus bus): subscribes to all chaos.* topics:
  - "chaos.experiment.execute" -> validate + execute experiment
  - "chaos.experiment.abort" -> abort running experiment
  - "chaos.experiment.list-running" -> return running experiments
  - "chaos.blast-radius.create-zone" -> create isolation zone
  - "chaos.blast-radius.release-zone" -> release zone
  - "chaos.blast-radius.status" -> return active zones
  - "chaos.immune-memory.recognize" -> lookup immune memory for fault
  - "chaos.immune-memory.apply" -> apply remediation from memory
  - "chaos.immune-memory.learn" -> record new immune entry
  - "chaos.immune-memory.list" -> return all entries
  - "chaos.immune-memory.forget" -> remove entry
  - "chaos.schedule.add" -> add vaccination schedule
  - "chaos.schedule.remove" -> remove schedule
  - "chaos.schedule.list" -> list schedules
  - "chaos.schedule.enable" -> toggle schedule
  - "chaos.results.query" -> query results
  - "chaos.results.summary" -> get summary
  - "chaos.results.purge" -> purge old results
- Each handler: deserialize payload, call appropriate sub-component, publish response to "{topic}.response" with correlation ID
- Error handling: catch exceptions, publish error response with exception message

**ChaosVaccinationStrategies.cs:**
- 3 resilience strategies (inheriting ResilienceStrategyBase from UltimateResilience namespace -- NO, must not reference that. Instead, these are standalone strategy classes for the chaos system):
  1. VaccinationRunStrategy: wraps experiment execution with its own circuit breaker (if too many experiments fail in a row, stop running them). Category "ChaosVaccination".
  2. ImmuneAutoRemediationStrategy: wraps any operation with immune system check -- on failure, checks immune memory and applies remediation if available. Category "ChaosVaccination".
  3. BlastRadiusGuardStrategy: wraps operation execution with blast radius monitoring -- creates temp isolation zone, runs operation, releases zone. Category "ChaosVaccination".
- Each strategy is a simple class with ExecuteAsync pattern, NOT inheriting from ResilienceStrategyBase (since that lives in the UltimateResilience plugin assembly). Instead, implement IResilienceStrategy-like pattern locally or reference the interface from SDK if available. If SDK has no such base, create a simple local abstract class ChaosVaccinationStrategyBase.
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.ChaosVaccination/DataWarehouse.Plugins.ChaosVaccination.csproj -- zero errors</verify>
  <done>Integration bridge communicates with UltimateResilience via bus. Message handler routes all chaos.* topics. 3 vaccination-specific strategies defined.</done>
</task>

<task type="auto">
  <name>Task 2: Wire plugin -- connect all sub-components in ChaosVaccinationPlugin</name>
  <files>
    Plugins/DataWarehouse.Plugins.ChaosVaccination/ChaosVaccinationPlugin.cs
  </files>
  <action>
Update ChaosVaccinationPlugin.cs (created in Plan 02 as scaffold) to fully wire all components:

1. **Field declarations:** Add fields for all sub-components:
   - ChaosInjectionEngine _engine
   - BlastRadiusEnforcer _enforcer
   - IsolationZoneManager _zoneManager
   - FailurePropagationMonitor _propagationMonitor
   - ImmuneResponseSystem _immuneSystem
   - FaultSignatureAnalyzer _signatureAnalyzer
   - RemediationExecutor _remediationExecutor
   - VaccinationScheduler _scheduler
   - InMemoryChaosResultsDatabase _resultsDb
   - ExistingResilienceIntegration _resilienceIntegration
   - ChaosVaccinationMessageHandler _messageHandler
   - ChaosVaccinationOptions _options (read from configuration or defaults)

2. **OnStartCoreAsync:** Initialize all components in dependency order:
   a. _options = new ChaosVaccinationOptions() (or read from config if available)
   b. _signatureAnalyzer = new FaultSignatureAnalyzer()
   c. _remediationExecutor = new RemediationExecutor(MessageBus)
   d. _immuneSystem = new ImmuneResponseSystem(MessageBus, _signatureAnalyzer)
   e. _resultsDb = new InMemoryChaosResultsDatabase()
   f. _engine = new ChaosInjectionEngine(MessageBus, _options)
   g. _zoneManager = new IsolationZoneManager(MessageBus)
   h. _propagationMonitor = new FailurePropagationMonitor(MessageBus)
   i. _enforcer = new BlastRadiusEnforcer(MessageBus, _zoneManager, _propagationMonitor)
   j. _scheduler = new VaccinationScheduler(_engine, MessageBus)

3. **OnStartWithIntelligenceAsync:** After base call:
   a. _resilienceIntegration = new ExistingResilienceIntegration(MessageBus!)
   b. _messageHandler = new ChaosVaccinationMessageHandler(_engine, _enforcer, _immuneSystem, _scheduler, _resultsDb)
   c. _messageHandler.RegisterSubscriptions(MessageBus!)
   d. Wire engine events: _engine.OnExperimentEvent += async (evt) => store result in _resultsDb, feed to _immuneSystem.LearnFromExperimentAsync
   e. Wire enforcer events: _enforcer.OnBreachDetected += async (evt) => publish alert, check immune memory for remediation
   f. Register capabilities and knowledge

4. **OnMessageAsync:** Route to appropriate handler:
   - "chaos.*" messages -> _messageHandler (already subscribed via bus, but also handle direct plugin messages)

5. **ExecuteWithResilienceAsync:** Delegate to _engine.ExecuteExperimentAsync after wrapping the action as a chaos experiment

6. **GetResilienceHealthAsync:** Report:
   - Total registered experiments, running experiments, immune memory size
   - Blast radius enforcer status (active zones)
   - Scheduler status (enabled schedules, next run times)

7. **Dispose:** Dispose all IDisposable sub-components (_scheduler, _enforcer timer, _propagationMonitor subscriptions)

8. **DeclaredCapabilities:** Return full list including per-fault-type capabilities:
   - chaos.vaccination.execute, chaos.vaccination.schedule, chaos.vaccination.immune-memory, chaos.vaccination.blast-radius, chaos.vaccination.results
   - One capability per fault type: chaos.vaccination.fault.network-partition, .disk-failure, .node-crash, .latency-spike, .memory-pressure

9. **GetStaticKnowledge:** Return knowledge objects:
   - Chaos vaccination summary (available fault types, immune memory size, schedule count)
   - Per-fault-type knowledge
  </action>
  <verify>dotnet build Plugins/DataWarehouse.Plugins.ChaosVaccination/DataWarehouse.Plugins.ChaosVaccination.csproj -- zero errors. Verify all sub-component references resolve.</verify>
  <done>ChaosVaccinationPlugin is fully wired: engine executes experiments, enforcer limits blast radius, immune system learns and remediates, scheduler automates, results DB stores history. All communication via message bus.</done>
</task>

</tasks>

<verification>
- Full plugin builds with zero errors
- All sub-components initialized in correct dependency order
- Message bus subscriptions cover all chaos.* topics
- No direct reference to UltimateResilience plugin assembly
- Plugin registers capabilities and knowledge for AI discovery
</verification>

<success_criteria>
- Plugin initializes all sub-components on startup
- Experiment lifecycle is complete: schedule -> validate -> isolate -> inject -> monitor -> cleanup -> store -> learn
- Bus topics registered for all operations
- Existing resilience infrastructure (circuit breakers, bulkheads) leveraged via message bus
</success_criteria>

<output>
After completion, create `.planning/phases/61-chaos-vaccination/61-06-SUMMARY.md`
</output>
