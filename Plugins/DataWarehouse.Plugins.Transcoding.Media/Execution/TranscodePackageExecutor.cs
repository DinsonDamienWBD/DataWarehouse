using System.Text;

namespace DataWarehouse.Plugins.Transcoding.Media.Execution;

/// <summary>
/// Executes transcode packages generated by codec strategies.
/// Parses the package format (magic bytes + FFmpeg args + source data) and runs FFmpeg.
/// </summary>
/// <remarks>
/// <para>
/// Codec strategies generate "transcode packages" containing:
/// <list type="number">
/// <item><description>Magic bytes identifying the codec (e.g., "H264", "THUMB")</description></item>
/// <item><description>Encoder name (length-prefixed string)</description></item>
/// <item><description>FFmpeg command-line arguments (length-prefixed string)</description></item>
/// <item><description>Source data hash for integrity (length-prefixed bytes)</description></item>
/// <item><description>Source data length (int32)</description></item>
/// </list>
/// </para>
/// <para>
/// This executor parses packages and runs FFmpeg with the extracted arguments and source data.
/// It returns actual transcoded output instead of the package format.
/// </para>
/// </remarks>
public sealed class TranscodePackageExecutor
{
    private readonly FfmpegExecutor _ffmpegExecutor;

    /// <summary>
    /// Initializes a new instance of the <see cref="TranscodePackageExecutor"/> class.
    /// </summary>
    /// <param name="ffmpegExecutor">
    /// The FFmpeg executor to use for running transcoding commands. If null, a default instance is created.
    /// </param>
    public TranscodePackageExecutor(FfmpegExecutor? ffmpegExecutor = null)
    {
        _ffmpegExecutor = ffmpegExecutor ?? new FfmpegExecutor();
    }

    /// <summary>
    /// Gets a value indicating whether FFmpeg is available for execution.
    /// </summary>
    public bool IsAvailable => _ffmpegExecutor.IsAvailable;

    /// <summary>
    /// Executes a transcode package by parsing its format and running FFmpeg with the embedded arguments.
    /// </summary>
    /// <param name="packageStream">
    /// Stream containing the transcode package (magic bytes + args + source data).
    /// </param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>
    /// A stream containing the actual transcoded output from FFmpeg.
    /// If FFmpeg is not available, returns the original package stream unchanged.
    /// </returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the package format is invalid or corrupt.
    /// </exception>
    public async Task<Stream> ExecutePackageAsync(
        Stream packageStream,
        CancellationToken cancellationToken = default)
    {
        // If FFmpeg is not available, return the package as-is (fallback behavior)
        if (!_ffmpegExecutor.IsAvailable)
        {
            return packageStream;
        }

        try
        {
            packageStream.Position = 0;
            var package = await ParsePackageAsync(packageStream, cancellationToken).ConfigureAwait(false);

            // Execute FFmpeg with the parsed arguments and source data
            var result = await _ffmpegExecutor.ExecuteAsync(
                arguments: package.FfmpegArguments,
                inputData: package.SourceData,
                cancellationToken: cancellationToken).ConfigureAwait(false);

            if (!result.Success)
            {
                throw new InvalidOperationException(
                    $"FFmpeg transcoding failed with exit code {result.ExitCode}. " +
                    $"Error: {result.StandardError}");
            }

            // Return the transcoded output data
            return new MemoryStream(result.OutputData);
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            throw new InvalidOperationException(
                $"Failed to execute transcode package: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Parses a transcode package into its components.
    /// </summary>
    private static async Task<TranscodePackage> ParsePackageAsync(
        Stream packageStream,
        CancellationToken cancellationToken)
    {
        using var reader = new BinaryReader(packageStream, Encoding.UTF8, leaveOpen: true);

        // Read magic bytes (4 bytes for H264, THUMB, etc.)
        var magicBytes = reader.ReadBytes(4);
        var magic = Encoding.UTF8.GetString(magicBytes).TrimEnd('\0');

        // Read encoder name (length-prefixed)
        var encoderLength = reader.ReadInt32();
        var encoderBytes = reader.ReadBytes(encoderLength);
        var encoder = Encoding.UTF8.GetString(encoderBytes);

        // Read FFmpeg arguments (length-prefixed)
        var argsLength = reader.ReadInt32();
        var argsBytes = reader.ReadBytes(argsLength);
        var ffmpegArgs = Encoding.UTF8.GetString(argsBytes);

        // Read source hash (length-prefixed)
        var hashLength = reader.ReadInt32();
        var sourceHash = reader.ReadBytes(hashLength);

        // Read source data length
        var sourceDataLength = reader.ReadInt32();

        // Read source data if present inline in the package
        byte[] sourceData;
        if (sourceDataLength > 0)
        {
            sourceData = reader.ReadBytes(sourceDataLength);
            if (sourceData.Length != sourceDataLength)
            {
                throw new InvalidOperationException(
                    $"Package truncated: expected {sourceDataLength} bytes of source data but got {sourceData.Length}. " +
                    "The transcode package may be corrupt or incomplete.");
            }
        }
        else
        {
            throw new InvalidOperationException(
                "Package does not contain inline source data (sourceDataLength is 0). " +
                "Provide source data embedded in the package, or supply a source path separately.");
        }

        return new TranscodePackage(
            Magic: magic,
            Encoder: encoder,
            FfmpegArguments: ffmpegArgs,
            SourceHash: sourceHash,
            SourceData: sourceData);
    }
}

/// <summary>
/// Represents a parsed transcode package with its components.
/// </summary>
/// <param name="Magic">Magic bytes identifier (e.g., "H264", "THUMB").</param>
/// <param name="Encoder">FFmpeg encoder name (e.g., "libx264", "h264_nvenc").</param>
/// <param name="FfmpegArguments">Complete FFmpeg command-line arguments.</param>
/// <param name="SourceHash">SHA256 hash of the source media for integrity verification.</param>
/// <param name="SourceData">Source media bytes to pipe to FFmpeg stdin.</param>
internal sealed record TranscodePackage(
    string Magic,
    string Encoder,
    string FfmpegArguments,
    byte[] SourceHash,
    byte[] SourceData);
