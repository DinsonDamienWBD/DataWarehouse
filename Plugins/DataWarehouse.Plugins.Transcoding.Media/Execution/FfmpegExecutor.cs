using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

namespace DataWarehouse.Plugins.Transcoding.Media.Execution;

/// <summary>
/// Executes FFmpeg commands generated by transcoding strategies.
/// Validates FFmpeg availability, runs the process, captures output,
/// and provides clear errors when FFmpeg is not installed.
/// </summary>
/// <remarks>
/// <para>
/// This executor bridges the gap between FFmpeg command generation (done by strategies)
/// and actual execution. It provides:
/// <list type="bullet">
/// <item><description>Automatic FFmpeg detection across platforms (Windows, Linux, macOS)</description></item>
/// <item><description>Process execution with stdin/stdout piping for streaming</description></item>
/// <item><description>Timeout protection to prevent hung transcoding jobs</description></item>
/// <item><description>Detailed error reporting with FFmpeg stderr capture</description></item>
/// <item><description>Clear installation instructions when FFmpeg is missing</description></item>
/// </list>
/// </para>
/// <para>
/// FFmpeg must be installed separately. This class detects it in the following order:
/// <list type="number">
/// <item><description>FFMPEG_PATH environment variable</description></item>
/// <item><description>System PATH (ffmpeg command available globally)</description></item>
/// <item><description>Platform-specific common locations (/usr/bin, /usr/local/bin, C:\ffmpeg\bin)</description></item>
/// </list>
/// </para>
/// </remarks>
public sealed class FfmpegExecutor
{
    private readonly string _ffmpegPath;
    private readonly TimeSpan _defaultTimeout;

    /// <summary>
    /// Initializes a new instance of the <see cref="FfmpegExecutor"/> class.
    /// </summary>
    /// <param name="ffmpegPath">
    /// Explicit path to the FFmpeg executable. If null, automatic detection is attempted.
    /// </param>
    /// <param name="defaultTimeout">
    /// Default timeout for transcoding operations. If null, defaults to 30 minutes.
    /// </param>
    /// <exception cref="FfmpegNotFoundException">
    /// Thrown when FFmpeg cannot be found and no explicit path is provided.
    /// </exception>
    public FfmpegExecutor(string? ffmpegPath = null, TimeSpan? defaultTimeout = null)
    {
        try
        {
            _ffmpegPath = ffmpegPath ?? FindFfmpeg();
            IsAvailable = true;
        }
        catch (FfmpegNotFoundException)
        {
            _ffmpegPath = string.Empty;
            IsAvailable = false;
            // If an explicit path was provided but not found, re-throw
            if (ffmpegPath != null)
            {
                throw;
            }
        }

        _defaultTimeout = defaultTimeout ?? TimeSpan.FromMinutes(30);
    }

    /// <summary>
    /// Gets a value indicating whether FFmpeg is available for execution.
    /// </summary>
    public bool IsAvailable { get; private set; }

    /// <summary>
    /// Gets the path to the FFmpeg executable being used.
    /// </summary>
    public string FfmpegPath => _ffmpegPath;

    /// <summary>
    /// Finds the FFmpeg executable by searching environment variables and common installation paths.
    /// </summary>
    /// <returns>The full path to the FFmpeg executable.</returns>
    /// <exception cref="FfmpegNotFoundException">
    /// Thrown when FFmpeg cannot be located in any of the expected locations.
    /// </exception>
    public static string FindFfmpeg()
    {
        // 1. Check FFMPEG_PATH environment variable
        var envPath = Environment.GetEnvironmentVariable("FFMPEG_PATH");
        if (!string.IsNullOrWhiteSpace(envPath) && File.Exists(envPath))
        {
            return envPath;
        }

        // 2. Check if ffmpeg is in PATH
        var ffmpegCommand = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "ffmpeg.exe" : "ffmpeg";
        var pathVariable = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
        var pathDirectories = pathVariable.Split(Path.PathSeparator, StringSplitOptions.RemoveEmptyEntries);

        foreach (var dir in pathDirectories)
        {
            var candidatePath = Path.Combine(dir, ffmpegCommand);
            if (File.Exists(candidatePath))
            {
                return candidatePath;
            }
        }

        // 3. Check common installation locations by platform
        var commonLocations = GetCommonFfmpegLocations();
        foreach (var location in commonLocations)
        {
            if (File.Exists(location))
            {
                return location;
            }
        }

        // FFmpeg not found - throw with installation instructions
        throw new FfmpegNotFoundException(GetInstallationInstructions());
    }

    /// <summary>
    /// Executes an FFmpeg command with the specified arguments.
    /// </summary>
    /// <param name="arguments">
    /// FFmpeg command-line arguments (excluding the executable name).
    /// Example: "-i input.mp4 -c:v libx264 output.mp4"
    /// </param>
    /// <param name="inputData">
    /// Optional binary data to pipe to FFmpeg's stdin. Used for pipe:0 input sources.
    /// </param>
    /// <param name="workingDirectory">
    /// Working directory for the FFmpeg process. If null, uses the current directory.
    /// </param>
    /// <param name="timeout">
    /// Operation timeout. If null, uses the default timeout from constructor.
    /// </param>
    /// <param name="progressCallback">
    /// Optional callback invoked with progress information parsed from FFmpeg stderr.
    /// Receives percentage progress (0-100) when available.
    /// </param>
    /// <param name="cancellationToken">
    /// Cancellation token to abort the operation.
    /// </param>
    /// <returns>
    /// An <see cref="FfmpegResult"/> containing exit code, output, error messages, and duration.
    /// </returns>
    /// <exception cref="TimeoutException">
    /// Thrown when the operation exceeds the specified timeout.
    /// </exception>
    /// <exception cref="OperationCanceledException">
    /// Thrown when the cancellation token is triggered.
    /// </exception>
    public async Task<FfmpegResult> ExecuteAsync(
        string arguments,
        byte[]? inputData = null,
        string? workingDirectory = null,
        TimeSpan? timeout = null,
        Action<double>? progressCallback = null,
        CancellationToken cancellationToken = default)
    {
        // Input validation
        if (string.IsNullOrWhiteSpace(arguments))
        {
            throw new ArgumentException("FFmpeg arguments cannot be null or empty.", nameof(arguments));
        }

        if (!IsAvailable)
        {
            throw new InvalidOperationException(
                "FFmpeg is not available. Please install FFmpeg or set the FFMPEG_PATH environment variable.");
        }

        // Validate timeout
        var effectiveTimeout = timeout ?? _defaultTimeout;
        if (effectiveTimeout <= TimeSpan.Zero)
        {
            throw new ArgumentException("Timeout must be positive.", nameof(timeout));
        }

        // Validate working directory if provided
        if (!string.IsNullOrWhiteSpace(workingDirectory) && !Directory.Exists(workingDirectory))
        {
            throw new DirectoryNotFoundException($"Working directory not found: {workingDirectory}");
        }

        var startTime = DateTime.UtcNow;

        var psi = new ProcessStartInfo
        {
            FileName = _ffmpegPath,
            Arguments = arguments,
            RedirectStandardInput = inputData != null,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
            WorkingDirectory = workingDirectory ?? Directory.GetCurrentDirectory()
        };

        var stderrBuilder = new StringBuilder();
        // Total source duration extracted from FFmpeg's "Duration:" header line.
        // Used to convert current encoding time to a 0-100 percentage (finding 1047).
        double totalDurationSeconds = 0.0;

        using var process = new Process { StartInfo = psi };
        using var stdoutMemory = new MemoryStream(1024 * 1024);

        // Capture stderr asynchronously (FFmpeg writes progress/diagnostics here)
        process.ErrorDataReceived += (sender, args) =>
        {
            if (args.Data != null)
            {
                stderrBuilder.AppendLine(args.Data);

                // Extract source duration from the "Duration: HH:MM:SS.cc" line that
                // FFmpeg emits at the start of processing (before progress lines).
                if (totalDurationSeconds <= 0.0)
                {
                    var dur = TryParseDuration(args.Data);
                    if (dur.HasValue)
                        totalDurationSeconds = dur.Value;
                }

                // Parse progress information if callback is provided.
                // Finding 1047: compute 0-100 percentage using captured total duration.
                if (progressCallback != null)
                {
                    // FFmpeg reports progress like: "frame= 123 fps=30 time=00:00:04.10 ..."
                    var currentSeconds = TryParseProgress(args.Data);
                    if (currentSeconds.HasValue)
                    {
                        double pct = totalDurationSeconds > 0.0
                            ? Math.Clamp(currentSeconds.Value / totalDurationSeconds * 100.0, 0.0, 100.0)
                            : Math.Min(currentSeconds.Value, 100.0); // fallback: treat raw seconds as best-effort
                        progressCallback(pct);
                    }
                }
            }
        };

        try
        {
            if (!process.Start())
                throw new InvalidOperationException("FFmpeg process could not be started (process.Start() returned false â€” process may already be running).");
            process.BeginErrorReadLine();

            // Write input data to stdin if provided
            if (inputData != null && inputData.Length > 0)
            {
                await process.StandardInput.BaseStream.WriteAsync(inputData, cancellationToken).ConfigureAwait(false);
                await process.StandardInput.BaseStream.FlushAsync(cancellationToken).ConfigureAwait(false);
                process.StandardInput.Close();
            }

            // Read binary stdout (transcoded media data)
            await process.StandardOutput.BaseStream.CopyToAsync(stdoutMemory, cancellationToken).ConfigureAwait(false);

            // Wait for process to complete with timeout
            var completed = await WaitForExitAsync(process, effectiveTimeout, cancellationToken).ConfigureAwait(false);

            if (!completed)
            {
                try
                {
                    process.Kill(entireProcessTree: true);
                }
                catch
                {

                    // Process may have already exited
                    System.Diagnostics.Debug.WriteLine("[Warning] caught exception in catch block");
                }

                throw new TimeoutException(
                    $"FFmpeg operation exceeded timeout of {effectiveTimeout.TotalSeconds:F1} seconds. " +
                    $"Partial stderr: {stderrBuilder}");
            }

            var duration = DateTime.UtcNow - startTime;

            return new FfmpegResult
            {
                ExitCode = process.ExitCode,
                OutputData = stdoutMemory.ToArray(),
                StandardError = stderrBuilder.ToString(),
                Duration = duration
            };
        }
        catch (OperationCanceledException)
        {
            try
            {
                if (!process.HasExited)
                {
                    process.Kill(entireProcessTree: true);
                }
            }
            catch
            {

                // Process may have already exited
                System.Diagnostics.Debug.WriteLine("[Warning] caught exception in catch block");
            }

            throw;
        }
    }

    /// <summary>
    /// Waits for a process to exit with timeout and cancellation support.
    /// </summary>
    private static async Task<bool> WaitForExitAsync(
        Process process,
        TimeSpan timeout,
        CancellationToken cancellationToken)
    {
        using var timeoutCts = new CancellationTokenSource(timeout);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);

        try
        {
            await process.WaitForExitAsync(linkedCts.Token).ConfigureAwait(false);
            return true;
        }
        catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested && !cancellationToken.IsCancellationRequested)
        {
            return false; // Timeout occurred
        }
    }

    /// <summary>
    /// Gets common FFmpeg installation locations based on the current platform.
    /// </summary>
    private static List<string> GetCommonFfmpegLocations()
    {
        var locations = new List<string>();

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            locations.AddRange(new[]
            {
                @"C:\ffmpeg\bin\ffmpeg.exe",
                @"C:\Program Files\ffmpeg\bin\ffmpeg.exe",
                @"C:\Program Files (x86)\ffmpeg\bin\ffmpeg.exe",
                Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "ffmpeg", "bin", "ffmpeg.exe")
            });
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            locations.AddRange(new[]
            {
                "/usr/bin/ffmpeg",
                "/usr/local/bin/ffmpeg",
                "/opt/ffmpeg/bin/ffmpeg",
                "/snap/bin/ffmpeg"
            });
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            locations.AddRange(new[]
            {
                "/usr/local/bin/ffmpeg",
                "/opt/homebrew/bin/ffmpeg",
                "/usr/bin/ffmpeg"
            });
        }

        return locations;
    }

    /// <summary>
    /// Tries to parse the total source duration from an FFmpeg stderr line.
    /// FFmpeg emits "  Duration: HH:MM:SS.cc, ..." early in its output.
    /// </summary>
    /// <param name="stderrLine">A line from FFmpeg stderr output.</param>
    /// <returns>Total duration in seconds if parseable, otherwise null.</returns>
    private static double? TryParseDuration(string stderrLine)
    {
        if (!stderrLine.Contains("Duration:"))
            return null;

        var m = System.Text.RegularExpressions.Regex.Match(
            stderrLine, @"Duration:\s*(\d{2}):(\d{2}):(\d{2}\.\d+)");
        if (m.Success &&
            int.TryParse(m.Groups[1].Value, out var h) &&
            int.TryParse(m.Groups[2].Value, out var min) &&
            double.TryParse(m.Groups[3].Value, System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture, out var sec))
        {
            return h * 3600 + min * 60 + sec;
        }

        return null;
    }

    /// <summary>
    /// Tries to parse the current encoding position in seconds from an FFmpeg stderr line.
    /// Returns elapsed seconds; callers should divide by total duration to get percentage.
    /// </summary>
    /// <param name="stderrLine">A line from FFmpeg stderr output.</param>
    /// <returns>Elapsed encoding seconds if parseable, otherwise null.</returns>
    private static double? TryParseProgress(string stderrLine)
    {
        if (!stderrLine.Contains("time="))
            return null;

        var timeMatch = System.Text.RegularExpressions.Regex.Match(
            stderrLine, @"time=(\d{2}):(\d{2}):(\d{2}\.\d{2})");

        if (timeMatch.Success &&
            int.TryParse(timeMatch.Groups[1].Value, out var hours) &&
            int.TryParse(timeMatch.Groups[2].Value, out var minutes) &&
            double.TryParse(timeMatch.Groups[3].Value, System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture, out var seconds))
        {
            return hours * 3600 + minutes * 60 + seconds;
        }

        return null;
    }

    /// <summary>
    /// Gets platform-specific installation instructions for FFmpeg.
    /// </summary>
    private static string GetInstallationInstructions()
    {
        var sb = new StringBuilder();
        sb.AppendLine("FFmpeg not found. Please install FFmpeg to enable transcoding functionality.");
        sb.AppendLine();

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            sb.AppendLine("Windows installation options:");
            sb.AppendLine("  1. Download from https://ffmpeg.org/download.html");
            sb.AppendLine("  2. Extract to C:\\ffmpeg\\ and add C:\\ffmpeg\\bin to PATH");
            sb.AppendLine("  3. Or install via package manager:");
            sb.AppendLine("     - Chocolatey: choco install ffmpeg");
            sb.AppendLine("     - Scoop: scoop install ffmpeg");
            sb.AppendLine("     - winget: winget install ffmpeg");
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            sb.AppendLine("Linux installation options:");
            sb.AppendLine("  - Debian/Ubuntu: sudo apt-get install ffmpeg");
            sb.AppendLine("  - Fedora: sudo dnf install ffmpeg");
            sb.AppendLine("  - Arch: sudo pacman -S ffmpeg");
            sb.AppendLine("  - Snap: sudo snap install ffmpeg");
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            sb.AppendLine("macOS installation options:");
            sb.AppendLine("  - Homebrew: brew install ffmpeg");
            sb.AppendLine("  - MacPorts: sudo port install ffmpeg");
        }

        sb.AppendLine();
        sb.AppendLine("After installation, either:");
        sb.AppendLine("  - Ensure ffmpeg is in your PATH, or");
        sb.AppendLine("  - Set the FFMPEG_PATH environment variable to the executable path");

        return sb.ToString();
    }
}

/// <summary>
/// Result of an FFmpeg execution operation containing process output and metadata.
/// </summary>
public sealed record FfmpegResult
{
    /// <summary>
    /// Gets the process exit code. 0 indicates success.
    /// </summary>
    public required int ExitCode { get; init; }

    /// <summary>
    /// Gets the binary output data (stdout) from the FFmpeg process.
    /// This typically contains transcoded media (MP4, WebM, etc.) when piping to stdout.
    /// </summary>
    public required byte[] OutputData { get; init; }

    /// <summary>
    /// Gets the standard error (stderr) from the FFmpeg process.
    /// FFmpeg writes progress and diagnostic information to stderr.
    /// </summary>
    public required string StandardError { get; init; }

    /// <summary>
    /// Gets the total duration of the transcoding operation.
    /// </summary>
    public required TimeSpan Duration { get; init; }

    /// <summary>
    /// Gets a value indicating whether the operation succeeded (exit code 0).
    /// </summary>
    public bool Success => ExitCode == 0;
}

/// <summary>
/// Exception thrown when FFmpeg cannot be found on the system.
/// </summary>
public sealed class FfmpegNotFoundException : Exception
{
    /// <summary>
    /// Initializes a new instance of the <see cref="FfmpegNotFoundException"/> class.
    /// </summary>
    /// <param name="message">Installation instructions message.</param>
    public FfmpegNotFoundException(string message) : base(message)
    {
    }
}
